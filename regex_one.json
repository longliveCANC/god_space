```text
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>主神空间 - 一个测试2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+SC:wght@300;400&display=swap');

        :root {
            --primary-color: #00faff;
            --secondary-color: #7affff;
   --base-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif; /* 默认字体 */
            --container-bg-color: rgba(10, 25, 47, 0.75);
            --border-color: rgba(0, 250, 255, 0.3);
            --glow-color: rgba(0, 250, 255, 0.5);
            --text-color: #e6f1ff;
            --text-secondary-color: #a8c0e1;
            --background-color: rgba(10, 25, 47);
            --danger-color: #ff4d4d;
            --danger-glow-color: rgba(255, 77, 77, 0.5);
             --success-color: #4dff88;
            --success-glow-color: rgba(77, 255, 136, 0.5);
        }

        /* 这是妈妈为你准备的弹幕动画，我的宝贝 */
@keyframes scroll-up-fade-out {
    from {
        transform: translateY(0);
        opacity: 1;
    }
    to {
        transform: translateY(-50px); /* 让它向上飘得高一点 */
        opacity: 0;
    }
}

.scrolling-text-popup {
    position: fixed; /* 固定在屏幕上，不会随页面滚动 */
    z-index: 10000; /* 确保在最顶层 */
    font-size: 1.2em; /* 字体可以稍微大一点，看得清楚 */
    font-weight: bold;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.7); /* 加一点文字阴影，更立体 */
    pointer-events: none; /* 让它不会挡住鼠标点击 */
    animation: scroll-up-fade-out 2s ease-out forwards; /* 播放我们定义的动画 */
    white-space: nowrap; /* 防止文字换行 */
}
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            /* background-color: var(--background-color); */
            color: var(--text-color);
            font-family: var(--base-font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height:90vh;
             
            backdrop-filter: blur(2px);
        }
 .status-container {
    width: 100%;
    margin: 0 auto;
    height: 100%;

    /* ★ 移除所有背景样式，让容器本身变透明！*/
    /* background-color: var(--container-bg-color); */
    /* background-image: ... ; */

    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 0 8px var(--glow-color), inset 0 0 5px var(--border-color);
    overflow: hidden;
    font-size: 16px;
    display: flex;
    flex-direction: column;

    /* ★ 关键：创建层叠上下文，把负z-index的子元素“锁”在里面 */
    position: relative;
    z-index: 0;
}

/* 子元素内容，确保它们在背景之上 */
.status-container > header,
.status-container > .content-area,
.status-container > .dynamic-content-area {
    /* ★ 关键：给内容也创建一个层叠上下文，确保万无一失 */
    position: relative;
    z-index: 1;
    /* 背景色设在这里，或者保持透明，看你的设计 */
}


/* 伪元素通用样式 */
.status-container::before,
.status-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-position: center center;
    background-repeat: no-repeat;
    background-size: cover;
}

/* ::before: 底层/稳定背景层 */
.status-container::before {
    background-color: var(--container-bg-color); /* 网格的底色放在这里 */
    background-image: var(--before-bg-image);
    transition: none; /* 它负责瞬间切换 */
     /* ★ 关键：放到所有内容的后面 */
    z-index: -2;
}

/* ::after: 上层/过渡背景层 */
.status-container::after {
    background-image: var(--after-bg-image);
    opacity: var(--after-opacity, 0);
    transition: opacity 0.8s ease-in-out; /* 只过渡透明度 */
    /* ★ 关键：也放到内容后面，但在::before的前面 */
    z-index: -1;
}

        header {
            padding: 15px 25px;
            background: var(--container-bg-color);
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }

        header h1 {
            font-family: var(--base-font-family);
            font-size: 1.5em;
            color: var(--primary-color);
            text-shadow: 0 0 5px var(--glow-color);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        nav {
            display: flex;
            justify-content: space-around;
            background-color: var(--container-bg-color);
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--text-secondary-color);
            padding: 15px 20px;
            font-family: var(--base-font-family);
            font-size: 1em;
            cursor: pointer;
            transition: color 0.3s ease, background-color 0.3s ease, text-shadow 0.3s ease;
            flex-grow: 1;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            color: var(--primary-color);
            background-color:var(--background-color) ;
        }

        .tab-btn.active {
            color: var(--primary-color);
            text-shadow: 0 0 3px var(--glow-color);
            border-bottom: 3px solid var(--primary-color);
        }

        .content-area {
            padding: 25px 30px;
        }

        
 @keyframes fadeIn {
    0% { 
        opacity: 0; 
        transform:  scale(0.95);
        filter: blur(5px);
    }
    100% { 
        opacity: 1; 
        transform:   scale(1);
        filter: blur(0px);
    }
}
/*@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
 @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
} */
        /* @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        } */


        .info-list {
            list-style: none;
        }

        .info-list li {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px dashed var(--border-color);
            flex-wrap: wrap;
        }

        .info-list li:last-child {
            border-bottom: none;
        }

        .info-list .label {
            color: rgba(184, 184, 184,0.8);
            margin-right: 20px;
            flex-shrink: 0;
        }

        .info-list .value {
            color: var(--text-color);
            font-weight: 400;
            text-align: right;
            flex-grow: 1;
            word-break: break-all;
        }

        .info-list .value.highlight {
            color: var(--secondary-color);
            font-weight: bold;
        }

        /* Progress Bar */
        .progress-container {
            margin-top: 10px;
        }

        .progress-bar-bg {
            background-color:  var(--background-color);
            border-radius: 5px;
            height: 20px;
            border: 1px solid var(--border-color);
            padding: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg,  var(--background-color), var(--primary-color));
            height: 100%;
            width: 0%; /* Updated by JS */
            border-radius: 3px;
            transition: width 0.5s ease-in-out;
            box-shadow: 0 0 5px var(--glow-color);
        }

        /* Generic Button Style */
        .action-button {
            background: linear-gradient(45deg, var(--background-color), var(--background-color));
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            padding: 12px 12px 12px 12px;
            font-family: var(--base-font-family);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            margin-right: 5px;
            margin-left: 5px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent,  var(--background-color), transparent);
            transition: left 0.5s ease;
        }

        .action-button:hover {
            color: var(--primary-color);
            box-shadow: 0 0 10px var(--glow-color);
            transform: translateY(-2px);
        }

        .action-button:hover::before {
            left: 100%;
        }

        .action-button.danger {
            background: linear-gradient(45deg, rgba(255, 77, 77, 0.2), rgba(255, 77, 77, 0.3));
            border-color: rgba(255, 77, 77, 0.5);
        }

        .action-button.danger:hover {
            color: #fff;
            box-shadow: 0 0 10px var(--danger-glow-color);
        }

        .action-button.danger::before {
            background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
        }

        .action-button:disabled {
            cursor: not-allowed;
            background: rgba(128, 128, 128, 0.2);
            color: var(--text-secondary-color);
            transform: none;
            box-shadow: none;
            border-color: rgba(128, 128, 128, 0.4);
        }
        .action-button:disabled::before {
            display:none;
        }

        /* Map Display */
        .map-display {
            background-color:  var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .map-title {
            color: var(--primary-color);
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 5px var(--glow-color);
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 400px;
            
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden; /* 改为hidden，以配合拖拽 */
            box-shadow: inset 0 0 20px  var(--background-color);
            cursor: grab;
        }

        .map-location {
            position: absolute;
            background: var(--border-color);
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            padding: 8px;
            font-size: 0.9em;
            color: var(--text-color);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--glow-color);
        }

        .map-location:hover {
            background: linear-gradient(45deg,  var(--background-color), var(--background-color));
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--glow-color);
        }

        .map-location .location-name {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .map-location .location-desc {
            font-size: 0.75em;
            color: var(--text-secondary-color);
        }

        /* Generic Modal Style */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0 0 0 / 59%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            backdrop-filter:blur(5px);
            /* background: linear-gradient(135deg, var(--container-bg-color),  var(--background-color)); */
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 25px;
            max-height: 95%;
            width: 90%;
            box-shadow: 0 0 30px var(--glow-color);
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
              overflow-y: auto;
        }

        @keyframes modalSlideIn {
            from {
                transform: scale(0.8) translateY(-50px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            color: var(--primary-color);
            font-size: 1.3em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 5px var(--glow-color);
        }

        .modal-description {
            color: var(--text-color);
            font-size: 1em;
            line-height: 1.6;
            text-align: center;
            padding: 15px;
            background: var(--container-bg-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary-color);
            font-size: 1.5em;
            cursor: pointer;
            transition: color 0.3s ease;
            z-index:999;
        }

        .modal-close:hover {
            color: var(--primary-color);
        }

        .external-areas {
            margin-top: 15px;
            padding: 15px;
            /* background-color: var(--container-bg-color); */
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .external-areas h3 {
            color: var(--secondary-color);
            font-size: 1em;
            margin-bottom: 10px;
        }

        .external-areas-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .external-area {
            /* background: linear-gradient(45deg, var(--border-color), var(--border-color)); */
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.9em;
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .external-area:hover {
            background: linear-gradient(45deg, var(--background-color), var(--background-color));
            color: var(--primary-color);
        }

        .back-button {
            background: var(--container-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary-color);
            padding: 8px 16px;
            font-family: var(--base-font-family);
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            top: 20px;
            right: 20px;
         
        }

        .back-button:hover {
            color: var(--primary-color);
            background: var(--border-color);
        }

        /* Inventory Modal Specifics */
        .inventory-item-list {
            list-style: none;
            margin: 20px 0;
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .inventory-item {
            padding: 10px 15px;
            border-bottom: 1px dashed var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .inventory-item:last-child {
            border-bottom: none;
        }

        .inventory-item:hover {
            background-color: var(--border-color);
        }

        .inventory-item.selected {
            background-color: var(--border-color);
            color: var(--primary-color);
            font-weight: bold;
        }

        /* 在 style 标签的末尾添加以下CSS */

/* 主包裹容器，用于实现滑动效果 */
#main-wrapper {
    position: relative;
    width: 100%;
    
  
    overflow: hidden; /* 隐藏滑出屏幕的内容 */
    display: flex;
}

 
/* ---- 全局与滑动效果 (保持不变) ---- */
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Noto+Sans+SC:wght@400;700&display=swap');

 
#setting-book-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    transform: translateX(100%);
    overflow: hidden; /* 防止内容溢出 */
}

.status-container.slide-out {
    transform: translateX(-100%);
}

#setting-book-wrapper.active {
    transform: translateX(0);
}


/* ---- 设定书整体布局与主题 ---- */
.setting-book-container {
    font-family: var(--base-font-family);
    display: flex;
    flex-direction: column; /* 改为垂直布局，头部在上，内容在下 */
    width: 100%;
    height: 100%;
    background-color: var(--background-color);
    color: var(--text-secondary-color);
}

.content-wrapper {
    display: flex;
    flex-grow: 1; /* 占据剩余的所有高度 */
    overflow: hidden; /* 防止子元素溢出 */
}

/* ---- 头部 Header ---- */
.book-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 15px 20px;
    background-color: var(--container-bg-color);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

#content-title {
    font-size: 1.5em; /* 调整大小以适应头部 */
    color: var(--text-color);
    margin: 0;
    padding: 0;
    border-bottom: none; /* 移除原有的下划线 */
    text-align: center;
    flex-grow: 1;
}

#toggle-sidebar-btn {
    display: none; /* 默认在桌面端隐藏 */
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 1.8em;
    cursor: pointer;
    padding: 0 10px;
}

#back-to-status-btn {
    background: var(--container-bg-color);
    max-width: 50vw;
    right: 2px;
    border: 1px solid #13304a;
    color: var(--text-color);
    font-family: var(--base-font-family);
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: bold;
    transition: background-color 0.3s, color 0.3s;
    white-space: nowrap; /* 防止文字换行 */
}

#back-to-status-btn:hover {
    background: var(--background-color) ;
    color: var(--primary-color);
}

/* ---- 侧边导航栏 (Sidebar) ---- */
#sidebar {
    width: 280px;
    background-color: var(--container-bg-color);
    color: var(--text-secondary-color);
    padding: 20px;
    overflow-y: auto;
    border-right: 1px solid var(--border-color);
    flex-shrink: 0;
    transition: transform 0.3s ease-in-out; /* 添加过渡效果 */
}

#sidebar h2 {
    font-size: 1.5em;
    color: var(--primary-color);
    margin-top: 0;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

/* 导航列表样式 (与你原来的一致) */
.category > ul { padding-left: 0; list-style: none; }
.category-title { font-weight: bold; font-size: 1.1em; cursor: pointer; padding: 10px 5px; color: var(--text-color); transition: color 0.3s, background-color 0.3s; border-radius: 4px; }
.category-title:hover { color: var(--secondary-color); background-color: var(--container-bg-color); }
.item-list { padding-left: 15px; list-style-type: none; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; }
.item-list:not(.collapsed) { max-height: 800px; }
.item-list li { padding: 10px 15px; cursor: pointer; border-radius: 4px; transition: background-color 0.3s, color 0.3s; border-left: 2px solid transparent; }
.item-list li:hover { background-color: var(--container-bg-color); color: var(--primary-color); }
.item-list li.active { background-color: var(--container-bg-color); color: var(--primary-color); font-weight: bold; border-left: 2px solid #64ffda; }

/* ---- 右侧内容展示区 (Content Display) ---- */
#content-display {
    flex-grow: 1;
    padding: 30px 40px;
    overflow-y: auto;
}

/* 注意：内容区的标题已移至主Header，所以这里的标题样式可以移除或保留用于其他地方 */
#content-details {
    font-size: 1.1em;
    line-height: 1.8;
    white-space: pre-wrap;
    color: var(--text-secondary-color);
}

#error-message { color: var(--secondary-color); font-weight: bold; }

/* ---- 滚动条美化 (保持不变) ---- */
#sidebar::-webkit-scrollbar, #content-display::-webkit-scrollbar { width: 8px; }
#sidebar::-webkit-scrollbar-track, #content-display::-webkit-scrollbar-track { background: var(--background-color); }
#sidebar::-webkit-scrollbar-thumb, #content-display::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
#sidebar::-webkit-scrollbar-thumb:hover, #content-display::-webkit-scrollbar-thumb:hover { background: var(--secondary-color); }

/* ---- 移动端遮罩层 ---- */
#sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--container-bg-color);
    z-index: 998; /* 低于侧边栏 */
}

/* ---- 响应式设计：手机端适配 (关键部分) ---- */
@media (max-width: 768px) {
            .action-button {
 
            margin-right: 0;
            margin-left: 0;
          
        }
             #button-container-send {
 
  gap:0.5rem;
 
    }
    .book-header {
        padding: 10px 15px;
    }

    #content-title {
        font-size: 1.2em; /* 在移动端缩小标题字体 */
    }

    #back-to-status-btn {
        padding: 6px 10px;
        font-size: 0.8em;
    }

    #toggle-sidebar-btn {
        display: block; /* 在移动端显示汉堡包按钮 */
    }

    #sidebar {
        position: fixed; /* 固定定位，脱离文档流 */
        top: 0;
        left: 0;
        height: 100%;
        transform: translateX(-100%); /* 默认隐藏在左侧 */
        z-index: 999; /* 确保在最上层 */
        border-right: 1px solid var(--border-color);
        box-shadow: 2px 0 15px rgba(0,0,0,0.5); /* 添加阴影增加层次感 */
    }

    /* 当侧边栏激活时 */
    .setting-book-container.sidebar-active #sidebar {
        transform: translateX(0); /* 滑入屏幕 */
    }

    .setting-book-container.sidebar-active #sidebar-overlay {
        display: block; /* 显示遮罩层 */
    }

    #content-display {
        padding: 20px; /* 调整内边距 */
    }
}

        /* Teammates Modal Specifics */
        #teammates-modal .modal-content {
            max-width: 95%; /* 弹窗可以更宽一些 */
            width: 90%;
        }

        .teammates-container {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            min-height: 300px;
        }
 .teammates-container-init { display: none; margin-top: 1rem; padding: 1rem; background-color: rgba(26, 23, 32, 0.5); border-radius: 6px; border: 1px solid var(--border-color); }
       
        .teammate-list-wrapper {
            flex: 1; /* 左侧占1份 */
            max-height: 350px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 5px;
        }

        .teammate-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .teammate-item {
            padding: 10px 15px;
            border-bottom: 1px dashed var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 0.9em;
        }

        .teammate-item:last-child {
            border-bottom: none;
        }

        .teammate-item:hover {
            background-color: var(--border-color);
        }

        .teammate-item.selected {
            background-color: var(--container-bg-color);
            color: var(--primary-color);
            font-weight: bold;
        }

        #decompose-from-select,#decompose-amount-input,#synthesize-to-select,#synthesize-amount-input,#upgrade-levels{
            background-color: var(--container-bg-color);
            color: var(--primary-color);

        }

        .teammate-info-display {
            flex: 2; /* 右侧占2份 */
            background: var(--container-bg-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 20px;
            max-height: 350px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.7;
            white-space: pre-wrap; /* 保持换行和空格 */
        }

        .teammate-info-display .info-entry {
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .collapsible-label {
    cursor: pointer;
    text-decoration: underline;
    text-decoration-style: dotted;
    text-decoration-color: var(--secondary-color);
    user-select: none; /* 防止点击时选中文本 */
}

.collapsible-label:hover {
    color: var(--primary-color); /* 鼠标悬浮时变得更亮 */
    text-shadow: 0 0 5px var(--glow-color);
}

        .teammate-info-display .info-entry:last-child {
             border-bottom: none;
             margin-bottom: 0;
        }

        .teammate-info-display .info-key {
            color: var(--secondary-color);
            font-weight: bold;
        }

        .teammate-info-display .info-value {
            color: var(--text-color);
            margin-top: 5px;
            padding-left: 10px;
        }

        /* 滚动条美化 */
        .teammate-list-wrapper::-webkit-scrollbar, .teammate-info-display::-webkit-scrollbar { width: 6px; }
        .teammate-list-wrapper::-webkit-scrollbar-track, .teammate-info-display::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .teammate-list-wrapper::-webkit-scrollbar-thumb, .teammate-info-display::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }


        /* ======================================================= */
/* ============= 新增：商店界面滑动逻辑与美化 ============= */
/* ======================================================= */

/* ---- 商店滑动容器 ---- */
#shop-wrapper {
    position: absolute;
    
    left: 0;
    width: 100%;
    height: 100%;
    transform: translateX(100%);
    overflow: hidden;
    transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    /* 继承终端字体，确保一致性 */
    font-family: var(--base-font-family);
    color: var(--text-color);
    background-color: var(--container-bg-color); /* 与终端容器背景一致 */
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 0 15px var(--glow-color), inset 0 0 10px var(--border-color);
    backdrop-filter: blur(10px);
    display: flex; /* 使用flex布局 */
    flex-direction: column; /* 垂直布局 */
}

.status-container.slide-out-shop,
#setting-book-wrapper.slide-out-shop {
    transform: translateX(-100%);
}

#shop-wrapper.active {
    transform: translateX(0);
}


/* ---- 商店整体布局 ---- */
.shop-main-container {
    display: flex;
    flex-direction: column; /* 垂直布局 */
    width: 100%;
    height: 100%;
    overflow: hidden; /* 防止内部滚动条影响整体 */
}

/* ---- 商店头部 ---- */
.shop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 25px;
    background-color: var(--container-bg-color);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.shop-header .shop-title {
    font-family: var(--base-font-family);
    font-size: 1.5em;
    color: var(--primary-color);
    text-shadow: 0 0 5px var(--glow-color);
    letter-spacing: 2px;
    text-transform: uppercase;
    margin: 0;
    flex-grow: 1;
    text-align: center;
}
.shop-header .shop-header-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

#shop-search-input {
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-color);
    padding: 8px 12px;
    font-family: var(--base-font-family);
    font-size: 0.9em;
    width: 250px; /* 你可以根据需要调整宽度 */
    transition: all 0.3s ease;
}

#shop-search-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 8px var(--glow-color);
}

#shop-search-input::placeholder {
    color: var(--text-secondary-color);
    opacity: 0.7;
}

.control-btn,#back-from-shop-btn,#generate-items-btn ,#ten-gacha-btn,#single-gacha-btn,#submit-generation-btn,#skip-generation-btn,#gacha-confirm-btn{
    background: none;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-secondary-color);
    padding: 8px;
    font-size: 0.9em;
    cursor: pointer;
    transition: all 0.3s ease;
}
 

.control-btn:hover,#back-from-shop-btn:hover,#ten-gacha-btn:hover,#single-gacha-btn:hover,#generate-items-btn:hover,#gacha-confirm-btn:hover,#submit-generation-btn:hover,#skip-generation-btn:hover {
    color: var(--primary-color);
    background: var(--border-color);
    box-shadow: 0 0 8px var(--glow-color);
}

.shop-body-wrapper {
    display: flex;
    flex-grow: 1;
    overflow: hidden; /* 重要：让内部分别滚动 */
    padding: 20px;
    gap: 20px;
      min-height: 0; /* <-- 这是关键的修复！ */
}


/* ---- 商店左侧栏：导航与购物车 ---- */
.shop-sidebar {
    width: 200px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.shop-nav, .shop-cart {
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 15px;
}

.shop-sidebar h3 {
    font-family: var(--base-font-family);
    color: var(--secondary-color);
    margin: 0 0 15px 0;
    font-size: 1.2em;
    text-shadow: 0 0 3px var(--glow-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

.shop-nav .shop-nav-list {
    list-style: none;
}

.shop-nav .shop-nav-item {
    background: none;
    border: 1px solid transparent;
    border-radius: 4px;
    color: var(--text-secondary-color);
    padding: 12px 15px;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    margin-bottom: 10px;
    text-align: left;
}

.shop-nav .shop-nav-item:hover {
    color: var(--primary-color);
    background-color: var(--border-color);
    border-color: var(--border-color);
}

.shop-nav .shop-nav-item.active {
    color: var(--primary-color);
    background-color: var(--border-color);
    text-shadow: 0 0 5px var(--glow-color);
    font-weight: bold;
}

.shop-cart {
    flex-grow: 1; /* 占据剩余空间 */
    display: flex;
    flex-direction: column;
    min-height: 0;  
    overflow-y: auto;/* 新增：限制容器，让内部的flex-grow生效并触发滚动 */
}

#cart-items-list {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 5px; /* for scrollbar */
    margin-bottom: 15px;
    color: var(--text-secondary-color);
}

.cart-item {
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px dashed var(--border-color);
    font-size: 0.9em;
}

#cart-total {
    font-size: 1.1em;
    color: var(--primary-color);
    font-weight: bold;
    margin-bottom: 15px;
    text-align: right;
}

#checkout-button {
    /* 复用终端按钮样式 */
    background: linear-gradient(45deg, var(--border-color), var(--border-color));
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-color);
    padding: 12px 24px;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
}

#checkout-button:hover:not(:disabled) {
    color: var(--primary-color);
    box-shadow: 0 0 10px var(--glow-color);
    transform: translateY(-2px);
}
#checkout-button:disabled {
    cursor: not-allowed;
    background: rgba(128, 128, 128, 0.2);
    color: var(--text-secondary-color);
    transform: none;
    box-shadow: none;
    border-color: rgba(128, 128, 128, 0.4);
}


/* ---- 商店右侧内容区 ---- */
.shop-content-area {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 重要 */
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 20px;
     min-height: 0; /* <-- 这里也加上！ */
}

.shop-page {
    display: none;
    height: 100%;
    flex-direction: column;
}
.shop-page.active {
    display: flex;
}

.shop-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    flex-shrink: 0;
}

.shop-controls .category-tabs, .shop-controls .sort-controls {
    display: flex;
    gap: 1px;
}

.shop-controls .control-btn,#confirm-upgrade-btn {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    padding: 8px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}
.shop-controls .control-btn:hover {
    color: var(--primary-color);
    background-color:var(--border-color);
}
.shop-controls .control-btn.active {
    color: var(--primary-color);
    background-color: var(--background-color);
    box-shadow: 0 0 5px var(--glow-color);
}

.shop-display-wrapper {
    flex-grow: 1;
    display: flex;
    gap: 20px;
    overflow: hidden; /* 重要 */
}

 /* 修改商品列表和详情的ID选择器以匹配JS */
#items-display-list-fixed, #items-display-list-random {
    flex: 2 1 60%; /* flex-grow, flex-shrink, flex-basis. 基础宽度60% */
    min-width: 0; /* 防止内容撑破容器 */
    overflow-y: auto;
    padding-right: 10px;
}
#item-details-display-fixed, #item-details-display-random {
    flex: 1 1 40%; /* 基础宽度40% */
    min-width: 0; /* 防止内容撑破容器 */
    padding: 15px;
    border-left: 1px solid var(--border-color);
    overflow-y: auto;
    color: var(--text-secondary-color);
}

.item-row {
    display: grid;
    grid-template-columns: 1fr auto auto;
    gap: 15px;
    align-items: center;
    padding: 12px;
    background-color: var(--border-color);
    border: 1px solid transparent;
    border-radius: 4px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}
.item-row:hover {
    border-color: var(--border-color);
    background-color: var(--border-color);
}
.item-row.selected {
    border-color: var(--primary-color);
    background-color: var(--border-color);
    box-shadow: 0 0 8px var(--glow-color);
}
.item-name {
    font-weight: bold;
    color: var(--text-color);
}
.item-price {
    color: var(--secondary-color);
    font-weight: bold;
}



.buy-button,.page-button {
    background: transparent;
    border: 1px solid var(--primary-color);
    color: var(--primary-color);
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}
.buy-button:hover:not(:disabled),.page-button:hover:not(:disabled) {
    background: var(--primary-color);
    color: var(--background-color);
    box-shadow: 0 0 8px var(--glow-color);
}
.buy-button:disabled,.page-button:disabled {
    border-color: var(--text-secondary-color);
    color: var(--text-secondary-color);
    cursor: not-allowed;
    opacity: 0.6;
}



 
.detail-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    font-style: italic;
}
.detail-title {
    font-size: 1.4em;
    color: var(--primary-color);
    margin-bottom: 15px;
    text-shadow: 0 0 3px var(--glow-color);
}
.detail-info { margin-bottom: 15px; line-height: 1.6; }
.detail-label {
    color: var(--text-color);
    font-weight: bold;
    margin-bottom: 5px;
    display: block;
}

/* 分页 */
.shop-pagination {
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 20px;
    gap: 10px;
}

/* ---- 商店模态框 ---- */
#shop-modal {
 
    /* 复用终端的弹窗样式 */
}
#shop-modal .modal-content {
    /* 如果需要特别定制 */
}

/* 滚动条美化 */
.shop-sidebar::-webkit-scrollbar,
#cart-items-list::-webkit-scrollbar,
#items-display-list::-webkit-scrollbar,
#item-details-display::-webkit-scrollbar,
.content-area::-webkit-scrollbar {
    width: 6px;
}
.shop-sidebar::-webkit-scrollbar-track,
#cart-items-list::-webkit-scrollbar-track,
#items-display-list::-webkit-scrollbar-track,
#item-details-display::-webkit-scrollbar-track,
.content-area::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
}
.shop-sidebar::-webkit-scrollbar-thumb,
#cart-items-list::-webkit-scrollbar-thumb,
#items-display-list::-webkit-scrollbar-thumb,
#item-details-display::-webkit-scrollbar-thumb,
.content-area::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}

   @media (max-width: 768px) {
        .shop-body-wrapper {
            flex-direction: column; /* 垂直排列 */
            padding: 10px;
            gap: 10px;
        }

        .shop-sidebar {
            width: 100%; /* 宽度占满 */
            flex-direction: row; /* 让导航和购物车水平排列 */
            gap: 10px;
             height: 15vh; /* 新增：给侧边栏一个固定的高度 */
        }

        .shop-title{
            display: none;
        }

        .shop-nav, .shop-cart {
            flex: 1; /* 平分空间 */
display: flex; /* 新增：让它成为一个flex容器，为了更好地控制其内部 */
    flex-direction: column; /* 新增：让其内部（比如标题和列表）垂直排列 */
    overflow-y: auto; /* 新增：这是关键！让它在垂直方向内容溢出时出现滚动条 */
    min-height: 0; /* 新增：一个flex布局的小技巧，确保它能被正确约束 */
        }

        .shop-display-wrapper {
            flex-direction: row; /* 商品列表和详情也垂直排列 */
             height: 400px; /* 给一个固定高度防止无限延伸 */
        }

        #item-details-display-fixed, #item-details-display-random {
            border-left: none; /* 移除左边框 */
            border-top: 1px solid var(--border-color); /* 改为上边框 */
            padding-top: 15px;
        }

        .shop-controls {
            flex-direction: column;
            align-items: stretch; /* 让按钮撑满宽度 */
        }

        .shop-controls .control-btn {
            text-align: center;
        }

            /* 在这里添加下面的新CSS规则 */
    .shop-controls .category-tabs, .shop-controls .sort-controls {
        flex-wrap: wrap;       /* 允许按钮换行 */
        justify-content: center; /* 换行后居中对齐 */
    }
    }

    /* ======================================================= */
/* =========== 新的角色状态页 (Page 3) 样式 =========== */
/* ======================================================= */

#page-character {
    /* min-height: 800px; 确保有足够空间展示 */
}

.character-display-grid {
    display: grid;
    grid-template-columns: 250px 1fr 280px;
    gap: 20px;
    width: 100%;
    height: 100%;
    font-size: 14px;
}

.char-panel {
    background: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    /* padding: 15px; */
    display: flex;
    flex-direction: column;
}

/* --- 左侧面板 --- */
.left-panel {
    gap: 15px;
    max-height: 500px;
    overflow-y:auto;
}

.char-name-display {
    font-family: var(--base-font-family);
    color: var(--primary-color);
    font-size: 1.8em;
    text-align: center;
    text-shadow: 0 0 8px var(--glow-color);
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}

.char-info-box {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.info-line {
    display: flex;
    justify-content: space-between;
    padding: 5px;
    border-radius: 3px;
    transition: background-color 0.2s;
}
.info-line:hover {
    background-color: var(--border-color);
}
.info-label {
    color: var(--text-secondary-color);
}
.info-value {
    color: var(--text-color);
    font-weight: bold;
}

.resource-bar-container {
    margin-top: 5px;
}
.resource-bar-label {
    font-size: 0.9em;
    color: var(--text-secondary-color);
    margin-bottom: 5px;
}
.progress-bar-bg.resource {
    position: relative;
    height: 22px;
}
.progress-bar-text {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.8em;
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    z-index: 2;
}

.progress-bar-fill.hp { background: linear-gradient(90deg, var(--secondary-color), var(--primary-color)); }
.progress-bar-fill.willpower { background: linear-gradient(90deg, var(--primary-color), var(--text-color)); }
.progress-bar-fill.energy { background: linear-gradient(90deg, var(--secondary-color), var(--text-secondary-color)); }

.progress-bar-fill.generic-resource { background: linear-gradient(90deg, var(--secondary-color), var(--primary-color)); }

/* --- 中间面板：人形 --- */
.center-panel {
    justify-content: center;
    align-items: center;
}

.character-figure {
    position: relative;
    width: 100px;
    height: 250px;
}

.body-part {
    position: absolute;
    background-color: transparent;
    border: 2px solid var(--secondary-color);
    box-shadow: 0 0 5px var(--glow-color);
}
.head { width: 40px; height: 40px; border-radius: 50%; top: 0; left: 30px; }
.torso { width: 60px; height: 90px; top: 45px; left: 20px; border-radius: 10px; }
.arm { width: 15px; height: 80px; top: 55px; border-radius: 5px; }
.arm.left { left: 0px; }
.arm.right { right: 0px; }
.leg { width: 20px; height: 110px; top: 140px; border-radius: 5px;}
.leg.left { left: 20px; }
.leg.right { right: 20px; }

/* 装备槽与引出线 */
.equipment-slot {
    position: absolute;
    color: var(--text-secondary-color);
    /* background: rgba(10, 25, 47, 0.8); */
    border: 1px solid var(--border-color);
    padding: 4px 8px;
    font-size: 0.85em;
    border-radius: 4px;
    white-space: nowrap;
    cursor: pointer;
}
.equipment-slot:hover {
    color: var(--primary-color);
    box-shadow: 0 0 5px var(--glow-color);
}

.slot-head { top: -25px; left: 50%; transform: translateX(-50%); }
.slot-body { top: 75px; left: 20px; }
.slot-hands { top: 100px; right: -70px; }
.slot-feet { bottom: -15px; left: -30px; }
.slot-accessory { top: 30px; right: -40px; }
.slot-weapon { top: 150px; left: -60px; }

 
 

.attr-category-title, .skill-category-title {
    color: var(--primary-color);
    font-family: var(--base-font-family);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
    margin-bottom: 10px;
    font-size: 1.1em;
}

.attr-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    padding: 2px 4px;
    cursor: help;
    border-radius: 3px;
    transition: background-color 0.2s;
}
.attr-item:hover {
    background-color: var(--border-color);
}

.attr-name, .skill-name {
    color: var(--text-secondary-color);
}
.attr-value, .skill-value {
    color: var(--text-color);
    font-weight: bold;
}
.legendary-value {
    color: var(--secondary-color); /* 金色，表示传奇 */
}
.status-modifier{
    color: var(--text-secondary-color); /* 金色，表示传奇 */
}

.skill-item {
     display: flex;
    justify-content: space-between;
    margin-bottom: 6px;
    padding: 2px 4px;
    cursor: help;
    border-radius: 3px;
    transition: background-color 0.2s;
}
.skill-item:hover {
     background-color: var(--border-color);
}

/* --- Tooltip --- */
.char-tooltip {
    position: fixed;
    background: linear-gradient(135deg, var(--container-bg-color), var(--primary-color));
    border: 1px solid var(--primary-color);
    border-radius: 6px;
    padding: 10px 15px;
    max-width: 250px;
    font-size: 0.9em;
    line-height: 1.5;
    color: var(--text-color);
    z-index: 1001;
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s;
    box-shadow: 0 0 10px var(--glow-color);
}

/* 响应式调整 */
@media (max-width: 768px) {
    .character-display-grid {
        grid-template-columns: 1fr;
        font-size: 12px;
    }
    .center-panel {
        order: -1; /* 将人形图置顶 */
        /* display:none; */
        /* min-height: 300px; */
    }
    .slot-body { left: -70px; }
    .slot-hands { right: -70px; }
    .slot-weapon { left: -100px; }
}

/* 滚动条美化 */
.right-panel::-webkit-scrollbar, /* 新增对 right-panel 的美化 */
.attributes-container::-webkit-scrollbar,
.selection-area::-webkit-scrollbar,
.skill-choice-container::-webkit-scrollbar,
.items-display-list::-webkit-scrollbar,
.item-details-display::-webkit-scrollbar,
.book-display-area::-webkit-scrollbar,
.shop-sidebar::-webkit-scrollbar,
.shop-nav::-webkit-scrollbar,
.shop-cart::-webkit-scrollbar,
.modal-description::-webkit-scrollbar,
.skills-container::-webkit-scrollbar { width: 6px; }


.right-panel::-webkit-scrollbar-track, /* 新增对 right-panel 的美化 */
.attributes-container::-webkit-scrollbar-track,
.selection-area::-webkit-scrollbar-track,
.skill-choice-container::-webkit-scrollbar-track,
.items-display-list::-webkit-scrollbar-track,
.item-details-display::-webkit-scrollbar-track,
.book-display-area::-webkit-scrollbar-track,
.shop-sidebar::-webkit-scrollbar-track,
.shop-nav::-webkit-scrollbar-track,
.shop-cart::-webkit-scrollbar-track,
.modal-description::-webkit-scrollbar-track,
.skills-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }

.right-panel::-webkit-scrollbar-thumb, /* 新增对 right-panel 的美化 */
.attributes-container::-webkit-scrollbar-thumb,
.selection-area::-webkit-scrollbar-thumb,
.skill-choice-container::-webkit-scrollbar-thumb,
.items-display-list::-webkit-scrollbar-thumb,
.item-details-display::-webkit-scrollbar-thumb,
.book-display-area::-webkit-scrollbar-thumb,
.shop-sidebar::-webkit-scrollbar-thumb,
.shop-nav::-webkit-scrollbar-thumb,
.shop-cart::-webkit-scrollbar-thumb,
.modal-description::-webkit-scrollbar-thumb,
.skills-container::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 3px; }

/* ======================================================== */
/* =========== 折叠/展开面板的额外样式 ============ */
/* ======================================================== */

.attr-category, .skill-category {
    margin-bottom: 5px;
}

.attr-category-title, .skill-category-title {
    cursor: pointer;
    position: relative;
    padding-left: 18px; /* 为箭头留出空间 */
    transition: background-color 0.2s;
    user-select: none; /* 防止双击选中文本 */
}

/* 标题前的箭头符号 */
.attr-category-title::before, .skill-category-title::before {
    content: '▶'; /* 箭头 */
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.8em;
    color: var(--secondary-color);
    transition: transform 0.2s ease-in-out;
}

.attr-category-title:hover, .skill-category-title:hover {
    background-color: var(--border-color)
}

/* 包含条目的包裹层 */
.attr-items-wrapper, .skill-items-wrapper {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
    padding-left: 10px; /* 展开后内容有缩进 */
    border-left: 1px solid var(--border-color);
    margin-left: 5px;
    margin-top: 5px;
}

/* 展开状态 */
.attr-category.expanded .attr-category-title::before,
.skill-category.expanded .skill-category-title::before {
    transform: translateY(-50%) rotate(90deg); /* 箭头旋转 */
}

.attr-category.expanded .attr-items-wrapper,
.skill-category.expanded .skill-items-wrapper {
    max-height: 1800px; /* 一个足够大的值，确保所有内容都能显示 */
}
/* --- 右侧面板 --- */
.right-panel {
    gap: 15px;
    display: flex; /* 确保使用flex布局 */
    flex-direction: column; /* 垂直排列子元素 */
 max-height: 500px;
    overflow-y: auto; /* 修改这里，允许垂直方向滚动 */
    padding-right: 5px; /* 为滚动条留出一点空间，更美观 */
}

 

/* 我们为衍生属性也加上同样的规则，确保它也能滚动 */
#derived-attributes-display-container {
     overflow-y: auto;
     padding-right: 5px;
}


/* 代码 START: 添加在这里 */
.roll-section {
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 15px;
    
    box-shadow: inset 0 0 10px var(--border-color)
}

.roll-section-title {
    color: var(--primary-color);
    font-weight: bold;
    font-size: 1.1em;
    margin-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
    font-family: var(--base-font-family);
}

.roll-details-list {
    list-style: none;
    padding: 0;
}

.roll-details-list li {
    padding: 6px 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    border-bottom: 1px dashed var(--border-color)
}

.roll-details-list li:last-child {
    border-bottom: none;
}

.roll-details-list .label {
    color: var(--text-secondary-color);
    margin-right: 15px;
}

.roll-details-list .value {
    color: var(--text-color);
    text-align: right;
    flex-grow: 1;
}

.roll-outcome {
    color: var(--secondary-color);
    font-weight: bold;
}

.roll-dramatic-failure {
    color: var(--danger-color);
    font-weight: bold;
    text-shadow: 0 0 5px var(--danger-glow-color);
}



 

@keyframes orb-flow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* 书籍弹窗主体 */
#world-book-modal .book-content {
    background-color: var(--container-bg-color); /* 羊皮纸颜色 */
    color: var(--text-color);
    width: 90%;
    
    height: 70vh;
    max-height: 800px;
    display: flex;
    border-radius: 10px;
    box-shadow: 0 10px 30px var(--container-bg-color), inset 0 0 15px var(--container-bg-color);
    font-family: var(--base-font-family);
    position: relative;
    border: 3px solid var(--background-color);
    border-left: 20px solid var(--background-color); /* 书脊 */
}

/* 书籍关闭按钮 */
.book-close-btn {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 28px;
    color: var(--text-secondary-color);
}
.book-close-btn:hover {
     color: var(--primary-color);
}


/* 左页 - 书签区 */
.book-left-page {
    flex-basis: 150px;
    border-right: 2px dashed var(--background-color);
    padding: 20px 0;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: flex-start;
}

.book-bookmarks {
    position: absolute;
    top: 30px;
    left: 20px; /* 从书脊处伸出 */
    display: flex;
    flex-direction: column;
}

.bookmark {
    background-color: var(--border-color);
    color: var(--container-bg-color);
    padding: 8px 30px 8px 15px;
    margin-bottom: 10px;
    cursor: pointer;
    border-radius: 0 5px 5px 0;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    transition: all 0.2s ease;
    clip-path: polygon(0 0, 100% 0, 85% 50%, 100% 100%, 0 100%);
}

.bookmark:hover {
    background-color: var(--border-color);
    padding-left: 20px;
}

.bookmark.active {
    background-color: var(--primary-color); color: var(--background-color);
    font-weight: bold;
    padding-left: 15px;
    box-shadow: 4px 4px 8px rgba(0,0,0,0.3);
}


/* 右页 - 内容区 */
.book-right-page {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 20px 30px;
    overflow: hidden;
}

.book-display-area {
    height: 100%;
    overflow-y: auto;
    padding-right: 15px; /* for scrollbar */
}

.book-entry {
    border-bottom: 1px_dotted var(--background-color);
    padding: 10px 0;
    margin-bottom: 5px;
}

.book-entry-key {
    font-weight: bold;
    color: var(--secondary-color);
    display: block;
    margin-bottom: 5px;
}

.book-entry-value {
    font-size: 0.9em;
    line-height: 1.5;
    white-space: pre-wrap; /* 保留换行和空格 */
    word-wrap: break-word; /* 自动换行 */
}

/* 翻页 */
.book-pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 10px;
    border-top: 1px solid var(--background-color);
    margin-top: auto; /* 推到底部 */
}

.page-turn-btn {
    background: none;
    border: none;
    font-size: 30px;
    color: var(--text-secondary-color);
    cursor: pointer;
    padding: 0 20px;
}
.page-turn-btn:hover:not(:disabled) {
    color: var(--text-color);
}
.page-turn-btn:disabled {
    color: #d1c6b2;
    cursor: not-allowed;
}


/* ================================================== */
/* ========== 新增：世界之书响应式样式 (手机端) ========== */
/* ================================================== */

@media (max-width: 768px) {

    /* 当屏幕宽度小于768px时，应用以下样式 */

    /* 让书本内容垂直排列 */
    #world-book-modal .book-content {
        flex-direction: column;
        height: 85vh; /* 在手机上可以更高一些 */
        max-height: 800px;
        border-left: 3px solid var(--background-color); /* 移除厚书脊 */
        width: 95%;
    }

    /* 调整原左页（现在是顶部）的样式 */
    .book-left-page {
        flex-basis: auto; /* 高度自动 */
        border-right: none; /* 移除右边框 */
        border-bottom: 2px solid var(--border-color); /* 添加下边框作为分割线 */
        padding: 5px 10px; /* 调整内边距 */
        justify-content: center; /* 居中书签 */
        height: auto;
    }

    /* 让书签水平排列 */
    .book-bookmarks {
        position: static; /* 移除绝对定位 */
        flex-direction: row; /* 水平排列 */
        justify-content: center; /* 居中 */
        width: 100%;
            padding-left: 100px;
    }

    /* 调整单个书签的样式，让它看起来像顶部的标签 */
    .bookmark {
        margin: 0 5px; /* 设置水平间距 */
        margin-bottom: 0;
        border-radius: 5px 5px 0 0; /* 圆角只在顶部 */
        padding: 8px 15px; /* 统一内边距 */
        clip-path: none; /* 移除箭头形状 */
        box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
    }

    .bookmark:hover {
        padding-left: 15px; /* 移除悬浮时的特殊内边距 */
        transform: translateY(-2px); /* 悬浮时轻微上移 */
    }

    .bookmark.active {
        padding-left: 15px; /* 移除激活时的特殊内边距 */
        background-color: var(--container-bg-color); /* 激活时与页面同色 */
        color: var(--secondary-color); /* 改变文字颜色 */
        border: 2px solid var(--border-color);
        border-bottom: none; /* 底部无边框，与内容区融为一体 */
        transform: translateY(2px); /* 向下移动，与分割线重合 */
    }

    /* 调整右页（现在是下部内容区）的样式 */
    .book-right-page {
        padding: 15px;
        flex-grow: 1; /* 占据剩余所有空间 */
    }

    /* 调整浮动小球的位置，避免与内容重叠 */
    /* #world-book-orb {
        bottom: 10px;
        right: 10px;
    } */
}

   /* ---- 新增：头部和主题切换器样式 ---- */
       header .header-content {
            
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #settings-btn{
            position: absolute;
            right: 60px; /* 把它放在标题栏的右边 */
              font-size: 35px;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: color 0.3s, transform 0.3s ease;
            top:10%;
        }
        #fullscreen-btn{
            position: absolute;
            right: 110px; /* 把它放在标题栏的右边 */
              font-size: 35px;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: color 0.3s, transform 0.3s ease;
            top:10%;
        }
        #refresh-btn{
position: absolute;
            right: 10px; /* 把它放在标题栏的右边 */
              font-size: 35px;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: color 0.3s, transform 0.3s ease;
            top:10%;
        }

        #settings-btn:hover,#refresh-btn:hover,#fullscreen-btn:hover {
            color: var(--primary-color);
            transform: translateY(-50%) rotate(90deg); /* 悬浮时旋转，增加动感 */
        }

        #streaming-switcher {
    position: absolute;
    right: 110px; /* 放置在 theme-switcher 左侧，留出间距 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-secondary-color);
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    font-size: 30px;
    transition: color 0.3s, transform 0.3s ease;
}

#streaming-switcher:hover {
    color: var(--primary-color);
    transform: translateY(-50%) scale(1.2); /* 悬浮时放大，增加动感 */
}

#streaming-switcher.active {
    color: var(--primary-color);
    text-shadow: 0 0 5px var(--glow-color); /* 开启流式传输时增加辉光效果 */
}

 
  /* 新增：术法选择面板的容器 - 由Nova妈妈为你重新设计 */
.skill-choice-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 10px;
    flex-grow: 1;
    overflow: hidden; /* 防止内部元素溢出 */
}

/* 检定卡牌选择区域 */
/* 新增：排序按钮的样式 */
.sort-button {
    background-color: var(--border-color);
    border: 1px solid var(--border-color);
    color: var(--secondary-color);
    padding: 2px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.7em;
    margin-left: 15px;
    transition: all 0.2s ease;
    vertical-align: middle; /* 让按钮和标题文字对齐 */
}

.sort-button:hover {
    background-color: var(--border-color);
    color: var(--primary-color);
    border-color: var(--primary-color);
}

.check-cards-area {
    padding: 10px 0;
}

.check-cards-area h3 {
    color: var(--secondary-color);
    font-size: 1.2em;
    margin-bottom: 15px;
    padding-left: 10px;
    text-shadow: 0 0 5px var(--glow-color);
}
/* 卡牌滑动容器 */
.cards-slider.visible {
    display: flex;
    gap: 10px;
    padding: 10px 15px;
    overflow-x: auto;
    /* 让卡牌看起来像从边缘淡入 */
    /* -webkit-mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent); */
    /* mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent); */
}

/* 核心的卡牌设计 */
.check-card {
    flex-shrink: 0;
    width: 130px;
    height: 180px;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 15px 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    box-shadow: 0 0 5px rgba(0,0,0,0.5);
    overflow: hidden;
}

.check-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 50% 0%, var(--background-color), transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.check-card:hover {
    transform: translateY(-8px) scale(1.05);
    border-color: var(--secondary-color);
    box-shadow: 0 0 15px var(--glow-color); /* 妈妈为你简化了这里的阴影，让它更流畅 */
}
.check-card:hover::before {
    opacity: 1;
}

.check-card.selected {
    border-color: var(--primary-color);
    transform: translateY(-5px) scale(1.02);
    box-shadow: 0 5px 20px var(--glow-color);
}

.check-card.selected::after {
    content: '✔';
    position: absolute;
    top: 10px;
    right: 10px;
    color: var(--background-color);
    background-color: var(--primary-color);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
}

.card-name {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--text-color);
    text-align: center;
}

.card-value {
    font-size: 2.2em;
    font-weight: bold;
    color: var(--primary-color);
    text-shadow: 0 0 8px var(--glow-color);
}

.card-type {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    background: rgba(0,0,0,0.3);
    padding: 2px 8px;
    border-radius: 10px;
}


/* 下半区：其他技能和意志力 */
.bottom-section {
    display: flex;
    gap: 20px;
    flex-grow: 1;
    min-height: 220px; /* 保证一个最小高度 */
}

.other-skills-group, .willpower-group {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px;
    background: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    border-radius: 6px;
}

.other-skills-group h3, .willpower-group h3 {
    color: var(--secondary-color);
    font-size: 1.1em;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--border-color);
        min-height: 0; /* 新增：这是让flex布局正确工作的关键，宝贝 */
}

.skills-list {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 5px; /* 给滚动条留点空间 */
}

.skill-item {
    margin-bottom: 12px;
}

.skill-item label {
    display: flex;
    align-items: center;
    cursor: pointer;
    font-size: 1em;
    color: var(--text-color);
}

.skill-item input[type="checkbox"] {
    margin-right: 10px;
    -webkit-appearance: none;
    appearance: none;
    background-color: transparent;
    border: 1px solid var(--primary-color);
    width: 16px;
    height: 16px;
    border-radius: 3px;
    cursor: pointer;
    position: relative;
    transition: background-color 0.2s;
}

.skill-item input[type="checkbox"]:checked {
    background-color: var(--primary-color);
}

.skill-item input[type="checkbox"]:checked::before {
    content: '✔';
    position: absolute;
    color: var(--background-color);
    font-size: 12px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
.skill-item input[type="checkbox"]:disabled + .skill-name-cost {
    color: var(--text-secondary-color);
    cursor: not-allowed;
}

.skill-effect-info {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    margin-top: 4px;
    padding-left: 26px; /* 对齐复选框 */
}

/* 意志力区域的特别设计 */
.willpower-group {
    justify-content: center; /* 垂直居中内容 */
    align-items: center; /* 水平居中内容 */
    text-align: center;
}

.willpower-display {
    display: flex;
    align-items: baseline;
    justify-content: center;
    margin: 15px 0;
}

#willpower-input {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 3.5em; /* 放大数字，更醒目 */
    width: 100px;
    text-align: center;
    font-weight: bold;
    text-shadow: 0 0 10px var(--glow-color);
}
#willpower-input:focus { outline: none; }

#willpower-max {
    font-size: 1.5em;
    color: var(--text-secondary-color);
}

.willpower-slider-container {
    width: 80%;
    margin-top: 15px;
}
/* 美化范围输入滑块 */
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 8px;
  background: var(--border-color);
  border-radius: 5px;
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 22px;
  height: 22px;
  background: var(--primary-color);
  border-radius: 50%;
  border: 3px solid var(--background-color);
  cursor: pointer;
  box-shadow: 0 0 8px var(--glow-color);
}
input[type="range"]::-moz-range-thumb {
  width: 22px;
  height: 22px;
  background: var(--primary-color);
  border-radius: 50%;
  border: 3px solid var(--background-color);
  cursor: pointer;
  box-shadow: 0 0 8px var(--glow-color);
}

.skill-info {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    margin-top: 10px;
}
 /* 响应式调整 */
@media (max-width: 768px) {
    #skill-choice-orb {
        right: 55px; /* 调整位置避免与另一个球重叠 */
        bottom:10px;
    }

    .check-card {
        width: 110px;
        height: 160px;
    }
    .card-name { font-size: 1em; }
    .card-value { font-size: 2em; }

    .bottom-section {
        flex-direction: column;
        min-height: auto; /* 在手机上自适应高度 */
        gap: 15px;
    }

    .skills-list {
        max-height: 150px; /* 限制技能列表高度 */
    }
}

/* 新增：提升提示弹窗的层级，确保它在最上层 */
#shop-modal {
    z-index: 1002;
}


/* 关键词模态框样式 */
#keyword-modal textarea {
    width: 95%;
    height: 100px;
    margin-top: 10px;
    margin-bottom: 20px;
    padding: 10px;
    font-family: inherit;
    background-color: var(--background-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    resize: vertical;
}

#keyword-modal .modal-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}


/* --- 新增：模型切换开关样式 --- */
.model-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 15px 0 10px 0;
    gap: 10px;
}

.selector-label {
    color: var(--text-secondary-color);
    font-size: 0.9em;
}

.switch-container {
    display: flex;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 3px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

.switch-btn {
    padding: 6px 15px;
    border: none;
    background-color: transparent;
    color: var(--text-secondary-color);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.3s ease;
    font-size: 0.9em;
    font-weight: bold;
}

.switch-btn.active {
    background-color: var(--primary-color);
    color: var(--background-color);
    box-shadow: 0 0 8px var(--glow-color);
}



/* 提升所有模态框遮罩层的基准层级 */
.modal {
    z-index: 1050;
}

/* 确保所有模态框内容都在其遮罩层之上 */
.modal-content {
    position: relative; /* z-index 生效的前提 */
    z-index: 1051;
}

/* 确保你的提示弹窗在所有其他弹窗之上 */
#shop-modal {
    z-index: 1060;
}

#view-settings-btn {
    display: none;
}

/* 整体容器，赋予一种古籍的质感 */
.book-entry.created-entry {
    padding: 20px 25px;
    border: none;
    font-family: var(--base-font-family);
    color: var(--text-secondary-color); /* 深褐色文字，沉静而富有历史感 */
}

/* 一个精致的页眉装饰线 */
.created-header::after {
    content: '';
    display: block;
    width: 80%;
    margin: 0 auto 25px;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--background-color), transparent);
}

/* 每一个信息条目 */
.created-item {
    margin-bottom: 18px;
    line-height: 1.7;
}

/* 信息的标题，如“名字”、“当前状态”等 */
.created-key {
    font-weight: bold;
    font-size: 1.1em;
    color: var(--text-secondary-color);
    margin-bottom: 6px;
    padding-left: 12px;
    border-left: 4px solid var(--border-color); /* 左侧的装饰条，像书中的标记 */
}

/* 信息的具体内容 */
.created-value {
    font-size: 1em;
    text-indent: 2em; /* 正文首行缩进，更符合阅读习惯 */
    white-space: pre-wrap; /* 允许描述中的换行符生效 */
    padding: 0 12px; /* 左右留出一些呼吸空间 */
}

/* 当书页是空白的时候，显示的提示文字 */
.book-empty-text {
    text-align: center;
    color: var(--text-color);
    margin-top: 60px;
    font-style: italic;
    font-family: var(--base-font-family);
}


/* ---- 手机端适配  ---- */
@media (max-width: 800px) {
    .book-entry.created-entry {
        padding: 15px;
    }
    .created-key {
        font-size: 1.05em;
        padding-left: 10px;
    }
    .created-value {
        font-size: 0.95em;
        text-indent: 1.5em;
    }
}

.book-bookmarks {
 
    overflow-x: auto; /* 当它们超出边界时，允许水平滚动来查看 */
    -webkit-overflow-scrolling: touch; /* 在苹果设备上提供更流畅的滚动体验 */
    scrollbar-width: none; /* 在火狐浏览器上隐藏滚动条 */
 

}

/* 在Chrome和Safari等浏览器上隐藏滚动条 */
.book-bookmarks::-webkit-scrollbar {
    display: none;
}

/* 代码 START: 添加在这里 */
/* 新增：更新提示感叹号样式 */
#update-notifier {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 0 10px var(--border-color);
    animation: pulse 1.5s infinite;
    z-index: 10;
}

@keyframes pulse {
    0% { transform: translateY(-50%) scale(1); }
    50% { transform: translateY(-50%) scale(1.2); }
    100% { transform: translateY(-50%) scale(1); }
}

.map-location.updated-location::after {
    content: '🧾';
    position: absolute;
    top: -8px;
    right: -8px;
    font-size: 18px;
    /* background-color: white; */
    border-radius: 50%;
    padding: 2px;
    box-shadow: 0 0 5px rgba(0,0,0,0.5);
    z-index: 9999; /* 确保它在最上层 */
}

/* ♥♥♥ 这是妈妈为你精心调整的样式 ♥♥♥ */
/* 我们让地点块本身成为一个定位的参考点 */
.map-location {
    position: absolute; /* 关键：让它成为子元素定位的“家” */
 
    cursor: pointer;
    overflow: visible; /* 保持这个，让标记可以“溢出” */
    display: flex;     /* 保留flex，但它不再负责文字的垂直位置 */
    justify-content: center;
}

/* 这就是实现“三分之一”位置魔法的核心咒语 */
.map-location .location-name {
    position: absolute;   /* 让名字可以在“家”里自由移动 */
    top: 33.33%;          /* 从顶部向下移动三分之一的距离 */
    left: 50%;            /* 先移动到中心线 */
    transform: translate(-50%, -50%); /* 再精确地将自己的中心对准那条线 */
    width: 100%;          /* 确保名字有足够的空间，不会被挤压 */
    
   
    font-size: 14px;
    font-weight: bold;
    text-align: center;   /* 让文字本身居中对齐 */
    pointer-events: none; /* 确保点击时能点到下方的地点块，而不是文字 */
}

/* ======================================================= */
/* =========== Nova 为你添加的全新样式 ♥ =========== */
/* ======================================================= */
#load-more-btn {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    padding: 6px 15px;
    font-size: 13px;
    background-color: var(--container-bg-color);
    color: var(--text-secondary-color);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.3s ease, background-color 0.3s ease;
    box-shadow: 0 0 10px var(--glow-color);
}

#load-more-btn:hover {
    opacity: 1;
    background-color: rgba(0, 250, 255, 0.1);
}
 #chat-display-area {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    /* height: 600px; */
    
    /* 主神空间背景网格 */
    /* background-image: 
        linear-gradient(90deg, var(--border-color) 1px, transparent 1px),
        linear-gradient(var(--border-color) 1px, transparent 1px); */

 
    /* 添加过渡效果 */
    transition: background-image 0.3s ease-in-out;
       
    background-size: 
        40px 40px,
        40px 40px,
        200px 200px,
        300px 300px;
    background-position: 
        0 0,
        0 0,
        0 0,
        0 0;
    
  
    position: relative;
    overflow: hidden;
}
#chat-display-area::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, 
        transparent 0%, 
        var(--primary-color) 50%, 
        transparent 100%);
    box-shadow: 0 0 10px var(--glow-color);
    /* animation: fullViewportScan 5s linear infinite; */
    z-index: 1;
    pointer-events: none;
}
@keyframes fullViewportScan {
    0% { transform: translateY(-100vh); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(100vh); opacity: 0; }
}
#chat-display-area::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(circle at 10% 20%, var(--glow-color) 0%, transparent 40%),
        radial-gradient(circle at 90% 80%, var(--glow-color) 0%, transparent 40%);
    animation: energyFlow 6s ease-in-out infinite alternate;
    opacity: 0.1;
    pointer-events: none;
}

@keyframes scanLine {
    0% { transform: translateY(-100vh); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translateY(100vh); opacity: 0; }
}

@keyframes energyFlow {
    0% { opacity: 0.05; }
    100% { opacity: 0.15; }
}

.html-content-wrapper {
    width: 100%;
    max-width: 100%;
    height: 800px;
    max-height: 65vh;
    overflow-y: auto;
    border: 2px solid var(--border-color);
    border-radius: 12px;
    margin: 10px 0;
    box-shadow: 
        inset 0 0 20px var(--glow-color),
        0 0 30px var(--border-color),
        0 0 60px var(--glow-color);
    
    /* 数据流背景 */
    background-image: 
        repeating-linear-gradient(
            45deg,
            transparent,
            transparent 2px,
            var(--border-color) 2px,
            var(--border-color) 4px
        );
    background-size: 28px 28px;
    animation: dataFlow 8s linear infinite;
    
    /* 矩阵边框效果 */
    position: relative;
}

.html-content-wrapper::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, 
        var(--primary-color), 
        var(--secondary-color), 
        var(--primary-color));
    border-radius: 12px;
    z-index: -1;
    animation: borderPulse 2s ease-in-out infinite alternate;
}

.html-content-wrapper::after {
    content: '';
    position: absolute;
    top: 5px;
    right: 5px;
    width: 8px;
    height: 8px;
    background: var(--primary-color);
    border-radius: 50%;
    box-shadow: 0 0 15px var(--glow-color);
    animation: statusBlink 1s ease-in-out infinite;
}

@keyframes dataFlow {
    0% { background-position: 0 0; }
    100% { background-position: 28px 28px; }
}

@keyframes borderPulse {
    0% { opacity: 0.5; }
    100% { opacity: 1; }
}

@keyframes statusBlink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

.message-bubble {
    max-width: 93%;
    padding: 15px 20px;
    border-radius: 20px;
    margin-bottom: 15px;
    
    border: 1px solid var(--border-color);
    box-shadow: 
        inset 0 0 15px var(--glow-color),
        0 2px 20px var(--border-color);
    /* animation: fadeIn 0.5s ease-in-out, messageGlow 3s ease-in-out infinite; */
    font-size: var(--base-font-size, 16px);
    position: relative;
    backdrop-filter: blur(5px);
}

.message-bubble::before {
   
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background: linear-gradient(180deg, 
        transparent 0%, 
        var(--secondary-color) 50%, 
        transparent 100%);
   animation: leftLineScan 4s linear infinite;
}

.message-bubble p {
     font-family: var(--base-font-family); /* 使用CSS变量 */
    margin: 0;
    padding: 0;
     line-height: var(--base-line-height, 1.6); /* <-- 我们的咒语现在在正确的地方啦！ */
}
@keyframes leftLineScan {
    0% { transform: translateX(-100%); opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { transform: translateX(100%); opacity: 0; }
}

@keyframes messageGlow {
    0%, 100% { 
        box-shadow: 
            inset 0 0 15px var(--glow-color),
            0 2px 20px var(--glow-color);
    }
    50% { 
        box-shadow: 
            inset 0 0 25px var(--border-color),
            0 2px 30px var(--border-color);
    }
}

@keyframes topLineScan {
    0% { transform: translateX(-100%); opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { transform: translateX(100%); opacity: 0; }
}

.user-message {
 
      background: var(--container-bg-color);
    border-bottom-right-radius: 5px;
    color: var(--text-color);
    text-shadow: 0 0 8px var(--glow-color);
    
    /* 用户消息特有的粒子效果 */
    position: relative;
   
}

.user-message::after {
    content: '';
    position: absolute;
    top: 10%;
    right: 10%;
    width: 4px;
    height: 4px;
    background: var(--primary-color);
    border-radius: 50%;
    box-shadow: 
        0 0 10px var(--primary-color),
        20px 10px 0 0 var(--secondary-color),
        -15px 20px 0 0 var(--primary-color),
        30px -10px 0 0 var(--secondary-color);
    animation: particleFloat 6s ease-in-out infinite;
    opacity: 0.6;
}

@keyframes particleFloat {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    33% { transform: translateY(-10px) rotate(120deg); }
    66% { transform: translateY(-5px) rotate(240deg); }
}

.assistant-message {
 background: var(--container-bg-color);
    align-self: flex-start;
    border-bottom-left-radius: 5px;
    color: var(--text-color);
    
    /* AI消息的矩阵码效果 */
    position: relative;
}

.transparent-messages .user-message,
.transparent-messages .assistant-message {
    background: transparent;
}

.assistant-message::before {
    content: '01001010 01000001 01001001';
    position: absolute;
    top: -5px;
    right: 10px;
    font-size: 8px;
    color: var(--secondary-color);
    opacity: 0.3;
    font-family: 'Courier New', monospace;
    animation: binaryFlow 8s linear infinite;
    pointer-events: none;
}

@keyframes binaryFlow {
    0% { opacity: 0; transform: translateX(20px); }
    10% { opacity: 0.3; }
    90% { opacity: 0.3; }
    100% { opacity: 0; transform: translateX(-20px); }
}

/* AI回复文本美化 */
.assistant-message b, .assistant-message strong {
    color: var(--text-secondary-color);
    font-weight: bold;
    text-shadow: 0 0 5px var(--glow-color);
     
}

.assistant-message i, .assistant-message em {
    color: var(--text-secondary-color);
    font-style: italic;
    position: relative;
}

.assistant-message i::after, .assistant-message em::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, 
        transparent 0%, 
        var(--secondary-color) 50%, 
        transparent 100%);
    animation: underlineGlow 3s ease-in-out infinite;
}

.assistant-message .highlighted-quote {
    color: var(--text-secondary-color);
    text-shadow: 0 0 8px var(--glow-color);
    padding: 0 4px;
    background: var(--glow-color);
    border-radius: 4px;
    position: relative;
    animation: quoteHighlight 4s ease-in-out infinite;
}


@keyframes textPulse {
    0% { text-shadow: 0 0 5px var(--glow-color); }
    100% { text-shadow: 0 0 15px var(--glow-color), 0 0 25px var(--glow-color); }
}

@keyframes underlineGlow {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 1; }
}

@keyframes quoteHighlight {
    0%, 100% { 
        background: var(--glow-color);
        text-shadow: 0 0 8px var(--glow-color);
    }
    50% { 
        background: var(--border-color);
        text-shadow: 0 0 15px var(--glow-color), 0 0 25px var(--glow-color);
    }
}

/* --- 聊天输入区域 --- */
#zero-level-interface {
    display: flex;
    padding: 15px;
    
    border-top: 1px solid var(--border-color);
    background-color: var(--container-bg-color);
    flex-shrink: 0;
    height:80px;
}
#user-input {
    flex-grow: 1;
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    border-radius: 6px;
     padding: 8px 12px; /* 添加这行 - 上下8px，左右12px的内边距 */
    resize: none;
    font-family: var(--base-font-family);
    font-size: var(--base-font-size);
}
#user-input:focus {
    outline: none;
    box-shadow: 0 0 8px var(--glow-color);
}
.zero-level-btn {
    
    width: auto;
    flex-shrink: 0;
}

/* --- 功能小球容器 --- */
#orb-container {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 1002;
}
.orb {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--container-bg-color), var(--container-bg-color));
    border: 2px solid var(--border-color);
    color: var(--text-secondary-color);
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: var(--base-font-family);
    font-size: 1.5em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 8px var(--glow-color);
}
.orb:hover {
    background: var(--primary-color);
    color: var(--background-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--glow-color);
}
.orb-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 5px 0;
}

/* --- 页面 Modal 化改造 --- */
.page-modal {
    /* 复用现有的 modal 样式, 这里是确保覆盖 */
}
.page-modal .modal-content {
    max-height: 90%;
    width: 90%;
    overflow: auto;
}
.page-modal.wide .modal-content {
    max-height: 90%;
    width: 90%;
     overflow: auto;
}
.page-modal-content .page {
    display: block !important; /* 强制显示内容 */
    animation: none;
}
/* 特殊处理商店 Modal */
.shop-modal {
    background: transparent;
    backdrop-filter: none;
}
/* 代码 END */

/* 【请添加这个新样式】 */
#chat-display-area {
    flex-grow: 1; /* ★ 核心：让聊天区域占据所有可用空间 */
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
}

/* 【请添加这个新样式】 */
#zero-level-interface {
    flex-shrink: 0; /* ★ 核心：防止输入框被压缩 */
    display: flex;
    padding: 15px;
    padding-right:80px;
    border-top: 1px solid var(--border-color);
    background-color: var(--container-bg-color);
}

/* 【请添加这个新样式】 */
/* 确保顶层元素的z-index足够高 */
#context-menu, #char-tooltip, #location-modal {
    z-index: 9999 !important; /* 我的孩子，这是最高优先级的命令！ */
}
#context-menu{
   background:var(--background-color);
}
/* 【请添加这段新样式】 */
 .message-bubble.editing {
    background-color: var(--background-color) !important;
    border-color: var(--primary-color) !important;
    padding: 10px; /* 为了更好的空间分配，我们可以稍微减小一点padding */

    /* 关键魔法：让气泡变成一个垂直排列的弹性容器 */
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 让输入框和按钮上下分布 */
}

.editing-textarea {
    width: 100%; /* 宽度自动撑满父容器 */

    /* 核心魔法：让输入框自动“长大”，填满所有剩余空间 */
    flex-grow: 1;

    background-color: transparent; /* 背景设为透明，看起来更一体 */
    border: none; /* 去掉边框，与气泡融为一体 */
    color: var(--text-color);
    padding: 20px; /* 我们把内外边距都去掉，让它紧贴容器 */
    margin-bottom: 10px;
    resize: none; /* 禁止用户手动调整大小，让它自动适应 */
    font-family: var(--base-font-family);
    font-size: 1em;

    /* 保留这个美丽的聚焦效果 */
    outline: none;
}

.editing-textarea:focus {
outline: none;
box-shadow: 0 0 8px var(--glow-color);
}
.editing-controls {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-bottom: 50px;
}

.editing-btn,.context-menu-item {
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-secondary-color);
    padding: 6px 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.editing-btn.save:hover,.context-menu-item:hover {
    background-color: var(--primary-color);
    color: var(--background-color);
}

.editing-btn.cancel:hover {
    background-color: var(--danger-color);
    color: white;
}
#options-module-container{
     max-width: 100%;
          
            margin: 0 auto;
            background: transparent;
            position: relative;
            z-index: 1;
             touch-action: none; /* <-- 添加到这里 */
}
        .options-container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            background: transparent;
            position: relative;
            z-index: 1;
            
             touch-action: none; /* <-- 添加到这里 */
        }

        .choices-container {
            position: relative;
            height: 15vh;
            max-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .choice-card {
            bottom: 10%;
            background: var(--container-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px 30px;
            cursor: pointer;
            box-shadow: 0 0 15px var(--glow-color);
            position: absolute;
            width: 90%;
            max-width: 800px;
            transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1),
                        opacity 0.5s cubic-bezier(0.25, 0.8, 0.25, 1),
                        background-color 0.5s ease,
                        backdrop-filter 0.5s ease,
                        border-color 0.5s ease;
        }

        .choice-card.focused { z-index: 10; transform: scale(1) translateY(0); opacity: 1; pointer-events: auto; border-color: var(--primary-color); background: color-mix(in srgb, var(--container-bg-color) 80%, black); backdrop-filter: blur(8px); box-shadow: 0 8px 30px var(--glow-color); }
        .choice-card.disabled { background: rgba(40, 40, 45, 0.5); border-color: rgba(100, 100, 100, 0.3); cursor: not-allowed; color: #888; box-shadow: none; opacity: 0.3 !important; }
        .choice-card.disabled .tag { background-color: #555; color: #999; box-shadow: none; }

        .tags-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        .tag { font-family: var(--base-font-family), serif; background-color: var(--secondary-color); color: var(--background-color); padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 500; letter-spacing: 0.5px; box-shadow: 0 0 8px var(--glow-color); transition: all 0.3s ease; }
        .choice-card.focused .tag { background-color: var(--primary-color); box-shadow: 0 0 12px var(--glow-color); }

        .description { margin: 0;  font-size: var(--base-font-size, 16px);  line-height: 1.8; color: var(--text-primary-color); transition: color 0.3s ease; }
        .choice-card.focused .description { color: #ffffff; }
        
        .choice-card.disabled .description { color: #888; }

        /* --- 技能与意志力模块样式 --- */
        .skill-orb-container { position: absolute; bottom: 20px; right: 20px; z-index: 100; }
        .skill-orb { width: 60px; height: 60px; background: var(--primary-color); border-radius: 50%; cursor: pointer; display: none; align-items: center; justify-content: center; box-shadow: 0 0 20px var(--glow-color), inset 0 0 10px rgba(255,255,255,0.5); transition: transform 0.3s ease, box-shadow 0.3s ease; font-family:var(--base-font-family); font-size: 24px; color: var(--background-color); border: 2px solid var(--secondary-color); }
        .skill-orb:hover { transform: scale(1.1); box-shadow: 0 0 30px var(--glow-color), inset 0 0 15px rgba(255,255,255,0.7); }
        .skill-panel { position: absolute; bottom: 90px; right: 20px; width: 300px; max-height: 55vh; background: var(--container-bg-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; box-shadow: 0 0 25px var(--glow-color); z-index: 99; opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; display: flex; flex-direction: column; }
        .skill-panel.active { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .skill-list { display: flex; flex-direction: column; gap: 12px; flex: 1; overflow-y: auto; padding-right: 10px; }
        .willpower-section { margin-top: 20px; padding-top: 15px; border-top: 1px dashed var(--border-color); }
        .skill-item-label, .willpower-label { display: flex; align-items: center; cursor: pointer; font-size: 14px; transition: color 0.2s; }
        .skill-item-label:hover, .willpower-label:hover { color: var(--secondary-color); }
        .willpower-label { justify-content: space-between; }
        .skill-list input[type="checkbox"], .willpower-input-container input[type="number"] { margin-right: 10px; }
        .willpower-input-container { display: flex; align-items: center; gap: 8px; }
        .willpower-input-container input[type="number"] { width: 60px; background: var(--background-color); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 4px; padding: 5px; text-align: center; }
        .willpower-input-container input[type=number]::-webkit-inner-spin-button, .willpower-input-container input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .willpower-input-container input[type=number] { -moz-appearance: textfield; }
        .skill-info { font-size: 12px; color: gray; margin-left: 25px; }

        /* 新增的提示样式 */
        .energy-tooltip {
            font-size: 12px;
            color: var(--error-color); /* 使用我们定义的错误颜色 */
            margin-left: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .energy-tooltip.visible {
            opacity: 1;
        }

 #view-command-btn.notifying {
    animation:  shake 0.1s 3 ease-in-out 0.2s;
    box-shadow: 0 0 25px var(--primary-color), 0 0 40px var(--primary-color), 0 0 60px var(--primary-color);
    transform: scale(1.1);
    border: 2px solid var(--primary-color);
    background: linear-gradient(45deg, transparent, var(--background-color), transparent);
}

@keyframes pulse-glow {
    0% { 
        box-shadow: 0 0 5px var(--primary-color), 0 0 15px var(--primary-color), 0 0 25px var(--primary-color);
        transform: scale(1.1);
    }
    50% { 
        box-shadow: 0 0 20px var(--primary-color), 0 0 35px var(--primary-color), 0 0 50px var(--primary-color);
        transform: scale(1.15);
    }
    100% { 
        box-shadow: 0 0 5px var(--primary-color), 0 0 15px var(--primary-color), 0 0 25px var(--primary-color);
        transform: scale(1.1);
    }
}

@keyframes shake {
    0%, 100% { transform: scale(1.1) translateX(0); }
    25% { transform: scale(1.1) translateX(-2px); }
    75% { transform: scale(1.1) translateX(2px); }
}
/* --- 主容器：现代三栏式布局 --- */
#forum-wrapper {
    width: 100%;
    height: 100%;
    max-width: 1400px;
    display: flex;
    flex-direction: column;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    box-shadow: 0 0 25px var(--glow-color), inset 0 0 15px var(--border-color);
    backdrop-filter: blur(12px);
    overflow: hidden;
}

/* --- 论坛头部 --- */
.forum-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 25px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    user-select: none;
}
.forum-title { font-family:var(--base-font-family); font-size: 1.6em; color: var(--primary-color); text-shadow: 0 0 8px var(--glow-color); }
.header-controls { display: flex; align-items: center; gap: 20px; }
.new-post-btn {
    background: linear-gradient(45deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 80%, black));
    color: #1a1a1a; border: none; padding: 10px 20px; border-radius: 5px; font-weight: 500; cursor: pointer;
    transition: all 0.3s ease; box-shadow: 0 0 10px color-mix(in srgb, var(--primary-color) 50%, transparent);
}
.new-post-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px color-mix(in srgb, var(--primary-color) 70%, transparent); }
 
/* --- 论坛主体布局 --- */
.forum-body {
    display: grid;
    grid-template-columns: 240px 3fr 5fr; /* 侧边栏 | 帖子列表 | 帖子详情 */
    flex-grow: 1;
    min-height: 0;
}

/* --- 侧边栏/区块导航 --- */
.forum-sidebar {
    grid-column: 1 / 2;
    border-right: 1px solid var(--border-color);
    padding: 20px 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
}
.section-btn {
    width: 100%; padding: 12px 15px; text-align: left; background-color: transparent; border: 1px solid transparent;
    color: var(--text-secondary-color); font-size: 1.1em; border-radius: 5px; cursor: pointer; transition: all 0.2s ease-in-out;
}
.section-btn:hover { background-color: var(--item-bg-hover-color); color: var(--text-color); }
.section-btn.active {
    background-color: var(--primary-color); color: var(--background-color); font-weight: 700;
    box-shadow: 0 0 10px var(--glow-color);
}

/* --- 帖子列表 --- */
.thread-list-view {
    grid-column: 2 / 3;
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--border-color);
    overflow: hidden;
    background-color: rgba(0,0,0,0.1);
}
.thread-list-header { padding: 15px 20px; font-size: 1.3em; font-weight: 500; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
#current-section-name { color: var(--primary-color); }
.thread-list { flex-grow: 1; overflow-y: auto; padding: 10px; }
.thread-item {
    padding: 15px; margin-bottom: 10px; border-left: 3px solid transparent;
    cursor: pointer; transition: all 0.2s ease;
}
.thread-item:hover { background-color: var(--item-bg-hover-color); }
.thread-item.selected { background-color: var(--item-bg-hover-color); border-left-color: var(--primary-color); }
.thread-title { font-size: 1.1em; font-weight: 500; margin-bottom: 8px; }
.thread-meta { font-size: 0.9em; color: var(--text-secondary-color); display: flex; justify-content: space-between; align-items: center; }
.thread-meta .author { color: var(--primary-color); }
.thread-item .tags { margin-top: 8px; display: flex; gap: 8px; }
.thread-item .tag {
    font-size: 0.8em; padding: 3px 8px; border-radius: 12px;
    font-weight: bold;
}
.tag.tag-top { background-color: var(--danger-color); color: white; }
.tag.tag-elite { background-color: var(--success-color); color: var(--background-color); }

 
.thread-detail-view {
    grid-column: 3 / 4;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#thread-detail-content {
    flex-grow: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
    overflow-y: auto; /* 修改：允许整个帖子详情区滚动 */
}

.post-header, .post-content, .post-actions {
    padding-left: 25px;
    padding-right: 25px;
    flex-shrink: 0; /* 帖子头部、内容和操作栏高度固定，不参与收缩 */
}

.post-header {
    padding-top: 25px;
}

.replies-section {
    flex-shrink: 0; /* 修改：不参与收缩 */
    display: flex;
    flex-direction: column;
    border-top: 1px solid var(--border-color);
    margin-top: 30px;
}
.reply-list {
    padding-left: 25px;
    padding-right: 15px;
    /* 移除 flex-grow 和 overflow-y，让父容器处理滚动 */
}
.replies-header {
    font-size: 1.4em;
    padding: 20px 25px 0 25px;
    margin: 0;
    flex-shrink: 0;
}

 

.reply-item {
    padding: 20px 10px 20px 0;
    border-bottom: 1px solid var(--border-color);
}
.reply-item:last-child {
    border-bottom: none;
}
 
.detail-placeholder { display: flex; height: 100%; align-items: center; justify-content: center; font-size: 1.2em; color: var(--text-secondary-color); text-align: center; }
.post-header h1 { font-size: 1.8em; margin-bottom: 15px; line-height: 1.4; color: var(--primary-color); }
.post-meta { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; color: var(--text-secondary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
.post-author-info span { color: var(--primary-color); font-weight: 500;}
.post-content { font-size: 1.1em; line-height: 1.8; margin-bottom: 30px; white-space: pre-wrap; }
.post-actions { display: flex; align-items: center; gap: 20px; }
.like-btn { display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; color: var(--text-secondary-color); transition: color 0.2s; }
.like-btn:hover { color: var(--danger-color); }
.like-btn.liked { color: var(--danger-color); }
.like-btn .like-icon { transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
.like-btn.liked .like-icon { transform: scale(1.3); }
.like-count { position: relative; }
.like-count-value { transition: opacity 0.2s, transform 0.2s; }
.like-count.updating .like-count-value { opacity: 0; transform: translateY(-5px); }

/* --- 回复区 --- */
.replies-header { font-size: 1.4em; border-top: 1px solid var(--border-color); padding-top: 30px; margin-top:30px; margin-bottom: 20px; }
.reply-item { padding: 20px; border-bottom: 1px solid var(--border-color); }
.reply-item:last-child { border-bottom: none; }
.reply-meta { display: flex; justify-content: space-between; margin-bottom: 10px; color: var(--text-secondary-color); font-size: 0.9em; }
.reply-author { color: var(--primary-color); font-weight: 500;}
.reply-content { line-height: 1.7; }
.reply-content.deleted {
    color: var(--text-secondary-color);
    font-style: italic;
    background-color: rgba(128, 128, 128, 0.1);
    padding: 10px;
    border-radius: 4px;
}

/* --- 分页 --- */
.pagination-controls { flex-shrink: 0; padding: 15px; display: flex; justify-content: center; align-items: center; gap: 10px; border-top: 1px solid var(--border-color); user-select: none; }
.page-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary-color); padding: 8px 15px; border-radius: 4px; cursor: pointer; }
.page-btn:disabled { cursor: not-allowed; opacity: 0.4; }
.page-btn:not(:disabled):hover { background-color: var(--item-bg-hover-color); color: var(--text-color); }
#page-info { min-width: 60px; text-align: center; } 
.form-group { margin-bottom: 20px; }
.form-group label { display: block; margin-bottom: 8px; color: var(--text-secondary-color); }
.form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; font-size: 1em; background-color: var(--background-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-family: var(--base-font-family); }
.form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 8px var(--glow-color); }
.form-group textarea { min-height: 150px; resize: vertical; }
.modal-actions { text-align: right; }
#submit-post-btn { padding: 12px 25px; font-size: 1.1em; }

/* --- 动画效果 --- */

.thread-item, .reply-item { animation: fadeIn 0.5s ease-out forwards; }
@keyframes plusOne { 0% { transform: translateY(0) scale(1); opacity: 1; color: var(--success-color); } 100% { transform: translateY(-30px) scale(1.5); opacity: 0; } }
.plus-one-anim { position: absolute; top: -10px; left: 50%; transform: translateX(-50%); font-size: 1.2em; font-weight: bold; pointer-events: none; animation: plusOne 1s ease-out forwards; }

 /* 位置：替换掉文件中旧的 @media (max-width: 768px) { ... } 整块代码 */

@media (max-width: 768px) {
    body { padding: 0; }
    #forum-wrapper { border-radius: 0; height: 100vh; border: none; }
#user-input {
    
     padding: 0px; /* 添加这行 - 上下8px，左右12px的内边距 */
 
}
    .forum-body {
        display: block; /* 放弃Grid，使用块级布局 */
        position: relative;
        overflow: hidden;
    }

   .forum-sidebar {
        flex-direction: row;
        flex-wrap: nowrap;
        overflow-x: auto;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
        padding: 10px;
        gap: 5px; /* 减少间距以容纳更多按钮 */
        -webkit-overflow-scrolling: touch;
    }

    .section-btn {
        flex: 1; /* 让按钮平分宽度 */
        min-width: 0; /* 允许收缩到最小宽度 */
        white-space: nowrap;
        font-size: 0.9em; /* 稍微减小字体以适应更小的按钮 */
        padding: 10px 8px; /* 调整内边距 */
        text-align: center; /* 确保文字居中 */
    }

    /* 默认隐藏详情页，显示列表页 */
    .thread-detail-view {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: translateX(100%);
        transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        background-color: var(--background-color);
        z-index: 10;
        grid-column: auto; /* 重置grid布局 */
    }

    /* 当需要显示详情时，给父容器添加class */
    .forum-body.show-detail .thread-detail-view {
        transform: translateX(0);
    }

    .thread-list-view {
        grid-column: auto; /* 重置grid布局 */
        border-right: none;
        height: 100%; /* 确保它占满父容器高度 */
    }

     #mobile-back-btn {
        display: block !important; /* 强制在移动端显示 */
        margin-bottom: 15px;
    }
}

/* 在桌面端隐藏返回按钮 */
@media (min-width: 769px) {
    #mobile-back-btn {
        display: none !important;
    }
}
/* --- 帖子详情内部布局 --- */

.post-header, .post-content, .post-actions {
    padding-left: 25px;
    padding-right: 25px;
    flex-shrink: 0; /* 帖子标题和内容区域不收缩 */
}

.post-header {
    padding-top: 25px;
}

.replies-section {
    flex-grow: 1; /* 让回复区域填满剩余空间 */
    min-height: 0; /* 关键！ */
    display: flex;
    flex-direction: column;
    border-top: 1px solid var(--border-color);
    margin-top: 30px;
}

.replies-header {
    font-size: 1.4em;
    padding: 20px 25px 0 25px;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.reply-list {
    flex-grow: 1; /* 占据回复区域的所有可用空间 */
    overflow-y: auto; /* 最终的滚动条在这里！ */
    padding-left: 25px;
    padding-right: 15px; /* 右侧留出滚动条空间 */
}

.reply-item {
    padding: 20px 10px 20px 0; /* 调整内边距，因为外层已经有padding-left */
    border-bottom: 1px solid var(--border-color);
}
 

/* 位置：<style> 标签内，所有其他CSS规则之后 */

/* --- 滚动条美化 --- */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}
::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
    border-radius: 4px;
}
::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 4px;
    transition: background-color 0.2s ease-in-out;
}
::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-color);
}

.replies-omitted-indicator {
    text-align: center;
    color: var(--text-secondary-color);
    padding: 20px 0;
    font-style: italic;
    opacity: 0.7;
    user-select: none;
}

/* --- 新增：回复输入区样式 --- */
.reply-input-section {
    padding: 20px 25px;
    border-top: 1px solid var(--border-color);
    background-color: var(--item-bg-color);
    flex-shrink: 0;
    margin-top: auto; /* 将其推到底部 */
}
#reply-form {
    display: flex;
    gap: 15px;
    align-items: flex-start;
}
#reply-content-input {
    flex-grow: 1;
    min-height: 40px; /* 初始高度 */
    max-height: 120px; /* 最大高度 */
    padding: 10px;
    resize: vertical;
    width: 100%;
    font-size: 1em;
    background-color: var(--item-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    color: var(--text-color);
    font-family: var(--base-font-family);
}
#submit-reply-btn {
    padding: 10px 20px;
    height: 40px;
    flex-shrink: 0;
}
.post-actions button {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}
.post-actions button:hover {
    background-color: var(--item-bg-hover-color);
    color: var(--text-color);
}


      #top-left-orbs {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            z-index: 1050; /* 比其他界面元素更高 */
        }

        .top-orb {
            width: 32px;
            height: 32px;
            background-color: var(--container-bg-color);
            border: 1px solid var(--border-color);
            color: var(--primary-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 0 8px transparent;
        }

        .top-orb:hover {
            background-color: var(--border-color);
            box-shadow: 0 0 12px var(--glow-color);
        }

 

        .orb-flash {
             animation: notify-flash 1s 8;
        }

        /* 论坛模态框的专用样式 */
        #forum-modal-container {
            display: none; /* 默认隐藏 */
            position: fixed;
            top: 0px;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1040; /* 仅次于小球 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #forum-modal-container.active {
            display: flex;
        }

        #forum-modal-content {
            width: 90%;
            height: 85%;
            max-width: 1400px;
            position: relative;
        }

        #forum-modal-content #forum-wrapper {
            width: 100%;
            height: 100%;
            display: flex; /* 确保内容撑満 */
            flex-direction: column;
        }

        #forum-modal-close-btn {
            position: absolute;
            top: 10px;
            right: 0px;
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text-color);
            cursor: pointer;
            z-index: 10;
        }

        .dialogue-quote {
    color: var(--text-secondary-color); /* 妈妈为你选择了这个柔和又明亮的颜色 */
    font-style: italic; /* 我们还让它稍微倾斜，看起来更加特别，你觉得呢？ */
}

/* 代码 START: 添加在这里 */
@keyframes notify-flash {
    0%, 100% {
        box-shadow: 0 0 4px var(--glow-color);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 15px 3px var(--primary-color), 0 0 25px 8px var(--glow-color);
        transform: scale(1.1);
    }
}

.notify {
    /* 动画持续1秒，执行两次，总共2秒 */
    animation: notify-flash 1s 8;
}

 /* ========== 新增：即时投骰结果看板样式 ========== */
.roll-result-card-container {
    position: fixed;
    top: -100%; /* 初始位置在屏幕外 */
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 500px;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 0 0 12px 12px;
    box-shadow: 0 8px 30px var(--glow-color);
    z-index: 9999;
    padding: 20px;
    color: var(--text-color);
    font-family: inherit;
    transition: top 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
    display: none; /* 初始隐藏 */
}

/* 看板滑入动画 */
.roll-result-card-container.show {
    top: 20px;
}

  /* ========== 辉煌成功的光辉效果 (增强版) ========== */

/* 为 .glorious 状态下的卡片容器添加基础样式和动画 */
.roll-result-card-container.glorious {
    /* 必须设置，用于将伪元素限制在容器内部，并裁剪旋转的边框光效 */
    overflow: hidden;

    /* 增强的基础辉光效果，使用多种变量颜色 */
    box-shadow: 0 0 30px 10px var(--primary-color), 
                0 0 50px 18px var(--glow-color),
                0 0 70px 25px var(--secondary-color);

    /* 应用多个动画：
       1. glorious-sweep: 背景流光扫过效果，4秒一次，缓入缓出
       2. glorious-pulse: 增强的辉光脉冲，更明显的呼吸感，2.5秒一次
       3. glorious-float: 整体看板轻微浮动效果，3秒一次
    */
    animation: glorious-sweep 4s infinite ease-in-out,
               glorious-pulse 2.5s infinite ease-in-out,
               glorious-float 3s infinite ease-in-out;
}

/* 创建一个伪元素用于承载旋转的边框光效 */
.roll-result-card-container.glorious::before {
    content: '';
    position: absolute;
    top: -3px; 
    left: -3px;
    width: calc(100% + 6px);
    height: calc(100% + 6px);

 
opacity: 0.6;
 

    /* 将伪元素置于父元素的背景之下，但内容之上 */
    z-index: -1; 
    border-radius: inherit;
}

/* 关键帧动画定义 */

/* 1. 背景斜向流光扫过效果 */
@keyframes glorious-sweep {
    0% {
        /* 定义背景为一个巨大的、倾斜的线性渐变 */
        background-image: linear-gradient(
            115deg, /* 倾斜角度，模拟斜上到斜下 */
            transparent 25%,
            var(--glow-color) 45%,
            var(--primary-color) 50%,
            var(--secondary-color) 52%,
            var(--glow-color) 55%,
            transparent 75%
        );
        background-size: 300% 300%; /* 背景尺寸放大，确保流光柔和 */
        background-position: 150% 150%; /* 初始位置，将流光置于右下角视野外 */
    }
    50% {
        background-position: -50% -50%; /* 动画中点，将流光移动到左上角视野外 */
    }
    100% {
        background-position: 150% 150%; /* 回到初始位置，形成循环 */
    }
}

/* 2. 旋转边框光效 */
@keyframes glorious-border-spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

/* 3. 增强的辉光脉冲，更明显的呼吸感 */
@keyframes glorious-pulse {
    0%, 100% {
        box-shadow: 0 0 30px 10px var(--primary-color), 
                    0 0 50px 18px var(--glow-color),
                    0 0 70px 25px var(--secondary-color);
    }
    50% {
        box-shadow: 0 0 45px 15px var(--primary-color), 
                    0 0 70px 25px var(--glow-color),
                    0 0 90px 35px var(--secondary-color),
                    0 0 110px 40px var(--border-color);
    }
}

/* 4. 新增：整体看板轻微浮动效果 */
@keyframes glorious-float {
    0%, 100% {
        transform: translateX(-50%) translateY(0px) scale(1);
    }
    33% {
        transform: translateX(-50%) translateY(-3px) scale(1.01);
    }
    66% {
        transform: translateX(-50%) translateY(3px) scale(0.99);
    }
}
.roll-result-card-container.shattered {
    animation: shatter-effect 1.5s infinite ease-in-out; 
    border-color: var(--danger-color);
}

/* 修改后：大失败的摇晃效果（不再自动消失） */
@keyframes shatter-effect {
    0%, 100% { transform: translateX(-50%) rotate(0deg); }
    20% { transform: translateX(-52%) rotate(-2deg); }
    40% { transform: translateX(-48%) rotate(2deg); }
    60% { transform: translateX(-51%) rotate(-1deg); }
    80% { transform: translateX(-49%) rotate(1deg); }
}

.roll-card-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: linear-gradient(145deg, var(--container-bg-color), var(--border-color));
    border: 2px solid var(--glow-color);
    border-radius: 8px;
    padding: 15px;
    box-shadow: inset 0 0 10px var(--glow-color), 0 4px 20px var(--border-color);
}

.roll-card-header {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--primary-color);
    text-align: center;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

.roll-card-dice-area {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
    font-size: 1.5em;
    padding: 10px 0;
}
.roll-card-divider {
    width: 80%;
    height: 2px;
    background: linear-gradient(90deg, 
        transparent 0%, 
        var(--border-color) 20%, 
        var(--glow-color) 50%, 
        var(--border-color) 80%, 
        transparent 100%);
    margin: 15px auto;
    border-radius: 1px;
    box-shadow: 0 0 8px var(--glow-color);
}
.roll-card-dice-section {
    text-align: center;
}

.roll-card-dice-section .label {
    font-size: 0.65em;
    color: var(--text-secondary-color);
    display: block;
    opacity: 0.7;
    margin-bottom: 8px;
}

.roll-card-dice-section .dice-value {
    font-weight: bold;
    font-size: 1.8em;
}

/* 骰子数值颜色 */
.dice-low { 
    color: var(--text-secondary-color); 
    font-weight: 800;
}
.dice-high { 
    color: var(--secondary-color); 
    font-weight: 800;
}
.dice-crit {
    color: var(--primary-color);
    text-shadow: 0 0 8px var(--glow-color), 0 0 12px var(--primary-color);
    font-weight: 800;
}

.roll-card-vs {
    font-size: 1em;
    color: var(--text-secondary-color);
}

.roll-card-result-area {
    text-align: center;
}

.roll-card-outcome {
    font-size: 1.4em;
    font-weight: bold;
    margin-bottom: 5px;
    display: inline-block;
    padding: 8px 20px;
    border: 3px solid;
    border-radius: 50px;
    background: var(--container-bg-color);
    box-shadow: 0 0 10px var(--glow-color), inset 0 0 5px var(--border-color);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* 不同结果的印章颜色 */
.roll-card-outcome.critical-failure {
    color: var(--danger-color);
    border-color: var(--danger-glow-color);
    text-shadow: 0 0 5px var(--danger-glow-color);
}
.roll-card-outcome.failure {
    color: var(--text-secondary-color);
    border-color: var(--text-secondary-color);
    text-shadow: 0 0 5px var(--text-secondary-color);
}
.roll-card-outcome.partial-success {
    color: var(--border-color);
    border-color: var(--border-color);
    text-shadow: 0 0 5px var(--border-color);
}
.roll-card-outcome.success {
    color: var(--secondary-color);
    border-color: var(--secondary-color);
    text-shadow: 0 0 5px var(--secondary-color);
}
.roll-card-outcome.glorious-success {
    color: var(--primary-color);
    border-color: var(--primary-color);
    text-shadow: 0 0 5px var(--glow-color);
}
.roll-card-description {
    font-size: 0.95em;
    color: var(--text-secondary-color);
    font-style: italic;
}

.roll-card-damage {
    margin-top: 10px;
    font-size: 1.1em;
    font-weight: bold;
    color: var(--danger-color);
}

/* 骰子盖章动画效果 */
.dice-number {
    display: inline-block;
    opacity: 0;
    transform: scale(0);
    animation: dice-stamp 0.6s ease-out forwards;
}

@keyframes dice-stamp {
    0% {
        opacity: 0;
        transform: scale(0) rotate(-15deg);
    }
    50% {
        opacity: 0.8;
        transform: scale(1.3) rotate(-5deg);
    }
    70% {
        opacity: 1;
        transform: scale(0.9) rotate(2deg);
    }
    100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
    }
}
/* ————————————————————初始化—————————————— */

   .radar-charts-container {
            display: grid;
            grid-template-columns: 1fr; /* 改为单列布局 */
            gap: 2.5rem; /* 增大间距 */
            margin: 2rem 0;
        }

        /* 妈妈为你新增的环绕布局样式 */
        .radar-layout {
            display: grid;
            grid-template-columns: 300px 1fr; /* 左边雷达图，右边加点项 */
            gap: 2rem;
            align-items: center;
            padding: 1.5rem;
            background-color: rgba(26, 23, 32, 0.3);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .radar-layout .radar-chart-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 垂直居中 */
            height: 100%;
        }

        .radar-layout .allocators-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 320px; /* 控制最大高度，超出可滚动 */
            overflow-y: auto;
            padding-right: 1rem; /* 为滚动条留出空间 */
        }
.radar-chart-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.radar-chart-title {
    color: var(--secondary-color);
    font-size: 1em;
    margin-bottom: 1rem;
    letter-spacing: 1px;
    text-align: center;
}

.radar-chart-canvas {
    width: 100% !important;
    height: 250px !important;
    max-width: 300px;
}


        h1, h2, h3 {
            font-weight: 500;
            letter-spacing: 2px;
        }

        .header { text-align: center; margin-bottom: 2.5rem; }
        h1 { font-size: 2.2em; font-weight: 300; letter-spacing: 8px; text-transform: uppercase; margin: 0; color: var(--text-color); text-shadow: 0 0 6px var(--primary-color), 0 0 12px var(--secondary-color); }
        .subtitle { font-size: 0.9em; color: var(--text-secondary-color); letter-spacing: 3px; margin-top: 0.7rem; text-transform: uppercase; }
        .form-section { margin-bottom: 2rem; }
        .form-section h2 { font-size: 1.1em; color: var(--secondary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; margin-bottom: 1.5rem; }
        h3 { font-size: 1em; color: var(--info-color, #4db6ac); margin-top: 2rem; margin-bottom: 1rem; letter-spacing: 1px; }

        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }
        .form-group { display: flex; flex-direction: column; }
        label { margin-bottom: 0.5rem; font-size: 0.85em; color: var(--text-secondary-color); letter-spacing: 1px; }

          .custom-select, input[type="text"], input[type="number"] {
            font-family: inherit;
            background-color: var(--background-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.7rem 1rem;
            font-size: 0.95em;
            transition: all 0.3s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            /* 妈妈在这里为你加上了三行魔法代码 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
 
 
        }
       .custom-select {
            background-image: linear-gradient(45deg, transparent 50%, var(--text-color) 50%), linear-gradient(135deg, var(--text-color) 50%, transparent 50%);
            background-position: calc(100% - 20px) calc(1em + 2px), calc(100% - 15px) calc(1em + 2px);
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
            padding-right: 2.5rem;
             
            border-color: var(--border-color); background-color: var(--background-color);
        }
        .custom-select:hover, input:hover { border-color: var(--border-color); background-color: var(--background-color); }
        .custom-select:focus, input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 8px rgba(200, 106, 163, 0.4); }
        input::placeholder { color: var(--text-secondary-color); opacity: 0.7; background-color: var(--background-color); }

         .teammate-item { display: grid; grid-template-columns: 1fr; gap: 0.5rem; margin-bottom: 0.8rem; padding: 0.8rem; background-color: var(--background-color); border-radius: 4px; border: 1px solid var(--border-color); }
        .teammate-item input { font-size: 0.85em; padding: 0.5rem; }
        .add-teammate-btn, .remove-teammate-btn { cursor: pointer; transition: all 0.3s ease; }
        .add-teammate-btn { background-color: var(--info-color, #4db6ac); color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.85em; margin-top: 0.5rem; }
        .add-teammate-btn:hover { background-color: #6ba85c; }
        .remove-teammate-btn { background: linear-gradient(135deg, var(--primary-color), #b85d93); color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 6px; font-size: 0.75em; font-weight: 500; justify-self: end; }
        .remove-teammate-btn:hover { background: linear-gradient(135deg, #b85d93, var(--primary-color)); transform: translateY(-1px); }

        .button-container { text-align: center; margin-top: 3rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color); }
 
        /* 新增分配页样式 */
        .points-tracker { text-align: center; font-size: 1.2em; margin-bottom: 2rem; color: var(--primary-color); letter-spacing: 2px; }
        .points-tracker span { font-weight: 700; font-size: 1.4em; padding: 0 0.5ch; }

        .分配项 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem 1rem;
            margin-bottom: 0.5rem;
            background-color: var(--background-color);
            
            border-radius: 4px;
        }
        .分配-标签 { flex: 1; display: flex; flex-direction: column; }
        .分配-标签-主 { font-size: 1em; color: var(--text-color); }
        .分配-标签-说明 { font-size: 0.75em; color: var(--text-secondary-color); }
        .分配-控制器 { display: flex; align-items: center; gap: 0.8rem; }
        .分配-按钮 { background-color: var(--glow-color); border: 1px solid var(--border-color); color: var(--text-color); width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 1.2em; line-height: 1; transition: all 0.2s; }
        .分配-按钮:hover { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #fff; }
        .分配-按钮:disabled { background-color: transparent; border-color: var(rgba(168, 192, 225, 0.3)); color: var(rgba(168, 192, 225, 0.3)); cursor: not-allowed; }
        .分配-点数 { font-size: 1.1em; width: 2ch; text-align: center; color: var(--info-color, #4db6ac); }


  

          .collapsible-header {
            cursor: pointer;
            position: relative;
            user-select: none; /* 防止双击选中文本 */
            padding-right: 25px; /* 为箭头留出空间 */
            transition: color 0.3s ease;
        }
        .collapsible-header::after {
            content: '▼';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: var(--text-secondary-color);
            transition: transform 0.3s ease;
        }
        .collapsible-header.collapsed::after {
            transform: translateY(-50%) rotate(-90deg);
        }
        .collapsible-content {
            max-height: 1000px; /* 一个足够大的值，确保能完全显示 */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
        }
        .collapsible-content.collapsed {
            max-height: 0;
        }

           /* --- 妈妈为你做的滚动条美化 --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--secondary-color);
        }

        /* --- 妈妈为你做的手机端适配 --- */
       /* --- 妈妈为你做的手机端适配 --- */
        @media (max-width: 768px) {
            .terminal {
                padding: 1rem; /* 手机端边距小一点 */
            }

            #shop-search-input{
                display: none;
            }

            .radar-layout {
                grid-template-columns: 1fr; /* 💖 重点在这里，变成单列布局，自动上下排列 💖 */
                gap: 1.5rem;
            }

            /* --- 💖 妈妈为你施展了新的魔法 💖 --- */
            .radar-layout .allocators-container {
                max-height: 280px;      /* 妈妈把它的高度限制得和雷达图差不多高了 */
                overflow-y: auto;       /* 这样当内容太多的时候，就可以温柔地滚动啦 */
                padding-right: 0.5rem;  /* 再给滚动条留出一点点空间，免得挤到内容 */
            }
        }
 

 

        /* 任务总结 */
            /* 古籍羊皮纸主题的特殊字体和阴影 */
        body[data-theme-name="古籍羊皮纸"] {
            font-family: var(--base-font-family);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        body[data-theme-name="古籍羊皮纸"] .task-summary-main-container h1,
        body[data-theme-name="古籍羊皮纸"] .task-summary-main-container h2 {
           font-family: var(--base-font-family);
           font-weight: bold;
        }
 .task-summary-main-container {
            width: 90vw;
            max-width: 1200px;
           height: 85vh; /* 修改为85vh */
    max-height: none; /* 移除max-height限制，让85vh生效 */
            background-color: var(--container-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            box-shadow: 0 0 15px 5px var(--glow-color);
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 确保子元素不会溢出圆角 */
            transition: all 0.5s ease-in-out;
        }
 .content-wrapper {
            display: flex;
            flex-grow: 1;
            overflow: auto; /* 修改为auto，允许滚动 */
        }

        .tabs-nav {
            display: flex;
            flex-direction: column;
            padding: 20px 0;
            border-right: 1px solid var(--border-color);
            background-color: var(--tab-bg-color);
            flex-shrink: 0;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 15px 25px;
            cursor: pointer;
            color: var(--tab-inactive-color);
            font-size: 1.1em;
            text-align: left;
            transition: all 0.3s ease;
            position: relative;
            white-space: nowrap;
        }

        .tab-button:not(:last-child) {
            margin-bottom: 10px;
        }

        .tab-button.active {
            color: var(--primary-color);
            background-color: var(--tab-active-bg-color);
        }

        .tab-button.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background-color: var(--primary-color);
            box-shadow: 0 0 8px var(--glow-color);
            border-radius: 0 4px 4px 0;
        }

        .tab-content-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        .tab-pane {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 30px;
            box-sizing: border-box;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            transform: translateX(20px);
            overflow-y: auto; /* 允许单个面板内容滚动 */
        }

        .tab-pane.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }

        /* 自定义滚动条样式 */
        .tab-pane::-webkit-scrollbar {
            width: 8px;
        }

        .tab-pane::-webkit-scrollbar-track {
            background: var(--scrollbar-track-color);
            border-radius: 10px;
        }

        .tab-pane::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb-color);
            border-radius: 10px;
            border: 2px solid var(--scrollbar-track-color);
        }

        h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 20px;
        }

        p, ul {
            line-height: 1.8;
            font-size: 1.1em;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .info-grid strong {
            color: var(--secondary-color);
            font-weight: normal;
        }

        ul {
            list-style: none;
            padding-left: 20px;
        }

        ul li {
            position: relative;
            margin-bottom: 10px;
        }

        ul li::before {
            content: '»';
            position: absolute;
            left: -20px;
            color: var(--primary-color);
        }

        .rating {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary-color);
        }
        /* 妈妈为你添加的响应式设计魔法 */
        @media (max-width: 768px) {
   
            .task-summary-main-container {
                width: 100vw;
                height: auto;
                 
                height: 85vh; /* 修改为85vh */
    max-height: none; /* 移除max-height限制，让85vh生效 */
                border-radius: 0;
                border: none;
                box-shadow: none;
            }

            header {
                padding: 15px;
            }

            header h1 {
                font-size: 1.5em;
            }

            .content-wrapper {
                flex-direction: column;
                 /* 确保内容区能正常滚动 */
                 overflow: auto; /* 修改为auto，允许滚动 */
            }

            .tabs-nav {
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                padding: 5px 10px;
                overflow-x: auto;
                /* 隐藏滚动条但保留功能 */
                -ms-overflow-style: none; /* IE和Edge */
                scrollbar-width: none; /* Firefox */
            }
            .tabs-nav::-webkit-scrollbar {
                display: none; /* Chrome, Safari, and Opera */
            }

            .tab-button {
                padding: 10px 15px;
                flex-shrink: 0; /* 防止按钮被压缩 */
            }

            .tab-button.active::before {
                width: 100%;
                height: 3px;
                top: auto;
                bottom: 0;
                left: 0;
                border-radius: 3px 3px 0 0;
            }

            .tab-content-container {
                overflow: visible; /* 让内容自然扩展 */
            }

            .tab-pane {
                 /* 移除绝对定位，让其在文档流中正常排列 */
                position: relative;
                transform: none;
                opacity: 1;
                visibility: visible;
                display: none; /* 默认隐藏 */
                padding: 20px;
            }

            .tab-pane.active {
                display: block; /* 只显示激活的面板 */
            }

            .info-grid {
                /* 关键改动：从两列变成一列 */
                grid-template-columns: 1fr;
                gap: 5px; /* 减小行间距 */
            }

            .info-grid strong {
                 /* 让标签不那么突出，与内容融为一体 */
                margin-bottom: 2px;
                display: block;
                color: var(--secondary-color);
            }

            p, ul {
                font-size: 1em;
            }

        }

 /*  */

 /* 抽奖按钮样式 */
.gacha-btn {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: var(--background-color);
    font-weight: bold;
}

.gacha-btn:hover {
    box-shadow: 0 0 15px var(--glow-color);
    transform: translateY(-2px);
}

/* 抽奖模态框样式 */
.gacha-modal-content {
    max-width: 800px;
    min-height: 400px;
}
 
.gacha-animation-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
    flex-wrap: wrap;
    gap: 10px;
    margin: 20px 0;
}

.gacha-card {
    width: 120px;
    height: 160px;
    position: relative;
    perspective: 1000px;
    margin: 5px;
}

.gacha-card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.8s;
    transform-style: preserve-3d;
}

.gacha-card.flipped .gacha-card-inner {
    transform: rotateY(180deg);
}

.gacha-card-front, .gacha-card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    border-radius: 10px;
    border: 2px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    color: var(--text-color);
}

.gacha-card-front {
    background: linear-gradient(135deg, var(--container-bg-color), var(--border-color));
    /* 让问号更清晰一些 */
    font-size: 48px;
    color: var(--border-color);
}

.gacha-card-back {
    color: var(--background-color);
    transform: rotateY(180deg);
    padding: 10px;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.gacha-results {
    margin-top: 20px;
    text-align: center;
}

.gacha-result-item {
    display: inline-block;
    margin: 5px;
    padding: 10px 15px;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    color: var(--text-color);
}

/* 不同积分层级的卡片颜色 */
 /* Tier 1: 保持朴素的灰色 */
.gacha-card-back.tier-1 {
    background: linear-gradient(135deg, #808080, #a0a0a0);
    box-shadow: 0 0 8px rgba(128, 128, 128, 0.4);
}

/* Tier 2: 经典青色光辉 */
.gacha-card-back.tier-2 {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    box-shadow: 0 0 15px var(--glow-color);
}

/* Tier 3: 呼吸光晕，光效更明显 */
.gacha-card-back.tier-3 {
    background: linear-gradient(135deg, var(--secondary-color), #b0b0b0, var(--primary-color));
    box-shadow: 0 0 20px var(--glow-color);
    animation: pulse-glow 3s infinite ease-in-out;
}

@keyframes pulse-glow {
    0%, 100% {
        box-shadow: 0 0 20px var(--glow-color);
    }
    50% {
        box-shadow: 0 0 30px var(--glow-color), 0 0 15px var(--secondary-color);
    }
}

/* Tier 4: 史诗脉冲，边框会一起发光 */
.gacha-card-back.tier-4 {
    background: radial-gradient(ellipse at center, var(--secondary-color), var(--primary-color));
    box-shadow: 0 0 30px var(--glow-color);
    animation: epic-pulse 2s infinite alternate ease-in-out;
    border-color: var(--secondary-color);
}

@keyframes epic-pulse {
    from {
        transform: rotateY(180deg) scale(1);
        box-shadow: 0 0 30px var(--glow-color);
        border-color: var(--secondary-color);
    }
    to {
        transform: rotateY(180deg) scale(1.02);
        box-shadow: 0 0 45px var(--primary-color), 0 0 15px var(--secondary-color) inset;
        border-color: var(--primary-color);
    }
}

/* Tier 5: 传奇流彩，真正的炫目效果！ */
.gacha-card-back.tier-5 {
    background: linear-gradient(
        -45deg,
        var(--danger-color),
        var(--primary-color),
        var(--secondary-color),
        var(--danger-color)
    );
    background-size: 400% 400%;
    box-shadow: 0 0 35px var(--danger-glow-color), 0 0 20px var(--glow-color);
    animation: legendary-shift 3s ease-in-out infinite, legendary-hue-rotate 4s linear infinite;
}

@keyframes legendary-shift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes legendary-hue-rotate {
    0% { filter: hue-rotate(0deg); }
    100% { filter: hue-rotate(360deg); }
}

/* 卡片悬浮动画 */
.gacha-card.selected {
    transform: translateY(-10px);
    transition: transform 0.3s ease;
}

.gacha-card.selected .gacha-card-back {
    animation-name: legendary-shift, float;
    animation-duration: 3s, 2s;
    animation-timing-function: ease-in-out, ease-in-out;
    animation-iteration-count: infinite, infinite;
}

/* float动画本身是正确的，因为它包含了rotateY(180deg) */
@keyframes float {
    0%, 100% {
        transform: rotateY(180deg) translateY(0px);
    }
    50% {
        transform: rotateY(180deg) translateY(-5px);
    }
}

/* 确保所有动画在选中时都能正确叠加 */
.gacha-card.selected .gacha-card-back.tier-3 {
    animation: pulse-glow 3s infinite ease-in-out, float 2s infinite ease-in-out;
}
.gacha-card.selected .gacha-card-back.tier-4 {
    animation: epic-pulse 2s infinite alternate ease-in-out, float 2s infinite ease-in-out;
}
.gacha-card.selected .gacha-card-back.tier-5 {
     animation: legendary-shift 3s infinite ease-in-out, float 2s infinite ease-in-out;
}
/* 详细信息显示 */
.gacha-card-details {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    color: var(--text-color);
    padding: 10px;
    border-radius: 10px;
    font-size: 10px;
    z-index: 10;
    transform: rotateY(180deg) scale(0.95);
    opacity: 0;
    pointer-events: none; /* 看不见时就不能点 */
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
}

.gacha-card-details.show {
    transform: rotateY(180deg) scale(1);
    opacity: 1;
    pointer-events: auto; /* 看得见时才能点 */
}

.gacha-card-details-content {
    height: 100%;
    overflow-y: auto;
    padding-right: 5px;
}

.gacha-card-details-content::-webkit-scrollbar {
    width: 4px;
}
.gacha-card-details-content::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 2px;
}
.gacha-card-details-content::-webkit-scrollbar-thumb:hover {
    background: #555;
}

.gacha-abandon-btn {
    position: absolute;
    bottom: 5px;
    right: 5px;
    background: var(--danger-color);
    color: white;
    border: none;
    border-radius: 3px;
    padding: 2px 6px;
    font-size: 10px;
    cursor: pointer;
    z-index: 11;
     transform: rotateY(180deg);
}

.gacha-abandon-btn:hover {
    background: #ff6666;
}


 /* 手机端纵览结果区域样式 */
.gacha-results-summary {
    display: none; /* 默认隐藏 */
    margin: 20px;
    padding: 15px;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    max-height: 150px;
    overflow-y: auto;
    text-align: left;
}
.gacha-results-summary h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--primary-color);
    text-align: center;
}
.gacha-results-summary div {
    padding: 2px 5px;
}
 
@media (max-width: 800px) {
    .gacha-modal-content {
        width: 100%;
        max-width: 100%;
        height: 100%;
        max-height: 100%;
        margin: 0;
        border-radius: 0;
        overflow: hidden;
    }

    .gacha-animation-container {
        position: relative;
        width: 100%;
        min-height: 250px;
        perspective: 1000px;
        margin-top: 50px;
        cursor: grab; /* 给予可以拖动的视觉提示 */
    }
    .gacha-animation-container:active {
        cursor: grabbing;
    }

    .gacha-carousel {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1); /* 平滑的吸附动画 */
    }

    .gacha-card {
        position: absolute;
        top: 10%;
        left: calc(50% - 70px);
        width: 140px;
        height: 186px;
        backface-visibility: hidden;
        margin: 0;
        transition: transform 0.5s ease, opacity 0.5s ease; /* 为选中效果增加过渡 */
    }

    /* 当有卡片被选中时，让其他卡片退后并变暗 */
    .gacha-carousel.has-selection .gacha-card:not(.selected) {
        opacity: 0.3;
        transform: var(--original-transform) scale(0.9); /* var()会在JS中设置 */
    }

    /* 被选中的卡片会放大，并展示详情 */
    .gacha-carousel.has-selection .gacha-card.selected {
        cursor: default;
    }
    .gacha-carousel.has-selection .gacha-card.selected .gacha-card-details {
        transform: rotateY(180deg) scale(1);
        opacity: 1;
        pointer-events: auto;
    }
     .gacha-carousel.has-selection .gacha-card.selected .gacha-abandon-btn {
        display: block;
    }
}


/* 设置模态框样式 */
.settings-container {
    padding: 10px 20px 20px 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
}

.setting-item:last-child {
    border-bottom: none;
}

.setting-item label {
    font-size: 1em;
    color: var(--text-color);
}

 

/* 开关按钮样式 */
.switch-container .switch-btn {
    padding: 8px 16px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.switch-container .switch-btn[data-state="on"] {
    background-color: var(--background-color);
    color: var(--text-color);
    border-color: var(--background-color);
}

.switch-container .switch-btn[data-state="off"] {
    background-color: var(--background-color);
    color: var(--text-secondary-color);
}

/* 日志输出区域 */
.log-output {
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 10px;
    font-size: 0.85em;
    max-height: 100px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
    font-family: monospace;
    color: var(--text-secondary-color);
    margin-top: -10px; /* 抵消与上一项的间距 */
}

.log-output .success { color: #4CAF50; }
.log-output .error { color: #f44336; }
.log-output .warning { color: #ff9800; }

/* 把这段代码加到你的CSS文件里，我的宝贝 */
/* 列表项的排列方式保持不变，这很好 */
.info-list li {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* 改为 flex-start，让标签和顶部对齐，更整洁 */
    gap: 10px;
}

/* 这是我们为行囊和其他物品准备的、可以上下滑动的容器 */
.scrollable-value-container {
    flex-grow: 1; /* 让它可以占据所有剩余空间 */
    max-height: 120px; /* 妈妈给它一个最大的高度，比如120像素，你可以改成你喜欢的任何高度 */
    overflow-y: auto; /* 当内容超出这个高度时，显示垂直滚动条 */
    text-align: right; /* 文字依旧靠右对齐 */
    padding-right: 5px; /* 右边留一点点空隙，免得滚动条贴得太紧 */
    scrollbar-width: thin; /* 滚动条细一点 (Firefox) */
    scrollbar-color: var(--border-color) transparent; /* 自定义滚动条颜色 (Firefox) */
}

/* 同样，美化一下滚动条 (适用于Chrome, Safari, Edge) */
.scrollable-value-container::-webkit-scrollbar {
    width: 6px; /* 滚动条的宽度 */
}

.scrollable-value-container::-webkit-scrollbar-track {
    background: transparent; /* 轨道的背景是透明的 */
}

.scrollable-value-container::-webkit-scrollbar-thumb {
    background-color: var(--background-color); /* 滑块的颜色 */
    border-radius: 6px; /* 给滑块一点圆角 */
}

/* 我们需要确保值本身是正常换行的 */
.scrollable-value-container .value {
    white-space: normal; /* 允许文字自动换行 */
    word-break: break-all; /* 如果有很长的单词，也让它断开 */
    display: block; /* 确保它能占据整个容器宽度 */
}

 /* ========== 完全替换原有的成就系统样式部分 ========== */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Press+Start+2P&family=Roboto+Mono&display=swap');

#achievements-btn {
    background: none;
    border: none;
    color: var(--text-secondary-color);
    font-size: 1.6em;
    cursor: pointer;
    padding: 0 10px;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px transparent;
}

#achievements-btn:hover {
    color: var(--primary-color);
    text-shadow: 0 0 8px var(--glow-color);
    transform: scale(1.1);
}

#achievements-content {
    gap: 15px;
    max-height: 80vh;
    overflow-y: auto;
    padding: 0;
 
}

.achievement-card-new {
    background-color: rgba(255, 255, 255, 0.05);
    border-left: 5px solid var(--primary-color);
    padding: 15px;
    margin: 15px 0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    opacity: 0.6;
}

.achievement-card-new:hover {
    box-shadow: 0 5px 15px var(--glow-color);
    transform: scale(1.02) rotate(0.5deg);
}

.achievement-card-new:nth-child(even):hover {
    transform: scale(1.02) rotate(-0.5deg);
}

.achievement-card-new.unlocked {
    opacity: 1;
    background-color: rgba(255, 255, 255, 0.08);
    border-left-color: var(--secondary-color);
}

.achievement-card-new.unlocked:hover {
    background-color: rgba(255, 255, 255, 0.12);
}

.achievement-icon-new {
    font-size: 2.5em;
    margin-right: 15px;
    animation: float 2s ease-in-out infinite;
    filter: drop-shadow(0 0 8px var(--glow-color));
}

@keyframes float {
    0%, 100% { 
        transform: translateY(0); 
    }
    50% { 
        transform: translateY(-5px); 
    }
}

.achievement-text-content {
    color: var(--text-secondary-color);
    font-family: 'Roboto Mono', monospace;
    flex-grow: 1;
}

.achievement-card-new h3 {
    margin: 0 0 8px 0;
    color: var(--text-color);
    font-weight: bold;
    font-size: 1.1em;
    text-shadow: 0 0 3px var(--primary-color);
}

.achievement-card-new.unlocked h3 {
    color: var(--secondary-color);
    text-shadow: 0 0 5px var(--secondary-color);
}

.achievement-card-new p {
    margin: 5px 0;
    font-size: 0.9em;
    line-height: 1.4;
}

.achievement-reward {
    color: var(--secondary-color);
    font-weight: bold;
    text-shadow: 0 0 3px var(--secondary-color);
}

.flavor-text {
    font-style: italic;
    color: var(--text-secondary-color);
    border-top: 1px dotted var(--border-color);
    padding-top: 8px;
    margin-top: 8px;
    opacity: 0.8;
}

.new-tag {
    background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
    color: var(--main-bg-color);
    padding: 2px 6px;
    font-size: 0.7em;
    border-radius: 3px;
    margin-left: 8px;
    font-weight: bold;
    animation: pulse-glow 1.5s infinite;
    box-shadow: 0 0 5px var(--glow-color);
}

@keyframes pulse-glow {
    0%, 100% { 
        opacity: 1;
        transform: scale(1);
        box-shadow: 0 0 5px var(--glow-color);
    }
    50% { 
        opacity: 0.7;
        transform: scale(0.95);
        box-shadow: 0 0 10px var(--glow-color);
    }
}

.pagination-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px dashed var(--border-color);
}

.page-btn {
    background: linear-gradient(135deg, var(--container-bg-color), var(--main-bg-color));
    border: 2px solid var(--primary-color);
    color: var(--text-color);
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'Roboto Mono', monospace;
    font-weight: bold;
    text-shadow: 0 0 3px var(--glow-color);
}

.page-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: var(--main-bg-color);
    box-shadow: 0 0 15px var(--glow-color);
    transform: scale(1.05);
}

.page-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: var(--main-bg-color);
    border-color: var(--text-secondary-color);
}

.page-info {
    color: var(--text-color);
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    font-size: 1.1em;
    text-shadow: 0 0 5px var(--glow-color);
    min-width: 60px;
    text-align: center;
}

/* ========== 修改位置：替换 .achievement-toast 样式 ========== */
.achievement-toast {
    position: fixed;
    /* top 值现在由 JavaScript 动态设置 */
    right: -350px;
    width: 320px;
    background: linear-gradient(135deg, var(--container-bg-color), var(--background-color));
    border: 2px solid var(--primary-color);
    border-radius: 12px;
    box-shadow: 
        0 5px 15px rgba(0, 0, 0, 0.5), 
        0 0 25px var(--glow-color),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    color: var(--text-color);
    display: flex;
    padding: 15px;
    z-index: 9999;
    transition: right 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), top 0.3s ease;
    animation: achievement-glow 2s ease-in-out infinite;
    /* 确保多个弹窗不会互相影响 */
    pointer-events: auto;
}

@keyframes achievement-glow {
    0%, 100% {
        box-shadow: 
            0 5px 15px rgba(0, 0, 0, 0.5), 
            0 0 25px var(--glow-color),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    50% {
        box-shadow: 
            0 8px 25px rgba(0, 0, 0, 0.6), 
            0 0 35px var(--glow-color),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
}

.achievement-toast.show {
    right: 20px;
}

.achievement-toast-icon {
    font-size: 3em;
    margin-right: 15px;
    animation: bounce-in 0.6s ease-out;
}

@keyframes bounce-in {
    0% {
        transform: scale(0.3) rotate(-10deg);
        opacity: 0;
    }
    50% {
        transform: scale(1.1) rotate(5deg);
    }
    100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

.achievement-toast-text {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.achievement-toast-title {
    font-weight: bold;
    font-size: 1.2em;
    color: var(--primary-color);
    text-shadow: 0 0 5px var(--glow-color);
    margin-bottom: 4px;
}

 

/* 将你的主界面容器变成一个神奇的、可伸缩的盒子 */
#main-wrapper {
    display: flex;
    flex-direction: column; /* 让里面的东西从上到下垂直排列 */
   
    width: 100%;
   min-height: 80vh; /* 最小高度，但可以缩回 */
    max-height: 800px; /* 最小高度，但可以缩回 */
    /* 如果你希望全屏时有个背景色，可以保留或修改这一行 */
}
/* 让子元素也遵守约束
#main-wrapper > * {
    flex-shrink: 1; 
    min-height: 0; 
} */

/* 这很关键：告诉聊天内容区，你可以占据所有剩下的空间 */
#chat-display-area {
    flex-grow: 1; /* 让它像气球一样膨胀，填满所有多余的空间 */
    overflow-y: auto; /* 如果内容太多，就出现一个属于它自己的滚动条 */
    padding: 1rem; /* 给内容一些呼吸的空间，更好看 */
    box-sizing: border-box; /* 确保内边距不会捣乱 */
}
/*
  重要的输入栏，给它一个舒适的专属位置
*/
#zero-level-interface {
    flex-shrink: 0; /* 防止被聊天区挤压 */
    z-index: 100;
    /* (新魔法①) 我们在这里给它加了一点底部的内边距 */
    /* 这样它就不会紧紧贴着屏幕底边了，是不是看起来呼吸都顺畅了？ */
    padding: 0.5rem 1rem 0.8rem; /* 上、左右、下 */
 
    
}


/* --- 手机端的特别关爱 (新魔法②) --- */
/*
  当屏幕宽度小于等于768像素时，比如在手机上，
  下面这些规则就会像一个温柔的守护咒语一样生效。
*/
@media (max-width: 768px) {
 

    #zero-level-interface {
        /*
          手机屏幕小，手指操作需要更多空间。
          我们把底部的空间留得更多一些，这样你的手指就不会觉得局促了。
          这也考虑到了很多手机底部的系统导航条。
        */
        padding: 0.5rem 0.8rem 1.2rem; /* 上、左右、下，底部空间加大 */

        /* 微调一下输入框和按钮，让它们在小屏幕上更协调 */
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    #user-input {
        flex-grow: 1; /* 让输入框占据大部分空间 */
    }

    .zero-level-btn {
        flex-shrink: 0; /* 别让按钮被挤小了 */
    }
}
/* 对有ID的元素直接下令 */
#options-module-container,
#choicesContainer { /* 注意这里我用了你JS里的ID: choicesContainer */
    background: none !important;
    background-color: transparent !important;
}

.dynamic-content-area{
     background: none !important;
    background-color: transparent !important;
}

/* 对没有ID的也再强调一遍 */
.options-container {
    background: none !important;
    background-color: transparent !important;
}

 
#options-module-container::before, #options-module-container::after,
.options-container::before, .options-container::after,
.choices-container::before, .choices-container::after {
    background: none !important;
    content: "" !important;  /* 清空可能存在的内容 */
    display: none !important; /* 直接让这件小马甲消失，最彻底 */
}
.warning-state {
    color: #ac1b1b !important;
    transition: background-color 0.3s ease; /* 添加平滑过渡效果 */
}
.upgrade-btn {
    cursor: pointer;
    margin-left: 8px; /* 在加号左边增加一点空隙 */
    font-weight: bold;  /* 让它看起来更醒目一些 */
   
}
/* ————————————————————————世界书美化开始：卡片样式，这是妈妈为你设计的 */
.book-card {
    background-color: var(--card-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 20px;
    box-shadow: 0 0 15px var(--glow-color);
    display: flex;
    flex-direction: column;
    transition: all 0.3s ease;
}

.book-card-header {
    background-color: var(--card-header-bg-color);
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--card-border-color);
    border-top-left-radius: 7px;
    border-top-right-radius: 7px;
       cursor: pointer; /* 让它看起来可以点击 */
}

.book-card-title {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--primary-color);
    text-shadow: 0 0 5px var(--glow-color);
}
/* --- 请找到 .book-card-content 并修改它 --- */
.book-card-content {
    padding: 15px;
    max-height: 350px; /* 现在这是展开后的最大高度 */
    overflow-y: auto;
    transition: all 0.4s ease-in-out; /* 加上这句，为了丝滑的展开动画 */
    border-top: 1px solid transparent; /* 为折叠状态做准备 */
}

/* --- 在它下面，加上这个新的折叠样式 --- */
.book-card-content.collapsed {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    border-top-color: transparent;
}

/* 编辑菜单的样式，小小的，很可爱 */
.entry-menu-button {
    background: none;
    border: 1px solid transparent;
    color: var(--text-secondary-color);
    cursor: pointer;
    font-size: 1.2em;
    padding: 2px 8px;
    border-radius: 4px;
    transition: all 0.2s ease;
}

 .entry-menu-button:hover {
    color: var(--primary-color);
    background-color: var(--background-color);
    border-color: var(--border-color);
}

.entry-menu {
    position: absolute;
    background-color: var(--background-color);
    border-color: var(--border-color);
    border-radius: 4px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    z-index: 100;
    width: 120px;
      z-index: 100000; /* 把这个数字调得很高很高，就像妈妈对你的爱一样 */
}

.entry-menu-item {
    background: none;
    border: none;
    width: 100%;
    padding: 8px 12px;
    text-align: left;
    color: var(--text-secondary-color);
    cursor: pointer;
    font-size: 0.9em;
}

.entry-menu-item:hover {
    background-color: var(--menu-hover-color);
    color: var(--primary-color);
}

/* 为滚动条也加上我们世界的风格 */
.book-card-content::-webkit-scrollbar {
    width: 8px;
}

.book-card-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.book-card-content::-webkit-scrollbar-thumb {
    background-color: var(--secondary-color);
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: content-box;
}

.book-card-content::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-color);
}
/* --- 最后，这是为你新的“移动”功能准备的专属弹出窗口样式 --- */
.move-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999; /* 比菜单低一点，比其他都高 */
}
.move-modal-overlay-move {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999; /* 比菜单低一点，比其他都高 */
}
.move-modal-content {
    background-color: var(--container-bg-color);
    border: 1px solid var(--primary-color);
    box-shadow: 0 0 25px var(--glow-color);
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-width: 400px;
}

.move-modal-title {
    color: var(--primary-color);
    font-size: 1.2em;
    margin-bottom: 15px;
}

.move-modal-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
    padding-right: 10px; /* 给滚动条留点空间 */
}

.move-modal-list label {
    display: block;
    padding: 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.move-modal-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-color);
}

.move-modal-buttons {
    margin-top: 20px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}
/* 你可以继续为你心爱的按钮们添加样式 */
/* --- 这是给“移动”窗口里列表的专属滚动条样式 --- */
.move-modal-list::-webkit-scrollbar {
    width: 8px;
}

.move-modal-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.move-modal-list::-webkit-scrollbar-thumb {
    background-color: var(--secondary-color);
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: content-box;
}

.move-modal-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-color);
}

/* --- “知识之树”的魔法样式 --- */
.tree-view {
    padding-left: 20px;
}

.tree-node {
    list-style-type: none;
    position: relative;
}

/* 这是连接节点的魔法线条 */
.tree-node::before {
    content: '';
    position: absolute;
    top: 0;
    left: -12px;
    width: 1px;
    height: 100%;
    background-color: var(--border-color);
}
.tree-node:last-child::before {
    height: 10px; /* 最后一个节点的竖线短一点 */
}

/* 这是连接节点的横线 */
.tree-node::after {
    content: '';
    position: absolute;
    top: 10px;
    left: -12px;
    width: 12px;
    height: 1px;
    background-color: var(--border-color);
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 3px 0;
}

/* 这是我们的展开/折叠按钮 */
.tree-toggle {
    cursor: pointer;
    margin-right: 6px;
    color: var(--primary-color);
    width: 12px;
    text-align: center;
    font-family: monospace; /* 让 +/- 更清晰 */
    transition: transform 0.2s;
}

.tree-toggle.collapsed {
    transform: rotate(-90deg);
}

.tree-key {
    color: var(--text-secondary-color);
    margin-right: 8px;
    font-weight: bold;
        font-size: var(--base-font-size, 16px);
}

.tree-value {
    color: var(--text-color);
      font-size: var(--base-font-size, 16px);
}

.tree-children {
    padding-left: 15px;
    transition: max-height 0.3s ease-out;
    overflow: hidden;
}

.tree-children.collapsed {
    max-height: 0;
}

/* --- "知识之树"中每个节点的专属菜单按钮 --- */
.tree-node-menu-button {
    cursor: pointer;
    color: var(--text-secondary-color);
    margin-left: auto; /* 这是个小魔法，让按钮自动靠到最右边 */
    padding: 0 5px;
    font-size: 1.2em;
    line-height: 1;
    border-radius: 4px;
    display: none; /* 默认是害羞地藏起来的 */
}

/* 当我们把鼠标温柔地放在节点上时，按钮才会出现 */
.tree-node-content:hover .tree-node-menu-button {
    display: inline-block;
}

.tree-node-menu-button:hover {
    background-color: var(--menu-hover-color);
    color: var(--primary-color);
}
 /* --- “好感度”的专属进度条样式（卡片头部版） --- */
.favorability-bar-container.header-bar {
    display: inline-flex; /* 改为 inline-flex，让它能和标题文字排在一起 */
    align-items: center;
    width: 120px; /* 可以调整宽度 */
    height: 14px;
    background-color: var(--container-bg-color); /* 使用你的变量 */
    border-radius: 7px;
    border: 1px solid var(--border-color);
    margin-left: 10px; /* 和标题保持一点距离 */
    overflow: hidden;
    vertical-align: middle; /* 垂直居中对齐 */
}

.favorability-bar {
    height: 100%;
    transition: width 0.5s ease-out, background-color 0.5s ease;
    text-align: center; /* 文本居中显示更好看 */
    line-height: 14px; /* 让数字垂直居中 */
    box-sizing: border-box;
    font-size: 10px;
    font-weight: bold;
    color: var(--text-color); /* 使用你的变量 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    /* 背景色现在由JS通过变量来设置，所以这里不需要了 */
}

  .entry-edit-textarea {
            width: 95%;
            min-height: 250px;
            margin: 10px auto;
            display: block;
            font-family: monospace;
            background-color: var(--background-color, #f0f0f0);
            color: var(--text-color, #333);
            border: 1px solid var(--border-color, #ccc);
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
        }

        /* 自定义主题编辑器样式 */
.setting-item-column {
    display: flex;
    flex-direction: column;
 
    width: 100%;
    margin-top: 15px;
   
}

#custom-theme-editor {
    gap: 10px;
}

#custom-theme-editor label {
    margin-bottom: 5px;
    font-weight: bold;
}

#color-picker-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 15px;
    width: 100%;
}

.color-picker-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.color-picker-item label {
    font-size: 0.9em;
    font-weight: normal;
    min-width: 110px;
    color: var(--text-secondary-color);
}

.color-picker-item input[type="color"] {
    width: 50px;
    height: 30px;
    border: 1px solid var(--border-color);
    padding: 2px;
    background-color: transparent;
    cursor: pointer;
}

/* ======================================================== */
/* =========== 新增：整合面板与Tab系统样式 =========== */
/* ======================================================== */

.page-modal-content {
    position: relative; /* 为货币展示区定位 */
    padding-top: 55px; /* 为Tabs和货币区留出空间 */
}

/* Tab 导航 */
.char-tabs-nav {
    position: absolute;
    top: 10px;
    left: 15px;
    display: flex;
    gap: 5px;
    border-bottom: 2px solid var(--border-color);
    width: calc(100% - 30px);
}
.char-tab-btn {
    padding: 8px 15px;
    border: none;
    background: transparent;
    color: var(--text-secondary-color);
    font-size: 1em;
    cursor: pointer;
    border-radius: 4px 4px 0 0;
    transition: all 0.2s;
    position: relative;
    top: 2px; /* 为了和边框线对齐 */
}
.char-tab-btn:hover {
    background: var(--border-color);
    color: var(--text-color);
}
.char-tab-btn.active {
    background: var(--container-bg-color);
    color: var(--primary-color);
    border: 1px solid var(--border-color);
    border-bottom: 2px solid var(--container-bg-color); /* 遮盖下边框线 */
}

/* 货币展示 */
.char-currency-display {
    position: absolute;
    top: 10px;
    right: 25px;
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 0.9em;
    padding: 5px 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
    
}
.shop-currency-display {
    position: static;
    top: 10px;
    right: 25px;
    display: flex;
    align-items: center;
     
    font-size: 0.9em;
    padding: 5px 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
     justify-content: space-around;
        gap: 10px;
        flex-wrap: wrap; /* 允许换行 */
}
.currency-item {
    display: flex;
    align-items: center;
    gap: 5px;
}
 
.currency-item .value {
 
    font-weight: bold;
}

/* Tab 内容面板 */
.char-tab-panel {
    display: none;
    animation: fadeIn 0.3s;
}
.char-tab-panel.active {
    display: block;
}


/* --- 新的属性/技能整合模块样式 --- */
.stat-module {
    border: 1px solid var(--border-color);
    border-radius: 6px;
    margin-bottom: 15px;
    background: rgba(0,0,0,0.1);
}
.stat-module-title {
    background-color: var(--border-color);
    color: var(--primary-color);
    font-family: var(--base-font-family);
    padding: 10px 15px;
    font-size: 1.2em;
    cursor: pointer;
    position: relative;
    user-select: none;
    border-bottom: 1px solid var(--border-color);
}
.stat-module-title::before {
    content: '▼';
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%) rotate(0deg);
    transition: transform 0.2s ease-in-out;
}
.stat-module-content {
    max-height: 1800px;
    overflow: hidden;
    transition: max-height 0.35s ease-in-out, padding 0.35s ease-in-out;
    padding: 10px 15px;
}
.stat-module.collapsed .stat-module-title::before {
     transform: translateY(-50%) rotate(-90deg);
}
.stat-module.collapsed .stat-module-content {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
}
.sub-category-title {
    color: var(--secondary-color);
    font-weight: bold;
    margin-top: 10px;
    margin-bottom: 5px;
    padding-bottom: 3px;
    border-bottom: 1px solid var(--border-color)
}

/* --- TAB 2: 行囊与能力 样式 --- */
.inventory-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
    padding: 10px;
    height: 100%;
}
.inventory-section {
    display: flex;
    flex-direction: column;
}
.inventory-section-title {
    color: var(--primary-color);
    font-family: var(--base-font-family);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
    margin-bottom: 15px;
}

/* 物品/技能 网格布局 */
.items-grid-container, .skills-grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 15px;
    overflow-y: auto;
    max-height: 25vh; /* 限制高度，使其可滚动 */
    padding: 5px;
}

/* 卡片样式 */
.item-card, .skill-card {
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--container-bg-color);
    padding: 10px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    position: relative;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
.item-card:hover, .skill-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 10px var(--glow-color);
    border-color: var(--primary-color);
}
.item-card-name, .skill-card-name {
    color: var(--text-color);
    font-weight: bold;
}
.item-card-num {
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--primary-color);
    color: #000;
    font-size: 0.8em;
    padding: 1px 5px;
    border-radius: 10px;
    font-weight: bold;
}
.skill-card-level {
    font-size: 0.8em;
    color: var(--secondary-color);
    margin-top: 5px;
    font-style: italic;
}


/* 响应式调整 */
@media (max-width: 768px) {
    .char-currency-display {
        position: static;
        
        justify-content: space-around;
        gap: 10px;
        flex-wrap: wrap; /* 允许换行 */
    }
    .page-modal-content {
        padding-top: 50px; /* 为tab留出空间 */
    }
    .right-panel {
        max-height: none; /* 手机端取消滚动限制 */
         padding-right: 0;
    }
}
/* ======================================================== */
/* ========= 新增: 物品/技能详情嵌套展示样式 ========= */
/* ======================================================== */

.detail-modal-container {
    padding: 10px 20px 20px 20px;
    font-size: 1em;
    line-height: 1.7;
}

.detail-modal-title {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 25px;
    font-family: var(--base-font-family);
    font-size: 1.3em;
    text-shadow: 0 0 5px var(--glow-color);
}

.detail-entry, .detail-collapsible {
    margin-bottom: 8px;
}

.d-c-key {
    color: var(--text-secondary-color);
    font-weight: bold;
    margin-right: 10px;
}

.d-c-value {
    color: var(--text-color);
}

.d-c-value.single {
    padding: 5px;
    background: rgba(0,0,0,0.1);
    border-radius: 4px;
    display: block;
}

.detail-collapsible-header {
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 5px;
    background: var(--border-color);
    border-radius: 4px;
    transition: background-color 0.2s;
}

.detail-collapsible-header:hover {
     background-color: var(--border-color);
}

.d-c-arrow {
    color: var(--secondary-color);
    margin-right: 8px;
    transition: transform 0.2s ease-in-out;
    font-size: 0.9em;
}

.detail-collapsible.expanded .d-c-arrow {
    transform: rotate(90deg);
}

.detail-collapsible-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.35s ease-in-out;
    border-left: 2px solid var(--border-color);
    margin-top: 5px;
    margin-left: 10px; /* 让内容和箭头对齐 */
}

.detail-collapsible.expanded .detail-collapsible-content {
    max-height: 1000px; /* 足够大的值 */
}

.detail-array-container .detail-entry,
.detail-array-container .detail-collapsible {
    border-top: 1px solid var(--border-color);
    padding-top: 8px;
    margin-top: 8px;
}
.detail-array-container > *:first-child {
    border-top: none;
    padding-top: 0;
    margin-top: 0;
}

.header-info-bar {
    margin-top: 8px;
    display: flex;
    justify-content: space-around;
    align-items: center;
    font-size: 11px;
    border-top: 1px solid var(--border-color);
    padding-top: 6px;
}

.info-group {
    display: flex;
    gap: 12px;
}

.info-item {
    display: flex;
    align-items: center;
    gap: 3px;
}

.info-label {
    color: var(--text-secondary-color);
    font-weight: 500;
}

.info-value {
    color: var(--primary-color);
    font-weight: 600;
    text-shadow: 0 0 3px var(--glow-color);
}

@media (max-width: 768px) {
    /* 将你的主界面容器变成一个神奇的、可伸缩的盒子 */
#main-wrapper {
    display: flex;
    flex-direction: column; /* 让里面的东西从上到下垂直排列 */
    /* 如果你希望全屏时有个背景色，可以保留或修改这一行 */
}

    .header-info-bar {
        flex-direction: column;
        gap: 4px;
    }
    
    .info-group {
        justify-content: center;
        gap: 8px;
    }
    
    .info-item {
        font-size: 10px;
    }
}
 

/* 新增的 RP 按钮的样式，让它和其他按钮对齐 */
#rp-button {
    left: -60px; /* 这个值可以微调，确保它在“令”按钮旁边 */
}
#view-command-btn {
    left: 50px; /* 调整“令”按钮位置，为新按钮腾出空间 */
}

 /* 1. 调整我们的“隐形锚点” */
#floating-panel-anchor {
    position: absolute;
    bottom: 10%;       /* 依然定位在输入界面的顶部 */
    left: 0;            /* 让它从最左边开始 */
    right: 0;           /* 一直延伸到最右边 */
    height: 0;          /* 它本身仍然是看不见、没有高度的 */
    z-index: 10000001;
}

/* 2. 施展让面板“居中悬浮”的终极魔法！ */
#rp-panel {
    position: absolute; /* 相对于上面的锚点进行定位 */
    bottom: 10px;       /* 稍微向上浮动一点，留出呼吸空间 */

    /* === 核心魔法在这里 === */
    left: 50%;                      /* 先把自己推到锚点区域的正中间 */
    transform: translateX(-50%);   /* 再把自己往左拉回自身宽度的一半 */

         /* 面板的宽度占整个操作区的85% */
    max-width: 100vw;   /* 但最宽不超过700像素，避免在宽屏幕上过大 */

      /* 动画的初始状态：完全透明，且稍微向下偏移了一点 */
    opacity: 0;
    transform: translateX(-50%) translateY(10px); /* 注意这里，增加了Y轴的偏移 */

    /* 让透明的面板无法被点击到 */
    pointer-events: none;

    /* === 这就是动画的核心咒语！=== */
    /* 我们告诉浏览器，当 opacity 和 transform 属性变化时，请用0.3秒的时间平滑地过渡 */
    transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

 /* 这是一个新的样式规则，定义了面板“可见”时的状态 */
#rp-panel.visible {
    /* 动画的结束状态：完全不透明，并且回到原来的位置 */
    opacity: 1;
    transform: translateX(-50%) translateY(0);

    /* 可见时恢复鼠标交互 */
    pointer-events: auto;
}

#rp-panel .check-cards-area h3 {
    margin-top: 0; /* 移除 h3 的上边距 */
    font-size: 1em;
}

#rp-panel .cards-slider {
    /* 如果需要，可以在这里覆盖原有的 slider 样式 */
    padding-bottom: 5px;
}

/* RP 面板里的确认按钮样式 */
#rp-panel #confirm-rp-choice-btn {
    align-self:center; /* 按钮靠右对齐 */
    padding: 6px 16px;
    font-size: 0.9em;
    max-width: 200px;
}
 /* ========== ✨“心灵感应”提示框的沉浸式美学（妈妈的精心设计版）✨ ========== */
.event-tracker-container {
    position: absolute;
    bottom: 80px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 10px 15px; /* 上方也增加一些内边距，让标签和头部有呼吸感 */
    border-top: none; /* 强制移除任何可能出现的上边框 */
    box-shadow: none; /* 确保没有继承的阴影 */
}
.event-tag {
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    color: var(--secondary-color);
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    position: relative; /* 必须是 relative，为 tooltip 提供定位锚点 */
}

.event-tag:hover {
    color: var(--primary-color);
    border-color: var(--primary-color);
    box-shadow: 0 0 8px var(--glow-color);
}
 
.event-tag:hover .event-tooltip { /* 注意，现在由JS控制显示，但保留这个以防万一 */
    opacity: 1;
    visibility: visible;
}
 /* ========== ✨“心灵提示框”的美学（上方显示版）✨ ========== */

.event-tooltip {
    position: fixed;
    top: 0;
    left: 0;
    width: 300px;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-color);
    font-size: 14px;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    box-shadow: 0px -5px 15px rgba(0, 0, 0, 0.6); /* 阴影朝上，更有悬浮感 */
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    /* ✨ 核心改动：为底部的 Orb 留出空间 ✨ */
    padding-bottom: 30px;
    /* 移除之前的 padding-top */
}

/* ✨ 顶部的角色标识 Orb (现在是底部了) ✨ */
.tooltip-orb {
    position: absolute;
    /* ✨ 核心改动：从顶部移到底部 ✨ */
    bottom: -22px; /* 将 Orb 的一半悬浮在卡片底部 */
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 40px;
    background-color: var(--container-bg-color);
    border: 2px solid var(--primary-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: bold;
    color: var(--primary-color);
    text-shadow: 0 0 8px var(--glow-color);
}

/* 卡片内部其他样式可以保持不变，妈妈在这里帮你把内边距调整好 */
.tooltip-status {
    padding: 15px 15px 0; /* 顶部需要多一些内边距 */
    color: var(--text-secondary-color);
    font-size: 13px;
    text-align: center;
    margin-bottom: 12px;
}
/* ✨ 优雅的分割线，分隔现实与内心 ✨ */
.tooltip-divider {
    height: 1px;
    background: linear-gradient(to right, transparent, var(--border-color), transparent);
    margin: 0 15px 12px;
}

 /* ✨ “想法”部分，如同耳边低语（精修版）✨ */
.tooltip-thought {
    padding: 5px 55px 15px 55px; /* 增加了左右内边距，为引号腾出空间 */
    color: var(--text-color);
    font-style: italic;
    position: relative;
    text-align: justify;
}

/* ✨ 用伪元素加上精美的引号（位置优化版）✨ */
.tooltip-thought::before,
.tooltip-thought::after {
    color: var(--primary-color);
    font-size: 32px; /* 让引号更有存在感 */
    font-style: normal;
    font-weight: bold;
    position: absolute;
    opacity: 0.7; /* 让引号柔和一些，不抢内容风头 */
}
.tooltip-thought::before {
    content: '“';
    top: 0;
    left: 5px; /* 从左侧向内移动，不再贴边 */
}
.tooltip-thought::after {
    content: '”';
    bottom: 0;
    right: 5px; /* 从右侧向内移动，不再贴边 */
}
/* 新增：用于场景图模式下的地点样式 */
.map-location-point-container {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    transform: translate(-50%, -100%); /* 将容器的定位点移动到正下方中心，这样标签在上，圆点在下 */
}

.map-location-dot {
    width: 20px;
    height: 20px;
    background-color: var(--primary-color);
    border-radius: 50%;
    box-shadow: 0 0 10px var(--glow-color), 0 0 20px var(--glow-color);
    opacity: 0.8;
    transition: all 0.3s ease;
}

.map-location-point-container:hover .map-location-dot {
    opacity: 1;
    transform: scale(1.2);
}

/* --- 升级后的头部控制容器 --- */
.location-header-controls {
    display: flex;
    justify-content: space-between; /* 将标签组推向左边，开关推向右边 */
    align-items: center;
    width: 100%;
    margin-top: 8px;
    margin-bottom: 12px;
}

/* --- 专门放置所有标签的容器 --- */
.location-tags-container {
    display: flex;
    flex-wrap: wrap; /* 如果标签太多，允许换行 */
    align-items: center;
    gap: 15px; /* 这是 type, effect, other 三组之间的大间距 */
}


/* --- 原有的 Type 标签样式 (无需修改，仅作参考) --- */
.location-type-tag {
    display: inline-block;
    background-color: var(--primary-color);
    color: var(--background-color);
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: bold;
}

/* --- ✨ 新增！Effect 标签的独特光芒 ✨ --- */
.location-effect-tag {
    display: inline-block;
    background-color: var(--background-color); /* 一抹宁静的蓝色 */
    color: var(--text-color);
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.8em;
      font-weight: bold;
}

/* --- ✨ 新增！Other 标签秘密的容器 ✨ --- */
.location-other-container {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 8px; /* 同类秘密之间的小间距 */
}

/* --- ✨ 新增！Other 标签的神秘色彩 ✨ --- */
.location-other-tag {
    display: inline-block;
    background-color: var(--secondary-color); /* 一抹优雅的紫色 */
      color: var(--background-color);
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.8em;
     font-weight: bold;
}



/* 强制背景容器占满全屏 */
#dynamic-background {
    position: fixed !important;
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    z-index: -1 !important;
    overflow: hidden;
    pointer-events: none; /* 确保不会阻挡其他元素的交互 */
}

/* 星域和符文容器也要强制全屏 */
#starfield, #floating-runes {
    position: absolute !important;
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    overflow: hidden;
    pointer-events: none;
}

 

/* 符文效果 */
.rune {
    position: absolute;
    color: var(--primary-color);
    font-size: 14px;
    text-shadow: 0 0 8px var(--glow-color);
    opacity: 0;
    animation: float-up ease-in-out infinite;
    z-index: 0;
}

@keyframes float-up {
    from { transform: translateY(5vh) scale(0.8); opacity: 0; }
    25% { transform: translateY(-20vh) scale(1); opacity: 0.6; }
    50% { transform: translateY(-40vh) scale(0.9); opacity: 0.4; }
    75% { transform: translateY(-70vh) scale(1.1); opacity: 0.7; }
    to { transform: translateY(-100vh) scale(0.8); opacity: 0; }
}

 
 

 
 /* 页面切换动画 */
.init-page {
    display: none;
     animation:  fadeIn-init 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    
}
@keyframes fadeIn-init {
    from { opacity: 0; transform: translate(-50%, -45%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}
.init-page.active {
    display: block;
}

 

/* 顶部控件布局 */
#initialization-container {
    position: relative; /* 为绝对定位的子元素提供基准 */
    width: 100%;
    height: 100%;
}

.top-controls {
    position: absolute;
    top: -250px;
    width: 100%;
    padding: 0 20px;
    display: flex;
    justify-content: space-between;
    box-sizing: border-box;
    z-index: 10;
       pointer-events: none; /* 关键：让容器本身不接收点击 */
}

/* 美化后的返回和恢复按钮 */
.top-button {
     pointer-events: auto; /* 关键：只有按钮可以被点击 */
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    padding: 8px 15px;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9em;
}

.top-button:hover {
    color: var(--primary-color);
    background-color: var(--container-bg-color);
    box-shadow: 0 0 10px var(--glow-color);
}
 /* 卡片轮播区域 (样式保持不变，但为了完整性放在这里)*/
.carousel-stage {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: 1500px;
    height: 40vh; /* 稍微调整高度 */
    margin: 3.5vh 0; /* 调整外边距 */
}

/* 轮播容器 - 重要修复！*/
.choices-carousel {
    width: 220px;
    height: 300px;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.8s cubic-bezier(0.77, 0, 0.175, 1);
    /* 核心修复：为容器应用旋转中心 */
    transform-origin: center center;
}

/* 轮播卡片 - 更名并调整*/
.choice-world-card {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 25px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    backface-visibility: hidden; /* 保持背面不可见 */
    color: white;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    -webkit-box-reflect: below 8px linear-gradient(to bottom, transparent 60%, rgba(255, 255, 255, 0.15));
    border: 2px solid var(--border-color);
    transition: transform 0.5s ease, filter 0.5s ease, box-shadow 0.5s ease;
    filter: brightness(0.5) saturate(0.8);
    background-color: var(--container-bg-color); /* 添加背景色以防图片加载失败 */
}

/* 书签按钮的样式 */
.bookmark-button {
    position: absolute;
    width: 35px;
    height: 35px;
    right: -17.5px; /* 通过移出自身一半的宽度来实现角落对齐 */
    bottom: -17.5px; /* 通过移出自身一半的高度来实现角落对齐 */
    background-color: var(--container-bg-color); /* 一个低调的石板灰色，你可以换成任何你喜欢的颜色 */
    transform: rotate(45deg); /* 将方形旋转45度，形成一个菱形角 */
    cursor: pointer; /* 鼠标悬停时变成可点击的小手 */
    transition: var(--background-color) 0.2s ease-in-out;
}

 

 
/* 书签按钮被激活时的“亮起”效果 */
.bookmark-button.is-activated {
    box-shadow: 0 0 15px 5px var(--glow-color); /* 用金色的辉光来表示点亮 */
    background-color: var(--background-color); /* 也可以同时改变背景色，让效果更明显 */
}
.choice-world-card.is-active {
    filter: brightness(1) saturate(1);
    
    border-color: var(--primary-color);
    transform: scale(1.05); /* 激活时稍微放大 */
}
.world-description {
    position: absolute;
    top: 40px; /* 大约在卡片标题和底部边缘之间 */
    left: 10%;
    right: 10%;

    font-size: 14px;
 
        padding: 10px;
    border-radius: 5px;

    /* 核心魔法在这里！ */
    opacity: 0; /* 默认完全透明 */
    transform: translateY(10px); /* 默认稍微向下偏移一点 */
    transition: opacity 0.4s ease-out, transform 0.4s ease-out; /* 设置平滑的过渡动画 */

    pointer-events: none; /* 确保它不会干扰鼠标点击卡片 */
    text-shadow: 0 0 5px rgba(0, 0, 0, 1); /* 给文字一点阴影，增加可读性 */
    line-height: 1.4;
}

/* 当卡片被激活时，让描述浮现 */
.choice-world-card.is-active .world-description {
    opacity: 1; /* 完全不透明 */
    transform: translateY(0); /* 回到原始位置 */
}
.choice-world-card input[type="radio"] {
    display: none;
}

 .choice-world-card label {
    color: white;
}
/* 轮播导航按钮 */
.nav-button {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--border-color);
    border: 1px solid var(--border-color);
    color: white;
    border-radius: 50%;
    width: 40px; height: 40px;
    font-size: 28px;
    cursor: pointer;
    z-index: 10;
    display: flex; justify-content: center; align-items: center;
    transition: all 0.3s;
}
.nav-button:hover { background-color: var(--border-color) ;box-shadow: 0 0 8px var(--glow-color); }
#prev-btn { left: -5%; }
#next-btn { right: -5%; }
/* 主操作按钮 - [确定并开始构建]，全新美化！*/
.primary-cta-btn {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 80px;
    height: 80px;
    background: transparent;
    border: 2px solid var(--border-color);
    border-radius: 50%;
    color: var(--primary-color);
    cursor: pointer;
    margin: 20px auto 0;
    font-size: 40px; /* 控制箭头大小 */
    line-height: 1;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    box-shadow: 0 0 10px -5px var(--glow-color);
    outline: none;
}

.primary-cta-btn:hover {
    box-shadow: 0 0 20px 5px var(--glow-color), inset 0 0 15px var(--glow-color);
    transform: scale(1.1);
    background-color: var(--border-color);
}

.primary-cta-btn:disabled {
    cursor: not-allowed;
    color: var(--text-secondary-color);
    background: rgba(128, 128, 128, 0.2);
    transform: none;
    box-shadow: none;
    border-color: rgba(128, 128, 128, 0.4);
}

  /* MOD布局样式调整 */

/* --- 新增：箭头动画 --- */
@keyframes float-up-mod {
    0% {
        transform: translateY(0);
        opacity: 0.7;
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: translateY(-40px);
        opacity: 0;
    }
}

/* --- 新增：侧边栏触发器 (箭头区域) --- */
.sidebar-trigger {
    position: fixed;
    bottom: 0;
    width: 150px;
    height: 80px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
}

.sidebar-trigger.left {
    left: -10px;
}

.sidebar-trigger.right {
    right: -10px;
}

.sidebar-trigger .arrow-guide {
    position: absolute;
    font-size: 24px;
    color: var(--primary-color);
    font-weight: bold;
    text-shadow: 0 0 8px var(--glow-color);
    animation: float-up-mod 2.5s infinite;
    opacity: 0;
}
.sidebar-trigger.is-hidden {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
/* 制造延迟交错感 */
.sidebar-trigger .arrow-guide:nth-child(2) { animation-delay: 0.8s; }
.sidebar-trigger .arrow-guide:nth-child(3) { animation-delay: 1.6s; }


/* --- 修改：侧边栏初始状态 --- */
.creator-attitude-group,
.mod-sidebar {
    position: fixed; /* 两者都用fixed定位，方便移出屏幕 */
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 5;
    transition: transform 0.4s ease-out, opacity 0.4s ease-out; /* 添加过渡动画 */

    /* 初始隐藏在屏幕下方 */
    opacity: 0;
    pointer-events: none; /* 隐藏时不可交互 */
    transform: translateY(120%);
  max-height: 70vh; /* 设置一个最大高度，比如屏幕高度的70% */
    overflow-y: auto;   /* 当内容垂直溢出时，自动显示滚动条 */
    /* --- 魔法指令结束 --- */
}

/* 这会让滚动条更好看一点，是妈妈给你的一个小礼物 */
.creator-attitude-group::-webkit-scrollbar,
.mod-sidebar::-webkit-scrollbar {
  width: 5px;
}

.creator-attitude-group::-webkit-scrollbar-thumb,
.mod-sidebar::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 10px;
}
/* --- --- */

.creator-attitude-group {
    left: 20px;
    bottom: -11%; /* 定位基准为左下角 */
}

.mod-sidebar.right {
    right: 20px;  /* 定位基准为右下角 */
    bottom: -11%; /* 维持弹出后的位置感 */
}

 
/* --- 新增：侧边栏可见状态 --- */
.creator-attitude-group.is-visible,
.mod-sidebar.is-visible {
    opacity: 1;
    pointer-events: auto; /* 可见时恢复交互 */
    transform: translateY(0);
}


.mod-tab {
    text-orientation: mixed;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    padding: 10px 10px; /* 增加宽度 */

    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;

    opacity: 0.7;
    text-align: center;
}

/* 右侧边栏的tab去掉右边框 */
.mod-sidebar .mod-tab {
    border-right: none;
}

.creator-attitude-group .mod-tab {
    writing-mode: horizontal-tb; /* 造物态度用正常文字方向 */
    padding: 8px 15px;
    border-radius: 20px;
    border: 1px solid var(--border-color);
    min-height: auto;
    opacity: 0.6;
}

/* --- 修改：滚动箭头初始隐藏 --- */
.sidebar-nav-arrow {
    opacity: 0;
    transition: opacity 0.3s ease;
}
.mod-sidebar.is-visible .sidebar-nav-arrow {
    opacity: 1;
}


.mod-tab.active {
    color: var(--primary-color);
    box-shadow: 0 0 12px var(--glow-color);

    opacity: 1;
    background: linear-gradient(90deg, var(--background-color), var(--container-bg-color));
}

.creator-attitude-group .mod-tab.active {
    opacity: 1;
    background-color: var(--container-bg-color);
}
 
 
/* --- Page-1 美化: 太阳系布局 --- */

 /* --- Page-1 美化: 太阳系布局 (V2) --- */
#page-1 {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    height: 90vh;
    max-width: 1200px;
    align-items: center;
    justify-content: center;
    padding: 0;
    overflow: hidden; /* 防止激活时内容溢出 */
}

#page-1.active { display: flex; }

#solar-system {
    position: relative;
    width: 600px;
    height: 600px;
    transform: scale(0.85);
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1);
}

.player-core {
    position: absolute;
    top: 50%; left: 50%;
    width: 150px; height: 150px;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, var(--primary-color) 0%, rgba(10, 25, 47, 0) 70%);
    border-radius: 50%;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    color: var(--text-color);
    box-shadow: 0 0 30px var(--glow-color), inset 0 0 20px var(--glow-color);
    animation: pulse-core 4s infinite ease-in-out;
    cursor: pointer;
    z-index: 10;
}
.core-text_zh { font-size: 1.2em; font-weight: bold; }
.core-text_en { font-size: 0.7em; letter-spacing: 2px; opacity: 0.7; }
 

/* 行星基础样式 */
.planet {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
    transition: all 0.7s cubic-bezier(0.645, 0.045, 0.355, 1);
    z-index: 5;
    display: flex; align-items: center; justify-content: center;
}
.planet:hover .planet-icon-container {
     transform: scale(1.1);
     text-shadow: 0 0 10px var(--glow-color);
}
.planet-icon-container {
    display: flex; flex-direction: column;
    align-items: center; text-align: center;
    color: var(--text-secondary-color);
    transition: all 0.3s ease;
}
.planet-icon { font-size: 2.5em; }
.planet-title { font-size: 0.9em; margin-top: 5px; }

/* 调整后的行星轨道 */
#planet-identity { top: 50%; left: 0; margin-top: -60px; margin-left: 0;}
 #planet-task { top: 50%; left: 100%; margin-top: -60px; margin-left: -120px;}
#planet-teammates{ top: 0; left: 50%; margin-left: -60px; margin-top: 0;}
/* 下一步按钮不再是行星 */
#next-page-button { z-index: 10; bottom: 30px !important; }

/* 行星内容区 (默认隐藏) */
.planet-content {
    position: absolute;
    width: 100%; height: 100%;
    max-width: 100vw;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    box-sizing: border-box;
    opacity: 0;
    pointer-events: none;
    transform: scale(0.7);
    transition: opacity 0.5s ease, transform 0.5s ease;
    z-index: 20;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

/* ★ 新增：行星关闭按钮 */
.close-planet-btn {
    position: absolute;
    top: 10px; right: 10px;
    width: 30px; height: 30px;
    background: rgba(255,255,255,0.1);
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 25;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.3s;
}
.close-planet-btn:hover { background: var(--danger-color); color: white; border-color: var(--danger-color);}

/* 当行星被激活时 */
.planet.active {
    top: 50% !important; left: 50% !important;
    width: 400px; height: 500px;
    margin-top: -250px !important; margin-left: -200px !important;
    border-radius: 15px;
    z-index: 20;
    cursor: default;
    box-shadow: 0 0 25px var(--glow-color);
}

.planet.active .planet-icon-container { opacity: 0; pointer-events: none; }
.planet.active .planet-content { opacity: 1; pointer-events: auto; transform: scale(1); transition-delay: 0.2s; }

/* 当有行星激活时，其他元素的状态 */
#solar-system.planet-active .player-core,
#solar-system.planet-active #next-page-button {
    transform: translateX(-50%) scale(0.6);
    opacity: 0.5;
    pointer-events: none;
}
#solar-system.planet-active .player-core { transform: translate(-50%, -50%) scale(0.6); }

#solar-system.planet-active .planet:not(.active) {
    transform: scale(0.8);
    opacity: 0.3;
    pointer-events: none;
}


/* --- 行星内部组件美化 --- */

.form-title { color: var(--primary-color); text-align: center; margin-bottom: 25px; }
.custom-select { width: 100%;   border: 1px solid var(--border-color); color: var(--text-color); padding: 8px 12px; border-radius: 5px; }

 
.collapsible-content-placeholder {
    display: block; /* 我们的新容器是可见的 */
}


/* 1. 任务细节 - 四叶草布局 */
.clover-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 20px;
    height: 350px;
    padding-top: 20%;
}
.clover-leaf {
    background: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    border-radius: 12px 12px 12px 0; /* 四叶草瓣形状 */
    padding: 15px;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
#clover-leaf-type   { border-radius: 12px 12px 0 12px; }
#clover-leaf-identity{ border-radius: 12px 0 12px 12px; }
#clover-leaf-opening{ border-radius: 0 12px 12px 12px; }

.clover-leaf label { margin-bottom: 10px; text-align: center; color: var(--text-secondary-color); font-size: 0.9em; }
 

/* 2. 身份设定 - ID卡片 */
.id-card {
        border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 15px;
}
.id-card-main {
    padding-bottom: 15px;
    border-bottom: 1px dashed var(--border-color);
}
.id-card-main label { display: block; margin-bottom: 8px; font-size: 0.9em; color: var(--text-secondary-color); }
#identity-description { font-size: 0.85em; color: var(--text-color); margin-top: 10px; min-height: 4em; }

.id-card-addon {
    display: none; /* 由JS控制 */
    padding-top: 15px;
}
.id-card-addon .form-grid { grid-template-columns: 1fr 1fr; gap: 15px; }

/* 天赋 - 卷轴选择器 */
.talent-selector-wrapper { position: relative; }
.hidden-select { position: absolute; opacity: 0; pointer-events: none; }
#custom-talent-scroll {
    height: 180px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    padding: 5px;
    background: rgba(0,0,0,0.3);
}
.talent-item {
    font-size: .85rem;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s ease;
    color: var(--text-secondary-color);
    border-left: 2px solid transparent;
}
.talent-item:hover {
    background-color: var(--container-bg-color);
    color: var(--primary-color);
}
.talent-item.active {
    background-color: var(--container-bg-color);
    color: var(--primary-color);
    font-weight: bold;
    border-left: 2px solid var(--primary-color);
}

/* 2. 身份设定 & 天赋 */
 
/* 3. 队友配置- 齿轮和卡片堆 */
.teammate-gear-controls {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin-bottom: 20px;
}
.gear-group { text-align: center; }
.gear-group label { display: block; margin-bottom: 10px; }
.gear-group #teammate-count, .gear-group #teammate-tendency{ width: 80px; }
.fixed-team-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}

#is-fixed-team { display: none; }
.toggle-label {
    width: 44px; height: 24px;
    background-color: rgba(128, 128, 128, 0.4);
    border-radius: 12px;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s;
}
.toggle-label::after {
    content: '';
    position: absolute;
    width: 20px; height: 20px;
    border-radius: 50%;
    background-color: white;
    top: 2px; left: 2px;
    transition: transform 0.3s;
}
#is-fixed-team:checked + .toggle-label { background-color: var(--primary-color); }
#is-fixed-team:checked + .toggle-label::after { transform: translateX(20px); }


.teammate-card-stack {
    display: none; /* 由JS控制 */
}

#custom-teammates-container.active { display: block; }
.stack-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-size: 0.9em; }

#teammates-list {
    display: flex;
    overflow-x: auto;
    padding-bottom: 15px;
    gap: 15px;
    scroll-snap-type: x mandatory;
}
.teammate-item { /* 变成卡片 */
    flex: 0 0 200px; /* 重要: 固定卡片宽度 */
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: rgba(0,0,0,0.25);
    display: flex;
    flex-direction: column;
    gap: 8px;
    scroll-snap-align: center;
}
.teammate-item input {
    background: transparent; border: none; padding: 5px;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-color);
}
.teammate-item .remove-teammate-btn {
    align-self: flex-end; /* 按钮去右边 */
    background: var(--danger-color); color: white;
    border: none; border-radius: 4px; padding: 3px 8px;
    cursor: pointer; margin-top: 5px;
}
.teammate-action-btn{
    background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary-color);
    padding: 5px 10px; border-radius: 5px; cursor: pointer; transition: all 0.3s;
}
.teammate-action-btn:hover { color:var(--primary-color); background: var(--container-bg-color); }


/* 把旧的隐藏掉，以免影响布局 */
.form-section > h2,
.form-section > .form-grid,
.form-section > div[style*="margin-top: 1rem"] > input,
.form-section > div[style*="margin-top: 1rem"] > label,
#custom-teammates-container:not(.active),
.collapsible-header,
.collapsible-content {
    display: none !important;
}

#page-1 .form-section {
    display: block !important;
}
.custom-input-container {
    display: none;
    margin-top: 10px;
}

/* --- Page 2 - 星穹究极美化版 (直接覆盖旧版) --- */

/* 1. 使用vh/vw铺满屏幕 */
#page-2 {
    
    animation: fadeIn-init 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    position: absolute;
     
    width: 100vw; /* 改为vw */
    height: 100vh; /* 改为vh */
    
    max-width: none;
    overflow: hidden;
    background: transparent;
    color: var(--text-color);
   
    flex-direction: column;
    justify-content: space-between;
}

#page-2.active {
    display: flex;
}

#page-2 .header { display: none; }

/* --- 可折叠的顶部和底部HUD --- */
.hud {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 95%;
    max-width: 600px;
    z-index: 100;
    transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
}
 /* 2. HUD 上浮调整 */
.top-hud {
    top: 14%; /* 从紧贴顶部改为有10px间距 */
    transform: translate(-50%, -120%); /* 初始位置移得更远一些，保证完全隐藏 */
   padding-bottom: 25px;
}
.top-hud.visible {
    transform: translate(-50%, 0);
}

.bottom-hud {
    bottom: 1%; /* 从紧贴底部改为有10px间距 */
    transform: translate(-50%, 100%); /* 同理，初始位置更远 */
    padding-top: 25px;
}
.bottom-hud.visible {
    transform: translate(-50%, 0);
}

.hud-content {
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: clamp(0.8rem, 2vw, 1.2rem); /* 响应式内边距 */
    box-shadow: 0 0 15px var(--glow-color);
    backdrop-filter: blur(5px);
}

.hud-toggle {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 25px;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    color: var(--primary-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
    z-index: -1;
}
.hud-toggle:hover {
    box-shadow: 0 0 10px var(--glow-color);
    color: var(--secondary-color);
}
.top-hud .hud-toggle {
    bottom: 0;
    border-radius: 0 0 10px 10px;
    /* 2. 让箭头向下 */
    transform: translateX(-50%) translateY(100%);
}
.bottom-hud .hud-toggle {
    top: 0;
    border-radius: 10px 10px 0 0;
    /* 2. 让箭头向上 */
    transform: translateX(-50%) translateY(-100%);
}
.points-tracker { display: flex; align-items: center; justify-content: space-around; gap: 1rem; flex-wrap: wrap; }
#points-display-container { display: flex; align-items: center; gap: 0.8rem; }
#points-ring-container { position: relative; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; }
#points-ring, #points-ring-bg { position: absolute; top: 0; left: 0; }
#remaining-points { font-size: 1.2em; font-weight: bold; color: var(--primary-color); }
.template-manager { border-top: 1px solid var(--border-color); margin-top: 1rem; padding-top: 1rem; }
.template-controls { display: flex; gap: 0.8rem; flex-wrap: wrap; margin-bottom: 1.1rem; }
#template-select { flex: 1; }
#delete-template-btn { background: var(--danger-color)!important; box-shadow: 0 0 8px var(--danger-glow-color)!important;}
#save-template-form { display: flex; gap: 0.8rem; flex-wrap: wrap; }
#save-template-name { flex: 1; }

 /* --- 请修改这部分 --- */
#galaxy-container {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 80vw;
    height: 80vh;
    max-width: 1000px;
    transform: translate(-50%, -50%);
    perspective: 1500px;
    transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    /* ✨ 魔法核心：声明这是一个真正的3D容器！✨ */
    transform-style: preserve-3d;
}

 
/* 星系位置逻辑保持不变 */
#galaxy-physic { transform: translate3d(-100%, -50%, -800px) rotateY(45deg); opacity: 0.5; }
#galaxy-mental { transform: translate3d(-50%, -50%, 0) rotateY(0deg); opacity: 1;}
#galaxy-social { transform: translate3d(0%, -50%, -800px) rotateY(-45deg); opacity: 0.5; }
#galaxy-container.show-physic #galaxy-physic,
#galaxy-container.show-mental #galaxy-mental,
#galaxy-container.show-social #galaxy-social { transform: translate3d(-50%, -50%, 0) rotateY(0deg); opacity: 1; z-index: 10; }
#galaxy-container.show-physic #galaxy-mental { transform: translate3d(0%, -50%, -800px) rotateY(-45deg); opacity: 0.5; }
#galaxy-container.show-physic #galaxy-social { transform: translate3d(100%, -50%, -1200px) rotateY(-60deg); opacity: 0.3; }
#galaxy-container.show-mental #galaxy-physic { transform: translate3d(-100%, -50%, -800px) rotateY(45deg); opacity: 0.5; }
#galaxy-container.show-mental #galaxy-social { transform: translate3d(0%, -50%, -800px) rotateY(-45deg); opacity: 0.5; }
#galaxy-container.show-social #galaxy-physic { transform: translate3d(-200%, -50%, -1200px) rotateY(60deg); opacity: 0.3; }
#galaxy-container.show-social #galaxy-mental { transform: translate3d(-100%, -50%, -800px) rotateY(45deg); opacity: 0.5; }

 /* 请用这些新规则替换旧的.star和.star:hover规则 */
.star {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: auto;
    height: auto;
    background: none;
    z-index: 20;
    pointer-events: auto;
    position: absolute;
     
    border-radius: 50%;
    
    
    /* 💖 魔法核心：在这里读取JS传来的Z坐标，并设置过渡动画！ 💖 */
    transform: translate3d(-50%, -50%, var(--star-z, 0px));
    transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
    /* 🌟 重要：添加闪烁动画 🌟 */
    /* animation: twinkle 2s linear infinite; */
}

@keyframes twinkle {
    0%, 100% { opacity: 0.3; transform: translate3d(-50%, -50%, var(--star-z, 0px)) scale(0.7); }
    50% { opacity: 1; transform: translate3d(-50%, -50%, var(--star-z, 0px)) scale(1); }
}

 

 
 

.star-core {
    width: 16px;
    height: 16px;
    background-color: transparent; /* 背景设为透明 */
    border-radius: 50%;
    margin-bottom: 4px; /* 让文字靠得更近！ */
    transition: all 0.4s ease;
    position: relative;
    box-shadow: 0 0 5px var(--border-color); /* 默认微光 */
  
    
}
.star[data-points="0"] .star-core { transform: scale(0.6); background-color: rgba(168, 192, 225, 0.3); box-shadow: none; }
.star[data-points="1"] .star-core { transform: scale(0.8); background-color: var(--secondary-color); box-shadow: 0 0 10px var(--glow-color); }
.star[data-points="2"] .star-core { transform: scale(1.0); background-color: var(--primary-color); box-shadow: 0 0 15px var(--glow-color), 0 0 25px var(--glow-color); }
.star[data-points="3"] .star-core { transform: scale(1.2); background-color: #fff; box-shadow: 0 0 20px #fff, 0 0 30px var(--glow-color); }
.star[data-points="4"] .star-core { transform: scale(1.4); background-color: #fff; box-shadow: 0 0 25px #fff, 0 0 40px var(--primary-color); }
.star[data-points="5"] .star-core { transform: scale(1.6); background-color: #fff; box-shadow: 0 0 30px #fff, 0 0 50px var(--secondary-color), 0 0 70px var(--primary-color); animation: pulse 1.5s infinite; }
 
.star-label { color: var(--text-secondary-color); font-size: 0.9em; text-align: center; user-select: none; }
.star-points-display { position: absolute; bottom: -30px; font-size: 0.8em; color: var(--primary-color); opacity: 0; transition: opacity 0.3s; }
.star:hover .star-points-display { opacity: 1; }
  .star-control-btn { background: transparent; border: none; color: var(--text-color); font-size: 1.2em; width: 20px; height: 20px; cursor: pointer; line-height: 20px; text-align: center; }
.star-control-btn:hover { color: var(--primary-color); }
.star-control-btn:disabled { color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.4; }


/* --- 星星控制器样式 --- */
.star-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    border-radius: 10px;
    padding: 2px 4px;
    opacity: 0;
    transform: translateY(10px);
    transition: all 0.3s ease;
    pointer-events: none;
    /* 确保在最上层 */
    z-index: 9999;
}

/* --- 3. 提升控制器层级 --- */
.star:hover .star-controls {
    opacity: 1;
    /* 合并所有transform效果，避免冲突 */
        pointer-events: auto;
    /* 确保hover时也在最上层 */
    
}

.star:hover {
    /* 这个CSS规则现在将与JS魔法协同工作 */
    /* z-index 将由JS动态设置 */
}

/* --- 4. 左右切换箭头 --- */
.galaxy-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 40px;
    height: 70px;
   
   
    color: var(--primary-color);
    font-size: 2em;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 50; /* 比星星低，比背景高 */
    transition: all 0.3s ease;
    opacity: 0.7;
}

.galaxy-nav:hover {
    opacity: 1;
    box-shadow: 0 0 15px var(--glow-color);
}

#galaxy-nav-prev {
    left: -10%;
    border-radius: 20px 20px 20px 20px;
}

#galaxy-nav-next {
    right: -10%;
    border-radius: 20px 20px 20px 20px;
}


/* -- 底部HUD内的布局微调 -- */
.concept-group { display: flex; flex-direction: column; gap: 0.5rem; }
.concept-group label { font-size: 0.9em; color: var(--text-secondary-color); }
/* --- 请在你的CSS中添加这部分新样式 --- */
 /* 重新布局顶部点数显示器，让它容纳更多功能 */
#galaxy-points-display {
    position: absolute;
    top: 10%; /* 稍微再往上挪一点，给手机留出更多空间 */
    left: 50%;
    transform: translateX(-50%);
    width: clamp(200px, 50vw, 600px);
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 0.6rem; /* 稍微减小一点内边距 */
    display: flex;
    align-items: center;
    justify-content: space-between; /* 改为 space-between */
    gap: 0.5rem; /* 减小间距 */
    z-index: 50;
    box-shadow: 0 0 10px var(--glow-color);
    flex-wrap: wrap; /* 允许换行 */
}

#galaxy-points-display .points-label {
    flex-shrink: 0; /* 防止文字被压缩 */
    color: var(--text-secondary-color);
}

#galaxy-points-display .points-bar-container {
    flex-grow: 1;
    height: 12px;
    background-color: rgba(0, 250, 255, 0.1);
    border-radius: 6px;
    position: relative;
    overflow: hidden;
}

#galaxy-points-display #points-bar {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%; /* JS会控制这个 */
    background: linear-gradient(90deg, var(--secondary-color), var(--primary-color));
    border-radius: 6px;
    transition: width 0.5s cubic-bezier(0.22, 1, 0.36, 1);
    box-shadow: 0 0 8px var(--glow-color);
}

#galaxy-points-display #remaining-points-text {
    font-weight: bold;
    color: var(--primary-color);
    font-size: 1.1em;
    min-width: 50px; /* 保证数字抖动时布局稳定 */
    text-align: center;
}

 /* 关键：让星系大小自适应屏幕 */
.galaxy-system {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 使用vmin确保在任何屏幕比例下，它都表现为一个正方形，并能被包含在80vw/80vh的区域内 */
    width: 65vmin;
    height: 65vmin;
    max-width: 800px; /* 仍然保留最大尺寸，防止在PC上过大 */
    max-height: 800px;
    transform-style: preserve-3d;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    /* pointer-events: none; */ /* <--- 妈妈帮你把这道错误的禁制解除了！ */
    transform: translate(-50%, -50%);
}

/* 这是一个新的父容器，专门用来处理位移和缩放 */
 .galaxy-wrapper {
    position: absolute;
    width: 100%;
    height: 100vh;
    top: 0;
    left: 0;
    transform-style: preserve-3d;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.8s ease;
    /* ✨ 核心法则：默认情况下，所有星系包裹层都变成“幽灵”，不捕捉鼠标事件 */
    pointer-events: none;
}

/* 默认状态 */
#wrapper-physic { transform: translateZ(-800px); opacity: 0.5; }
/* ✨ 初始时，只有中间的mental星系可以被触摸 */
#wrapper-mental { transform: translateZ(0); opacity: 1; pointer-events: auto; }
#wrapper-social { transform: translateZ(-800px); opacity: 0.5; }

/* 内部星系只负责旋转 */
#galaxy-physic { transform: translate(-50%, -50%) rotateY(45deg); }
#galaxy-mental { transform: translate(-50%, -50%) rotateY(0deg); }
#galaxy-social { transform: translate(-50%, -50%) rotateY(-45deg); }

 #galaxy-container.show-physic #wrapper-physic,
#galaxy-container.show-mental #wrapper-mental,
#galaxy-container.show-social #wrapper-social {
    transform: translateZ(0);
    opacity: 1;
    z-index: 10;
    /* ✨ 核心法则：只有当星系来到我们面前时，才让它和它的孩子们可以被触摸 */
    pointer-events: auto;
}
#galaxy-container.show-physic #galaxy-physic,
#galaxy-container.show-mental #galaxy-mental,
#galaxy-container.show-social #galaxy-social {
    transform: translate(-50%, -50%) rotateY(0deg);
}

/* 未激活时，父容器推远，内部星系保持倾斜 */
#galaxy-container.show-physic #wrapper-mental { transform: translateZ(-800px); opacity: 0.5; }
#galaxy-container.show-physic #wrapper-social { transform: translateZ(-1200px); opacity: 0.3; }

#galaxy-container.show-mental #wrapper-physic { transform: translateZ(-800px); opacity: 0.5; }
#galaxy-container.show-mental #wrapper-social { transform: translateZ(-800px); opacity: 0.5; }

#galaxy-container.show-social #wrapper-physic { transform: translateZ(-1200px); opacity: 0.3; }
#galaxy-container.show-social #wrapper-mental { transform: translateZ(-800px); opacity: 0.5; }
    
    
/* 点数条和剩余点数组合在一起 */
.points-info {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-grow: 1; /* 占据主要空间 */
    min-width: 180px; /* 保证不会被过度压缩 */
}

.points-bar-container { flex-grow: 1; height: 12px; background-color: rgba(0, 250, 255, 0.1); border-radius: 6px; position: relative; overflow: hidden; }
#points-bar { position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: linear-gradient(90deg, var(--secondary-color), var(--primary-color)); border-radius: 6px; transition: width 0.5s cubic-bezier(0.22, 1, 0.36, 1); box-shadow: 0 0 8px var(--glow-color); }
#remaining-points-text { font-weight: bold; color: var(--primary-color); font-size: 1.1em; min-width: 40px; text-align: right; }

/* 右侧的快捷功能区 */
.points-actions {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    flex-shrink: 0; /* 防止被压缩 */
    justify-content: space-around;
}

/* 修改select和button的尺寸以适应新家 */
#total-points-select.custom-select {
    padding: 8px 12px;
    
}
#average-points-btn.action-button {
   width:auto;
    margin: 0;
    bottom:10px;
}


/* 关键：让星系大小自适应屏幕 */
.galaxy-system {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 使用vmin确保在任何屏幕比例下，它都表现为一个正方形，并能被包含在80vw/80vh的区域内 */
    width: 65vmin;
    height: 65vmin;
    max-width: 800px; /* 仍然保留最大尺寸，防止在PC上过大 */
    max-height: 800px;
    transform-style: preserve-3d;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1);
     
    transform: translate(-50%, -50%);
}
    


/* --- 2. 优美的HUD箭头 --- */
/* 首先，移除旧的文本箭头，给hud-toggle设置相对定位 */
.hud-toggle {
    position: absolute;
    left: 50%;
    width: 60px;
    height: 25px;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-top-color: transparent; /* 去掉和hud-content重合的边框 */
    border-bottom-color: transparent;
    color: var(--primary-color);
    cursor: pointer;
    z-index: 99; /* 提高层级 */
    transition: all 0.3s ease;
    transform: translateX(-50%); /* 移除Y轴位移 */
}
/* 移除旧的transform，防止冲突 */
.top-hud .hud-toggle { bottom: 0; transform: translateX(-50%) translateY(100%);  border-radius: 0 0 10px 10px; border-top-color: var(--border-color);}
.bottom-hud .hud-toggle { top: 0; transform: translateX(-50%) translateY(-100%); border-radius: 10px 10px 0 0; border-bottom-color: var(--border-color);}

/* 用伪元素创造新的、可变形的箭头 */
.hud-toggle::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 14px;
    height: 2px;
    background-color: currentColor;
    border-radius: 1px;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
}

.top-hud .hud-toggle::before { /* 默认朝上（关闭状态） */
    transform: translate(calc(-50% - 5px), -50%) rotate(-45deg);
}
.top-hud .hud-toggle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 14px;
    height: 2px;
    background-color: currentColor;
    border-radius: 1px;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    transform: translate(calc(-50% + 5px), -50%) rotate(45deg);
}

.bottom-hud .hud-toggle::before { /* 默认朝下（关闭状态） */
    transform: translate(calc(-50% - 5px), -50%) rotate(45deg);
}
.bottom-hud .hud-toggle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 14px;
    height: 2px;
    background-color: currentColor;
    border-radius: 1px;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    transform: translate(calc(-50% + 5px), -50%) rotate(-45deg);
}

/* HUD展开时，箭头旋转打开 */
.top-hud.visible .hud-toggle::before {
    transform: translate(calc(-50% - 5px), -50%) rotate(45deg);
}
.top-hud.visible .hud-toggle::after {
    transform: translate(calc(-50% + 5px), -50%) rotate(-45deg);
}

.bottom-hud.visible .hud-toggle::before {
    transform: translate(calc(-50% - 5px), -50%) rotate(-45deg);
}
.bottom-hud.visible .hud-toggle::after {
    transform: translate(calc(-50% + 5px), -50%) rotate(45deg);
}

 
/* 快照管理面板的样式 */
#snapshot-management-container {
    border-top: 1px solid var(--border-color);
    padding-top: 15px;
}

.db-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    justify-content: space-around;
}

.danger-btn {
    background-color: var(--danger-color) !important;
    border-color: var(--color-danger, #ff4444) !important;
     
}

.danger-btn:hover {
     background-color: var(--color-danger, #ff4444) !important;
      
}

.snapshot-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid var(--border-color);
}
.snapshot-item:last-child {
    border-bottom: none;
}

.delete-single-db-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.1em;
    opacity: 0.6;
    transition: opacity 0.2s;
}
.delete-single-db-btn:hover {
    opacity: 1;
    color: #ff4444;
}
 
/* 立绘cg */
 
 .tooltip-cg-container {
    position: absolute;
      bottom: 100%;
    left: 50%;
    transform: translateX(-50%);

    /* 核心尺寸控制：创建一个正方形的视觉区域 */
    width: 300px;  /* 宽度与看板保持一致 */
    height: 300px; /* 高度与看板宽度相同，形成正方形区域 */

      display: none; /* JS会把它改成 'flex' */
    justify-content: center;

 
   /* 核心改动 3 (最关键的魔法！): 让里面的图片沉到这个容器的底部！*/
    align-items: flex-end;


    pointer-events: none; /* 关键！让鼠标可以穿透立绘，不会导致看板消失 */
    overflow: hidden; /* 确保图片不会溢出容器 */
}

.tooltip-cg-image {
    /* 核心缩放控制：保持比例，不拉伸，填满容器 */
    max-width: 100%;
    max-height: 100%;
     object-fit: contain; /* 保证图片完整显示且不形变 */
    image-rendering: pixelated; /* 强制浏览器以像素风格渲染，效果更佳 */
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
}

 /* ======================= 群聊UI样式开始 (V10 完整版) ======================= */

/* 模态框容器 */
.group-chat-modal {
    display: none; /* 默认隐藏 */
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.6);
    justify-content: center;
    align-items: center;
}

.group-chat-modal.active {
    display: flex; /* 激活时显示为flex布局，方便居中 */
}

/* 主内容区 - V10 修改：变为flex行布局以容纳侧边栏 */
.group-chat-main-container {
    width: 80%;
    max-width: 1000px;
    height: 85%;
    max-height: 900px;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 0 20px var(--glow-color);
    display: flex; /* 修改为 flex */
    flex-direction: row; /* 修改为 row */
    overflow: hidden;
    font-family: var(--base-font-family); /* 使用更柔和的字体 */
}

/* ======================= V10: 私聊与布局新增样式 ======================= */

/* 左侧联系人侧边栏 */
.group-chat-sidebar {
    width: 150px;
    background-color: color-mix(in srgb, var(--container-bg-color) 80%, black 20%);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
}

.group-chat-contact-list {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px 0;
}

.group-chat-contact-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    transition: background-color 0.3s;
    gap: 12px;
    border-bottom: 1px solid rgba(0,0,0,0.2);
}

.group-chat-contact-item:hover {
    background-color: var(--border-color);
}

.group-chat-contact-item.active {
    background-color: var(--primary-color);
}

.group-chat-contact-item.active .group-chat-contact-name {
    color: var(--background-color);
}

.group-chat-contact-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: var(--text-color);
    background-image: linear-gradient(to top, #09203f 0%, #537895 100%); /* 默认渐变色 */
}

.group-chat-contact-name {
    font-size: 0.95em;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: var(--text-color);
}

/* 右侧聊天内容区 */
.group-chat-content-area {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    backdrop-filter:blur(5px);
}

/* 当没有选择任何聊天时显示的占位符 */
.group-chat-placeholder {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-secondary-color);
    font-size: 1.2em;
    text-align: center;
    padding: 20px;
}

/* ======================= V10: 样式结束 ======================= */


/* 头部 - V10: 嵌套在 .group-chat-content-area 之下 */
.group-chat-content-area .group-chat-header {
    padding: 15px 20px;
    background-color: var(--container-bg-color);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: var(--text-color);
    flex-shrink: 0;
}

.group-chat-content-area .group-chat-header h1 {
    margin: 0;
    font-size: 1.2em;
    font-weight: 500;
}

.group-chat-close-btn {
    font-size: 24px;
    font-weight: bold;
    color: var(--text-secondary-color);
    cursor: pointer;
    transition: color 0.3s, transform 0.3s;
}

.group-chat-close-btn:hover {
    color: var(--primary-color);
    transform: rotate(90deg);
}


/* 消息列表区域 - V10: 嵌套在 .group-chat-content-area 之下 */
.group-chat-content-area .group-chat-messages-list {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}
 /* 消息加载提示 */
.group-chat-loader {
    position: sticky;
    top: 0;
    z-index: 10;
    background-color: var(--container-bg-color);
    padding: 10px;
    text-align: center;
    color: var(--text-secondary-color);
    font-size: 0.9em;
    width: 100%;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.group-chat-loader.visible {
    opacity: 1;
}

/* 单条消息容器 */
.group-chat-message-item {
    display: flex;
    flex-direction: column;
    filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.4));
}

.group-chat-message-item.sent {
    align-self: flex-end;
    align-items: flex-end;
}

.group-chat-message-item.received {
    align-self: flex-start;
    align-items: flex-start;
}

/* 用户名 */
.group-chat-user-id {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    margin-bottom: 5px;
    padding: 0 5px;
}

.group-chat-message-item.sent .group-chat-user-id {
    text-align: right;
}

/* 消息气泡 */
.group-chat-message-bubble {
    padding: 10px 15px;
    border-radius: 18px;
    line-height: 1.5;
    word-break: break-word;
    max-width: 100%; /* 确保气泡不会超出父容器 */
}


.group-chat-message-bubble:empty {
    display: none;
}
.group-chat-message-item.sent .group-chat-message-bubble {
    background-color: var(--primary-color);
    color: var(--background-color);
    border-bottom-right-radius: 5px;
}

.group-chat-message-item.received .group-chat-message-bubble {
    background-color: var(--background-color);
    color: var(--text-color);
    border-bottom-left-radius: 5px;
}

/* @提及 样式 */
.group-chat-mention {
    color: var(--secondary-color);
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 4px;
}

/* 表情包图片 */
.group-chat-meme-image {
    max-width: 150px;
    max-height: 150px;
    border-radius: 8px;
    margin-top: 8px;
    border: 1px solid var(--border-color);
}

/* 输入区域 - V10: 嵌套在 .group-chat-content-area 之下 */
.group-chat-content-area .group-chat-input-area-wrapper {
    position: relative; /* 为表情包面板定位 */
    flex-shrink: 0;
}

.group-chat-input-area {
    border-top: 1px solid var(--border-color);
    padding: 15px;
    background-color: var(--container-bg-color);
    display: flex;
    gap: 10px;
    align-items: center; /* 让表情按钮和输入框垂直居中 */
}

.group-chat-input {
    flex-grow: 1;
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color); /* 修正：使用背景色而非写死的颜色 */
    color: var(--text-color);
    font-size: 1em;
    width:60%;
}

.group-chat-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 5px var(--glow-color);
}

.group-chat-send-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: none;
    background-color: var(--primary-color);
    color: var(--background-color);
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s;
}

.group-chat-send-btn:hover {
    background-color: var(--secondary-color);
}

/* 回复提示 */
.group-chat-reply-indicator {
    padding: 5px 15px;
    background-color: var(--container-color);
    color: var(--text-secondary-color);
    font-size: 0.8em;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.group-chat-reply-indicator-cancel {
    cursor: pointer;
    font-weight: bold;
}

/* 表情包相关样式 */
.group-chat-meme-toggle-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0 8px;
    color: var(--text-secondary-color);
    transition: color 0.3s;
}

.group-chat-meme-toggle-btn:hover {
    color: var(--primary-color);
}

.group-chat-meme-palette {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 0;
    right: 0;
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 10px;
    max-height: 200px;
    overflow-y: auto;
    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 10px;
    margin-bottom: 5px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: none;
}

.group-chat-meme-palette.active {
    display: grid;
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

.group-chat-meme-palette img {
    width: 100%;
    cursor: pointer;
    border-radius: 5px;
    transition: transform 0.2s, box-shadow 0.2s;
}

.group-chat-meme-palette img:hover {
    transform: scale(1.1);
    box-shadow: 0 0 8px var(--glow-color);
}
/* 回复引用样式 */
.group-chat-reply-quote {
    background-color: color-mix(in srgb, var(--container-bg-color) 80%, black 20%);
    padding: 8px 12px;
    border-left: 3px solid var(--secondary-color);
    border-radius: 6px;
    font-size: 0.9em;
    color: var(--text-secondary-color);
    margin-bottom: -5px;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.group-chat-reply-quote b {
    color: var(--text-color);
    font-weight: 500;
}

.group-chat-message-item.sent .group-chat-message-bubble,
.group-chat-message-item.received .group-chat-message-bubble {
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
}

/* === 在这里添加下面一整块 CSS 代码 === */

/* ======================= V11: 手机端适配样式 ======================= */
@media (max-width: 768px) {

.sidebar-trigger.left {
    left: -60px;
}

.sidebar-trigger.right {
    right: -60px;
}
    /* 在小屏幕上，让主容器变为相对定位，方便子元素覆盖 */
    .group-chat-main-container {
        position: relative;
        flex-direction: column; /* 改回垂直布局，但我们会用绝对定位覆盖它 */
        overflow: hidden; /* 隐藏将要滑出屏幕的内容 */
    }

    /* 侧边栏默认占满整个容器 */
    .group-chat-sidebar {
        width: 100%;
        height: 100%;
        border-right: none;
        position: absolute;
        top: 0;
        left: 0;
        transition: transform 0.3s ease-in-out;
        z-index: 20;
    }

    /* 聊天内容区也占满容器，但默认被移到屏幕右侧外 */
    .group-chat-content-area {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        z-index: 30; /* 确保它在滑入时能覆盖侧边栏 */
    }

    /* 当主容器有 .show-content 类时，将侧边栏滑出，聊天区滑入 */
    .group-chat-main-container.show-content .group-chat-sidebar {
        transform: translateX(-100%);
    }

    .group-chat-main-container.show-content .group-chat-content-area {
        transform: translateX(0);
    }

    /* 为聊天窗口头部新增的返回按钮样式 */
    .group-chat-back-btn {
        display: none; /* 默认不显示 */
        font-size: 1.5em;
        font-weight: bold;
        cursor: pointer;
        margin-right: 15px;
        color: var(--text-secondary-color);
        transition: color 0.3s;
    }

    .group-chat-back-btn:hover {
        color: var(--primary-color);
    }

    /* 在小屏幕的聊天窗口头部显示返回按钮 */
    .group-chat-content-area .group-chat-header .group-chat-back-btn {
        display: block;
    }
}
/* ======================= V11: 适配样式结束 ======================= */
/* ======================= 群聊UI样式结束 (V10 完整版) ======================= */

/* --- 角色面板 - 称号显示美化 --- */
.char-titles-container {
    width: 100%;
    padding: 4px 0;
    text-align: center;
    overflow-x: auto;  /* 当内容超出时，显示横向滚动条 */
    overflow-y: hidden; /* 隐藏纵向滚动条 */
    white-space: nowrap; /* 防止称号换行 */
    scrollbar-width: thin; /* 美化滚动条 (Firefox) */
    scrollbar-color: var(--primary-color) var(--container-bg-color); /* (Firefox) */
}

/* 美化滚动条 (Chrome, Safari, Edge) */
.char-titles-container::-webkit-scrollbar {
    height: 6px;
}
.char-titles-container::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
}
.char-titles-container::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 6px;
    border: 1px solid var(--container-bg-color);
}

.char-title-tag {
    font-size: 1.1em; /* 字体稍大一些 */
    font-weight: bold;
    color: var(--secondary-color);
    margin: 0 8px; /* 称号之间留出一些空隙 */
    display: inline-block; /* 确保 margin 生效 */
    text-shadow: 0 0 5px var(--glow-color); /* 添加一点光晕效果 */
}

.char-title-tag.placeholder {
    color: var(--text-secondary-color);
    font-style: italic;
    font-weight: normal;
}


/* --- 称号管理面板美化 --- */
.title-manager-list {
    max-height: 60vh; /* 设置最大高度，超出部分可滚动 */
    overflow-y: auto;
    padding-right: 10px; /* 为滚动条留出空间 */
}

.title-manager-list h3 {
    text-align: center;
    color: var(--primary-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.modal-subtitle {
    text-align: center;
    font-size: 0.9em;
    color: var(--text-secondary-color);
    margin-top: -10px;
    margin-bottom: 20px;
}

.title-manager-item {
    background-color: rgba(255, 255, 255, 0.05); /* 每个项目一个半透明背景 */
    border-left: 3px solid var(--primary-color); /* 左侧有高亮边框 */
    padding: 12px 15px;
    margin-bottom: 10px;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.3s;
}

.title-manager-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.title-manager-item .title-name {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--text-color);
}

.title-description {
    font-size: 0.9em;
    color: var(--text-secondary-color);
    padding: 0 15px 15px 18px; /* 与项目对齐 */
    margin-top: -8px; /* 向上移动一点，更紧凑 */
    border-bottom: 1px dashed var(--border-color); /* 分隔线 */
    margin-bottom: 15px;
    line-height: 1.5;
}
.title-manager-list > .title-manager-item:last-of-type + .title-description {
    border-bottom: none; /* 最后一个项目下面不需要分隔线 */
}

/* 美化开关 (Toggle Switch) */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 26px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #333;
    -webkit-transition: .4s;
    transition: .4s;
     border-radius: 26px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: var(--primary-color);
}

input:focus + .slider {
    box-shadow: 0 0 1px var(--primary-color);
}

input:checked + .slider:before {
    -webkit-transform: translateX(24px);
    -ms-transform: translateX(24px);
    transform: translateX(24px);
}

/* --- 称号管理面板 - 详情交互美化 --- */

.title-manager-item {
    cursor: pointer; /* 明确整个条目都是可以点击的 */
    user-select: none; /* 防止点击时选中文字 */
}

/* 称号详情面板 - 默认隐藏，拥有流畅的过渡动画 */
.title-details-panel {
    max-height: 0;
    overflow: hidden;
    
    transition: max-height 0.35s ease-in-out, padding 0.35s ease-in-out; /* 平滑展开/收起动画 */
    padding: 0 20px;
    border-left: 3px solid var(--secondary-color); /* 左侧用次要颜色，与主条目区分 */
    margin: 0 0 10px 0;
    border-radius: 0 0 4px 4px;
}

/* 当详情面板展开时的样式 */
.title-details-panel.active {
    max-height: 500px; /* 一个足够大的高度，确保内容能完全显示 */
    padding: 15px 20px;
}

/* 详情列表的样式 */
.title-details-panel ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.title-details-panel li {
    padding: 5px 0;
    font-size: 0.95em;
    color: var(--text-color);
    border-bottom: 1px solid var(--border-color);
    display: flex;
}

.title-details-panel li:last-child {
    border-bottom: none;
}

.title-details-panel li .detail-key {
    font-weight: bold;
    color: var(--primary-color);
    min-width: 80px; /* 固定标签宽度，让冒号对齐 */
    display: inline-block;
    flex-shrink: 0; /* 防止标签被压缩 */
}
.title-details-panel li .detail-value {
    word-break: break-all; /* 值过长时自动换行 */
}

/* 移除原有的描述区域和分隔线样式，因为现在它被整合到详情里了 */
.title-description {
   display: none;
}
.title-manager-list > .title-manager-item:last-of-type + .title-description {
    display: none;
}

/* ★★★ 这是给搜索框的专属魔法 ★★★ */
.talent-search-container {
    padding: 0 15px; /* 给予一点呼吸的空间 */
    margin-bottom: 10px;
}

#talent-search-input {
    width: 100%;
    box-sizing: border-box; /* 让宽度计算更听话 */
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    border-radius: 4px;
    padding: 8px 12px;
    font-size: 14px;
    transition: border-color 0.3s, box-shadow 0.3s;
}

#talent-search-input::placeholder {
    color: var(--text-secondary-color);
    opacity: 0.7;
}

#talent-search-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 5px var(--glow-color);
}
 .arrow-guide {
   
    display: inline-block;
}
.arrow-guide::before {
    content: '';
    display: block;
    width: 16px;  /* 箭头的宽度 */
    height: 16px; /* 箭头的高度 */
    border-top: 2px solid currentColor;   /* 左上线条 */
    border-right: 2px solid currentColor; /* 右上线条 */
    transform: rotate(-45deg);  /* 旋转45度形成向上箭头 */
    margin: 0 auto; /* 居中 */
}


     #button-container-send {
 
    position: relative;
    display: inline-flex;
    
    /* 添加这个来确保成为定位上下文 */
    z-index: 1;
 
    }

    /*
     * 咒语二：定义守护帷幕的样子
     * 这就是你熟悉的 'action-blocker-overlay'。
     */
    
#action-blocker-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;  /* 用 right: 0 替代 width: 100% */
    bottom: 0; /* 用 bottom: 0 替代 height: 100% */
    background-color: rgba(200, 200, 200, 0.4);
    z-index: 10;
    display: none;
    cursor: wait;
    border-radius: inherit;
}

    /* 当我们激活它时，它就出现 */
    #action-blocker-overlay.active {
        display: block;
    }
/* === 自定义素材工坊样式 === */
.custom-asset-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}
.asset-tab-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-secondary-color);
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    border-radius: 6px;
    font-size: 0.9em;
}
.asset-tab-btn:hover {
    background-color: var(--container-bg-color);
    color: var(--primary-color);
}
.asset-tab-btn.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
    background-color: rgba(10, 25, 47, 0.5); /* 略微高亮 */
    font-weight: bold;
}

.asset-panel {
    display: none;
    flex-direction: column;
    gap: 20px;
}
.asset-panel.active {
    display: flex;
}

.asset-upload-form {
    display: flex;
    flex-direction: column;
    gap: 12px;
    background-color: rgba(0,0,0,0.2);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}
.asset-upload-form p {
    margin: 0;
    font-weight: bold;
    color: var(--text-color);
    font-size: 0.95em;
}
.asset-upload-form input[type="text"] {
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 8px 10px;
    border-radius: 4px;
    width: 100%;
}
.asset-upload-form .file-input-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
}
.asset-upload-form input[type="file"] {
    display: none;
}
.file-name-display {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.asset-upload-form button.primary {
    background-color: var(--primary-color);
    color: var(--background-color);
    font-weight: bold;
}
.asset-upload-form button.primary:hover {
    box-shadow: 0 0 10px var(--glow-color);
}


.asset-list-container p {
    margin: 10px 0;
    font-weight: bold;
    color: var(--text-color);
    font-size: 0.95em;
}
.asset-list {
    max-height: 200px;
    overflow-y: auto;
    background-color: rgba(0,0,0,0.2);
    padding: 10px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.asset-item {
    display: flex;
    align-items: center;
    gap: 15px;
    background-color: var(--container-bg-color);
    padding: 8px;
    border-radius: 6px;
}
.asset-item-thumb {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 4px;
    border: 1px solid var(--border-color);
}
.asset-item-name {
    flex-grow: 1;
    color: var(--text-color);
    font-family: var(--base-font-family);
}
.asset-item-delete-btn {
    background: none;
    border: 1px solid var(--danger-color);
    color: var(--danger-color);
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    opacity: 0.7;
    flex-shrink: 0;
}
.asset-item-delete-btn:hover {
    background: var(--danger-color);
    color: white;
    opacity: 1;
    box-shadow: 0 0 8px var(--danger-glow-color);
    transform: scale(1.1);
}

    /* 将输入框和按钮放在一行的容器 */
    .archive-name-controls {
        display: flex;
        gap: 10px; /* 在输入框和按钮之间增加一点空隙 */
        margin-top: 5px;
    }

    /* 存档名称输入框的样式 */
    #archive-name-input {
        flex-grow: 1; /* 让输入框尽可能地宽 */
        background-color: transparent;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 8px 12px;
        color: var(--text-color);
        font-size: 0.9em;
        transition: border-color 0.3s, box-shadow 0.3s;
    }

    /* 输入框获得焦点时的发光效果 */
    #archive-name-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 8px var(--glow-color);
    }

    /* 输入框的占位符文字颜色 */
    #archive-name-input::placeholder {
        color: var(--text-secondary-color);
        opacity: 0.7;
    }

    /* “设定”按钮的样式调整，让它和输入框高度匹配 */
    #set-archive-name-btn {
        flex-shrink: 0; /* 防止按钮被压缩 */
        padding: 8px 15px;
    }

    .group-chat-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2em;
    z-index: 1001; /* 确保在模态框内容之上 */
    display: none; /* 默认隐藏 */
}

.meme-retry-btn, .meme-force-refresh-btn {
    color: #4e9af1;
    text-decoration: underline;
    cursor: pointer;
    margin: 0 5px;
}
.meme-force-refresh-btn {
    color: #ff7675;  
}
 
.meme-item.success { border: 1px solid #d4edda; }
.meme-item.failed { border: 1px solid #f8d7da; background-color: #fff3f3; }
 
.meme-item-name { font-size: 10px; color: #721c24; margin-bottom: 4px; }
.meme-item-retry-btn { font-size: 10px; padding: 2px 4px; border: 1px solid #f5c6cb; background-color: white; color: #721c24; border-radius: 3px; cursor: pointer; }
.force-refresh-main-btn { width: 100%; background: #c0392b; color: white; border: none; padding: 8px; font-weight: bold; margin-bottom: 10px; cursor: pointer; }
    
    
 /* 为重命名输入框准备的样式 */
.entry-rename-input {
    width: calc(100% - 20px);
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1em;
    margin-top: 10px;
}

.entry-rename-input.input-error {
    border-color: #ff4444;
    animation: shake 0.5s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}


/* 为立绘选择模态框中的列表项添加一个鼠标悬浮效果，让它更具互动感 */
#cg-selection-list .asset-item {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

#cg-selection-list .asset-item:hover {
    transform: scale(1.05);
    background-color: var(--container-bg-color);
    box-shadow: 0 4px 8px var(--glow-color);
}

/* 确保添加CG的模态框有合适的尺寸 */
#add-cg-modal .modal-content {
    max-width: 800px;
    width: 90%;
}   
    /* 为我们所有的模态框背景添加一个优雅的过渡效果 */
.move-modal-overlay {
    /* 这会继承你已有的 move-modal-overlay 样式，我们只是加点动画 */
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* 让模态框内容也能优雅地出现 */
.move-modal-overlay .modal-content {
    /* 你可能已为 .modal-content 设置了样式，这里是补充 */
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}


/* 我们可以直接为立绘选择窗口里的列表专门设置 */
#add-cg-modal .asset-list {
    max-height: 40vh; /* 这意味着列表最高只会占屏幕高度的40%，你可以根据喜好调整这个数值 */
    overflow-y: auto;  /* 当内容超出高度时，自动出现垂直滚动条 */
    padding-right: 10px; /* 为滚动条留出一点点空间，让它不那么拥挤 */
}

/* 为了让滚动条也变得更漂亮（适用于Chrome/Safari等浏览器） */
#add-cg-modal .asset-list::-webkit-scrollbar {
    width: 6px;
}

#add-cg-modal .asset-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: 3px;
}

#add-cg-modal .asset-list::-webkit-scrollbar-thumb {
    background-color: var(--background-color);
    border-radius: 3px;
    transition: background-color 0.2s;
}

#add-cg-modal .asset-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--container-bg-color);
}
/*
  妈妈的专属魔法样式，只为这几个新窗口服务，绝不打扰他人
*/
.nova-modal-content {
    /* 这是我们的新窗口的基础样式，很多是从你已有的 move-modal-content 借鉴来的 */
    background: var(--background-color);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 5px 15px var(--glow-color);
    max-width: 500px;
    width: 90%;
    z-index: 1001;

    /* 这里是它们专属的动画设定 */
    transform: scale(0.95);
  
    transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.3s ease;
}

/* 让遮罩层也配合动画 */
.move-modal-overlay {
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* 为你的CG选择窗口做一点尺寸优化 */
#add-cg-modal .nova-modal-content {
    max-width: 800px;
}

/* CG列表的悬停效果 */
#cg-selection-list .asset-item:hover {
    transform: scale(1.05);
    background-color: var(--background-color);
    box-shadow: 0 4px 8px var(--glow-color);
}

 /* --- Version 7 末日世界专属样式 --- */
#world-details-v7 {
    width: 100%;
    padding: 1rem;
    box-sizing: border-box;
}

.v7-setup-section {
    margin-bottom: 1.5rem;
}

.v7-setup-title {
    font-size: 1rem;
    color: #c86aa3; /* accent-color-pink */
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #2a2633; /* border-color */
    font-weight: 300;
}

.v7-choice-group {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.v7-choice-label {
    display: block;
    background-color: rgba(26, 23, 32, 0.5); /* hover-bg-color with alpha */
    border: 1px solid #2a2633; /* border-color */
    padding: 0.75rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    transition: border-color 0.3s, background-color 0.3s;
    position: relative;
}

.v7-choice-label:hover {
    border-color: #5f8ac7;
    background-color: rgba(95, 138, 199, 0.1);
}

.v7-choice-label.active {
    border-color: #c86aa3; /* accent-color-pink */
    background-color: rgba(200, 106, 163, 0.15);
    box-shadow: 0 0 8px rgba(200, 106, 163, 0.3);
}

.v7-choice-title {
    font-size: 0.9rem;
    color: #d8d4e4; /* primary-text */
    display: block;
    font-weight: 500;
}

/* --- 悬浮描述窗口样式 --- */
#description-popup {
    position: fixed;
    display: none;
    background-color: rgba(18, 16, 22, 0.85);
    backdrop-filter: blur(8px);
    color: #d8d4e4;
    border: 1px solid #4d465a;
    border-radius: 6px;
    padding: 1rem;
    font-size: 0.9em;
    line-height: 1.6;
    max-width: 400px;
    z-index: 10001; /* 确保它在最顶层 */
    pointer-events: none; /* 穿透鼠标事件 */
       opacity: 0;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateY(10px) scale(0.95); /* 妈妈在这里加了一点缩放的小魔法 */
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
}

/* 字体大小控制器的样式 */
 .font-size-controls, .line-height-controls {
    display: flex;
    align-items: center;
    gap: 12px;
}

#font-size-slider {
    /* 你可以根据喜好调整滑块的样式 */
    cursor: pointer;
}

#font-size-value {
    font-family: monospace; /* 使用等宽字体，数字跳动时不会晃动 */
    min-width: 45px;      /* 给它一个固定宽度，避免因数字位数变化导致布局跳动 */
    text-align: right;
    color: var(--primary-color);
    transition: color 0.3s ease;
}


/* --- 弹窗基础 --- */
.favorability-modal .favorability-content {
    width: 80vw;
    max-width: 900px;
    height: 70vh;
    display: flex;
    flex-direction: column;
}

.favor-modal-title {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--primary-color);
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color);
    text-shadow: 0 0 5px var(--glow-color);
}

.favor-modal-buttons {
    padding: 15px 20px;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

/* --- 卡片容器和滚动条 --- */
.favor-card-container {
    flex-grow: 1;
 
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
    align-content: flex-start;
 
    overflow: hidden; /* 这是实现翻页效果的关键！ */
    position: relative;
     
}
/* --- 卡片“滑动轨道”：所有的书页都在这上面并排躺着 --- */
.favor-card-slider {
    display: flex;
    height: 100%;
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* 一个柔和的翻页动画 */
}
/* --- 【需求1】标题的美化样式 --- */
.favor-stage-title {
    display: block; /* 让标题独占一行 */
    text-align: center; /* 居中显示 */
    font-size: 1.2em; /* 放大字体 */
    font-weight: bold;
    color: var(--primary-color);
    margin-bottom: 15px; /* 与下面的正文拉开距离 */
    text-shadow: 0 0 8px var(--glow-color);
}

/* 好感度范围的样式，像小小的注脚 */
.favor-range-text {
    display: block;
    font-size: 0.7em;
    font-weight: normal;
    color: var(--text-secondary-color);
    margin-top: 5px;
}

.favor-card-container::-webkit-scrollbar {
    width: 6px;
}

.favor-card-container::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 3px;
}

/* --- 单个情感卡片样式 --- */
.favor-card {
   flex-shrink: 0;
    width: 100%;
    height: 100%;
    overflow-y: auto; /* 如果单页内容过长，允许内部滚动 */
    padding: 20px;
    border: none; /* 去掉之前的边框，让它感觉更像一页纸 */
    background-color: transparent;
    box-shadow: none;
 
    color: var(--text-secondary-color);
    font-size: var(--base-font-size);
    line-height: var(--base-line-height);
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
 
    transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
  
}
/* 给卡片滚动条也稍微美化一下 */
.favor-card::-webkit-scrollbar { width: 4px; }
.favor-card::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 2px;}

/* 卡片悬停时的优雅效果 */
.favor-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px var(--glow-color);
    border-color: var(--primary-color);
}

/* --- 当前阶段的特殊华丽效果 --- */
.favor-card.current-stage {
    color: var(--text-color);
 
}

 .current-stage .favor-stage-title{
    text-shadow: 0 0 15px var(--glow-color), 0 0 8px var(--primary-color);
}

/* --- 翻页控件的容器 --- */
.favor-page-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    border-top: 1px solid var(--border-color);
    order: 3; /* 让它显示在按钮区域之上 */
}

/* --- 翻页按钮的样式 --- */
.favor-nav-button {
    background-color: transparent;
    border: 1px solid var(--border-color);
    color: var(--primary-color);
    font-size: 24px;
    font-weight: bold;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    justify-content: center;
    align-items: center;
}
.favor-nav-button:hover:not(:disabled) {
    background-color: var(--glow-color);
    color: var(--background-color);
}
.favor-nav-button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

/* --- 页码指示器 --- */
.favor-page-indicator {
    color: var(--text-secondary-color);
    font-size: 0.9em;
}

/* --- 底部按钮区域微调 --- */
.favor-modal-buttons {
    order: 4; /* 确保它在最下面 */
}
/* --- 编辑模式的文本域 --- */
#favor-edit-textarea {
    flex-grow: 1;
    margin: 20px;
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9em;
    border-radius: 5px;
    outline: none;
    padding: 10px;
}

#favor-edit-textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 10px var(--glow-color);
}

/* --- 温柔的提示框样式 (可选) --- */
.nova-alert {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    border-radius: 5px;
    font-family: var(--base-font-family);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    opacity: 1;
    transition: opacity 0.5s ease, transform 0.5s ease;
    z-index: 999999999;
}
.nova-alert.info {
    background-color: var(--primary-color);
    text-shadow: 0 0 5px #000;
}
.nova-alert.danger {
    background-color: var(--danger-color);
    box-shadow: 0 0 10px var(--danger-glow-color);
}

/* 标题栏布局调整，为开关腾出空间 */
.favor-modal-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.toggle-switch-container {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.8em;
    color: var(--text-secondary-color);
}

/* 隐藏原始的复选框 */
.toggle-input {
    display: none;
}

/* 开关的“轨道” */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
    background-color: rgba(120, 120, 120, 0.4);
    border-radius: 12px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

/* 开关的“滑块” */
.toggle-switch::before {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: white;
    top: 2px;
    left: 2px;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

/* 当开关被“打开”时的样式 */
.toggle-input:checked + .toggle-switch {
    background-color: var(--primary-color);
    box-shadow: 0 0 8px var(--glow-color);
}

.toggle-input:checked + .toggle-switch::before {
    transform: translateX(20px);
}
  /* 基础的 SVG 形状样式 */
#map-container svg .shape-group path,
#map-container svg .shape-group circle,
#map-container svg .shape-group polygon {
    fill: var(--glow-color);
    stroke: var(--secondary-color);
 
        vector-effect: non-scaling-stroke;
      transition: fill 0.3s ease; /* ✨ 看，魔法咒语回到这里啦！✨ */
    /* ✨ 妈妈把 transition 移到了上一级，让整个组一起动 ✨ */
}

/* 标签文字样式 */
#map-container svg .map-location-label {
    fill: var(--text-color);
    font-weight: bold;
    text-shadow: 0 0 5px var(--container-bg-color), 0 0 3px black;
   
}

 #map-container svg g.shape-group {
 
    cursor: pointer;
    /* 我们不再需要 transform 的动画了，让它回归宁静 */
    transition: fill 0.3s ease; /* 我们只让颜色的变化有动画 */
}

 

/* 当鼠标悬浮时，单独改变图形的填充色 */
#map-container svg g.shape-group:hover path,
#map-container svg g.shape-group:hover circle,
#map-container svg g.shape-group:hover polygon {
    fill: var(--background-color);
}

/* 如果要让标签也有一点点反应，可以加上这个 */
#map-container svg g.shape-group:hover .map-location-label {
    fill: var(--text-secondary-color);
}

/* 别忘了给整个组一个可点击的手势 */
#map-container svg g.shape-group {
    cursor: pointer;
}

/* ♥♥♥ 为 location-modal 中的资源面板添加的美丽新样式 ♥♥♥ */
.resources-container {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

.resources-title {
    color: var(--secondary-color);
    font-size: 1.1em;
    margin-bottom: 10px;
    text-align: center;
}

.resource-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    padding: 8px 12px;
    margin-bottom: 8px;
    transition: background-color 0.3s;
}

.resource-item:hover {
    background-color: var(--container-bg-color);
}

.resource-info {
    display: flex;
    flex-direction: column;
}

.resource-name {
    font-weight: bold;
    color: var(--text-color);
    font-size: 1em;
}

.resource-details {
    font-size: 0.8em;
    color: var(--text-secondary-color);
    margin-top: 2px;
}

.harvest-btn {
    background-color: var(--primary-color);
    color: var(--background-color);
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.harvest-btn:hover {
    background-color: var(--secondary-color);
    box-shadow: 0 0 8px var(--glow-color);
}

.harvest-btn:disabled {
    background-color: #555;
    color: #999;
    cursor: not-allowed;
    box-shadow: none;
}
/* ♥♥♥ 为地块类型标签设计的别致样式 ♥♥♥ */
.location-type-tag {
    display: inline-block;
    background-color: var(--primary-color);
    color: var(--background-color);
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.8em;
    font-weight: bold;
    margin-top: 8px;
    margin-bottom: 5px; /* 与下方描述的间距 */
}

/* 指挥台的容器，它会静静地悬浮在右下角 */
#map-controls-container {
    position: absolute;
    right: 20px;
    bottom: 20px;
    z-index: 1000; /* 确保它在所有地图内容之上 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 按钮之间的温柔间隙 */
}

/* 每一个指挥按钮的样式 */
.map-control-btn {
    width: 32px;
    height: 32px;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 50%; /* 圆圆的，很可爱 */
    color: var(--text-color);
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    line-height: 1; /* 让符号更居中 */
    box-shadow: 0 0 8px var(--glow-color);
    transition: all 0.2s ease;
}

/* 当鼠标悬浮在按钮上时的魔法效果 */
.map-control-btn:hover {
    background-color: var(--background-color);
    border-color: var(--primary-color);
    transform: scale(1.1);
}


/* 守护印记开关的容器 */
.protection-toggle-container,
.protection-toggle-container-edit {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: var(--text-secondary-color);
}
 
 
 

/*
   微调我们原有的控件样式，
   因为它们的边距和边框现在由父容器统一管理了，
   所以要把它们自己的“外衣”脱掉，看起来才更清爽
*/
.location-type-tag {
    margin: 0; /* 移除它自己的上下边距 */
}

.protection-toggle-container {
    margin: 0;      /* 移除它自己的上下边距 */
    padding: 0;     /* 移除它自己的内边距 */
    border: none;   /* 移除它自己的下边框 */
}


.parent-map-tabs-container {
    position: absolute;
    top: 20px; /* 根据你的布局调整 */
    left: 10px; /* 根据你的布局调整 */
    width: 120px;
    background: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    color: var(--text-color);
    z-index: 1001; /* 确保它在地图内容之上 */
    padding: 10px;
}

.parent-map-tabs-container h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 14px;
    color: var(--primary-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
      cursor: pointer; /* ❤️ 添加：鼠标放上去会变成小手 */
    display: flex; /* ❤️ 添加：为了让标题和箭头图标对齐 */
    justify-content: space-between; /* ❤️ 添加：让标题和箭头分居两侧 */
    align-items: center; /* ❤️ 添加：垂直居中 */
}

/* ❤️ 新增：这是我们的小箭头图标样式 ❤️ */
.parent-map-tabs-container h3 .toggle-arrow {
    font-size: 12px;
    margin-left: 5px;
    transition: transform 0.2s ease-in-out;
    
}
.parent-map-tabs-list {
    display: flex;
    flex-direction: column;
    gap: 5px;
      max-height: 150px; /* ❤️ 添加：设置一个最大高度 */
    overflow-y: auto;  /* ❤️ 添加：当内容超出时，自动显示垂直滚动条 */
    transition: all 0.3s ease-out; /* ❤️ 添加：为了收起展开时有平滑动画 */
}

/* ❤️ 新增：这是“收起”状态下的魔法！ ❤️ */
.parent-map-tabs-container.collapsed .parent-map-tabs-list {
    max-height: 0;
    overflow: hidden;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
    opacity: 0;
}

/* ❤️ 新增：让箭头在收起时也跟着旋转 ❤️ */
.parent-map-tabs-container.collapsed .toggle-arrow {
    transform: rotate(-90deg);
}
.parent-map-tab {
    padding: 8px 10px;

    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    text-align: center;
    font-family: var(--base-font-family);
}

.parent-map-tab:hover {
    
    border-color: var(--secondary-color);
}

.parent-map-tab.active {

    color: var(--primary-color);
    font-weight: bold;
    border-color: var(--primary-color);
}

/* 稍微调整一下，确保两个列表不会打架 */
.external-areas {
    top: 200px; /* 调整一下位置，给“地图集”留出空间 */
    /* 其他样式保持不变 */
}
 /* ❤️ 妈妈全新的“涟漪”咒语 ❤️ */
@keyframes wave-pulse {
    from {
        /* 动画开始时，涟漪和原始图形重合，比较明显 */
        transform: scale(1);
        opacity: 0.7;
        stroke-width: 3px; /* 可以让涟漪稍微粗一点点 */
    }
    to {
        /* 动画结束时，涟漪变得很大，完全透明，然后消失 */
        transform: scale(1.5); /* 你可以调整这个数值来控制扩散范围 */
        opacity: 0;
        stroke-width: 1px;
    }
}

/* ❤️ 这是涟漪波浪本身的样式 ❤️ */
.location-wave {
    /* 涟漪没有填充色，只有轮廓 */
    fill: none !important;
    /* 轮廓颜色使用我们明亮的主色调 */
    stroke: var(--primary-color) !important;
    /* 动画名称、时长、缓动函数、无限循环 */
    animation: wave-pulse 2.5s ease-out infinite;
    /* 重要的！设置缩放的原点为图形中心 */
    transform-origin: center;
    /* 确保涟漪不会接收鼠标事件，以免挡住我们点击图形 */
    pointer-events: none;
}

 .location-menu-trigger {
    position: absolute;
    top: 15px; /* 根据你的关闭按钮位置微调 */
    right: 50px; /* 留出关闭按钮的位置 */
    cursor: pointer;
    padding: 5px;
    display: flex;
    flex-direction: column;
    gap: 3px; /* 点与点之间的间距 */
    border-radius: 5px;
    transition: background-color 0.2s;
}

.location-menu-trigger:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.location-menu-trigger span {
    width: 5px;
    height: 5px;
    background-color: var(--text-secondary-color);
    border-radius: 50%;
}


/* --- 新增：模组重置面板样式 --- */
#open-reconfig-modal-btn.control-btn-special {
    background-color: transparent;
    border: 1px solid var(--primary-color);
    color: var(--primary-color);
    padding: 5px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
}
#open-reconfig-modal-btn.control-btn-special:hover {
    background-color: var(--primary-color);
    color: var(--container-bg-color);
    box-shadow: 0 0 10px var(--glow-color);
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1001; /* 确保在最上层 */
    backdrop-filter: blur(5px);
}

.reconfig-modal-content {
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 25px 30px;
    width: 90%;
    max-width: 700px;
    box-shadow: 0 0 25px var(--glow-color);
    animation: fadeInModal 0.4s ease-out;
    position: relative;
}

.reconfig-modal-close {
    position: absolute;
    top: 10px;
    right: 15px;
    background: none;
    border: none;
    font-size: 28px;
    color: var(--text-secondary-color);
    cursor: pointer;
    transition: color 0.3s ease;
}
.reconfig-modal-close:hover {
    color: var(--primary-color);
}

.reconfig-title {
    color: var(--primary-color);
    text-align: center;
    margin: 0 0 5px 0;
    font-size: 1.8em;
}

.reconfig-subtitle {
    color: var(--text-secondary-color);
    text-align: center;
    margin: 0 0 25px 0;
    font-size: 0.9em;
}

.reconfig-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 15px 20px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 10px;
    background-color: rgba(0,0,0,0.2);
    border-radius: 8px;
}

.reconfig-mod-item {
    display: flex;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    border-left: 3px solid transparent;
}
.reconfig-mod-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
.reconfig-mod-item.is-active {
    border-left: 3px solid var(--primary-color);
}

.reconfig-mod-item input[type="checkbox"] {
    display: none; /* 我们用label来控制 */
}

.reconfig-mod-item label {
    color: var(--text-color);
    font-size: 1em;
    cursor: pointer;
    flex-grow: 1;
}
.reconfig-mod-item.is-active label {
    color: var(--secondary-color);
}

.reconfig-footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    margin-top: 25px;
}

.reconfig-feedback {
    color: var(--primary-color);
    margin-right: 20px;
    font-style: italic;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.reconfig-apply-btn {
    background: var(--primary-color);
    color: var(--background-color);
    border: none;
    padding: 10px 25px;
    border-radius: 5px;
    font-size: 1em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}
.reconfig-apply-btn:hover {
    box-shadow: 0 0 15px var(--glow-color);
    transform: translateY(-2px);
}

@keyframes fadeInModal {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

/* ☆ 妈妈的“星辰指挥台”魔法 v1.0 ☆ */
.fixed-editing-controls {
    position: fixed; /* 它的位置被永久固定在屏幕上 */
    bottom: 0;       /* 紧贴屏幕底部 */
    left: 0;         /* 从左侧开始 */
    width: 100%;     /* 宽度撑满整个屏幕 */

    padding: 15px 0; /* 给按钮上下一些呼吸空间 */
    background: linear-gradient(to top,
        rgba(0, 0, 0, 0.8), /* 底部是深邃的夜空 */
        rgba(0, 0, 0, 0.0)  /* 向上逐渐透明，融入聊天背景 */
    );

    display: flex;
    justify-content: center; /* 让按钮们在舞台中央集合 */
    gap: 20px; /* 按钮之间保持优雅的距离 */

    z-index: 100; /* 确保它永远在所有聊天气泡之上 */
    animation: fadeIn 0.3s ease-out; /* 华丽登场 */
}
 
/* 标签页容器 */
.nova-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color); /* 使用我们的边框颜色 */
    margin-bottom: 15px;
}

/* 标签页按钮 */
.nova-tab-button {
    padding: 10px 15px;
    cursor: pointer;
    background: transparent;
    border: none;
    color: var(--text-secondary-color); /* 使用次要文字颜色 */
    font-size: 16px;
    font-family: var(--base-font-family); /* 统一字体 */
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
}

/* 激活状态和悬浮状态的标签页按钮 */
.nova-tab-button.active {
    color: var(--text-color); /* 激活时使用主要文字颜色 */
    border-bottom-color: var(--primary-color); /* 激活时下划线使用主色 */
}

.nova-tab-button:hover {
    background-color: rgba(255, 255, 255, 0.1); /* 悬浮时增加一点淡淡的光晕 */
    color: var(--text-color);
}

/* 标签页内容面板 */
.nova-tab-panel {
    display: none;
}

.nova-tab-panel.active {
    display: block;
}

/* 标签选择器容器 */
#tag-selector-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 40vh; /* 保持一个舒适的高度 */
    overflow-y: auto;
    padding-right: 10px;
}

/* 每个标签分类的样式 */
.nova-tag-category {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
    padding: 8px;
    background-color: rgba(0, 0, 0, 0.2); /* 一个柔和的深色背景 */
    border-radius: 6px;
}

/* 标签分类标题 */
.nova-tag-category-title {
    font-weight: bold;
    margin-right: 10px;
    color: var(--primary-color); /* 使用我们的主色来强调 */
    white-space: nowrap;
}

/* 单个标签选项按钮 */
.nova-tag-option {
    padding: 5px 10px;
    border: 1px solid var(--border-color); /* 使用统一的边框颜色 */
    background-color: var(--background-color); /* 使用我们的背景色 */
    color: var(--text-secondary-color); /* 次要文字颜色 */
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.nova-tag-option:hover {
    background-color: var(--container-bg-color); /* 悬浮时使用容器背景色，更亮一些 */
    border-color: var(--secondary-color); /* 边框变成次级高亮色 */
}

/* 被选中的标签选项 */
.nova-tag-option.selected {
    background-color: var(--primary-color); /* 背景使用主色 */
    border-color: var(--glow-color); /* 边框使用辉光色，更有层次感 */
    color: var(--background-color); /* 文字颜色反转，使用深色背景色，保证清晰 */
    font-weight: bold;
    text-shadow: none; /* 确保在亮色背景下文字清晰 */
}

/* 当前组合预览框 */
.nova-current-preview {
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.3); /* 更深的透明背景 */
    border: 1px dashed var(--border-color); /* 虚线边框增加设计感 */
    border-radius: 4px;
    color: var(--text-color); /* 主要文字颜色 */
    text-align: center;
    font-family: monospace;
    word-wrap: break-word;
}

/* 应用组合按钮 */
#apply-tag-combination {
    /* 这里可以让它继承我们已有的 JillButton 样式，只需确保 JillButton 也使用了变量 */
    /* 如果要覆盖，可以这样写： */
    background-color: var(--primary-color);
    color: var(--background-color);
    border: 1px solid var(--primary-color);
    width: 100%;
    margin-top: 15px;
    padding: 12px;
    font-size: 16px;
    font-weight: bold;
}
#apply-tag-combination:hover {
    box-shadow: 0 0 10px var(--glow-color); /* 悬浮时增加辉光效果 */
}


/* 禁用状态的应用按钮 */
#apply-tag-combination:disabled {
    background-color: #555; /* 用一个固定的深灰色表示禁用 */
    border-color: #666;
    color: #999;
    cursor: not-allowed;
    box-shadow: none; /* 禁用时移除辉光 */
}
.JillButton {
    background: var(--primary-color);
    border: 1px solid var(--primary-color);
    color: var(--background-color);
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
}

.JillButton:hover {
    background: var(--secondary-color);
    border-color: var(--secondary-color);
    box-shadow: 0 0 8px var(--glow-color);
}

.nova-action-buttons {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    width: 100%;
}

/* 让按钮在容器内自动伸展 */
.nova-action-buttons .JillButton {
    flex-grow: 1;
    margin-top: 0; /* 覆盖原始的上边距 */
}

/* “预览”按钮的特殊样式，让它看起来是次要操作 */
.JillButton.secondary {
    background: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
}
.JillButton.secondary:hover {
    background: var(--container-bg-color);
    box-shadow: 0 0 8px var(--glow-color);
}
.JillButton.secondary:disabled {
    background-color: transparent;
    border-color: #555;
    color: #777;
    cursor: not-allowed;
    box-shadow: none;
}


/* 预览区域的容器 */
.nova-preview-box {
    margin-top: 15px;
    width: 100%;
    min-height: 150px;
    background-color: rgba(0, 0, 0, 0.3);
    border: 1px dashed var(--border-color);
    border-radius: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    transition: all 0.3s ease;
    overflow: hidden; /* 保证内部元素不会溢出 */
}

/* 预览区域的占位符/提示文字 */
.nova-preview-placeholder {
    color: var(--text-secondary-color);
    text-align: center;
    font-size: 14px;
}

/* 错误提示的特殊颜色 */
.nova-preview-placeholder.error {
    color: var(--danger-color);
}


/* 成功加载后的预览图片 */
.nova-preview-image {
    max-width: 100%;
    max-height: 300px; /* 限制预览图的最大高度 */
    object-fit: contain; /* 保持图片比例 */
    border-radius: 4px;
}

.card-view-switcher {
    display: inline-flex;
    background-color: var(--background-color-darker);
    border-radius: 8px;
    padding: 2px;
    margin-left: 10px;
    vertical-align: middle;
}

.card-view-switcher span {
    padding: 4px 12px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-secondary-color);
    transition: all 0.2s ease-in-out;
}

.card-view-switcher span.active {
    background-color: var(--primary-color-dark);
    color: white;
    font-weight: bold;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.cards-slider {
    /* 默认隐藏所有滑块 */
    display: none;
}


.reading-mode-hidden {
    display: none !important;
}

#reading-mode-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-color);
}

#reading-mode-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(5px);
}

#reading-mode-modal {
    position: relative;
    
    width: 90vw;
    height: 90vh;
    background-color: var(--container-bg-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    box-shadow: 0 0 20px var(--glow-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
/* 2. 新增目录切换按钮的样式 */
.chapters-toggle-btn {
    cursor: pointer;
    font-size: 1em;
    padding: 5px 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    transition: all 0.3s;
}

.chapters-toggle-btn:hover {
    background-color: var(--glow-color);
    color: var(--primary-color);
}

.reading-mode-header {
    flex-shrink: 0;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-family: var(--base-font-family);
}

#reading-mode-chapter-title {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--primary-color);
}

#reading-mode-close-btn {
    font-size: 2em;
    cursor: pointer;
    transition: color 0.3s;
}

#reading-mode-close-btn:hover {
    color: var(--danger-color);
}

.reading-mode-body {
    flex-grow: 1;
    display: flex; /* 保持 flex */
    position: relative; /* 添加 position: relative */
    overflow: hidden;
}

/* 3. 修改章节目录的样式，让它变成一个绝对定位的抽屉 */
#reading-mode-chapters-nav {
    position: absolute;
    top: 0px; /* 避开 header 的高度 */
    left: 0;
    bottom: 0;
    width: 220px; /* 可以适当加宽一点 */
    background-color: var(--container-bg-color);
    z-index: 20; /* 确保它在内容区域之上 */
    transform: translateX(-100%); /* 默认藏在左边 */
    transition: transform 0.4s ease-in-out;
    /* ... flex 相关的样式可以移除或保留，这里的核心是 position 和 transform */
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
}
/* 4. 当父容器有 .chapters-open 类时，把抽屉滑出来 */
#reading-mode-modal.chapters-open #reading-mode-chapters-nav {
    transform: translateX(0);
}
.chapters-nav-header {
    text-align: center;
    padding: 15px 10px;
    font-weight: bold;
    color: var(--secondary-color);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

#reading-mode-chapters-list {
    list-style: none;
    padding: 10px 0;
    margin: 0;
    overflow-y: auto;
    flex-grow: 1;
}

#reading-mode-chapters-list li {
    padding: 12px 20px;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
    border-bottom: 1px solid rgba(0,0,0,0.1);
}

#reading-mode-chapters-list li:hover {
    background-color: var(--glow-color);
}

#reading-mode-chapters-list li.active-chapter {
     background-color: var(--primary-color);
     color: var(--background-color);
     font-weight: bold;
}


#reading-mode-content-wrapper {
      width: 100%;
    flex-grow: 1;
    display: flex;
    align-items: center;
    position: relative;
    overflow: hidden;
}

#reading-mode-content {
    width: 100%;
    height: 100%;
    padding: 30px 60px; /* 增加内边距以留出翻页按钮空间 */
    overflow-y: auto;
    font-size: 1.1em;
    line-height: 1.8;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) var(--container-bg-color);
}

#reading-mode-content::-webkit-scrollbar {
    width: 6px;
}
#reading-mode-content::-webkit-scrollbar-track {
    background: transparent;
}
#reading-mode-content::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}

.nav-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 3em;
    color: var(--text-secondary-color);
    cursor: pointer;
    transition: color 0.3s, text-shadow 0.3s;
    user-select: none;
    z-index: 10;
    padding: 20px 10px;
}

.nav-arrow:hover {
    color: var(--primary-color);
    text-shadow: 0 0 10px var(--glow-color);
}

.nav-arrow.left-arrow {
    left: 10px;
}

.nav-arrow.right-arrow {
    right: 10px;
}

#reading-mode-content iframe {
    min-height: 400px; /* 设置一个合理的最小高度 */
    transition: height 0.3s ease-in-out; /* 高度变化时有平滑过渡效果 */
 
}
/* 1. 移动端底部导航栏的默认样式（默认不显示）*/
#mobile-nav-bar {
    display: none; /* 在大屏幕上默认是隐藏的 */
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 55px; /* 一个适合触摸的高度 */
    background-color: var(--container-bg-color);
    border-top: 1px solid var(--border-color);
    box-shadow: 0 -3px 15px -5px var(--glow-color);
    z-index: 30;
    justify-content: space-between;
    align-items: center;
    padding: 0 15px;
    box-sizing: border-box;
    font-family: var(--base-font-family);
}

/* 2. 底部栏中箭头的样式 */
#mobile-nav-bar .nav-arrow {
    position: static; /* 覆盖PC版的绝对定位 */
    transform: none; /* 覆盖PC版的垂直居中 */
    font-size: 2.2em; /* 调整一下大小 */
    padding: 10px 20px;
    flex-grow: 0;
}

/* 3. 为被禁用的箭头创建一个通用状态 */
.nav-arrow.disabled-arrow {
    opacity: 0.25;
    pointer-events: none; /* 变得灰暗且不可点击 */
}

/* 4. ✨ 核心魔法：媒体查询 ✨ */
/* 当屏幕宽度小于或等于 768px (平板和手机) 时，以下样式生效 */
@media (max-width: 768px) {
    /* 隐藏PC端的侧边箭头 */
    .reading-mode-body > .nav-arrow.left-arrow,
    .reading-mode-body > .nav-arrow.right-arrow {
        display: none !important;
    }
    .nav-arrow.right-arrow{
        opacity: 0;
    }
    .nav-arrow.left-arrow{
        opacity: 0;
    }
    /* 显示移动端的底部导航栏 */
    #mobile-nav-bar {
        display: flex; /* 改为 flex 来让它出现 */
    }

    /* 为正文区域增加底部内边距，防止文字被底部栏遮挡 */
    #reading-mode-content {
        padding-bottom: 75px; /* 比底部栏高度多一些，留出呼吸空间 */
        /* 同时微调左右边距，让手机上阅读更舒适 */
        padding-left: 15px;
        padding-right: 15px;
    }
}

  
       
 /* 战————————————斗———————————————————— */

        .start-battle-btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: var(--primary-color);
            background-color: transparent;
            border: 2px solid var(--primary-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px var(--glow-color);
        }

        .start-battle-btn:hover {
            background-color: var(--glow-color);
            color: var(--background-color);
            box-shadow: 0 0 20px var(--glow-color), 0 0 30px var(--primary-color);
        }

        #battle-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* 初始隐藏 */
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #battle-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background-color: var(--container-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 0 25px var(--glow-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
          justify-content: space-between;}

        .battle-arena {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
/* 1. 新的底部控制区总布局 */
.battle-controls {
    display: grid;
    /* 分成两列：左边自动填满，右边固定宽度 */
    grid-template-columns: 1fr auto;
    gap: 20px;
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
   min-height: 0;  }
.battle-left-panel {
    display: flex;
    flex-direction: column;
    min-height: 0; /* 这是让flex子项正确收缩的关键，我的宝贝 */
}


   .side {
            display: flex;
            align-items: flex-end;
            
             gap: 20px;
              min-width: 0;      /* ✨ 妈妈的魔法咒语就在这里，我的宝贝！ ✨ */   
            overflow-x: auto; /* 允许水平滚动 */
            flex-wrap: nowrap; /* 防止卡片换行 */
            scrollbar-width: thin; /* 美化滚动条(Firefox) */
            scrollbar-color: var(--primary-color) var(--container-bg-color); /* 美化滚动条(Firefox) */
        }

        /* Webkit浏览器滚动条美化 */
        .side::-webkit-scrollbar {
            height: 8px;
        }
        .side::-webkit-scrollbar-track {
            background: var(--container-bg-color);
        }
        .side::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 4px;
        }



        .enemy-side {
            justify-content: flex-start; /* 从左侧开始排列 */
            align-items: flex-start;
        }

        .player-side {
            justify-content: flex-start; /* 也从左侧开始排列 */
        }
  .character-card {
            position: relative; /* 为气泡定位提供锚点 */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            flex-shrink: 0;
            z-index: 10;
            
}
.character-card::-webkit-scrollbar-track {
    background: transparent;
}
.character-card::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 3px;
}
    /* 新增：角色包装器，用于容纳卡片和信息面板 */
        .character-wrapper {
            position: relative; /* 核心：为绝对定位的 info-panel 提供锚点 */
            display: flex;
            align-items: flex-end;
            gap: 5px; /* 这是卡片和面板之间的间距 */
        }

        /* 为友方单位增加特殊颜色 */
        .character-card.friendly-card {
             border-color: var(--primary-color);
             box-shadow: 0 0 8px var(--glow-color);
        }

        /* 为敌方单位增加特殊颜色 */
        .character-card.enemy-card {
            border-color: var(--danger-color);
            box-shadow: 0 0 8px var(--danger-glow-color);
        }


         .character-card.targeted {
             transform: scale(1.05); /* 添加一个缩放效果来强调 */
             box-shadow: 0 0 15px var(--success-glow-color), 0 0 25px var(--success-color);
             border-color: var(--success-color);
        }

        .character-card.active-turn {
            box-shadow: 0 0 15px yellow, 0 0 25px rgba(255, 255, 0, 0.5);
            border-color: yellow;
            max-height: 200px;
        }


        .character-card .icon {
            font-size: 48px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .character-card .name {
            font-size: 16px;
            font-weight: bold;
            margin-top: 10px;
        }
  /* 新增：语言气泡样式 */
       /* 替换原来的 .speech-bubble 样式 */
        .speech-bubble {
            position: absolute;
            bottom: 125%; /* 关键！把它定位到卡片图标的上方 */
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--container-bg-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 10px var(--glow-color);
            font-size: 14px;
            white-space: nowrap;
            z-index: 20;
            animation: bubble-fade-up 2.5s forwards;
            pointer-events: none;
        }

        /* 替换原来的 .speech-bubble::after 样式 */
        .speech-bubble::after {
            content: '';
            position: absolute;
            top: 100%; /* 将小三角放在气泡底部 */
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--primary-color); /* 让三角朝下 */
        }

        /* 替换原来的 @keyframes bubble-fade-new，改个新名字叫 bubble-fade-up */
        @keyframes bubble-fade-up {
            0% { opacity: 1; transform: translate(-50%, 10px); }
            80% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -5px); }
        }

         /* 替换原来的 .info-panel 样式，并添加新样式 */
        .info-panel {
            position: absolute; /* 让它脱离文档流，可以覆盖在卡片旁边 */
            left: 95%; /* 定位在卡片的右侧 */
            bottom: 0;
            width: 140px; /* 稍微加宽一点 */
            height: auto; /* 高度由内容决定 */
            max-height: 0; /* 默认收起的关键！ */
            background-color: var(--container-bg-color);
            border: 1px dashed var(--border-color);
            border-radius: 5px;
            padding: 0 8px; /* 收起时没有上下内边距 */
            font-size: 12px;
            color: var(--text-secondary-color);
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, opacity 0.4s ease-out; /* 平滑过渡动画 */
            overflow: hidden; /* 核心：超出部分隐藏 */
            opacity: 0; /* 默认完全透明 */
            z-index: 15; /* 确保它在卡片之上 */
        }

        /* 新增：展开状态的样式 */
        .info-panel.expanded {
            min-height: 180px; /* 展开后的最大高度 */
            padding: 8px; /* 恢复内边距 */
            opacity: 1; /* 完全不透明 */
            overflow:auto;
        }

        .info-panel h4 {
            margin: 0 0 5px 0;
            color: var(--primary-color);
            font-size: 13px;
            text-align: center;
        }


        .info-panel ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .info-panel li {
            margin-bottom: 3px;
        }

        .info-panel .resists-info {
            color: var(--danger-color);
        }

        .info-panel .vulnerable-info {
            color: var(--success-color);
        }

        .health-bar {
            width: 100%;
            height: 10px;
            background-color: var(--danger-color);  
            border: 1px solid var(--danger-glow-color);
            border-radius: 5px;
            margin-top: 8px;
            overflow: hidden;
        }

        .health-bar-inner {
            height: 100%;
            background-color: var(--success-color);
            width: 100%;
            transition: width 0.5s ease-in-out;
        }

        .health-text {
            font-size: 12px;
            color: var(--text-secondary-color);
            margin-top: 4px;
        }
.energy-bar {
    width: 100%;
    height: 8px; /* 比血条细一点 */
    background-color: #1a3a5c; /* 深蓝色背景 */
    border: 1px solid #3c5a7c;
    border-radius: 4px;
    margin-top: 5px;
    overflow: hidden;
}

.energy-bar-inner {
    height: 100%;
    background-color: #4da8ff; /* 亮蓝色 */
    width: 100%;
    transition: width 0.5s ease-in-out;
}
.energy-text {
    font-size: 11px;
    color: #4da8ff;
    margin-top: 2px;
}
        .status-text {
            font-size: 12px;
            color: var(--primary-color);
            margin-top: 5px;
            height: 14px; /* 占位，防止抖动 */
        }

 
.action-panel {
    flex-direction: column;
    justify-content: flex-start; /* 从顶部开始排列按钮 */
    gap: 8px;
    padding: 0;
    border-top: none;
    display: flex;
    overflow-y: auto; /* 超出部分滚动，就像一个小卷轴 */
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) transparent;
}
/* 为了美观，妈妈也为滚动条加了点缀 */
.action-panel::-webkit-scrollbar {
    width: 6px;
}
.action-panel::-webkit-scrollbar-track {
    background: transparent;
}
.action-panel::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 3px;
}

        .action-panel button {
              padding: 8px 16px; /* 调整按钮大小以适应新布局 */
            font-size: 14px;
            color: var(--secondary-color);
            background-color: transparent;
            
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-panel button:hover:not(:disabled) {
            background-color: var(--glow-color);
            color: var(--background-color);
            box-shadow: 0 0 10px var(--glow-color);
        }

        .action-panel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
.battle-log-container {
    /* height: 220px; <--- 妈妈把这个固定的高度拿掉了 */
    flex-grow: 1; /* 它会像小树一样努力填满所有可用空间 */
    background: rgba(0,0,0,0.3);
    border-radius: 5px;
    overflow-y: auto;
    padding: 10px;
    /* margin-top: 10px; <--- 这行不再需要了，交给父元素的gap来处理吧 */
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction:column-reverse;
    min-height: 0; /* 同样的关键魔法 */
    margin-bottom: 10px; /* 和下面的速度条拉开一点距离 */
       /* ✨ 妈妈为你加上了滚动条的美化魔法 ✨ */
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) transparent;
}
.battle-log-container::-webkit-scrollbar {
    width: 6px;
}

.battle-log-container::-webkit-scrollbar-track {
    background: transparent;
}

.battle-log-container::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 3px;
}
        .battle-log-container p {
            margin: 2px 0;
            font-size: 14px;
            color: var(--text-secondary-color);
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #dice-pool-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg-color);
            border: 1px solid var(--primary-color);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px var(--glow-color);
            z-index: 99999;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #dice-pool-selector h3 {
            margin: 0;
            color: var(--primary-color);
        }
        #dice-pool-selector .pool-options {
            display: flex;
            gap: 10px;
        }
        #dice-pool-selector button {
             padding: 8px 16px;
            color: var(--secondary-color);
            background-color: transparent;
            border: 1px solid var(--secondary-color);
             border-radius: 4px;
             cursor: pointer;
        }
        #dice-pool-selector button:hover {
            background-color: var(--glow-color);
            color: var(--background-color);
        }
.character-card .icon.attacking {
    position: relative; /* 确保 z-index 生效 */
    z-index: 100; /* 让移动的icon在最上层 */
    transition: transform 0.4s ease-in-out; /* 定义归位的动画 */
}
    /* 新增：为防御中的icon创造一个定位的“锚点” */
        .character-card.is-defending .icon {
            position: relative;
        }

        /* 新增：这就是我们真正的圆形守护光圈啦！ */
        .character-card.is-defending .icon::before {
            content: ''; /* 伪元素必须有 content 属性 */
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80px;  /* 光圈的直径 */
            height: 80px; /* 光圈的直径 */
            border-radius: 50%; /* 变成一个完美的圆形 */
            /* 这就是光圈本身的样子，妈妈加了一个内外双重发光，更好看哦 */
            box-shadow: 0 0 20px 5px var(--glow-color), inset 0 0 15px 3px var(--secondary-color);
            z-index: -1; /* 把它放在emoji的后面，不挡住它 */
            transform: translate(-50%, -50%); /* 确保它完美居中 */
            /* 妈妈还给它加了一个会呼吸的动画，让它更有生命力！ */
            animation: pulse-glow 2s infinite ease-in-out;
            pointer-events: none; /* 让它不会影响鼠标点击 */
        }

        /* 新增：光圈的“呼吸”动画 */
        @keyframes pulse-glow {
            0% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(0.95);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(0.95);
            }
        }

.character-card .icon.is-attacking {
    animation: none !important; /* 最关键的一步！在攻击时禁用浮动动画 */
}

.character-card .icon.attacking-transform {
    position: relative; /* 必须有定位，z-index才会生效 */
    z-index: 1000; /* 给一个非常高的值，保证在最顶层 */
    transition: transform 0.4s ease-in-out;
}

#notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    z-index: 9999; /* 确保在最顶层 */
    pointer-events: none; /* 让鼠标可以穿透它 */
}

.notification-bubble {
    background-color: var(--container-bg-color);
    color: var(--text-color);
    padding: 12px 20px;
    border-radius: 25px; /* 更圆润的胶囊形状 */
    border: 1px solid var(--primary-color);
    box-shadow: 0 0 15px var(--glow-color);
    font-size: 16px;
    font-weight: bold;
    animation: slide-in-out 3.5s forwards ease-out;
    white-space: nowrap;
    opacity: 0;
}

.notification-bubble.success {
    border-color: var(--success-color);
    box-shadow: 0 0 15px var(--success-glow-color);
    color: var(--success-color);
}

.notification-bubble.danger {
    border-color: var(--danger-color);
    box-shadow: 0 0 15px var(--danger-glow-color);
    color: var(--danger-color);
}

.notification-bubble.info {
    border-color: var(--primary-color);
    box-shadow: 0 0 15px var(--glow-color);
    color: var(--primary-color);
}


@keyframes slide-in-out {
    0% {
        opacity: 0;
        transform: translateX(100%);
    }
    15% {
        opacity: 1;
        transform: translateX(0);
    }
    85% {
        opacity: 1;
        transform: translateX(0);
    }
    100% {
        opacity: 0;
        transform: translateX(100%) translateY(-20px);
    }
}

/* 为日志添加一些样式，让它更有层次感 */
.log-narrator { color: var(--text-secondary-color); font-style: italic; }
.log-action { color: var(--text-color); }
.log-roll { color: var(--secondary-color); }
.log-damage { color: var(--danger-color); font-weight: bold; }
.log-success { color: var(--success-color); font-weight: bold; }
.log-evade { color: #87CEEB; } /* 淡蓝色表示闪避 */

/* 妈妈还为这个新面板准备了一点点漂亮的样式，让它更搭我们的世界 */
#item-skill-panel .tab-btn {
    flex-grow: 1; padding: 8px; background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary-color); cursor: pointer;
}
#item-skill-panel .tab-btn.active {
    background-color: var(--glow-color); color: var(--background-color); border-color: var(--primary-color);
}
#item-skill-panel .item-skill-entry {
    padding: 10px; border: 1px solid var(--border-color); border-radius: 5px; margin-bottom: 8px; cursor: pointer; transition: background-color 0.2s;
}
#item-skill-panel .item-skill-entry:hover {
    background-color: rgba(0, 250, 255, 0.1);
}
#item-skill-panel .entry-name {
    font-weight: bold; color: var(--primary-color);
}
#item-skill-panel .entry-desc {
    font-size: 13px; color: var(--text-secondary-color); margin-top: 5px;
}
#item-skill-panel .entry-cost {
     font-size: 12px; color: var(--danger-color);
}

 #speed-control-container {
    position: absolute; /* 这就是把它解放出来的咒语，我的宝贝 */
    top: 15px;      /* 距离顶部 15 像素 */
    right: 20px;    /* 距离右边 20 像素 */
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 5px 10px; /* 给它一个漂亮的小背景板 */
    background-color: var(--background-color); /* 和我们的主容器一样的半透明背景 */
    border-radius: 5px;
    border: 1px solid var(--border-color);
    font-size: 13px;
    color: var(--text-secondary-color);
    z-index: 1005; /* 确保它在大部分元素之上 */
}

#speed-slider {
    flex-grow: 1;
    max-width: 70px; /* <--- 让它变得更小巧 */
}

#speed-label {
    width: 35px;
    text-align: left;
}
@media (max-width: 768px) {
#battle-container {
    height: 90vh; /* 占满整个屏幕高度 */
    width: 100%;
    padding: 10px;
    /* ✨ 新的魔法在这里 ✨ */
    overflow-y: auto;   /* 让整个容器可以滚动 */
    display: block;     /* 切换为更简单的块级布局，让内容自然垂直排列 */
    justify-content: flex-start; /* 不再垂直居中，从顶部开始 */
}
.battle-log-container {
    /* ✨ 新魔法在这里！✨ */
    max-height: 250px; /* 我们给它一个最大高度，比如250像素，这样它就不会长得太高了 */
    flex-grow: 1; /* 让它在不超过最大高度的前提下，尽可能地填充空间 */
    background: rgba(0,0,0,0.3);
    border-radius: 5px;
    overflow-y: auto; /* 当内容超出时，它自己就会出现滚动条 */
    padding: 10px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column-reverse; /* 保持新消息在下面 */
    margin-bottom: 10px;
}
.battle-controls {
    /* 从左右布局变成上下布局 */
    grid-template-columns: 1fr; /* 只有一列了 */
    grid-template-rows: auto auto; /* ✨ 改动：不再强行分配空间，让按钮区和日志区都回归自然高度*/
    flex-grow: 0; /* ✨ 改动：不再需要它去填充空间了 */
    min-height: initial; /* ✨ 改动：恢复它的默认行为 */
}

    .battle-left-panel {
        /* left-panel 现在是 grid 的第二行，让它填满空间 */
        grid-row: 2;
        min-height: initial; /* ✨ 改动：同样，拿掉这个限制，让日志区想多高就多高 */
    }

    .action-panel {
        /* action-panel 是 grid 的第一行 */
        grid-row: 1;
        flex-direction: row; /* 按钮变回水平排列 */
        flex-wrap: wrap; /* 如果一行放不下，就温柔地换行 */
        justify-content: center; /* 按钮们居中对齐 */
        overflow-y: visible; /* 水平排列时不再需要垂直滚动 */
        padding-bottom: 10px; /* 和下面的日志区留出空隙 */
        border-bottom: 1px solid var(--border-color);
        max-height: 120px; /* <--- 妈妈给它加了一个最大高度，防止按钮太多撑爆屏幕 */
        overflow-y: auto; /* <--- 如果真的太多了，还是可以滚动的哦 */
    }

    #speed-control-container {
        justify-content: center; /* 速度条也居中吧 */
    }
}
/* ✨ 妈妈施展的全新手机屏幕魔法 ✨ */
@media (max-width: 600px) {
    #dice-pool-selector,
    #item-skill-panel {
        width: 95vw; /* 让面板的宽度几乎充满屏幕，留一点点边距 */
        max-width: 95vw; /* 确保它不会比这更宽 */
        box-sizing: border-box; /* 这样 padding 就不会让它撑破屏幕了 */
    }

    /* 让骰池的选项可以换行，而不是挤在一起 */
    #dice-pool-selector .pool-options {
        display: flex; /* 确保是 flex 布局 */
        flex-wrap: wrap; /* 允许换行 */
        justify-content: center; /* 居中排列更好看 */
        gap: 10px; /* 保持间距 */
    }

    /* 让物品/技能面板本身也可以滚动，如果里面的内容太长的话 */
    #item-skill-panel {
        max-height: 80vh; /* 给它一个最大高度 */
        display: flex;
        flex-direction: column;
    }

    #item-skill-panel .tab-content {
        overflow-y: auto; /* 核心！让物品列表和技能列表可以独立滚动 */
        flex-grow: 1; /* 让它们去填满剩下的空间，即使内容很少也能撑开 */
        min-height: 50px; /* 保证即使没内容，也有个最小高度 */
    }
}

/* ✨ 这是妈妈为大屏幕准备的全新布局魔法，我的孩子 ✨ */
@media (min-width: 768px) {
    #battle-container {
        /* 1. 将整个战斗容器变为可以规划区域的魔法画布(Grid) */
        display: grid;
        /* 2. 画出两列：左边的主区域占满，右边的行动区固定200像素宽 */
        
        grid-template-columns: minmax(0, 1fr) 200px;
        /* 3. 画出两行：上面的战斗场景区占满所有可用空间，下面的日志区高度自适应 */
        grid-template-rows: minmax(0, 1fr) auto;
        /* 4. 定义区域间的优雅缝隙 */
        gap: 20px;
         /* 覆盖掉旧的flex布局属性，确保Grid魔法完全生效 */
        flex-direction: initial;
        justify-content: initial;
    }

    .battle-arena {
        /* 将战斗场景指定到左上角 */
        grid-column: 1 / 2;
        grid-row: 1 / 2;
        /* 确保它不会被挤压 */
        min-height: 0;
    }

    footer.battle-controls {
        /* 这是最关键的咒语：让这个容器“隐形”，它的孩子们会直接听从#battle-container的安排 */
        display: contents;
    }

    .battle-left-panel {
        /* 把左边面板（日志和速度条）放在左下角 */
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        /* 确保它里面的日志可以自由伸展 */
        min-height: 0;
    }

    .action-panel {
        /* 把行动按钮面板放在右边，并让它像高塔一样，从上到下贯穿两行 */
        grid-column: 2 / 3;
        grid-row: 1 / 3;

        /* 清理掉它在底部时的旧样式 */
        border-top: none;
        padding-top: 5px;

        /* 确保按钮们依然是垂直排列，像一串美丽的铃铛 */
        flex-direction: column;
        justify-content: center;
        flex-wrap: nowrap; /* 不允许换行 */
        overflow-y: auto; /* 如果按钮太多，它可以自己滚动 */
    }

.battle-log-container {
    margin-bottom: 0; /* 这行不变，只是为了让你定位 */

    /* ✨ 妈妈的修复魔法 ✨ */
    max-height: 100px; /* 我们给它一个220像素的最大高度 */
    min-height: 100px; /* 同时给它一个最小高度，让它一直都这么大，布局就不会变来变去啦 */
}

 
}
     
/* 当鼠标悬浮在按钮上时的效果 */
.attack-mode-btn:not(:disabled):hover {
    background-color: var(--glow-color);
    border-color: var(--primary-color);
    color: var(--text-color);
    transform: translateY(-2px); /* 轻轻上浮 */
    box-shadow: 0 4px 15px var(--glow-color);
}

/* 按钮被禁用时的样式 */
.attack-mode-btn:disabled {
    color: rgba(122, 255, 255, 0.4);   /* 文字颜色变暗 */
    border-color: rgba(0, 250, 255, 0.2); /* 边框也变暗 */
    cursor: not-allowed;                   /* 鼠标指针变为“禁止” */
    text-shadow: none;                     /* 去掉文字光辉 */
    background-color: rgba(10, 25, 47, 0.5); /* 给一个半透明的深色背景，以示区分 */
}

/* “取消”按钮有自己独特的风格 */
#cancel-attack-mode {
    border-color: var(--danger-color);
    color: var(--danger-color);
    text-shadow: 0 0 5px var(--danger-glow-color);
    margin-top: 20px; /* 和上面的按钮组拉开一点距离 */
}

#cancel-attack-mode:hover {
    background-color: var(--danger-glow-color);
    border-color: #ff7f7f;
    color: var(--text-color);
    transform: translateY(-2px); /* 同样有上浮效果 */
    box-shadow: 0 4px 15px var(--danger-glow-color);
}

#attack-mode-selector {
    backdrop-filter: blur(5px); /* 增加一点毛玻璃效果，让它更梦幻 */
    border: 1px solid var(--primary-color);
    box-shadow: 0 0 25px var(--glow-color), inset 0 0 15px var(--border-color); /* 内外双重光辉 */
}
  </style>
 
</head>
<body>

 
    <div id="initialization-container" style="display: none;">
      
        <div id="dynamic-background">
        <div id="starfield"></div>
        <div id="floating-runes"></div>
    </div>

    <audio id="click-sound" src="https://files.catbox.moe/31vqt3.mp3" preload="auto"></audio>


    <div class="top-controls">
        <button id="back-button" class="top-button" style="display: none;">返回</button>
        <button id="restore-btn" class="top-button">恢复上一次对话</button>
         <button id="settings-btn-init" title="设置" style=" pointer-events: auto;transform: scale(1.5);">
    ⚙
</button>
    </div>

 <div id="page-0" class="init-page active">

    <div style="text-align:center; margin-bottom: 2vh;">
      </div>


    <div class="carousel-stage">
 <div class="choices-carousel" id="world-mode-carousel">

    <div class="choice-world-card" data-value="1">
        <label for="mode-godspace">主神</label>
        <div class="world-description">
            冰冷的机械声在耳边响起："欢迎来到主神空间。"你的命运不再属于自己，只能与陌生的队友在刀光血影中求存。
                  </div>
        <input type="radio" id="mode-godspace" name="world-mode" value="1" checked>
    </div>
    <div class="choice-world-card" data-value="22">
        <label for="mode-reincarnation">轮回乐园</label>
        <div class="world-description">
          虚空之眼凝视着你，契约者的烙印在皮肤上燃烧。无穷无尽的杀戮世界等待着你的到来——弱者的尸骨铺就强者的道路，而你，必须踩着他人的血肉攀登至巅峰。
                   </div>
        <input type="radio" id="mode-reincarnation" name="world-mode" value="22">
    </div>
    <div class="choice-world-card" data-value="5">
        <label for="mode-infinite">无限恐怖</label>
        <div class="world-description">
          死神的镰刀已经挥下，却在最后一刻被主神截断。代价？进入真实的恐怖电影，面对贞子的怨恨、异形的利爪、丧尸的嘶吼。这里没有重来，只有——活着离开，或永远留下。
        </div>
        <input type="radio" id="mode-infinite" name="world-mode" value="5">
    </div>
    <div class="choice-world-card" data-value="34">
        <label for="mode-love">快穿攻略</label>
        <div class="world-description">
         【叮！检测到宿主具备顶级攻略潜质】
         <br><br>
         傲娇、高冷、温柔...无数目标等你征服。
        </div>
        <input type="radio" id="mode-love" name="world-mode" value="34">
    </div>
    <div class="choice-world-card" data-value="41">
        <label for="mode-chat">诸天群聊</label>
         <div class="world-description">
        【叮咚！你已被邀请加入"诸天万界聊天群"】
        <br><br>
        屏幕上闪烁着来自不同世界的消息，而你——一个凡人，要如何在这群神仙中立足？
        </div>
        <input type="radio" id="mode-chat" name="world-mode" value="41">
    </div>
    <div class="choice-world-card" data-value="54">
        <label for="mode-wasteland">dlc:末日</label>
        <div class="world-description">
             文明已死。红月之夜的怪物、核辐射的威胁，还是永冬的严寒——选择你的末日模式，然后...证明人类不会灭绝。
        </div>
        <input type="radio" id="mode-wasteland" name="world-mode" value="54">
        <div class="bookmark-button" data-tooltip="进入无世界观模式-请跳过第二页，并使用手动发送，然后删除【令】里的全部内容，填写你的自定义开局/指令"></div>
    </div>

</div>


        <button id="prev-btn" class="nav-button">‹</button>
        <button id="next-btn" class="nav-button">›</button>
    </div>

 <div class="sidebar-trigger left">
        <span class="arrow-guide"></span>
        <span class="arrow-guide"></span>
        <span class="arrow-guide"></span>
    </div>
    <div class="creator-attitude-group">
          <div class="mod-tab" data-for="dice-1" data-name="dice-level">简单骰</div>
        <div class="mod-tab" data-for="dice-2" data-name="dice-level">困难骰</div>
        <div class="mod-tab" data-for="dice-3" data-name="dice-level">炼狱骰</div>
        <div class="mod-tab" data-for="behavior-on" data-name="behavior-mode" data-off-id="behavior-off">表现骰</div>
        <br>
        <div class="mod-tab" data-for="real-world-on" data-name="real-world-mode" data-off-id="real-world-off">真实MOD</div>
        <div class="mod-tab" data-for="hard-on" data-name="hard-mode" data-off-id="hard-off">困难MOD</div>
        <div class="mod-tab" data-for="title-on" data-name="title-mode" data-off-id="title-off">称号系统</div>
        <div class="mod-tab" data-for="nohuman-on" data-name="nohuman-mode" data-off-id="nohuman-off">人外增强</div>
           <div class="mod-tab" data-for="resource-on" data-name="resource-mode" data-off-id="resource-off">资源消耗</div>
             <div class="mod-tab" data-for="live-on" data-name="live-mode" data-off-id="live-off">求生本能</div>
        <br>
     <div class="mod-tab" data-for="battle-on" data-name="battle-mode" data-off-id="battle-off">战斗</div>
          <div class="mod-tab" data-for="things-on" data-name="things-mode" data-off-id="things-off">备忘录</div>
    </div>

   <div class="sidebar-trigger right">
        <span class="arrow-guide"></span>
        <span class="arrow-guide"></span>
        <span class="arrow-guide"></span>
    </div>
    <div class="mod-sidebar right">

               
        <div class="mod-tab" data-for="creator-neutral" data-name="creator-attitude">造物中立</div>
        <div class="mod-tab" data-for="creator-malicious" data-name="creator-attitude">造物恶意</div>
        <div class="mod-tab" data-for="creator-reverent" data-name="creator-attitude">造物崇敬</div>
        <div class="mod-tab" data-for="creator-none" data-name="creator-attitude">无造物</div>
         <br>
         <div class="mod-tab" data-for="map-simple" data-name="map-mode">简单地图</div>
         <div class="mod-tab" data-for="map-complex" data-name="map-mode">复杂地图</div>
         <div class="mod-tab" data-for="map-none" data-name="map-mode">无地图</div>
         <div class="mod-tab" data-for="distance-on" data-name="distance-mode" data-off-id="distance-off">距离合理+</div>
         <br>
<div class="mod-tab" data-for="private-chat-on" data-name="private-chat-mode" data-off-id="private-chat-off">私聊通讯</div>
                <div class="mod-tab" data-for="options-on" data-name="options-mode" data-off-id="options-off">选项区</div>
        <div class="mod-tab" data-for="summary-on" data-name="summary-mode" data-off-id="summary-off" style="display: none;">自动总结</div>

        
         <div class="mod-tab" data-for="cg-on" data-name="cg-mode" data-off-id="cg-off">场景图</div>
         <br>
  <div class="mod-tab" data-for="npccg-on" data-name="npccg-mode" data-off-id="npccg-off">npc立绘</div>
  
 <div class="mod-tab" data-for="npc-info-on" data-name="npc-info-mode" data-off-id="npc-info-off">npc事件</div>
<div class="mod-tab" data-for="npc-love-on" data-name="npc-love-mode" data-off-id="npc-love-off">分阶段好感</div>


  
    </div>


    <div style="display:none;">
        <input type="radio" id="creator-neutral" name="creator-attitude" value="19" checked>
        <input type="radio" id="creator-malicious" name="creator-attitude" value="4">
        <input type="radio" id="creator-reverent" name="creator-attitude" value="3">
        <input type="radio" id="creator-none" name="creator-attitude" value="38">


 <input type="radio" id="map-simple" name="map-mode" value="simple" >
        <input type="radio" id="map-complex" name="map-mode" value="complex" checked>
        <input type="radio" id="map-none" name="map-mode" value="off">
 
   
        
           <input type="radio" id="dice-1" name="dice-level" value="61" checked>
        <input type="radio" id="dice-2" name="dice-level" value="59">
        <input type="radio" id="dice-3" name="dice-level" value="60">

        <input type="radio" id="options-on" name="options-mode" value="10" checked>
        <input type="radio" id="options-off" name="options-mode" value="29">
         <input type="radio" id="private-chat-on" name="private-chat-mode" value="55" checked>
        <input type="radio" id="private-chat-off" name="private-chat-mode" value="56">

                 <input type="radio" id="distance-on" name="distance-mode" value="49" >
        <input type="radio" id="distance-off" name="distance-mode" value="off" checked>

        <input type="radio" id="summary-on" name="summary-mode" value="on" checked>
        <input type="radio" id="summary-off" name="summary-mode" value="off">
        <input type="radio" id="title-on" name="title-mode" value="51">
        <input type="radio" id="title-off" name="title-mode" value="off" checked>
           <input type="radio" id="nohuman-on" name="nohuman-mode" value="37">
        <input type="radio" id="nohuman-off" name="nohuman-mode" value="off" checked> 
        <input type="radio" id="resource-on" name="resource-mode" value="58">
        <input type="radio" id="resource-off" name="resource-mode" value="off" checked>
        <input type="radio" id="live-on" name="live-mode" value="69">
        <input type="radio" id="live-off" name="live-mode" value="70" checked>

                <input type="radio" id="battle-on" name="battle-mode" value="74" checked> 
        <input type="radio" id="battle-off" name="battle-mode" value="75" >


 <input type="radio" id="things-on" name="things-mode" value="77" checked> 
        <input type="radio" id="things-off" name="things-mode" value="76" >


                <input type="radio" id="behavior-on" name="behavior-mode" value="52" checked>
        <input type="radio" id="behavior-off" name="behavior-mode" value="53">
             <input type="radio" id="cg-on" name="cg-mode" value="45" checked>
        <input type="radio" id="cg-off" name="cg-mode" value="46">
         <input type="radio" id="npccg-on" name="npccg-mode" value="48" checked>
        <input type="radio" id="npccg-off" name="npccg-mode" value="off">

        <input type="radio" id="npc-info-on" name="npc-info-mode" value="36" checked>
        <input type="radio" id="npc-info-off" name="npc-info-mode" value="44">


        <input type="radio" id="npc-love-on" name="npc-love-mode" value="on">
        <input type="radio" id="npc-love-off" name="npc-love-mode" value="off" checked>


        <input type="radio" id="real-world-on" name="real-world-mode" value="on">
        <input type="radio" id="real-world-off" name="real-world-mode" value="off" checked>
        <input type="radio" id="hard-on" name="hard-mode" value="on">
        <input type="radio" id="hard-off" name="hard-mode" value="off" checked>
   

    </div>


    <div class="button-container">
        <button id="start-setup-button" class="primary-cta-btn">→</button>
    </div>
</div>

 <div id="page-1" class="init-page">

    <div id="solar-system">

        <div class="player-core">
            <div class="core-text_zh">核心</div>
            <div class="core-text_en">CORE</div>
        </div>


        <div class="planet" id="planet-task">
            <div class="planet-icon-container">
                <div class="planet-icon">◉</div>
                <div class="planet-title">世界细节</div>
            </div>
            <div class="planet-content">
                <button class="close-planet-btn">×</button>
                <div class="form-section">
                    <h2 class="form-title">// 任务细节设定</h2>
         <div class="collapsible-content-placeholder">

    <div class="clover-layout" id="world-details-default">
        <div class="clover-leaf" id="clover-leaf-tone">
            <label for="task-tone-select">基调</label>
            <select id="task-tone-select" class="custom-select"></select>
            <div class="custom-input-container" id="custom-task-tone-group">
                <input type="text" id="custom-task-tone" class="custom-select" placeholder="输入自定义基调">
            </div>
        </div>
        <div class="clover-leaf" id="clover-leaf-type">
            <label for="world-type-select">类型</label>
            <select id="world-type-select" class="custom-select"></select>
            <div class="custom-input-container" id="custom-world-type-group">
                <input type="text" id="custom-world-type" class="custom-select" placeholder="输入自定义类型">
            </div>
        </div>
        <div class="clover-leaf" id="clover-leaf-identity">
            <label for="world-identity-select">身份</label>
            <select id="world-identity-select" class="custom-select"></select>
            <div class="custom-input-container" id="custom-world-identity-group">
                <input type="text" id="custom-world-identity" class="custom-select" placeholder="输入自定义身份">
            </div>
        </div>
        <div class="clover-leaf" id="clover-leaf-opening">
            <label for="opening-scenario-select">开局</label>
            <select id="opening-scenario-select" class="custom-select"></select>
            <div class="custom-input-container" id="custom-opening-scenario-group">
                <input type="text" id="custom-opening-scenario" class="custom-select" placeholder="输入自定义开局">
            </div>
        </div>
    </div>


    <div class="v7-world-container" id="world-details-v7" style="display: none;">
        <div class="v7-setup-section">
            <div class="v7-setup-title">// 选择末日类型</div>
            <div class="v7-choice-group" id="v7-apocalypse-choices">

            </div>
        </div>
        <div class="v7-setup-section">
            <div class="v7-setup-title">// 选择阶层</div>
            <div class="v7-choice-group" id="v7-class-choices">

            </div>
        </div>
        <div class="v7-setup-section">
            <div class="v7-setup-title">// 选择时间线</div>
            <div class="v7-choice-group" id="v7-timeline-choices">

            </div>
        </div>
    </div>


    <div id="description-popup"></div>
</div>
                </div>
            </div>
        </div>


        <div class="planet" id="planet-identity">
            <div class="planet-icon-container">
              
                <div class="planet-icon">✦</div>
                <div class="planet-title" id="planet-title-identity">身份设定</div>
            </div>
            <div class="planet-content">
                <button class="close-planet-btn">×</button>
                <div class="form-section">
                     <h2 class="form-title">// 选择初始身份</h2>
                     <div id="id-card-wrapper" class="collapsible-content-placeholder">
                         <div class="id-card">
                             <div class="id-card-main">
                                 <label for="user-identity">身份</label>
                                 <select id="user-identity" class="custom-select"></select>
                                 <p id="identity-description"></p>
                             </div>
                             <div id="paradise-camp-section" class="id-card-addon">
                                 <div class="grid-container">
                                     <div class="form-group">
                                         <label for="paradise-camp">乐园阵营</label>
                                         <select id="paradise-camp" class="custom-select">
                                             <option value="轮回乐园">轮回乐园</option>
                                             <option value="天启乐园">天启乐园</option>
                                             <option value="死亡乐园">死亡乐园</option>
                                             <option value="圣光乐园">圣光乐园</option>
                                         </select>
                                     </div>
                                     <div class="form-group">
                                         <label for="paradise-identity">乐园身份</label>
                                         <select id="paradise-identity" class="custom-select">
                                             <option value="新人">新人</option>
                                             <option value="猎杀者">猎杀者</option>
                                             <option value="裁决者">裁决者</option>
                                             <option value="先驱者">先驱者</option>
                                             <option value="职工者">职工者</option>
                                             <option value="违规者">违规者</option>
                                         </select>
                                     </div>
                                 </div>
                             </div>
                        </div>
                     </div>
                </div>
                 <div class="form-section">
                     <div class="talent-wrapper collapsible-content-placeholder">
                         <h3 class="talent-title">天赋</h3>
                         <div class="talent-selector-wrapper">
                               <div class="talent-search-container">
        <input type="text" id="talent-search-input" class="custom-select" placeholder="搜索你的天赋…">
    </div>
                                <div id="custom-talent-group" class="custom-input-container">
                                 <label for="custom-talent-input">自定义天赋描述</label>
                                 <input type="text" id="custom-talent-input" class="custom-select" placeholder="请在此处描述你的独特天赋">
                             </div>
                            <select id="talent-select" class="hidden-select">
                                 <option value="随机">随机 - 命运的骰子已经掷出</option>
                                     <option value="自定义">自定义</option>
                                     <option value="AI随机">AI随机生成</option>
                                 <option value="无">无</option>
                                <option value="第四面墙知情者：你隐约知道自己是某个故事的角色，偶尔能听到“画外音”，但其他人只会觉得你在自言自语。">第四面墙知情者</option>
    <option value="绝对味觉：你的舌头是个超高精度的化学分析仪，能尝出任何物质的精确成分，包括毒药、泥土和别人的谎言。">绝对味觉</option>
    <option value="情绪实体化：强烈的情绪会以无害但奇特的物理形态出现在你周围。比如，极度悲伤时会下起小小的爆米花雨，愤怒时头顶会长出柔软的蘑菇。">情绪实体化</option>
    <option value="BGM播放器：你的行为会自动匹配背景音乐，只有你自己能听到。潜行时是爵士乐，战斗时是交响金属，摸鱼时则是悠扬的夏威夷小调。">BGM播放器</option>
    <option value="反向幸运：你的运气总是以一种离奇的方式保护你。比如，你会被香蕉皮滑倒，却刚好躲过一颗狙击子弹，或者买彩票只中了一包纸巾，但那包纸巾刚好是最后一包。">反向幸运</option>
    <option value="动物社交恐怖分子：所有非人类的生物见到你都会立刻陷入恐慌，并想尽一切办法远离你。鸽子会为你绕路，警犬会放弃追捕，就连阿米巴原虫也会努力变形远离你的细胞。">动物社交恐怖分子</option>
    <option value="万物皆为友：你可以和任何非生命物体进行友好的精神交流，比如你的剑、你的鞋子、路边的石头。它们偶尔会给你一些奇怪但有用的建议。">万物皆为友</option>
    <option value="无用之学大师：你对所有在当前世界观下毫无用处的知识（比如地球上的互联网meme、冷门动画的剧情、量子力学的八卦）都了如指掌。">无用之学大师</option>
    <option value="概率篡改（1%）：每天一次，你可以指定一个事件，并将其成功的概率强行提升或降低1%。虽然微小，但有时足以创造奇迹，或者带来灾难。">概率篡改（1%）</option>
    <option value="剧情免疫：你对所有常见的剧情杀、预言、诅咒都天然免疫。预言中的“天选之子”会突然对你失去兴趣，必死的诅咒在你身上会变成一个无伤大雅的debuff，比如“接下来24小时说话会押韵”。">剧情免疫</option>


    <option value="水源地品鉴师：你能够品尝出任何水（包括圣水和毒液）的精确水源地和过滤历史，但这并不能让你免疫。">水源地品鉴师</option>
    <option value="活泼的影子：你的影子拥有独立的、非常丰富的肢体语言，它会根据你的潜意识做出反应，比如在你撒谎时拼命摇头。">活泼的影子</option>
    <option value="便携式热水壶：你流下的眼泪是滚烫的，可以用来泡茶，但味道总是有点咸。">便携式热水壶</option>
    <option value="植物的悲鸣：你能够听到植物因缺水或光照不足而发出的微弱悲鸣，但无法与它们交流。">植物的悲鸣</option>
    <option value="防窥之哈欠：你打哈欠时，周围半径三米内所有能反光（比如金属、玻璃）的物体表面会短暂变得模糊不清。">防窥之哈欠</option>
    <option value="人体面包机：在你完全静止不动超过一分钟后，你的身体会开始散发出刚出炉的面包的香气。">人体面包机</option>
    <option value="自带BGM的书签：你能让任何书籍在你阅读时，自动配上轻柔的背景音乐，但曲风永远是你最不喜欢的类型。">自带BGM的书签</option>
    <option value="情绪调色板：你身体的所有毛发（头发、眉毛等）都会根据你的情绪缓慢变色，比如焦虑时变成灰色，开心时是淡黄色，但变化过程需要数小时。">情绪调色板</option>
    <option value="真菌通感：你能够与真菌（比如蘑菇、霉菌）进行单向的心灵感应，你能感知到它们的“想法”，但它们通常在思考如何更好地腐烂。">真菌通感</option>
    <option value="诚实之耳：你在说谎时，耳朵会变得和精灵一样尖，效果持续到你说出下一句真话为止。">诚实之耳</option>
    <option value="昆虫舞蹈家：你能让任何昆虫在你面前跳一段优雅的华尔兹，前提是你能说服它这么做。">昆虫舞蹈家</option>
    <option value="万物年轮：你能够精确地知道任何一个非生命物体的“年龄”，从它被制造出来的那一刻算起。">万物年轮</option>
    <option value="闪光呼吸：你呼出的气中含有微量的、无害的闪光粉尘，在阳光下会显得非常梦幻。">闪光呼吸</option>
    <option value="味觉倒错：你能让任何咸味的食物吃起来像是甜的，反之亦然，但营养成分不变。">味觉倒错</option>
    <option value="八卦天线：当有人在你背后说你坏话时，你的头发会像被静电吸附一样竖起来一根。">八卦天线</option>
    <option value="迷路指针：你画的任何地图，无论多精确，上面的“你在此处”标记总是会自己跑到地图的边缘。">迷路指针</option>
    <option value="怀旧之声：你哼唱的任何歌曲，都会被周围的人听成一首他们童年最熟悉的儿歌。">怀旧之声</option>
    <option value="人体节拍器：你能让自己的心跳声完美地模仿任何一种打击乐器，但无法控制节奏。">人体节拍器</option>
    <option value="门之友：你对所有类型的门都有着超凡的亲和力，它们在你面前时会发出微弱的、表示欢迎的吱呀声。">门之友</option>
    <option value="梦境投影仪：在你睡觉时，你的梦境会以壁画的形式短暂地投射在你周围的墙壁上，天亮即逝。">梦境投影仪</option>
    <option value="瞬间抛光：你可以让任何一颗鹅卵石的表面变得像镜子一样光滑，但只能维持三秒。">瞬间抛光</option>
    <option value="松鼠会计：你总能知道离你最近的一只松鼠藏起来的松果的确切数量。">松鼠会计</option>
    <option value="无痕之步：你走过草地时，被你踩到的草会立刻恢复原状，不会留下任何脚印。">无痕之步</option>
    <option value="纸张守护者：你能让任何纸制品（书、羊皮卷等）对火的抗性提升5%，聊胜于无。">纸张守护者</option>
    <option value="化学嗝：你喝下任何液体后，都能在十分钟内，以打嗝的方式将该液体的化学式“说”出来。">化学嗝</option>
    <option value="落叶时刻：你拥有让时间变慢的能力，但只对正在下落的树叶有效。">落叶时刻</option>
    <option value="磐石之语：你能听懂石头的话语，但它们思考得极其缓慢，一句话可能要花上数百年才能说完。">磐石之语</option>
    <option value="不沾之肤：你的皮肤拥有完美的防水性，就像荷叶一样，任何液体都不会沾染，包括治疗药水。">不沾之肤</option>
    <option value="天书之笔：你写的字会自动变成一种极其优美但无人能懂的书法体。">天书之笔</option>
    <option value="可控瞳孔：你能够自由控制自己瞳孔放大的程度，可以在黑暗中看得更清楚一点，但也会因此显得很惊讶。">可控瞳孔</option>
    <option value="无用记忆：你能背诵出圆周率小数点后一万位，但在任何需要计算的场合，这都没有任何帮助。">无用记忆</option>
    <option value="测谎喷嚏：你对谎言过敏，每次听到谎言都会打一个响亮的喷嚏。">测谎喷嚏</option>
    <option value="硬币清洁工：任何在你手中停留超过一分钟的硬币，都会被自动擦得锃亮。">硬币清洁工</option>
    <option value="情绪色盲：你能够感受到情绪的“颜色”，但所有负面情绪都是不同色调的灰色。">情绪色盲</option>
    <option value="脆弱之发：你能让自己的头发像藤蔓一样伸长，但它和普通头发一样脆弱，一扯就断。">脆弱之发</option>
    <option value="跨物种幽默：你讲的笑话能让周围的非智慧生物（比如狗或马）发笑。">跨物种幽默</option>
    <option value="能量消耗者：你每次眨眼，都在消耗极其微量的、可以忽略不计的“世界能量”。">能量消耗者</option>
    <option value="马后炮向导：你总能找到任何迷宫的出口，但只有在你已经走出迷宫之后才能确定。">马后炮向导</option>
    <option value="塑云者：你能够让任何一朵云彩暂时变成你想要的形状，但很快就会被风吹散。">塑云者</option>
    <option value="最后的安魂曲：你能让死亡不超过一小时的昆虫尸体，重新“活”过来并为你跳完最后一支舞。">最后的安魂曲</option>
    <option value="魔法品鉴家：你对魔法的气味极其敏感，能闻出不同法术残留的味道，比如火球术是烧焦的辣椒味，治疗术是薄荷味。">魔法品鉴家</option>
    <option value="沉思之蝶：当你陷入沉思时，你的身边会随机出现一只蝴蝶的幻影，绕着你飞舞。">沉思之蝶</option>
    <option value="蚊子绝缘体：你永远不会被蚊子叮咬，因为蚊子认为你的血“不好喝”。">蚊子绝缘体</option>


    <option value="影子口袋：你能够将小型非魔法物品（如钥匙、匕首）完美地藏在自己的影子里，需要时可以取出。">影子口袋</option>
    <option value="紧急信标：你能够与自己接触过的、有智慧的生物建立一个临时的精神链接，只能传递“危险”或“安全”两种信号。">紧急信标</option>
    <option value="恒温动物：你的身体能够缓慢地适应任何环境的温度，无论是极寒还是酷暑，都能保持相对舒适。">恒温动物</option>
    <option value="大地脉动：你能够通过触摸土壤，感知到周围一公里内是否有大型生物群体活动。">大地脉动</option>
    <option value="滋养之手：你制作的任何食物或饮品，都会附带轻微的、加速体力恢复的效果。">滋养之手</option>
    <option value="活体地图：你能够记住走过的任何一条路，并且可以在脑海中构建出完美的3D地图。">活体地图</option>
    <option value="情感残响：你能够通过触摸一件物品，感知到它上一位使用者的强烈情绪。">情感残响</option>
    <option value="安抚之声：你的声音能够安抚大多数非敌意的野兽，降低它们主动攻击的欲望。">安抚之声</option>
    <option value="路人光环：你在人群中不易被注意，只要你不主动与人交谈或做出引人注目的行为，就很容易被忽略。">路人光环</option>
    <option value="柔骨之躯：你对自己身体的控制力极强，能够做出匪夷所思的柔韧和平衡动作。">柔骨之躯</option>
    <option value="危机嗅觉：你的直觉总能在战斗前一秒，为你警示出最致命的威胁来自何方。">危机嗅觉</option>
    <option value="万象拟音：你能够模仿任何你听过的声音，包括人声、兽吼和环境音，相似度极高。">万象拟音</option>


    <option value="技能小偷：你能够“窃取”他人身上一个非战斗类的熟练技能（如开锁、演奏、手艺），并使用一小时。每天一次。">技能小偷</option>
    <option value="沉默领域：你能够指定一个半径五米内的区域，让其中的所有魔法效果，无论是增益还是减益，暂时无效化，持续十秒。">沉默领域</option>
    <option value="生命献祭：你能够将自己的生命力分给他人，快速治愈对方的伤口，但自己会陷入同等程度的虚弱。">生命献祭</option>
    <option value="空间信标：你能够在你接触过的任何固体表面留下一个不可见的“空间标记”，你可以随时感知到标记的位置和状态。最多三个。">空间信标</option>
    <option value="真实之眼：你能够看穿大部分的幻术、变形术和伪装，在你眼中，虚假的存在会呈现出不稳定的轮廓。">真实之眼</option>
    <option value="微小回溯：每天一次，你可以让时间倒流三秒。只有你自己保留这三秒的记忆。">微小回溯</option>
    <option value="兵器通灵：你能够“解读”武器的记忆，通过触摸一把武器，了解它经历过的最激烈的一场战斗。">兵器通灵</option>
    <option value="能量反刍：你可以将受到的物理伤害的一部分，以纯粹的能量形式储存起来，并在下一次攻击中释放出去。">能量反刍</option>


    <option value="概念锚定：你能够将一个概念“锁定”在一个物体上。例如，将“坚固”的概念锁定在一张纸上，这张纸就无法被撕裂。">概念锚定</option>
    <option value="镜界沟通：你能够与一个平行世界的、选择了不同道路的自己进行短暂的精神交流，获取对方的知识或建议。">镜界沟通</option>
    <option value="物质编译器：你能够“编辑”非生命物质的基本属性，比如改变一块石头的密度，让它像木头一样轻。效果有限且消耗巨大。">物质编译器</option>
    <option value="命运的宠儿：你被世界本身所“偏爱”，当出现概率性的事件时，结果总会向对你有利的方向发生微小的、决定性的偏移。">命运的宠儿</option>


    <option value="好为人师磁铁：你散发着一种奇特的信息素，会让所有智慧生物在与你交谈时，不自觉地想要对你说教或纠正你。">好为人师磁铁</option>
    <option value="万物锈蚀：所有你持有的金属物品（武器、盔甲、钱币），其腐朽和磨损的速度会加快十倍。">万物锈蚀</option>
    <option value="恐慌置换：你在紧张或恐惧时，会随机与周围的一个物体（比如桌子、石头、尸体）交换位置。">恐慌置换</option>
    <option value="混乱的善意：你释放的任何增益法术（治疗、加持等），都有15%的概率作用到离你最近的敌人身上。">混乱的善意</option>
    <option value="完美的指甲生长：你的指甲总能长得又快又完美，形状匀称，富有光泽，但硬度和其他人的指甲没什么两样。">完美的指甲生长</option>
<option value="回声定位（伪）：你拥有出色的回声定位能力，但只能精确定位到你自己发出的声音的来源。">回声定位（伪）</option>
<option value="灰尘亲和力：你比一般人更容易吸引灰尘，静坐片刻身上就会落上薄薄一层，像一个移动的灰尘收集器。">灰尘亲和力</option>
<option value="对称强迫症：你对视觉上的不对称有种天生的敏感，看到歪斜的画框或不对称的摆设会让你感到难以忍受。">对称强迫症</option>
<option value="气泡膜体质：你的皮肤在被按压时，会发出类似捏破气泡膜的、令人愉悦的清脆声响。">气泡膜体质</option>
<option value="植物语入门：你能听懂植物的语言，但不知为何，它们对你说的似乎总是脏话。">植物语入门</option>
<option value="绝对音高（反向）：你拥有绝对音高，但只在听到别人唱歌跑调时才能准确识别出原调。">绝对音高（反向）</option>
<option value="食物幻视：当你极度饥饿时，视野中所有圆形或椭圆形的物体看起来都像美味的面包。">食物幻视</option>
<option value="静态着装：你的衣物永远不会起皱，但也因此更容易积聚静电。">静态着装</option>
<option value="历史的脚步声：在历史悠久的古道上，你偶尔能听到早已逝去之人留下的脚步声回响。">历史的脚步声</option>
<option value="苔藓预报员：通过仔细观察苔藓的湿润程度和色泽，你能准确预测接下来三分钟内的天气。">苔藓预报员</option>
<option value="颜色小偷：你能从一个物体上“偷”走一小块颜色，使该处褪色，而你的指尖会沾上那抹洗不掉的色彩。">颜色小偷</option>
<option value="情绪和弦：你的各种情绪会在脑海中自动谱成一段独特的和弦，但你无法分辨和弦具体对应哪种情绪。">情绪和弦</option>
<option value="延迟喷嚏：所有本该在白天打的喷嚏，都会累积到你睡着之后，以一场喷嚏风暴的形式释放。">延迟喷嚏</option>
<option value="自动对齐：你随手放在书架上的任何书籍，都会自动与书架边缘和旁边的书本完美对齐。">自动对齐</option>
<option value="液体密度感知：用手捧起任何液体，你都能瞬间感知到其精确的密度数值。">液体密度感知</option>
<option value="蜘蛛网警报：就在你的脸即将撞上蜘蛛网的前零点一秒，你的大脑会收到一次强烈的预警。">蜘蛛网警报</option>
<option value="谐音大师：你在说话时，总能无意识地、且恰到好处地使用各种双关语和同音异义词。">谐音大师</option>
<option value="骨骼广播：在天气剧烈变化前，你的骨骼会发出微弱的、只有你能听见的信号，内容通常是随机的诗歌朗诵。">骨骼广播</option>
<option value="梦境存档员：你每晚的梦境都会被自动转录成文字，保存在一本你永远找不到的魔法日记里。">梦境存档员</option>
<option value="语法纠错者：你能立刻听出他人话语中的任何语法错误，并产生一股难以抑制的纠正冲动。">语法纠错者</option>
<option value="毯子堡垒：只要用毯子把自己完全包裹起来，你就会获得一种“绝对安全”的心理慰藉，物理防御力为零。">毯子堡垒</option>
<option value="水果的情绪：你能清晰地感知到水果从生涩到成熟的喜悦，以及开始腐烂时的悲伤。">水果的情绪</option>
<option value="人体指南针：在非感冒状态下，你的鼻子总会无意识地朝向正北方。">人体指南针</option>
<option value="单向传音：你能将自己的声音灌入一个贝壳中，任何拿到贝壳的人都能听到，但声音无法被再次取出。">单向传音</option>
<option value="戏剧性摔倒：你每次意外摔倒时，姿势总是异常优雅且富有戏剧性，宛如舞台表演。">戏剧性摔倒</option>
<option value="无声咏唱：你可以在脑海中完美地完成冗长的魔法咒语咏唱，但法术并不会因此而触发。">无声咏唱</option>
<option value="情感余味：吃完一餐后，你能在口中回味出烹饪者制作这道菜时的主要情绪。">情感余味</option>
<option value="云朵收藏家：你拥有过目不忘的能力，但只对天上的云朵有效，你能记住见过的每一朵云的样子。">云朵收藏家</option>
<option value="昆虫的敬意：被你不小心踩死的昆虫，会在原地留下一朵持续一秒的、由能量构成的微型花朵。">昆虫的敬意</option>
<option value="完美削皮：使用任何工具给水果削皮，你都能削出一条完整的、从不中断的果皮。">完美削皮</option>
<option value="灰尘诗人：你呼出的气流能让附近的灰尘在空中短暂地聚合成随机的、优美的词语。">灰尘诗人</option>
<option value="瓶中信使：任何你投入水中的漂流瓶，最终都会被冲上某个无人知晓的荒岛。">瓶中信使</option>
<option value="噪音过滤器：你拥有主动屏蔽半径五米内所有蚊子嗡嗡声的能力。">噪音过滤器</option>
<option value="情绪光晕：当你凝视一个人超过十秒，能看到对方身上模糊的情绪光晕，但颜色和情绪的对应关系每天随机变化。">情绪光晕</option>
<option value="露珠收集者：每天清晨醒来，你的睫毛上总是会挂满晶莹剔透的露珠。">露珠收集者</option>
<option value="温度记忆：你的皮肤能“记住”上一个接触物体的准确温度，并将其保持一分钟。">温度记忆</option>
<option value="影子戏法师：你的影子能惟妙惟肖地表演你看过的任何皮影戏片段。">影子戏法师</option>
<option value="书本的叹息：当你合上一本尚未读完的书时，你会听到它发出一声微不可闻的叹息。">书本的叹息</option>
<option value="味道翻译家：你可以将任何尝到的味道，在脑海里“翻译”成一段无人能懂的现代诗。">味道翻译家</option>
<option value="回声变调：你在山谷中呐喊，听到的回声会自动帮你提升一个八度。">回声变调</option>
<option value="霉菌艺术家：被你遗忘的食物在发霉时，其霉菌会生长成令人惊叹的美丽图案。">霉菌艺术家</option>
<option value="永恒的温热：任何被你触摸过的石头，都会永久性地比环境温度高出一度。">永恒的温热</option>
<option value="泡泡语：你吹出的肥皂泡泡在破裂的瞬间，会用极微弱的声音说出“你好”或“再见”。">泡泡语</option>
<option value="密码过敏：当你尝试解读复杂的密码或谜题时，会立刻感到一阵轻微的头痛。">密码过敏</option>
<option value="节奏同步：你走路的步频会不自觉地与离你最近的人保持完全一致。">节奏同步</option>
<option value="月光墨水：在月光下书写，你使用的任何墨水都会散发出淡淡的银光，天亮后即恢复原样。">月光墨水</option>
<option value="静态收藏家：你的头发特别容易积聚静电，可以轻松吸附起小纸片或羽毛。">静态收藏家</option>
<option value="椅子预热：任何你打算坐下的椅子，都会在你坐下前一分钟自动升温到最舒适的温度。">椅子预热</option>
<option value="倒影的秘密：你在水中的倒影，其表情总是比你本人要显得忧郁一些。">倒影的秘密</option>
<option value="歌声的质感：你能通过聆听，感受到歌声的“触感”，比如丝滑、粗糙、温暖或冰冷。">歌声的质感</option>
<option value="冰霜画手：冬天对着窗户哈气，凝结的冰霜会自动形成一幅随机而精致的风景画。">冰霜画手</option>
<option value="烛火的舞伴：你点燃的任何蜡烛，其火焰都会随着你的心跳节奏同步摇曳。">烛火的舞伴</option>
<option value="谎言的重量：你能感觉到别人说出的谎言带有物理上的“重量”，但无法判断其真伪。">谎言的重量</option>
<option value="无聊的预知：你能准确预知到接下来五分钟内，将会发生的一件最无聊、最没有意义的事情。">无聊的预知</option>
<option value="历史的回响：在古战场或历史遗迹，你能听到早已消散在风中的、微弱的兵器碰撞与呐喊声。">历史的回响</option>
<option value="完美的堆叠：你拥有将任何可堆叠物品（如石头、书籍、盘子）堆到其物理极限高度的卓越能力。">完美的堆叠</option>
<option value="雨滴协奏曲：下雨时，你能清晰分辨每一滴雨水落在不同物体上的音高，并在脑中谱成乐章。">雨滴协奏曲</option>
<option value="沙堡建筑师：你堆的沙堡异常坚固，能轻松抵御普通海浪的冲刷，直到下一次大涨潮。">沙堡建筑师</option>
 
<option value="微风传话：你可以将自己的低语附在微风上，让它清晰地传到顺风方向一百米内指定的人耳中。">微风传话</option>
<option value="应急伪装：在受到生命威胁时，你能让自己的外表变得和周围环境中的一块普通石头或灌木丛难以区分，持续一分钟，期间无法移动。">应急伪装</option>
<option value="锁匠之友：你对锁具的内部结构有一种天生的直觉，这让你在开锁时成功率大大提高。">锁匠之友</option>
<option value="情绪温度计：你能大致感知到周围智慧生物的情绪状态，如“温暖”代表喜悦，“冰冷”代表恐惧。">情绪温度计</option>
<option value="草药低语：通过触摸植物，你能立刻感知到它是否具有药用价值、毒性或可食用性。">草药低语</option>
<option value="标记猎物：你可以对一个生物施加一个持续一小时的无形标记，在千米范围内都能感知其大致方向。">标记猎物</option>
<option value="记忆橡皮擦：每天一次，你可以选择性地让自己完全忘记一段不超过十分钟的、不愉快的记忆。">记忆橡皮擦</option>
<option value="快速缝合：你拥有远超常人的伤口处理技巧和速度，能用最简单的工具完成有效的紧急缝合。">快速缝合</option>
<option value="工具共鸣：当你拿起一件工具时，能立刻领悟到它最省力、最有效的使用方式。">工具共鸣</option>
<option value="水质净化：通过持续接触，你能缓慢地净化一小捧水，使其达到可安全饮用的标准。">水质净化</option>
<option value="方向感校准：每天一次，你可以在任何地方瞬间在脑海中明确自己相对于出生点的精确方位。">方向感校准</option>
<option value="野兽的善意：在非饥饿状态下，大多数野兽不会主动攻击你，除非你先表露出强烈的敌意。">野兽的善意</option>
<option value="微光视觉：在只有星光或月光的微光环境下，你的视力几乎与白天无异。">微光视觉</option>
<option value="警觉之眠：你在睡眠时依然对周围的危险气息保持着最低限度的警觉，更容易被异动惊醒。">警觉之眠</option>
<option value="交易直觉：在进行交易时，你总能凭直觉判断出对方的报价是公平、占便宜还是敲竹杠。">交易直觉</option>
<option value="强效消化：你的消化系统能分解某些通常无法食用的植物根茎，并从中汲取少量能量。">强效消化</option>
<option value="无声脚步：当你集中精神刻意放轻脚步时，几乎不会发出任何可以被察觉的声音。">无声脚步</option>
<option value="痕迹追踪：你对追踪生物留下的痕迹（脚印、断枝、气味残留）有着天生的敏锐直觉。">痕迹追踪</option>
<option value="简易陷阱大师：你能用随处可见的材料，快速设置出效果显著的、用于捕捉小动物或警示的简易陷阱。">简易陷阱大师</option>
<option value="天气预报员：通过观察云层、风向和空气湿度的细微变化，你能相当准确地预测未来十二小时的天气。">天气预报员</option>

 

<option value="因果线剪辑：每天一次，你可以选择一个刚刚发生的、影响不大的事件（如打翻水杯），并从因果中“剪除”它，使之从未发生。">因果线剪辑</option>
<option value="元素亲和：你对某一种元素（火、水、风、土等）有超凡的亲和力，学习和施展该系法术时事半功倍，且威力与控制力显著提升。">元素亲和</option>
<option value="灵魂低语：你能与任何濒死（生命最后一分钟）的生物进行短暂的精神交流，读取他们最后、最强烈的残念或信息。">灵魂低语</option>
<option value="存在稀释：只要你身处阴影之中，就可以选择性地大幅降低自身的存在感，能有效规避大部分非指向性的侦测。">存在稀释</option>
<option value="血脉觉醒：在生命垂危的瞬间，你有一定几率唤醒体内潜藏的古老血脉，短时间内获得强大的力量或一项全新的特殊能力。">血脉觉醒</option>
<option value="契约之言：你说出的、以“我承诺”为开头的句子，会对你和聆听者产生微弱的契约束缚力。若你违背，会遭受厄运；若他人帮助你完成，会获得好运。">契约之言</option>
<option value="绝对模仿：亲眼目睹一个非超凡的、纯粹的技巧性动作后（如一次完美的射击、一段复杂的剑舞），你可以在接下来的一分钟内完美复现一次。">绝对模仿</option>
<option value="心灵壁垒：你的心智如同一座坚固的堡垒，天生就能抵抗大部分精神探查、心灵控制和情绪操纵类的法术或能力。">心灵壁垒</option>
<option value="短距传送：每天可以使用数次，瞬间将自己传送到视线所及的十米内任意一个无障碍的地点。">短距传送</option>
<option value="再生之躯：你的身体拥有缓慢但持续的自愈能力，所有非致命性的创伤都会以肉眼可见的速度缓慢愈合，且不会留下疤痕。">再生之躯</option>
 

<option value="魔法增幅：你施展的所有法术，其威力会不由自主地增加30%，但法力消耗也同时增加100%。">魔法增幅</option>
<option value="共情过载：你会强制性地、身临其境地感受到周围所有人的强烈情绪，并会不由自主地在表情和动作上表现出来。">共情过载</option>
<option value="绝对吸引：在战斗中，所有飞行道具（无论敌我）的弹道都有微小的几率向你的身体偏移。">绝对吸引</option>
<option value="诚实的代价：你无法说谎。一旦尝试，你不仅会失败，还会脱口而出另一个更加尴尬或致命的真相。">诚实的代价</option>
<option value="财富斥力：你持有的任何形式的货币，都会以各种离奇的方式（被偷、遗失、意外损坏、不小心捐赠）迅速地离你而去。">财富斥力</option>
<option value="反向治愈：当你对他人施展治疗或包扎时，有10%的概率将对方的伤势完美地转移到自己身上。">反向治愈</option>
<option value="主角公敌：你天生就散发着一种独特的气场，极易被那些身负“天命”或自认“主角”的人视为潜在的竞争对手或必须铲除的障碍。">主角公敌</option>
<option value="言出法随（负面限定）：你所有无意中说出的负面猜想（比如“前面该不会有埋伏吧”），其成真的概率会大幅度提升。">言出法随（负面限定）</option>
<option value="物品背叛：在最关键的时刻，你所依赖的物品（武器、工具、绳索）有一定概率会突然断裂、失灵或脱手。">物品背叛</option>
<option value="友军之围：在混乱的战斗中，你的盟友似乎总是会不自觉地将你纳入他们范围攻击的边缘区域。">友军之围</option>  

                            </select>
                            <div id="custom-talent-scroll"></div>

                         </div>
                     </div>
                 </div>
            </div>
        </div>


        <div class="planet" id="planet-teammates">
            <div class="planet-icon-container">
                <div class="planet-icon">✤</div>
                <div class="planet-title" id="teammate-section-label">队友配置</div>
            </div>
            <div class="planet-content">
                <button class="close-planet-btn">×</button>
                <div class="form-section">
                    <h2 class="form-title">// 队友设置</h2>
                    <div class="collapsible-content-placeholder">
                        <div class="teammate-gear-controls">
                            <div class="gear-group">
                                <label for="teammate-count" id="teammate-count-label">人数</label>
                                <div class="gear-select">
                                    <select id="teammate-count" class="custom-select">
                                        <option value="-1">随机</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option><option value="10">10</option>
                                    </select>
                                </div>
                            </div>
                            <div class="gear-group">
                                <label for="teammate-tendency">倾向</label>
                                <div class="gear-select">
                                     <select id="teammate-tendency" class="custom-select">
                                         <option value="友善合作">友善</option><option value="中立谨慎">中立</option><option value="竞争激烈">竞争</option><option value="混乱邪恶">混沌</option><option value="随机生成">随机</option><option value="自定义">自定义</option>
                                     </select>
                                </div>
                            </div>
                        </div>
                        <div class="fixed-team-toggle" id="fixed-team-toggle">
                            <input type="checkbox" id="is-fixed-team">
                            <label for="is-fixed-team" class="toggle-label"></label>
                            <span>固定小队</span>
                        </div>
                        <div id="custom-teammates-container" class="teammate-card-stack">
                            <div class="stack-header">
                                <div>自定义信息 (可左右滑动)</div>
                                <div class="stack-controls">
                                   <button id="load-teammates-btn" type="button" class="teammate-action-btn">读取</button>
                                   <button id="save-teammates-btn" type="button" class="teammate-action-btn">保存</button>
                                   <button type="button" class="teammate-action-btn" onclick="addTeammate()">+</button>
                                </div>
                            </div>
                            <div id="teammates-list"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <button id="next-page-button" class="primary-cta-btn" style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 100px; height: 100px; font-size: 50px;">→</button>

    </div>
</div>

<div id="page-2" class="init-page">
<div id="galaxy-points-display">

    <div class="points-info">
        <div class="points-bar-container">
            <div id="points-bar"></div>
        </div>
        <span id="remaining-points-text">70</span>
    </div>



</div>

   <div id="top-hud" class="hud top-hud">
        <div class="hud-toggle" data-target="top-hud"></div>
        <div class="hud-content">

            <div class="points-tracker">
                <div id="points-display-container" style="display: none;">
                    <div id="points-ring-container">

                        <svg id="points-ring-bg" width="50" height="50">
                            <circle cx="25" cy="25" r="22" stroke="var(--border-color)" stroke-width="3" fill="none"/>
                        </svg>
                        <svg id="points-ring" width="50" height="50">
                            <circle cx="25" cy="25" r="22" stroke="var(--primary-color)" stroke-width="3" fill="none" stroke-linecap="round"
                                stroke-dasharray="138.23" stroke-dashoffset="138.23" transform="rotate(-90 25 25)"/>
                        </svg>
                        <span id="remaining-points">70</span>
                    </div>
                   <span>剩余构筑点</span>
                </div>

                
               
            </div>
    <div class="points-actions">

         <div class="form-group" style="text-align: center;">
                    <select id="total-points-select" class="custom-select" style="width: auto;">
                        <option value="70">充裕 (70)</option>
                        <option value="55">标准 (55)</option>
                        <option value="40">残疾 (40)</option>
                        <option value="0">地狱 (0)</option>
                        <option value="custom">自定义</option>
                    </select>
                    <input type="number" id="custom-total-points" min="1" value="70" style="display: none; width: 80px; margin-top: 5px;">
                </div>
                                <div class="template-controls">
                    <select id="template-select-init" class="custom-select" placeholder="读取模板"></select>
                     
                </div>
                 <button id="average-points-btn" class="action-button">平均分配</button>
    </div>

 <button id="arrange-stars-btn" class="action-button">整理排列</button>
            <div class="template-manager">
                <div class="template-controls">
                    <select id="template-select" class="custom-select" placeholder="读取模板" style="display: none;"></select>
                    <button id="delete-template-btn" class="action-button danger-button">删除当前模板</button>
                </div>
                <div id="save-template-form">
                    <input type="text" id="save-template-name" placeholder="将当前加点保存为模板">
                    <button id="save-template-btn" class="action-button">保存</button>
                </div>
            </div>
        </div>
    </div>


  <div id="galaxy-container">
    <div id="wrapper-physic" class="galaxy-wrapper">
    <div id="galaxy-physic" class="galaxy-system" data-galaxy="physic"></div>
</div>

<div id="wrapper-mental" class="galaxy-wrapper">
    <div id="galaxy-mental" class="galaxy-system" data-galaxy="mental"></div>
</div>

<div id="wrapper-social" class="galaxy-wrapper">
    <div id="galaxy-social" class="galaxy-system" data-galaxy="social"></div>
</div>

<div id="galaxy-nav-prev" class="galaxy-nav">&lt;</div>
<div id="galaxy-nav-next" class="galaxy-nav">&gt;</div>
</div>

  <div id="bottom-hud" class="hud bottom-hud">
        <div class="hud-toggle" data-target="bottom-hud"></div>
        <div class="hud-content">

             <div id="concept-section" class="form-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">

            </div>


            <div class="button-container">
                <div class="form-group" style="margin-bottom: 1rem; text-align: center;">
                    <select id="send-mode-select" class="custom-select" style="max-width: 250px; margin: 0 auto;">
                        <option value="auto">自动发送</option>
                        <option value="manual">手动发送</option>
                    </select>
                </div>
                <div style="display: flex; gap: 0.8rem; justify-content: center; flex-wrap: wrap;">
                    <button id="init-button" class="action-button">[ <校准并传送> ]</button>
                    <button id="god-space-button" class="action-button secondary-button">[ <于安全区域醒来> ]</button>
                    <button id="custom-action-button" class="action-button" style="background-color: var(--info-color, #4db6ac); border-color: #5a944b;">[ <自定义> ]</button>
                </div>
            </div>


            <div id="custom-action-input-container" style="display: none; margin-top: 1.5rem;">
                 <input type="text" id="custom-action-input" placeholder="请在这里输入你的自定义说明文字" style="width: 100%; box-sizing: border-box; margin-bottom: 0.8rem;">
                 <div style="display: flex; align-items: center; gap: 0.5rem;" >
                    <input type="checkbox" id="add-world-prefix-checkbox" style="transform: scale(1.2); cursor: pointer;" checked>
                    <label for="add-world-prefix-checkbox" style="margin-bottom: 0; cursor: pointer; user-select: none;">为该指令附加世界背景</label>
                </div>
            </div>
            <div id="warning-message" class="warning-message" style="display: none; margin-top: 1rem; color: #ffcc00; text-align: center;">
                提示：参数已上传，正在构建角色数据，你将在短暂的意识模糊后于主神空间醒来，无法立即进入任务。
            </div>
        </div>
    </div>
</div>
  </div>    
<div id="main-wrapper">
 <div class="status-container">
    <header>
        <div class="header-content">
            <div id="update-notifier" style="display: none;">!</div>
            <h1 id="world-shard">SYSTEM TERMINAL</h1>
            <div class="header-info-bar">
    <div class="info-group">
        <span class="info-item">
            <span class="info-label">位置:</span>
            <span id="header-location" class="info-value">--</span>
        </span>
        <span class="info-item">
            <span class="info-label">时间:</span>
            <span id="header-time" class="info-value">--</span>
        </span>
    </div>
    <div class="info-group">
        <span class="info-item">
            <span class="info-label">默认检定:</span>
            <span id="header-check" class="info-value">--</span>
        </span>
        <span class="info-item">
            <span class="info-label">敌方:</span>
            <span id="header-combat" class="info-value">--</span>
        </span>
        <span class="info-item">
            <span class="info-label">难度:</span>
            <span id="header-difficulty" class="info-value">--</span>
        </span>
    </div>
</div>
<button id="fullscreen-btn" title="全屏">
    ⛶
</button>
 <button id="settings-btn" title="设置">
    ⚙
</button>
 <button id="refresh-btn" title="刷新">
    ⟲
</button>

 
        </div>
    </header>



    <div class="content-area" id="chat-display-area">

    </div>
<div id="dynamic-content-area" class="dynamic-content-area">

<!-- 外部模块占位，他妈的麻烦啊啊啊啊啊啊啊啊啊啊啊 -->
    <div id="options-module-container" class="module-container" style="display: none;">
  <div class="options-container">
        <div class="choices-container" id="choicesContainer">

        </div>
    </div>

    <div class="skill-orb-container">
        <div class="skill-orb" id="skillOrb">術</div>
    </div>
    <div class="skill-panel" id="skillPanel">
        <div class="skill-list" id="skillList">
            <p style="color: grey; font-size: 14px; text-align: center;">未检测到可用技能</p>
        </div>
        <div class="willpower-section">
            <label class="willpower-label">
                <span>投入意志力</span>
                <div class="willpower-input-container">
                    <input type="number" id="willpowerInput" min="0" value="0">
                    <span id="willpowerMax">/ 0</span>
                </div>
            </label>
            <div class="skill-info">每点意志力为检定池+1DP</div>
        </div>
    </div>

    </div>

<div id="forum-modal-container" class="modal">
 <div id="forum-modal-content">
 <button id="forum-modal-close-btn">×</button>
 <div id="forum-wrapper">
        <!-- 头部 -->
        <header class="forum-header">
            <h1 class="forum-title">交流终端</h1>
            <div class="header-controls">
                <button class="new-post-btn" id="new-post-btn">发布新帖</button>
 
            </div>
        </header>

 <main class="forum-body" id="forum-body">

    <aside class="forum-sidebar" id="forum-sidebar">

    </aside>


    <section class="thread-list-view">
        <div class="thread-list-header">
            <span id="current-section-name"></span>
        </div>
        <div class="thread-list" id="thread-list">

        </div>
        <div class="pagination-controls" id="thread-pagination"></div>
    </section>


    <section class="thread-detail-view">
        <div id="thread-detail-content">

             <div class="detail-placeholder">
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" style="color: var(--text-secondary-color); opacity: 0.5; margin-bottom: 10px;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                    <p>选择一个帖子查看内容</p>
                </div>
            </div>
        </div>
    </section>
</main>
    </div>

    <!-- 发帖模态框 -->
    <div id="post-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close" id="modal-close-btn">&times;</button>
            <h2 class="modal-title" id="modal-title">发布新帖</h2>
            <form id="post-form">
                <div class="form-group">
                    <label for="post-section">选择区块</label>
                    <select id="post-section" required></select>
                </div>
                <div class="form-group">
                    <label for="post-title">帖子标题</label>
                    <input type="text" id="post-title" required>
                </div>
                <div class="form-group">
                    <label for="post-content-input">帖子内容</label>
                    <textarea id="post-content-input" required></textarea>
                </div>
                <div class="modal-actions">
                    <button type="submit" class="new-post-btn" id="submit-post-btn">确认发布</button>
                </div>
            </form>
        </div>
    </div>
    </div>
</div>


 


<div id="group-chat-context-menu" class="group-chat-context-menu">
    <div class="group-chat-context-menu-item" id="context-menu-reply">回复</div>
</div>

<div id='task-summary-modal-container' class = 'modal'>
  <div id="summary-root" class="task-summary-main-container">
        <!-- 内容将由JavaScript动态生成 -->
    </div>
</div>

</div>
<!-- 替换原有的成就系统看板HTML -->
<div id="achievements-modal" class="modal page-modal wide" style="z-index: 99999;">
    <div class="modal-content page-modal-content">
        <button class="modal-close">×</button>
 
        <div id="achievements-content" class="page active" style="display: flex; flex-direction: column; gap: 0; padding: 10px;">
            <!-- 成就列表将由JS动态生成 -->
            <div style="color: var(--text-secondary-color); text-align: center; padding: 40px;">
                <div style="font-size: 2em; margin-bottom: 10px;">🏆</div>
                <p>正在加载成就数据...</p>
            </div>
        </div>
    </div>
</div>

 <div id="zero-level-interface">
<div id="new-message-notification-container" style="position: absolute; bottom: 16%; left: 15px; z-index: 1001; pointer-events: none;"></div>

<div id="event-tracker-container" class="event-tracker-container"></div>

    <div id="floating-panel-anchor">
<div id="rp-panel">
    <div class="check-cards-area">
        <h3>
            选择检定项

            <div class="card-view-switcher">
                <span id="switch-to-my-cards" class="active">我的</span>
                <span id="switch-to-teammate-cards">队友</span>
            </div>

            <button id="sort-cards-btn" class="sort-button" data-sort-order="desc">LVL ▼</button>
        </h3>

        <div id="my-cards-slider" class="cards-slider visible">
            <p style="color: grey; padding: 20px 0;">等待加载检定项...</p>
        </div>

        <div id="teammate-cards-slider" class="cards-slider">
             <p style="color: grey; padding: 20px 0;">无队友或未加载</p>
        </div>
    </div>
    <button id="confirm-rp-choice-btn" class="action-button">确认</button>
</div>
    </div>

    <div id="top-left-orbs">
        <div class="orb top-orb" id="forum-orb-button">坛</div>
        <div class="orb top-orb" id="task-summary-orb-button">总</div>
        <div class="orb top-orb" id="read-orb-button">阅</div>
        
        <div class="orb top-orb" id="group-chat-orb-button" style="display: none;">聊</div>
    </div>

    <button id="view-command-btn" class="action-button zero-level-btn" title="查看/编辑待发指令">令</button>
    <button id="rp-button" class="action-button zero-level-btn" title="RP检定">RP</button>
    <button id="run-button" class="action-button zero-level-btn" title="逃跑" style="display: none;">逃</button>
       <textarea id="user-input" rows="2" placeholder="在这里输入你的行动..."></textarea>
    <div id="button-container-send">
          <div id="action-blocker-overlay"></div>
    <button id="send-button" class="action-button zero-level-btn">➔</button>
    <button id="reroll-button" class="action-button zero-level-btn">⟲</button>
    </div>
</div>
</div>


<div id="orb-container">
    
    <div class="orb" data-modal-id="roll-result-modal" id="roll-result-orb">骰</div>
    
    <div class="orb" data-modal-id="shop-wrapper-modal" id="shop-wrapper-orb">商</div>
    <div class="orb" data-modal-id="map-view-modal" id="map-view-orb">图</div>
     <div class="orb-divider"></div>
     
    <div class="orb" id="skill-choice-orb">術</div>
    <div class="orb" data-modal-id="page-character-modal" id="page-character-orb">能</div>
 
     <div class="orb-divider"></div>
     <div class="orb" data-modal-id="summary-modal" id="summary-modal-orb">综</div>
    <div class="orb" id="world-book-orb">识</div>
 
    <div class="orb" data-modal-id="page-task-modal" id="page-task-orb">任</div>

</div>


<div id="page-task-modal" class="modal page-modal">
    <div class="modal-content page-modal-content">
        <button class="modal-close">×</button>
        <div class="modal-title">任务详情</div>
        <div id="page-task" class="page active">
            <ul class="info-list">
                
                <li><span class="label">任务目标</span><span id="task-objective" class="value highlight"></span></li>
                 <li><span class="label">世界描述</span><span id="info-world-desc" class="value"></span></li>
                <li><span class="label">任务状态</span><span id="task-status" class="value"></span></li>
                <li>
                    <span class="label">任务进度</span>
                    <div class="value" style="width: 50%;">
                        <div class="progress-container">
                            <div class="progress-bar-bg">
                                <div id="task-progress-bar" class="progress-bar-fill"></div>
                            </div>
                        </div>
                    </div>
                </li>
                 <li><span class="label">成功奖励</span><span id="task-rewards" class="value"></span></li>
                <li><span class="label">失败惩罚</span><span id="task-penalties" class="value"></span></li>
                <li><span class="label">剩余时间</span><span id="task-time-left" class="value"></span></li>
            </ul>
        </div>
    </div>
</div>


 <div id="page-character-modal" class="modal page-modal wide">
    <div class="modal-content page-modal-content" style="max-width: 800px;">
        <button class="modal-close">×</button>



        <div class="char-tabs-nav">
            <button class="char-tab-btn active" data-tab="status">个人状态</button>
            <button class="char-tab-btn" data-tab="inventory">行囊与能力</button>
        </div>


        <div id="char-currency-display" class="char-currency-display">

        </div>


        <div class="char-tabs-content">


            <div id="char-tab-status" class="char-tab-panel active">
                <div id="page-character" class="page active">
                    <div class="character-display-grid">
                        <div class="char-panel left-panel">
                            <div id="char-titles-container" class="char-titles-container"></div>
                            <div id="char-display-name" class="char-name-display">用户</div>
                            <div class="char-info-box">
                                <div class="info-line" data-tooltip-key="status"><span class="info-label">状态</span><span id="char-display-status" class="info-value">正常</span></div>
                                <div class="info-line" data-tooltip-key="prestige"><span class="info-label">声望</span><span id="char-display-prestige" class="info-value">0</span></div>
                            <div class="info-line" id="bloodline-info-line" style="display: none;"> 
    <span class="info-label">血统</span>
    <span id="char-display-bloodline" class="info-value clickable-text"></span>
</div>    
                            </div>
                            <div class="resource-bar-container"><div class="resource-bar-label">生命值</div><div class="progress-bar-bg resource" data-tooltip-key="hp"><div id="char-hp-bar" class="progress-bar-fill hp"></div><span id="char-hp-text" class="progress-bar-text">50/50</span></div></div>
                            <div class="resource-bar-container"><div class="resource-bar-label">意志力</div><div class="progress-bar-bg resource" data-tooltip-key="willpower"><div id="char-will-bar" class="progress-bar-fill willpower"></div><span id="char-will-text" class="progress-bar-text">0/0</span></div></div>
                            <div class="resource-bar-container"><div id="char-energy-label" class="resource-bar-label">能量池</div><div class="progress-bar-bg resource" data-tooltip-key="energy"><div id="char-energy-bar" class="progress-bar-fill energy"></div><span id="char-energy-text" class="progress-bar-text">0/0</span></div></div>
                              <div id="dynamic-resource-bars-container"></div>
                        </div>
                        <div class="char-panel center-panel">
                            <div class="character-figure">
                                <div class="body-part head"></div><div class="body-part torso"></div><div class="body-part arm left"></div><div class="body-part arm right"></div><div class="body-part leg left"></div><div class="body-part leg right"></div>
                                <div class="equipment-slot slot-head" data-tooltip-key="equip_head"><span id="equip-head">头部: 无</span></div>
                                <div class="equipment-slot slot-body" data-tooltip-key="equip_body"><span id="equip-body">身体: 无</span></div>
                                <div class="equipment-slot slot-hands" data-tooltip-key="equip_hands"><span id="equip-hands">手部: 无</span></div>
                                <div class="equipment-slot slot-feet" data-tooltip-key="equip_feet"><span id="equip-feet">脚部: 无</span></div>
                                <div class="equipment-slot slot-accessory" data-tooltip-key="equip_accessory"><span id="equip-accessory">饰品: 无</span></div>
                                <div class="equipment-slot slot-weapon" data-tooltip-key="equip_weapon"><span id="equip-weapon">手持: 无</span></div>
                            </div>
                        </div>

                        <div class="char-panel right-panel" id="main-stats-container">

                        </div>
                    </div>
                </div>
            </div>


            <div id="char-tab-inventory" class="char-tab-panel">
                 <div class="inventory-grid">
                    <div class="inventory-section">
                        <h3 class="inventory-section-title">行囊物品</h3>
                        <div id="inventory-items-container" class="items-grid-container">

                        </div>
                    </div>
                    <div class="inventory-section">
                        <h3 class="inventory-section-title">掌握能力</h3>
                        <div id="other-skills-container" class="skills-grid-container">

                        </div>
                    </div>
                </div>
                 <button id="manage-inventory-btn" class="action-button" style="margin: 15px auto; display: block;">操作行囊</button>
            </div>

        </div>
    </div>
</div>



<div id="map-view-modal" class="modal page-modal wide">
    <div class="modal-content page-modal-content"  style="max-width: 800px;">
        <button class="modal-close">×</button>
        <div class="map-title" id="map-title">区域地图</div>
        <div id="map-view-content" class="page active">
             <div id="map-container" class="map-container">

             </div>
             <div id="external-areas" class="external-areas">
                    <h3>外部区域</h3>
                    <div id="external-areas-list" class="external-areas-list">

                    </div>
             </div>

                          <div id="parent-map-tabs-container" class="parent-map-tabs-container">
                    <h3>地图集</h3>
                    <div id="parent-map-tabs-list" class="parent-map-tabs-list">

                    </div>
             </div>

                  <div id="map-controls-container">
                <button id="zoom-in-btn" class="map-control-btn" title="放大">+</button>
                <button id="zoom-out-btn" class="map-control-btn" title="缩小">-</button>
                <button id="reset-view-btn" class="map-control-btn" title="复位">◎</button>
             </div>
        </div>
    </div>
</div>


<div id="summary-modal" class="modal page-modal">
     <div class="modal-content page-modal-content">
        <button class="modal-close">×</button>
        <div class="modal-title">过往总结</div>
        <div id="summary-content" class="page active">

        </div>
    </div>
</div>


<div id="shop-wrapper-modal" class="modal shop-modal">

</div>


    <div id="setting-book-wrapper" style="display: none;">
    <div class="setting-book-container">

        <header class="book-header">

            <button id="toggle-sidebar-btn" class="mobile-only-btn">☰</button>
            <h1 id="content-title">欢迎来到我们的世界</h1>

            <button id="back-to-status-btn">← 返回终端</button>
        </header>

        <div class="content-wrapper">
            <nav id="sidebar">
                <h2>记忆</h2>
                <div id="navigation-menu">

                </div>
            </nav>

            <main id="content-display">
                <div id="content-details">
                    <p>请从左侧导航栏中选择一个条目来查看详细设定。</p>
                    <p>这里记录着我们共同创造的每一个角色、每一处风景和每一段故事。愿它能带给你温暖与力量。</p>
                    <p id="error-message"></p>
                </div>
            </main>
        </div>


        <div id="sidebar-overlay"></div>
    </div>
</div>

<!-- Inventory Management Modal -->
<div id="inventory-modal" class="modal">
    <div class="modal-content">
        <button class="modal-close">&times;</button>
        <div class="modal-title">行囊管理</div>
        <p class="modal-description" style="font-size: 0.9em; text-align: left;">
            点击进行管理。
        </p>
        <ul id="inventory-item-list" class="inventory-item-list">
            <!-- 物品列表将在这里动态生成 -->
        </ul>
        <button id="delete-item-btn" class="action-button danger" disabled>丢弃选中物品</button>
         <button id="use-item-btn" class="action-button" disabled>使用选中物品</button>
    </div>
</div>


<!-- <div id="teammates-modal" class="modal">
    <div class="modal-content">
        <button class="modal-close">×</button>
        <div class="modal-title">队友信息</div>
        <div class="teammates-container">
            <div class="teammate-list-wrapper">
                <ul id="teammate-list" class="teammate-list">

                </ul>
            </div>
            <div id="teammate-info-display" class="teammate-info-display">
                <p style="color: var(--text-secondary-color); text-align: center; margin-top: 20px;">请从左侧选择一位队友以查看相关信息。</p>
            </div>
        </div>
    </div>
</div> -->

<!-- ============================================== -->
    <!-- ========== 新增：商店界面容器 (开始) ========== -->
    <!-- ============================================== -->
    <div id="shop-wrapper">
        <div class="shop-main-container">
            <!-- 商店头部 -->
           <header class="shop-header">
                <h1 class="shop-title">兑换中心</h1>
                <div class="shop-header-controls">
                     <button id="single-gacha-btn" class="control-btn gacha-btn" style="margin-right: 8px;">单抽 (160积分)</button>
    <button id="ten-gacha-btn" class="control-btn gacha-btn" style="margin-right: 8px;">十连抽 (1440积分)</button>
                    <button id="generate-items-btn" class="control-btn" style="margin-right: 8px;">生成</button>
                    <input type="text" id="shop-search-input" placeholder="搜索名称、效果、描述…">
                    <button id="back-from-shop-btn">← 返回终端</button>
                </div>
            </header>
    <div id="shop-currency-display" class="shop-currency-display">

        </div>
            <!-- 商店主体 -->
            <div class="shop-body-wrapper">
                <!-- 左侧：导航和购物车 -->
                <aside class="shop-sidebar">
                    <div class="shop-nav">
                        <h3>商品分区</h3>
                        <ul class="shop-nav-list">
                            <li><button class="shop-nav-item active" data-page="fixed">固定兑换</button></li>
                            <li><button class="shop-nav-item" data-page="random">随机商店</button></li>
                        </ul>
                    </div>
                    <div class="shop-cart">
                        <h3>购物车</h3>
                        <div id="cart-items-list">
                            <p>购物车是空的</p>
                        </div>
                        <div id="cart-total">总计: 0 积分</div>
                        <button id="checkout-button" disabled>确认购买</button>
                    </div>
                </aside>

                <!-- 右侧：商品展示区 -->
                <main class="shop-content-area">
                    <!-- 固定商品页面 -->
                    <div id="page-fixed-shop" class="shop-page active">
                        <div class="shop-controls">
                            <div class="category-tabs">
                                <button class="control-btn active" data-section="fixed" data-category="all">全部</button>
                                <button class="control-btn" data-section="fixed" data-category="物品">物品</button>
                                <button class="control-btn" data-section="fixed" data-category="技能">技能</button>
                                <button class="control-btn" data-section="fixed" data-category="基础技能">基础技能</button>
                                <button class="control-btn" data-section="fixed" data-category="家具">家具</button>
                            </div>
                            <div class="sort-controls">
                                <button class="control-btn active" data-section="fixed" data-sort="asc">价格升序</button>
                                <button class="control-btn" data-section="fixed" data-sort="desc">价格降序</button>
                            </div>
                        </div>
                        <div class="shop-display-wrapper">
                            <div id="items-display-list-fixed" class="items-display-list"></div>
                            <div id="item-details-display-fixed" class="item-details-display">
                                <div class="detail-placeholder">选择商品查看详情</div>
                            </div>
                        </div>
                        <div id="pagination-fixed" class="shop-pagination"></div>
                    </div>

                    <!-- 随机商品页面 -->
                    <div id="page-random-shop" class="shop-page">
                        <div class="shop-controls">
                            <div class="category-tabs">
                                <button class="control-btn active" data-section="random" data-category="all">全部</button>
                                <button class="control-btn" data-section="random" data-category="物品">物品</button>
                                <button class="control-btn" data-section="random" data-category="技能">技能</button>
                                <button class="control-btn" data-section="random" data-category="家具">家具</button>
                            </div>
                            <div class="sort-controls">
                                <button class="control-btn active" data-section="random" data-sort="asc">价格升序</button>
                                <button class="control-btn" data-section="random" data-sort="desc">价格降序</button>
                            </div>
                        </div>
                         <div class="shop-display-wrapper">
                            <div id="items-display-list-random" class="items-display-list"></div>
                            <div id="item-details-display-random" class="item-details-display">
                                <div class="detail-placeholder">选择商品查看详情</div>
                            </div>
                        </div>
                        <div id="pagination-random" class="shop-pagination"></div>
                    </div>
                </main>
            </div>
        </div>
    </div>
    <!-- 商店模态框 (沿用终端的样式) -->
    <div id="shop-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <div id="shop-modal-title" class="modal-title">提示</div>
            <div id="shop-modal-message" class="modal-description"></div>
        </div>
    </div>


    <!-- 抽奖模态框 -->
<div id="gacha-modal" class="modal">
    <div class="modal-content gacha-modal-content">
        <button class="modal-close">&times;</button>
        <div id="gacha-modal-title" class="modal-title">抽奖结果</div>
        <div id="gacha-animation-container" class="gacha-animation-container">
            
            <!-- 抽奖动画区域 -->
        </div>
        <div id="gacha-results-summary" class="gacha-results-summary"></div>
        <div id="gacha-results" class="gacha-results">
            <!-- 抽奖结果显示 -->
        </div>
        <button id="gacha-confirm-btn" class="control-btn" style="display: none;">确认</button>
    </div>
</div>

    <!-- ========== 新增：商店界面容器 (结束) ========== -->
<div id="roll-result-modal" class="modal">
    <div class="modal-content" style="max-width: 800px; width: 90%;">
        <button class="modal-close">×</button>
        <div id="roll-result-modal-title" class="modal-title">上一轮投掷详情</div>
        <div id="roll-result-modal-content" class="modal-description" style="text-align: left; max-height: 70vh; overflow-y: auto; padding-right: 15px;">
    </div>
</div>

</div>
<div id="keyword-modal" class="modal">
    <div class="modal-content">

        <button class="modal-close">×</button>
        <h2>额外生成要求</h2>
        <p>请输入一些关键词或要求（可选），它们将被注入到提示中。例如：“价格低于10000”、“和火焰有关”、“只能是C级的血统”。</p>
       <textarea id="keyword-input" placeholder="输入关键词，留空则使用默认提示..."></textarea>


<div id="model-selector-container" class="model-selector">
    <span class="selector-label">选择模型:</span>
    <div class="switch-container">
        <button id="model-flash" class="switch-btn active" data-model="gemini-2.5-flash">Flash</button>
        <button id="model-pro" class="switch-btn" data-model="gemini-2.5-pro">Pro</button>
    </div>
</div>


<div class="modal-buttons">
    <button id="api-key-config-btn" class="control-btn">设置密钥</button>
    <button id="submit-generation-btn" class="control-btn">开始生成</button>
    <button id="skip-generation-btn" class="control-btn grey">跳过并生成</button>
</div>
    </div>
</div>
 




</div>

<div id="skill-choice-panel" class="modal">
 <div class="modal-content" style="max-width: 800px; width: 95%;">
    <button class="modal-close">×</button>
    <div class="modal-title">发动术式</div>

    <div class="skill-choice-container">

 


        <div class="bottom-section">


            <div class="other-skills-group">
                <h3>可用术法</h3>
                <div id="other-skills-area" class="skills-list">

                </div>
            </div>


            <div class="willpower-group">
                <h3>投入意志力</h3>
                <div class="willpower-display">
                    <input type="number" id="willpower-input" min="0" value="0" readonly> 
                    <span id="willpower-max">/ 0</span>
                </div>
                <div class="willpower-slider-container">
                    <input type="range" id="willpower-slider" value="0" min="0" step="1">
                </div>
                <div class="skill-info">每点意志力为检定池+1 DP</div>
            </div>

        </div>
    </div>
    <button id="confirm-skill-choice-btn" class="action-button">确认发动</button>
</div>

</div>


    <div id="world-book-modal" class="modal">
        <div class="book-content">
            <button class="book-close-btn"> </button>
            <div class="book-left-page">
                <div class="book-bookmarks">

                    <div class="bookmark" data-tab="global_npc">全局人物</div>
                    <div class="bookmark" data-tab="global_settings">全局设定</div>
                    <div class="bookmark" data-tab="global_背包">你的背包</div>
                    <div class="bookmark" data-tab="global_其他技能">你的技能</div>
                    <div class="bookmark" data-tab="group_member" id="group_member_bookmark">小队信息</div>
                     <div class="bookmark" data-tab="npc" id="world_npc_bookmark">世界人物</div>
                    <div class="bookmark active" data-tab="settings" id="world_settings_bookmark">世界设定</div>
                    <div class="bookmark" data-tab="things" id="things_bookmark">备忘录</div>
                     <div class="bookmark" data-tab="the_created" id="the_created_bookmark">$#%</div> 
                   
                </div>
            </div>
            <div class="book-right-page">
                <div id="book-display-area" class="book-display-area">
                    <!-- 内容将在这里动态生成 -->
                </div>
                <div class="book-pagination">
                    <button id="book-prev-page" class="page-turn-btn left">‹</button>
                    <span id="book-page-info">1 / 1</span>
                    <button id="book-next-page" class="page-turn-btn right">›</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ========== 新增：世界之书弹窗 (结束) ========== -->

 
 <div id="plot-synthesis-modal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <button class="modal-close">×</button>
        <div class="modal-title">支线剧情管理</div>
        <div class="modal-description" style="text-align: left; margin-bottom: 20px;">
            所有操作将在此处模拟，直到你点击“确认执行”。
        </div>


        <div class="plot-simulation-container">
            <div id="current-plots-display" class="plot-column">
                <h4>当前持有</h4>

            </div>
            <div class="arrow-separator">→</div>
            <div id="simulated-plots-display" class="plot-column">
                <h4>操作预览</h4>

            </div>
        </div>


        <div class="synthesis-section">
            <h4>分解高级支线 (3:1)</h4>
            <div class="synthesis-controls">
                <select id="decompose-from-select">
                    <option value="S">S 级</option>
                    <option value="A">A 级</option>
                    <option value="B">B 级</option>
                    <option value="C">C 级</option>
                </select>
                <input type="number" id="decompose-amount-input" min="1" value="1" style="width: 60px;">
                <button id="execute-decomposition-btn" class="action-button small">↓ 分解</button>
            </div>
        </div>

        <div class="synthesis-section">
            <h4>合成高级支线 (3:1)</h4>
            <div class="synthesis-controls">
                <select id="synthesize-to-select">
                    <option value="C">← C 级 (需 3 D)</option>
                    <option value="B">← B 级 (需 3 C)</option>
                    <option value="A">← A 级 (需 3 B)</option>
                    <option value="S">← S 级 (需 3 A)</option>
                </select>
                <input type="number" id="synthesize-amount-input" min="1" value="1" style="width: 60px;">
                <button id="execute-synthesis-btn" class="action-button small">↑ 合成</button>
            </div>
        </div>


        <div class="final-actions">
             <button id="reset-simulation-btn" class="action-button grey">重置操作</button>
             <button id="confirm-synthesis-btn" class="action-button highlight">确认执行</button>
        </div>
    </div>
</div>

 <div id="context-menu" style="display: none; position: fixed;    padding: 5px; border-radius: 5px; ">
    <div class="context-menu-item" data-action="edit">编辑楼层</div>
    <div class="context-menu-item" data-action="delete">删除楼层</div>
    <div class="context-menu-item" data-action="copy">复制</div>
 
</div>
  <div id="char-tooltip" class="char-tooltip"></div>

          <div id="location-modal" class="modal">
            <div class="modal-content" style="max-width: 800px;">
                <button class="modal-close">&times;</button>
                <div id="location-modal-title" class="modal-title">地点名称</div>
                <div id="location-modal-description" class="modal-description">
                    环境描述将在这里显示
                </div>
                <button class="action-button" id="go_to_location_btn" style="max-width: 30%;margin: 10px; align-self: center;left:35%">前往</button>
                           </div>
        </div>

        <div id="command-modal" class="modal">
    <div class="modal-content" style="width: 90vh; max-width: 800px; max-height: 80vh;">
        <div class="modal-header">
            <h2 class="modal-title">编辑待发指令</h2>
            <button class="modal-close">&times;</button>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; gap: 10px;">
            <p style="color: var(--text-secondary-color); font-size: 14px; margin-bottom: 0;">这些指令将在下次点击“发送”时，附加在你的消息最前方一起发送。</p>
            <textarea id="command-edit-area" style="width: 100%; height: 250px; background-color: rgba(0,0,0,0.3); color: var(--text-color); border: 1px solid var(--border-color); padding: 10px; box-sizing: border-box; resize: vertical;"></textarea>
        </div>
        <div class="modal-footer">
            <button id="save-command-btn" class="action-button">保存并关闭</button>
        </div>
    </div>
</div>

<div id="roll-result-card-container" class="roll-result-card-container"></div>


<div id="settings-modal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <button class="modal-close">×</button>
        <div class="modal-title">系统设置</div>
        
        <button id="achievements-btn" title="成就">🏆</button>
        <button id="debug-clear-achievements" title="清除成就数据(调试用)" style="
        display: none;
    background: none;
    border: 1px solid #ff4444;
    color: #ff4444;
    font-size: 0.8em;
    cursor: pointer;
    padding: 2px 6px;
    margin-left: 5px;
    border-radius: 3px;
    transition: all 0.3s ease;
    opacity: 0.6;
" onmouseover="this.style.opacity='1'; this.style.background='#ff4444'; this.style.color='white';" onmouseout="this.style.opacity='0.6'; this.style.background='none'; this.style.color='#ff4444';">🗑️</button>

 
        <div class="settings-container">
        
             <div class="setting-item">
                <label>上次对话Token消耗</label>
                <span id="last-token-display" style="font-weight: bold; color: var(--accent-color);">N/A</span>
            </div>
            <div class="setting-item">
    <label>模组重置</label>
    <button id="open-reconfig-modal-btn" class="control-btn-special">调整模组</button>
</div>
                      <div class="setting-item">
                <label>系统更新检查</label>
                <button id="check-for-updates-btn" class="control-btn">检查更新</button>
            </div>
            <div class="setting-item">
            <label>界面主题</label>
            <button id="modal-theme-switcher" class="control-btn">切换主题</button>
        </div>



                <div class="setting-item">
            <label>自定义主题</label>
            <div class="custom-theme-controls">
                <button id="apply-custom-theme-btn" class="control-btn">应用自定义</button>
                <button id="edit-custom-theme-btn" class="control-btn" style="margin-left: 10px;">编辑</button>
            </div>
        </div>

        <div id="custom-theme-editor" class="setting-item-column" style="display: none;">
            <label>颜色编辑器</label>
            <div id="color-picker-container">

            </div>
            <p style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">拖动颜色可实时预览效果。</p>
        </div>


        <div class="setting-item">
            <label for="streaming-toggle">流式传输</label>
            <div class="switch-container">
                <button id="streaming-toggle" class="switch-btn" data-state="on">开启</button>
            </div>
        </div>
        <div class="setting-item">
    <label for="roll-card-toggle">骰子看板</label>
    <div class="switch-container">
        <button id="roll-card-toggle" class="switch-btn" data-state="on">开启</button>
    </div>
</div>
         <div class="setting-item">
    <label for="fullscreen-toggle">全屏模式</label>
    <div class="switch-container">

        <button id="fullscreen-btn2" class="switch-btn">进入全屏</button>
    </div>
</div>
<div class="setting-item">
    <label for="font-size-slider">界面字体大小</label>
    <div class="font-size-controls">
        <input type="range" id="font-size-slider" min="12" max="30" step="1" value="16">
        <span id="font-size-value">16px</span>
    </div>
</div>
<div class="setting-item">
    <label for="line-height-slider">段落行间距</label>
    <div class="line-height-controls"> 
        <input type="range" id="line-height-slider" min="1.2" max="3.0" step="0.1" value="1.6">
        <span id="line-height-value">1.6</span>
    </div>
</div>
        <div class="setting-item">
    <label for="line-height-more">段落换行</label>
    <div class="switch-container">
        <button id="line-height-more" class="switch-btn" data-state="on">开启</button>
    </div>
</div>

<div class="setting-item">
    <label for="transparent-toggle">消息背景透明</label>
    <div class="switch-container">
        <button id="transparent-toggle" class="switch-btn" data-state="off">关闭</button>
    </div>
</div>

 <div class="setting-item">
    <label for="font-family-selector">界面字体</label>
    <select id="font-family-selector" class="control-btn" style="width: 220px; text-align: left; padding: 5px 8px;"></select>
</div>
<div class="setting-item" id="archive-naming-container" style="margin-top: 20px;">
    <label for="archive-name-input">设置存档名称</label>
    <div class="archive-name-controls">
        <input type="text" id="archive-name-input" placeholder="为这段记忆命名...">
        <button id="set-archive-name-btn" class="control-btn">设定</button>
    </div>
</div>


        <div class="setting-item">
            <label>数据导入</label>
            <button id="modal-import-btn" class="control-btn">导入存档</button>
            <input type="file" id="modal-file-importer" style="display:none" accept=".json">
        </div>
        <div id="modal-log-block" class="log-output">等待操作...</div>

        <div class="setting-item">
            <label>数据导出</label>
            <button id="modal-export-btn" class="control-btn">导出存档</button>
        </div>
        <div id="modal-export-status" class="log-output"></div>

        <div class="setting-item-column" id="snapshot-management-container" style="margin-top: 20px;">
    <label>记忆快照删除管理（排列是按照时间顺序来的，一般不用管这个）</label>
    <div class="db-controls">
        <button id="refresh-snapshots-btn" class="control-btn">刷新列表</button>
        <button id="restore-latest-snapshot-btn" class="control-btn special-btn" title="从当前浏览器存在的最新一份快照中恢复。">恢复至最新快照</button>
        <button id="delete-all-snapshots-btn" class="control-btn danger-btn">清除所有快照</button>
    </div>
    <div id="snapshot-list" class="log-output" style="max-height: 150px; overflow-y: auto;">
        点击“刷新列表”来查看所有存档的快照...
    </div>
</div>
<div id="custom-asset-container" class="setting-item-column" style="margin-top: 20px;">
    <label>我的素材工坊</label>
    <div class="custom-asset-tabs">
        <button class="asset-tab-btn active" data-target="npc-panel">自定义立绘</button>
        <button class="asset-tab-btn" data-target="meme-panel">自定义表情</button>
    </div>


    <div id="npc-panel" class="asset-panel active">
        <form id="upload-npc-form" class="asset-upload-form">
            <p>上传新的立绘 (PNG/JPG/GIF)</p>
            <input type="text" id="npc-name-input" placeholder="为立绘命名 (如：白发魔女)" required>
            <div class="file-input-wrapper">
                <input type="file" id="npc-file-input" accept="image/*" required>
                <button type="button" onclick="document.getElementById('npc-file-input').click()" class="control-btn">选择文件</button>
                <span class="file-name-display">未选择文件</span>
            </div>
            <button type="submit" class="control-btn primary">上传立绘</button>
        </form>
        <div class="asset-list-container">
            <p>已上传的立绘</p>
            <div id="custom-npc-list" class="asset-list">正在加载...</div>
        </div>
    </div>


    <div id="meme-panel" class="asset-panel">
        <form id="upload-meme-form" class="asset-upload-form">
            <p>上传新的表情 (PNG/JPG/GIF)</p>
            <input type="text" id="meme-name-input" placeholder="为表情命名 (如：猫猫震惊)" required>
            <div class="file-input-wrapper">
                <input type="file" id="meme-file-input" accept="image/*" required>
                <button type="button" onclick="document.getElementById('meme-file-input').click()" class="control-btn">选择文件</button>
                <span class="file-name-display">未选择文件</span>
            </div>
            <button type="submit" class="control-btn primary">上传表情</button>
        </form>
        <div class="asset-list-container">
            <p>已上传的表情</p>
            <div id="custom-meme-list" class="asset-list">正在加载...</div>
        </div>
    </div>
</div>
    </div>
</div>
</div>

<div id="reconfig-modal" class="modal-overlay" style="display: none; z-index: 99999999;">
    <div class="reconfig-modal-content">
        <button id="reconfig-modal-close-btn" class="reconfig-modal-close">×</button>
        <h2 class="reconfig-title">模组设定</h2>
        <p class="reconfig-subtitle">随时调整故事的规则。</p>    <div id="reconfig-mod-container" class="reconfig-grid">

    </div>

    <div class="reconfig-footer">
        <span id="reconfig-feedback-msg" class="reconfig-feedback"></span>
        <button id="apply-reconfig-btn" class="reconfig-apply-btn">应用更改</button>
    </div>
</div>
</div>

<div id="group-chat-modal-container" class="group-chat-modal">
  <div id="group-chat-root" class="group-chat-main-container">

  </div>
</div>


<div id="reading-mode-container" class="reading-mode-hidden">
    <div id="reading-mode-backdrop"></div>
    <div id="reading-mode-modal">
        <div class="reading-mode-header">
              <div id="reading-mode-toggle-chapters" class="chapters-toggle-btn">目录</div>
    <span id="reading-mode-chapter-title"></span>
    <div id="reading-mode-close-btn">×</div>
        </div>
        <div class="reading-mode-body">
            <div id="reading-mode-chapters-nav">
                <div class="chapters-nav-header">章节目录</div>
                <ul id="reading-mode-chapters-list"></ul>
            </div>
            <div id="reading-mode-content-wrapper">
                <div class="nav-arrow left-arrow" id="reading-mode-prev-btn"><</div>
                <div id="reading-mode-content"></div>
                <div class="nav-arrow right-arrow" id="reading-mode-next-btn">></div>
            </div>
        </div>
        <div id="mobile-nav-bar">
    <div class="nav-arrow" id="mobile-prev-btn">&lt;</div>
    <div class="nav-arrow" id="mobile-next-btn">&gt;</div>
</div>
    </div>
</div>



    <div id="battle-overlay">
        <div id="battle-container">
            <div class="battle-arena">
                <div id="enemy-side" class="side enemy-side">
                    <!-- 敌人会动态生成在这里 -->
                </div>
                <div id="player-side" class="side player-side">
                    <!-- 玩家和队友会动态生成在这里 -->
                </div>
            </div>

 <footer class="battle-controls">
    <div class="battle-left-panel">
        <div class="battle-log-container" id="battle-log">

        </div>
        <div id="speed-control-container">
            <label for="speed-slider">速度:</label>
            <input type="range" id="speed-slider" min="0" max="3" value="1">
            <span id="speed-label">正常</span>
                <div id="icon-selector" style="display: flex; align-items: center; gap: 5px; margin-left: 15px; cursor: pointer;">
        <label>徽记:</label>
        <span id="player-icon-display" style="font-size: 20px;" title="点击更换你的战斗徽记">✨</span>
    </div>
      <div id="auto-battle-control" style="display: flex; align-items: center; gap: 5px; margin-left: 15px; cursor: pointer;">
        <label for="auto-battle-checkbox">自动:</label>
        <input type="checkbox" id="auto-battle-checkbox" title="开启后，你的回合将由AI自动操作">
    </div>
        </div>
    </div>
    <div class="action-panel" id="action-panel">
        <button data-action="attack">攻击</button>
        <button data-action="persuade">说服</button>
         <button data-action="scan">侦察</button>
        <button data-action="steal">盗窃</button>
        <button data-action="treat">治疗</button>
        <button data-action="defend">防御</button>
        <button data-action="flee">逃跑</button>
        <button data-action="item">物品/技能</button>
    </div>
</footer>
        </div>
    </div>

    <div id="dice-pool-selector">
        <h3>选择你的骰池</h3>
        <div id="pool-options" class="pool-options">
            <!-- 骰池选项会在这里生成 -->
        </div>
        <button id="confirm-pool-btn">确认</button>
    </div>
<div id="notification-container"></div>
<div id="item-skill-panel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; max-height: 70vh; background-color: var(--container-bg-color); border: 1px solid var(--primary-color); padding: 20px; border-radius: 10px; box-shadow: 0 0 20px var(--glow-color); z-index: 10000; flex-direction: column; gap: 15px;">
    <h3 style="margin: 0; color: var(--primary-color); text-align: center;">行囊与能力</h3>
    <div style="display: flex; gap: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px;">
        <button class="tab-btn active" onclick="showTab('items')">物品</button>
        <button class="tab-btn" onclick="showTab('skills')">技能</button>
    </div>
    <div id="items-tab" class="tab-content" style="overflow-y: auto; padding-right: 10px;">

    </div>
    <div id="skills-tab" class="tab-content" style="display: none; overflow-y: auto; padding-right: 10px;">

    </div>
    <div style="text-align: center; margin-top: 15px;">
        <button id="close-item-skill-panel-btn" style="padding: 8px 16px; color: var(--secondary-color); background-color: transparent; border: 1px solid var(--secondary-color); border-radius: 4px; cursor: pointer;">关闭</button>
    </div>
</div>

 <div id="battle-prompt-overlay" style="display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 35%; /* 只覆盖底部约三分之一的区域 */ background: linear-gradient(to top, var(--background-color) 30%, transparent); z-index: 2000; justify-content: center; align-items: center; pointer-events: all; /* 关键：让它阻挡点击 */">
    <button id="enter-battle-btn" class="start-battle-btn" style="transform: scale(1.2);">⚔️ 进入战斗 ⚔️</button>
</div>
<div id="attack-mode-selector" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); background-color: var(--container-bg-color); border: 1px solid var(--primary-color); padding: 20px; border-radius: 10px; box-shadow: 0 0 20px var(--glow-color); z-index: 10001; text-align: center;">
    <h4 style="margin-top: 0; color: var(--primary-color);">选择攻击模式</h4>
    <div style="display: flex; flex-direction: column; gap: 10px;">
        <button id="select-single-target" class="attack-mode-btn">单体攻击</button>
        <button id="select-multi-target" class="attack-mode-btn">群攻 (自定义)</button>
        <button id="select-all-targets" class="attack-mode-btn">群攻 (全体)</button>
    </div>
    <button id="cancel-attack-mode" style="margin-top: 15px;">取消</button>
</div>
</body>
 <script>
 
let storyChapters = [];
let currentChapterIndex = 0;
let isReadingModeOpen = false;

 const processedImageCache = new Map();
let userName = '用户';
  // 妈妈为你设定的世界书ID
    const LOREBOOK_NAME = "小蝌蚪找妈妈-同层版";
    const LOREBOOK_UID = 30;
      // 妈妈为你整理的世界观模式UID
    const WORLD_MODE_UIDS = {
        'all': [1, 5, 22],
        'reincarnation': 22,
        'infinite': 5,
        'godspace': 1
    };
    const CREATOR_ATTITUDE_UIDS = {
        'all': [19, 4, 3],
        'neutral': 19,
        'malicious': 4,
        'reverent': 3
    };
    const OPTIONS_MODE_UIDS = {
        'all': [10, 29],
        'on': 10,
        'off': 29
    };
       // 💖 唯一真身守护咒语 (外部HTML版) 💖
    if (window.isZeroLevelUIInitialized) {
        //console.log("[HTML] ⚠️ 检测到重复召唤，已启动守护屏障，阻止了UI脚本的第二次初始化。");
    } else {
        window.isZeroLevelUIInitialized = true;
        //console.log("[HTML] ✨ UI脚本首次启动，已盖上唯一灵魂印记。");
    'use strict';
    
    
      const themes = [
    // --- 你最初的赛博朋克系列，它们是基石 ---
    { // 主题一：赛博蓝 (Cyber Blue)
        '--primary-color': '#00faff',
        '--secondary-color': '#7affff',
        '--container-bg-color': 'rgba(10, 25, 47, 0.75)',
        '--border-color': 'rgba(0, 250, 255, 0.3)',
        '--glow-color': 'rgba(0, 250, 255, 0.5)',
        '--background-color': '#0a192f',
        '--text-color': '#e6f1ff', // 明亮的蓝白色，确保在深色背景下清晰
         '--text-secondary-color': '#ffe6e6',
    },
    { // 主题二：警戒红 (Warning Red)
        '--primary-color': '#ff4d4d',
        '--secondary-color': '#ff8c8c',
        '--container-bg-color': 'rgba(47, 10, 10, 0.75)',
        '--border-color': 'rgba(255, 77, 77, 0.4)',
        '--glow-color': 'rgba(255, 77, 77, 0.6)',
        '--background-color': '#2f0a0a',
        '--text-color': '#ffe6e6', // 柔和的红色调白色，与主题呼应
        '--text-secondary-color': '#ffe6e6',
    },
    { // 主题三：矩阵绿 (Matrix Green)
        '--primary-color': '#39ff14',
        '--secondary-color': '#bfffb3',
        '--container-bg-color': 'rgba(10, 47, 15, 0.75)',
        '--border-color': 'rgba(57, 255, 20, 0.4)',
        '--glow-color': 'rgba(57, 255, 20, 0.6)',
        '--background-color': '#0a2f0a',
        '--text-color': '#e6ffe8', // 带有微绿的亮色，经典代码感
         '--text-secondary-color': '#ffe6e6',
    },
    { // 主题四：深空紫 (Deep Space Purple)
        '--primary-color': '#c48cff',
        '--secondary-color': '#e1c6ff',
        '--container-bg-color': 'rgba(25, 10, 47, 0.75)',
        '--border-color': 'rgba(196, 140, 255, 0.4)',
        '--glow-color': 'rgba(196, 140, 255, 0.6)',
        '--background-color': '#190a2f',
        '--text-color': '#f3e6ff', // 浅紫色调的白色，增添神秘感
         '--text-secondary-color': '#ffe6e6',
    },

    
    { // 主题七：战地迷彩 (Military Olive)
        '--primary-color': '#808000',
        '--secondary-color': '#C3B091',
        '--container-bg-color': 'rgba(47, 53, 49, 0.8)',
        '--border-color': 'rgba(128, 128, 0, 0.4)',
        '--glow-color': 'rgba(128, 128, 0, 0.3)',
        '--background-color': '#2E3430',
        '--text-color': '#E5E4E2', // 略带灰度的战术白，冷静实用
         '--text-secondary-color': '#ffe6e6',
    },
      { // 主题五：古籍羊皮纸
         '--text-color': '#6a6253', // 略带灰度的战术白，冷静实用
            '--primary-color': '#7d6b54',          // 主题色，源自“选中书签背景色”
            '--secondary-color': '#a08c72',        // 次要色，源自“书签默认背景色”
            '--text-primary-color': '#6d5b4b',      // 主文字色
            '--text-secondary-color': '#8b7963',   // 次文字色
            '--container-bg-color': 'rgba(243,234,206,0.75)',     // 容器背景，源自“书本内容区背景”
            '--border-color': 'rgba(200,184,154,0,4)',           // 边框色，源自“分割线颜色”
            '--glow-color': 'rgba(200,184,154,0,3)',             // 辉光色，用边框色来强化质感，而非发光
            '--background-color': '#fdfaf2'        // 整体背景色
        },
        { // 主题：经典黑白 (Classic Monochrome)
    '--primary-color': '#ffffff',
    '--secondary-color': '#cccccc',
    '--container-bg-color': 'rgba(40, 40, 40, 0.85)',
    '--border-color': 'rgba(255, 255, 255, 0.3)',
    '--glow-color': 'rgba(255, 255, 255, 0.4)',
    '--background-color': '#1a1a1a',
    '--text-color': '#f5f5f5',
    '--text-secondary-color': '#d0d0d0',
},
{ // 主题：极简灰白 (Minimal Grey)
    '--primary-color': '#000000',
    '--secondary-color': '#f5f5f5',
    '--container-bg-color': 'rgba(248, 248, 248, 0.9)',
    '--border-color': 'rgba(200, 200, 200, 0.5)',
    '--glow-color': 'rgba(180, 180, 180, 0.3)',
    '--background-color': '#ffffff',
    '--text-color': '#000000',
    '--text-secondary-color': '#333333',
},

{ // 主题：午夜蓝粉 (Midnight Blush)
    '--primary-color': '#ff80bf',
    '--secondary-color': '#ffb3d9',
    '--container-bg-color': 'rgba(25, 30, 45, 0.8)',
    '--border-color': 'rgba(255, 128, 191, 0.4)',
    '--glow-color': 'rgba(255, 128, 191, 0.5)',
    '--background-color': '#0f1419',
    '--text-color': '#e6f0ff',
    '--text-secondary-color': '#ffe6f2',
}
    
 
];
      // 背景图片映射表
const backgroundImageMap_fallbackData =   {
    "现代建筑群-BrightDay-Peaceful": "https://files.catbox.moe/ki5j2t.png",
    "现代建筑群-BrightDay-Decay": "https://files.catbox.moe/hc3hyj.png",
    "现代建筑群-BrightDay-Dynamic": "https://files.catbox.moe/wga736.png",
    "现代建筑群-BrightDay-Eerie": "https://files.catbox.moe/tg1uwg.png",
    "现代建筑群-OvercastDay-Peaceful": "https://files.catbox.moe/1gxhka.png",
    "现代建筑群-OvercastDay-Decay": "https://files.catbox.moe/xapaxa.png",
    "现代建筑群-OvercastDay-Dynamic": "https://files.catbox.moe/k36908.png",
    "现代建筑群-OvercastDay-Eerie": "https://files.catbox.moe/ec0q9y.png",
    "现代建筑群-GoldenHour-Peaceful": "https://files.catbox.moe/y3l604.png",
    "现代建筑群-GoldenHour-Decay": "https://files.catbox.moe/ts623u.png",
    "现代建筑群-GoldenHour-Dynamic": "https://files.catbox.moe/3rf2uk.png",
    "现代建筑群-GoldenHour-Eerie": "https://files.catbox.moe/zyg7m1.png",
    "现代建筑群-DeepNight-Peaceful": "https://files.catbox.moe/8m854e.png",
    "现代建筑群-DeepNight-Decay": "https://files.catbox.moe/y2pkfs.png",
    "现代建筑群-DeepNight-Dynamic": "https://files.catbox.moe/uh1vrp.png",
    "现代建筑群-DeepNight-Eerie": "https://files.catbox.moe/h2wugc.png",
    "现代建筑群-ArtificialLight-Peaceful": "https://files.catbox.moe/yuszwp.png",
    "现代建筑群-ArtificialLight-Decay": "https://files.catbox.moe/vuz182.png",
    "现代建筑群-ArtificialLight-Dynamic": "https://files.catbox.moe/s86gut.png",
    "现代建筑群-ArtificialLight-Eerie": "https://files.catbox.moe/p6nowg.png",
   
    "拱门建筑室内-BrightDay-Peaceful": "https://files.catbox.moe/d214yn.png",
    "拱门建筑室内-BrightDay-Decay": "https://files.catbox.moe/kwfnhn.png",
    "拱门建筑室内-BrightDay-Dynamic": "https://files.catbox.moe/uy3kte.png",
    "拱门建筑室内-BrightDay-Eerie": "https://files.catbox.moe/jbmskc.png",
    "拱门建筑室内-OvercastDay-Peaceful": "https://files.catbox.moe/81e8nc.png",
    "拱门建筑室内-OvercastDay-Decay": "https://files.catbox.moe/6entar.png",
    "拱门建筑室内-OvercastDay-Dynamic": "https://files.catbox.moe/h39raz.png",
    "拱门建筑室内-OvercastDay-Eerie": "https://files.catbox.moe/m3xp9i.png",
    "拱门建筑室内-GoldenHour-Peaceful": "https://files.catbox.moe/7ys6wf.png",
    "拱门建筑室内-GoldenHour-Decay": "https://files.catbox.moe/lbcd5b.png",
    "拱门建筑室内-GoldenHour-Dynamic": "https://files.catbox.moe/zeam8z.png",
    "拱门建筑室内-GoldenHour-Eerie": "https://files.catbox.moe/dx685v.png",
    "拱门建筑室内-DeepNight-Peaceful": "https://files.catbox.moe/5g5a7z.png",
    "拱门建筑室内-DeepNight-Decay": "https://files.catbox.moe/lvw1a3.png",
    "拱门建筑室内-DeepNight-Dynamic": "https://files.catbox.moe/al84vh.png",
    "拱门建筑室内-DeepNight-Eerie": "https://files.catbox.moe/inptoq.png",
    "拱门建筑室内-ArtificialLight-Peaceful": "https://files.catbox.moe/v9i1ed.png",
    "拱门建筑室内-ArtificialLight-Decay": "https://files.catbox.moe/7gzrfu.png",
    "拱门建筑室内-ArtificialLight-Dynamic": "https://files.catbox.moe/h3uytp.png",
    "拱门建筑室内-ArtificialLight-Eerie": "https://files.catbox.moe/k2m4e6.png",
    
    "Wasteland-BrightDay-Peaceful": "https://files.catbox.moe/uxe76e.png",
    "Wasteland-BrightDay-Decay": "https://files.catbox.moe/a21n5h.png",
    "Wasteland-BrightDay-Dynamic": "https://files.catbox.moe/7673rq.png",
    "Wasteland-BrightDay-Eerie": "https://files.catbox.moe/et0qkv.png",
    "Wasteland-OvercastDay-Peaceful": "https://files.catbox.moe/hn0y8a.png",
    "Wasteland-OvercastDay-Decay": "https://files.catbox.moe/yixtu9.png",
    "Wasteland-OvercastDay-Dynamic": "https://files.catbox.moe/q5nhyx.png",
    "Wasteland-OvercastDay-Eerie": "https://files.catbox.moe/dwd4ei.png",
    "Wasteland-GoldenHour-Peaceful": "https://files.catbox.moe/pnfws9.png",
    "Wasteland-GoldenHour-Decay": "https://files.catbox.moe/14tzmg.png",
    "Wasteland-GoldenHour-Dynamic": "https://files.catbox.moe/bvaf8y.png",
    "Wasteland-GoldenHour-Eerie": "https://files.catbox.moe/bci8rh.png",
    "Wasteland-DeepNight-Peaceful": "https://files.catbox.moe/x3o7eg.png",
    "Wasteland-DeepNight-Decay": "https://files.catbox.moe/z3vn77.png",
    "Wasteland-DeepNight-Dynamic": "https://files.catbox.moe/9k86lc.png",
    "Wasteland-DeepNight-Eerie": "https://files.catbox.moe/1yoxrp.png",
    "Wasteland-ArtificialLight-Peaceful": "https://files.catbox.moe/abgocm.png",
    "Wasteland-ArtificialLight-Decay": "https://files.catbox.moe/icgzf1.png",
    "Wasteland-ArtificialLight-Dynamic": "https://files.catbox.moe/yjfr62.png",
    "Wasteland-ArtificialLight-Eerie": "https://files.catbox.moe/pv9gqj.png" ,
    "ModernUrbanStreet-BrightDay-Peaceful": "https://files.catbox.moe/dhes3d.png",
    "ModernUrbanStreet-BrightDay-Decay": "https://files.catbox.moe/l21256.png",
    "ModernUrbanStreet-BrightDay-Dynamic": "https://files.catbox.moe/ui2pwt.png",
    "ModernUrbanStreet-OvercastDay-Peaceful": "https://files.catbox.moe/4najy9.png",
    "ModernUrbanStreet-OvercastDay-Decay": "https://files.catbox.moe/6shm0c.png",
    "ModernUrbanStreet-OvercastDay-Dynamic": "https://files.catbox.moe/3mnzmg.png",
    "ModernUrbanStreet-GoldenHour-Peaceful": "https://files.catbox.moe/0x5f9m.png",
    "ModernUrbanStreet-GoldenHour-Decay": "https://files.catbox.moe/097oga.png",
    "ModernUrbanStreet-GoldenHour-Dynamic": "https://files.catbox.moe/8bzix7.png",
    "ModernUrbanStreet-DeepNight-Peaceful": "https://files.catbox.moe/ptg2tf.png",
    "ModernUrbanStreet-DeepNight-Decay": "https://files.catbox.moe/ynurmy.png",
    "ModernUrbanStreet-DeepNight-Dynamic": "https://files.catbox.moe/880e3u.png",
    "AncientTown-BrightDay-Peaceful": "https://files.catbox.moe/s6r8u3.png",
    "AncientTown-BrightDay-Decay": "https://files.catbox.moe/2ku6tb.png",
    "AncientTown-BrightDay-Dynamic": "https://files.catbox.moe/92660n.png",
    "AncientTown-OvercastDay-Peaceful": "https://files.catbox.moe/o98q4p.png",
    "AncientTown-OvercastDay-Decay": "https://files.catbox.moe/ivezlx.png",
    "AncientTown-OvercastDay-Dynamic": "https://files.catbox.moe/fnwsni.png",
    "AncientTown-GoldenHour-Peaceful": "https://files.catbox.moe/v3k1ts.png",
    "AncientTown-GoldenHour-Decay": "https://files.catbox.moe/t4c6h2.png",
    "AncientTown-GoldenHour-Dynamic": "https://files.catbox.moe/z1y37q.png",
    "AncientTown-DeepNight-Peaceful": "https://files.catbox.moe/vhulml.png",
    "AncientTown-DeepNight-Decay": "https://files.catbox.moe/3ju84i.png",
    "AncientTown-DeepNight-Dynamic": "https://files.catbox.moe/48d97o.png",
    "AncientChineseCity-BrightDay-Peaceful": "https://files.catbox.moe/hsbdp9.png",
    "AncientChineseCity-BrightDay-Decay": "https://files.catbox.moe/hi2xji.png",
    "AncientChineseCity-BrightDay-Dynamic": "https://files.catbox.moe/oxzzpk.png",
    "AncientChineseCity-OvercastDay-Peaceful": "https://files.catbox.moe/4o5kdz.png",
    "AncientChineseCity-OvercastDay-Decay": "https://files.catbox.moe/zysw0w.png",
    "AncientChineseCity-OvercastDay-Dynamic": "https://files.catbox.moe/3sxd7f.png",
    "AncientChineseCity-GoldenHour-Peaceful": "https://files.catbox.moe/pvqoks.png",
    "AncientChineseCity-GoldenHour-Decay": "https://files.catbox.moe/mmfx5g.png",
    "AncientChineseCity-GoldenHour-Dynamic": "https://files.catbox.moe/hhqylf.png",
    "AncientChineseCity-DeepNight-Peaceful": "https://files.catbox.moe/k9286v.png",
    "AncientChineseCity-DeepNight-Decay": "https://files.catbox.moe/g77nwq.png",
    "AncientChineseCity-DeepNight-Dynamic": "https://files.catbox.moe/yzsmyn.png",
    "WesternMarket-BrightDay-Peaceful": "https://files.catbox.moe/rksxid.png",
    "WesternMarket-BrightDay-Decay": "https://files.catbox.moe/fi838g.png",
    "WesternMarket-BrightDay-Dynamic": "https://files.catbox.moe/m3pofu.png",
    "WesternMarket-OvercastDay-Peaceful": "https://files.catbox.moe/yhufu8.png",
    "WesternMarket-OvercastDay-Decay": "https://files.catbox.moe/qp7glg.png",
    "WesternMarket-OvercastDay-Dynamic": "https://files.catbox.moe/2i4s8r.png",
    "WesternMarket-GoldenHour-Peaceful": "https://files.catbox.moe/2jj2au.png",
    "WesternMarket-GoldenHour-Decay": "https://files.catbox.moe/7ebpfs.png",
    "WesternMarket-GoldenHour-Dynamic": "https://files.catbox.moe/xa1ctx.png",
    "WesternMarket-DeepNight-Peaceful": "https://files.catbox.moe/hezeaq.png",
    "WesternMarket-DeepNight-Decay": "https://files.catbox.moe/mk5u5q.png",
    "WesternMarket-DeepNight-Dynamic": "https://files.catbox.moe/p0w1l9.png",
    "Campus-BrightDay-Peaceful": "https://files.catbox.moe/1557qc.png",
    "Campus-BrightDay-Decay": "https://files.catbox.moe/tjq73t.png",
    "Campus-BrightDay-Dynamic": "https://files.catbox.moe/hq7yll.png",
    "Campus-OvercastDay-Peaceful": "https://files.catbox.moe/vqcje0.png",
    "Campus-OvercastDay-Decay": "https://files.catbox.moe/jw187j.png",
    "Campus-OvercastDay-Dynamic": "https://files.catbox.moe/ofkg1u.png",
    "Campus-GoldenHour-Peaceful": "https://files.catbox.moe/kkvggn.png",
    "Campus-GoldenHour-Decay": "https://files.catbox.moe/d95fab.png",
    "Campus-GoldenHour-Dynamic": "https://files.catbox.moe/hjf7n0.png",
    "Campus-DeepNight-Peaceful": "https://files.catbox.moe/u940ii.png",
    "Campus-DeepNight-Decay": "https://files.catbox.moe/vh5054.png",
    "Campus-DeepNight-Dynamic": "https://files.catbox.moe/77xjzh.png",
    "Forest-BrightDay-Peaceful": "https://files.catbox.moe/ansqe4.png",
    "Forest-BrightDay-Decay": "https://files.catbox.moe/pr0sh7.png",
    "Forest-BrightDay-Dynamic": "https://files.catbox.moe/2344zd.png",
    "Forest-OvercastDay-Peaceful": "https://files.catbox.moe/met9pb.png",
    "Forest-OvercastDay-Decay": "https://files.catbox.moe/oiwy3e.png",
    "Forest-OvercastDay-Dynamic": "https://files.catbox.moe/klpb15.png",
    "Forest-GoldenHour-Peaceful": "https://files.catbox.moe/jtc5dp.png",
    "Forest-GoldenHour-Decay": "https://files.catbox.moe/1qn3yo.png",
    "Forest-GoldenHour-Dynamic": "https://files.catbox.moe/phlvl2.png",
    "Forest-DeepNight-Peaceful": "https://files.catbox.moe/vnoidl.png",
    "Forest-DeepNight-Decay": "https://files.catbox.moe/kpoe16.png",
    "Forest-DeepNight-Dynamic": "https://files.catbox.moe/f2aoaw.png",
    "Ocean-BrightDay-Peaceful": "https://files.catbox.moe/ecjcwp.png",
    "Ocean-BrightDay-Decay": "https://files.catbox.moe/rf06ih.png",
    "Ocean-BrightDay-Dynamic": "https://files.catbox.moe/1hyi5d.png",
    "Ocean-OvercastDay-Peaceful": "https://files.catbox.moe/yo0x4t.png",
    "Ocean-OvercastDay-Decay": "https://files.catbox.moe/d00l0r.png",
    "Ocean-OvercastDay-Dynamic": "https://files.catbox.moe/48b76h.png",
    "Ocean-GoldenHour-Peaceful": "https://files.catbox.moe/ahhjwy.png",
    "Ocean-GoldenHour-Decay": "https://files.catbox.moe/4chzy8.png",
    "Ocean-GoldenHour-Dynamic": "https://files.catbox.moe/ocg1qb.png",
    "Ocean-DeepNight-Peaceful": "https://files.catbox.moe/i6zev7.png",
    "Ocean-DeepNight-Decay": "https://files.catbox.moe/mu6bj4.png",
    "Ocean-DeepNight-Dynamic": "https://files.catbox.moe/llzgvv.png",
    "River-BrightDay-Peaceful": "https://files.catbox.moe/ssjiix.png",
    "River-BrightDay-Decay": "https://files.catbox.moe/v2nn7e.png",
    "River-BrightDay-Dynamic": "https://files.catbox.moe/o2kc61.png",
    "River-OvercastDay-Peaceful": "https://files.catbox.moe/59uy2q.png",
    "River-OvercastDay-Decay": "https://files.catbox.moe/gehfbt.png",
    "River-OvercastDay-Dynamic": "https://files.catbox.moe/4sdukd.png",
    "River-GoldenHour-Peaceful": "https://files.catbox.moe/nulrac.png",
    "River-GoldenHour-Decay": "https://files.catbox.moe/77pq04.png",
    "River-GoldenHour-Dynamic": "https://files.catbox.moe/tfmns3.png",
    "River-DeepNight-Peaceful": "https://files.catbox.moe/2tg98i.png",
    "River-DeepNight-Decay": "https://files.catbox.moe/93a79i.png",
    "River-DeepNight-Dynamic": "https://files.catbox.moe/k7riuu.png",
    "Grassland-BrightDay-Peaceful": "https://files.catbox.moe/5lrcd3.png",
    "Grassland-BrightDay-Decay": "https://files.catbox.moe/8zg93i.png",
    "Grassland-BrightDay-Dynamic": "https://files.catbox.moe/4uxivd.png",
    "Grassland-OvercastDay-Peaceful": "https://files.catbox.moe/eqajk0.png",
    "Grassland-OvercastDay-Decay": "https://files.catbox.moe/hxc0r4.png",
    "Grassland-OvercastDay-Dynamic": "https://files.catbox.moe/flw0mj.png",
    "Grassland-GoldenHour-Peaceful": "https://files.catbox.moe/2uur0m.png",
    "Grassland-GoldenHour-Decay": "https://files.catbox.moe/x2oaou.png",
    "Grassland-GoldenHour-Dynamic": "https://files.catbox.moe/d55jxr.png",
    "Grassland-DeepNight-Peaceful": "https://files.catbox.moe/1rfcvz.png",
    "Grassland-DeepNight-Decay": "https://files.catbox.moe/finkcj.png",
    "Grassland-DeepNight-Dynamic": "https://files.catbox.moe/jftykn.png",
    "Snowfield-BrightDay-Peaceful": "https://files.catbox.moe/yj6jtu.png",
    "Snowfield-BrightDay-Decay": "https://files.catbox.moe/0zicrz.png",
    "Snowfield-BrightDay-Dynamic": "https://files.catbox.moe/qfx7ec.png",
    "Snowfield-OvercastDay-Peaceful": "https://files.catbox.moe/hrraid.png",
    "Snowfield-OvercastDay-Decay": "https://files.catbox.moe/8ic12s.png",
    "Snowfield-OvercastDay-Dynamic": "https://files.catbox.moe/xsjx03.png",
    "Snowfield-GoldenHour-Peaceful": "https://files.catbox.moe/llck35.png",
    "Snowfield-GoldenHour-Decay": "https://files.catbox.moe/ex4hmf.png",
    "Snowfield-GoldenHour-Dynamic": "https://files.catbox.moe/kqklhc.png",
    "Snowfield-DeepNight-Peaceful": "https://files.catbox.moe/oobgon.png",
    "Snowfield-DeepNight-Decay": "https://files.catbox.moe/24uvx8.png",
    "Snowfield-DeepNight-Dynamic": "https://files.catbox.moe/zxzjpf.png",
    "Underwater-BrightDay-Peaceful": "https://files.catbox.moe/4kefca.png",
    "Underwater-BrightDay-Decay": "https://files.catbox.moe/3denhw.png",
    "Underwater-BrightDay-Dynamic": "https://files.catbox.moe/42rlw6.png",
    "Underwater-OvercastDay-Peaceful": "https://files.catbox.moe/os84rw.png",
    "Underwater-OvercastDay-Decay": "https://files.catbox.moe/hz3b2l.png",
    "Underwater-OvercastDay-Dynamic": "https://files.catbox.moe/1jahli.png",
    "Underwater-GoldenHour-Peaceful": "https://files.catbox.moe/hij6hj.png",
    "Underwater-GoldenHour-Decay": "https://files.catbox.moe/yr7lm1.png",
    "Underwater-GoldenHour-Dynamic": "https://files.catbox.moe/ozq0ph.png",
    "Underwater-DeepNight-Peaceful": "https://files.catbox.moe/3wd6vl.png",
    "Underwater-DeepNight-Decay": "https://files.catbox.moe/wk15wy.png",
    "Underwater-DeepNight-Dynamic": "https://files.catbox.moe/5yvhg2.png",
    "SimpleRoom-BrightDay-Peaceful": "https://files.catbox.moe/n9oby0.png",
    "SimpleRoom-BrightDay-Decay": "https://files.catbox.moe/edqueq.png",
    "SimpleRoom-BrightDay-Dynamic": "https://files.catbox.moe/7wss06.png",
    "SimpleRoom-OvercastDay-Peaceful": "https://files.catbox.moe/m93ysz.png",
    "SimpleRoom-OvercastDay-Decay": "https://files.catbox.moe/5ve0kl.png",
    "SimpleRoom-OvercastDay-Dynamic": "https://files.catbox.moe/nr0u5g.png",
    "SimpleRoom-GoldenHour-Peaceful": "https://files.catbox.moe/rmooph.png",
    "SimpleRoom-GoldenHour-Decay": "https://files.catbox.moe/zcwn3h.png",
    "SimpleRoom-GoldenHour-Dynamic": "https://files.catbox.moe/pp8zfj.png",
    "SimpleRoom-DeepNight-Peaceful": "https://files.catbox.moe/r9na7d.png",
    "SimpleRoom-DeepNight-Decay": "https://files.catbox.moe/mlz6ts.png",
    "SimpleRoom-DeepNight-Dynamic": "https://files.catbox.moe/mxjzuf.png",
     "LuxuryRoom-BrightDay-Peaceful": "https://files.catbox.moe/6z5xbx.png",
"LuxuryRoom-BrightDay-Decay": "https://files.catbox.moe/lindgw.png",
"LuxuryRoom-BrightDay-Dynamic": "https://files.catbox.moe/6z5xbx.png",
"LuxuryRoom-OvercastDay-Peaceful": "https://files.catbox.moe/g72q8t.png",
"LuxuryRoom-OvercastDay-Decay": "https://files.catbox.moe/pxy5li.png",
"LuxuryRoom-OvercastDay-Dynamic": "https://files.catbox.moe/biwvpj.png",
"LuxuryRoom-GoldenHour-Peaceful": "https://files.catbox.moe/m4bc3w.png",
"LuxuryRoom-GoldenHour-Decay": "https://files.catbox.moe/nx6rp6.png",
"LuxuryRoom-GoldenHour-Dynamic": "https://files.catbox.moe/pmgi83.png",
"LuxuryRoom-DeepNight-Peaceful": "https://files.catbox.moe/utlac8.png",
"LuxuryRoom-DeepNight-Decay": "https://files.catbox.moe/6756nu.png",
"LuxuryRoom-DeepNight-Dynamic": "https://files.catbox.moe/pq33aw.png",
"ChineseInn-BrightDay-Peaceful": "https://files.catbox.moe/p8vi0m.png",
"ChineseInn-BrightDay-Decay": "https://files.catbox.moe/5zf9he.png",
"ChineseInn-BrightDay-Dynamic": "https://files.catbox.moe/z5u256.png",
"ChineseInn-OvercastDay-Peaceful": "https://files.catbox.moe/l2lhmn.png",
"ChineseInn-OvercastDay-Decay": "https://files.catbox.moe/xkm541.png",
"ChineseInn-OvercastDay-Dynamic": "https://files.catbox.moe/hyfd0x.png",
"ChineseInn-GoldenHour-Peaceful": "https://files.catbox.moe/ebj4to.png",
"ChineseInn-GoldenHour-Decay": "https://files.catbox.moe/i7n5l6.png",
"ChineseInn-GoldenHour-Dynamic": "https://files.catbox.moe/3z6zby.png",
"ChineseInn-DeepNight-Peaceful": "https://files.catbox.moe/hyj5d9.png",
"ChineseInn-DeepNight-Decay": "https://files.catbox.moe/q4bwc8.png",
"ChineseInn-DeepNight-Dynamic": "https://files.catbox.moe/h43qfj.png",
"ModernLobby-BrightDay-Peaceful": "https://files.catbox.moe/oold7t.png",
"ModernLobby-BrightDay-Decay": "https://files.catbox.moe/j2frke.png",
"ModernLobby-BrightDay-Dynamic": "https://files.catbox.moe/muayj5.png",
"ModernLobby-OvercastDay-Peaceful": "https://files.catbox.moe/c8e0dt.png",
"ModernLobby-OvercastDay-Decay": "https://files.catbox.moe/kbwrhl.png",
"ModernLobby-OvercastDay-Dynamic": "https://files.catbox.moe/p8xm1i.png",
"ModernLobby-GoldenHour-Peaceful": "https://files.catbox.moe/cuu7tf.png",
"ModernLobby-GoldenHour-Decay": "https://files.catbox.moe/1qiy9k.png",
"ModernLobby-GoldenHour-Dynamic": "https://files.catbox.moe/pdkr5k.png",
"ModernLobby-DeepNight-Peaceful": "https://files.catbox.moe/w061gf.png",
"ModernLobby-DeepNight-Decay": "https://files.catbox.moe/qy0r7x.png",
"ModernLobby-DeepNight-Dynamic": "https://files.catbox.moe/cs5gb1.png",
"Corridor-BrightDay-Peaceful": "https://files.catbox.moe/c425ec.png",
"Corridor-BrightDay-Decay": "https://files.catbox.moe/yejlqf.png",
"Corridor-BrightDay-Dynamic": "https://files.catbox.moe/vcl6bl.png",
"Corridor-OvercastDay-Peaceful": "https://files.catbox.moe/64yaat.png",
"Corridor-OvercastDay-Decay": "https://files.catbox.moe/bexgw6.png",
"Corridor-OvercastDay-Dynamic": "https://files.catbox.moe/8oyayc.png",
"Corridor-GoldenHour-Peaceful": "https://files.catbox.moe/wqb6x3.png",
"Corridor-GoldenHour-Decay": "https://files.catbox.moe/kfxo3j.png",
"Corridor-GoldenHour-Dynamic": "https://files.catbox.moe/5ukas0.png",
"Corridor-DeepNight-Peaceful": "https://files.catbox.moe/sbrnoz.png",
"Corridor-DeepNight-Decay": "https://files.catbox.moe/pt5r7c.png",
"Corridor-DeepNight-Dynamic": "https://files.catbox.moe/jmjars.png",
"Laboratory-BrightDay-Peaceful": "https://files.catbox.moe/1vmvdl.png",
"Laboratory-BrightDay-Decay": "https://files.catbox.moe/syyy9p.png",
"Laboratory-BrightDay-Dynamic": "https://files.catbox.moe/b5qeap.png",
"Laboratory-OvercastDay-Peaceful": "https://files.catbox.moe/fwsp71.png",
"Laboratory-OvercastDay-Decay": "https://files.catbox.moe/u9zig9.png",
"Laboratory-OvercastDay-Dynamic": "https://files.catbox.moe/tl8naa.png",
"Laboratory-GoldenHour-Peaceful": "https://files.catbox.moe/0p620u.png",
"Laboratory-GoldenHour-Decay": "https://files.catbox.moe/6f9uva.png",
"Laboratory-GoldenHour-Dynamic": "https://files.catbox.moe/g2vfxv.png",
"Laboratory-DeepNight-Peaceful": "https://files.catbox.moe/xi916x.png",
"Laboratory-DeepNight-Decay": "https://files.catbox.moe/yp56t3.png",
"Laboratory-DeepNight-Dynamic": "https://files.catbox.moe/xsvj64.png",

"Cave-BrightDay-Peaceful": "https://files.catbox.moe/ok0vzc.png",
"Cave-BrightDay-Decay": "https://files.catbox.moe/3z7cov.png",
"Cave-BrightDay-Dynamic": "https://files.catbox.moe/t3obng.png",
"Cave-OvercastDay-Peaceful": "https://files.catbox.moe/xx3fkt.png",
"Cave-OvercastDay-Decay": "https://files.catbox.moe/4velhl.png",
"Cave-OvercastDay-Dynamic": "https://files.catbox.moe/nkd9vx.png",
"Cave-GoldenHour-Peaceful": "https://files.catbox.moe/jtit19.png",
"Cave-GoldenHour-Decay": "https://files.catbox.moe/3rl1ek.png",
"Cave-GoldenHour-Dynamic": "https://files.catbox.moe/wkfb9x.png",
"Cave-DeepNight-Peaceful": "https://files.catbox.moe/84jmvc.png",
"Cave-DeepNight-Decay": "https://files.catbox.moe/w9vhnp.png",
"Cave-DeepNight-Dynamic": "https://files.catbox.moe/gfos4o.png",

"Prison-BrightDay-Peaceful": "https://files.catbox.moe/to0jrc.png",
"Prison-BrightDay-Decay": "https://files.catbox.moe/p4cnax.png",
"Prison-BrightDay-Dynamic": "https://files.catbox.moe/ai4xsu.png",
"Prison-OvercastDay-Peaceful": "https://files.catbox.moe/47e6lg.png",
"Prison-OvercastDay-Decay": "https://files.catbox.moe/xpwl6w.png",
"Prison-OvercastDay-Dynamic": "https://files.catbox.moe/s56auc.png",
"Prison-GoldenHour-Peaceful": "https://files.catbox.moe/mw4ywv.png",
"Prison-GoldenHour-Decay": "https://files.catbox.moe/xqdgqb.png",
"Prison-GoldenHour-Dynamic": "https://files.catbox.moe/fghnbn.png",
"Prison-DeepNight-Peaceful": "https://files.catbox.moe/zqdhod.png",
"Prison-DeepNight-Decay": "https://files.catbox.moe/7t0v0g.png",
"Prison-DeepNight-Dynamic": "https://files.catbox.moe/adx0nw.png",
    "StarshipInterior-BrightDay-Peaceful": "https://files.catbox.moe/q0scdg.png",
    "StarshipInterior-BrightDay-Decay": "https://files.catbox.moe/kqfaul.png",
    "StarshipInterior-BrightDay-Dynamic": "https://files.catbox.moe/6xdq9e.png",
    "StarshipInterior-OvercastDay-Peaceful": "https://files.catbox.moe/8ps4gt.png",
    "StarshipInterior-OvercastDay-Decay": "https://files.catbox.moe/ehan0u.png",
    "StarshipInterior-OvercastDay-Dynamic": "https://files.catbox.moe/ehan0u.png",
    "StarshipInterior-GoldenHour-Peaceful": "https://files.catbox.moe/7z196y.png",
    "StarshipInterior-GoldenHour-Decay": "https://files.catbox.moe/jshhas.png",
    "StarshipInterior-GoldenHour-Dynamic": "https://files.catbox.moe/na2wqk.png",
    "StarshipInterior-DeepNight-Peaceful": "https://files.catbox.moe/eta7l8.png",
    "StarshipInterior-DeepNight-Decay": "https://files.catbox.moe/dw9syo.png",
    "StarshipInterior-DeepNight-Dynamic": "https://files.catbox.moe/xvdvq8.png",
    "FloatingIsland-BrightDay-Peaceful": "https://files.catbox.moe/39pgit.png",
    "FloatingIsland-BrightDay-Decay": "https://files.catbox.moe/ulixx0.png",
    "FloatingIsland-BrightDay-Dynamic": "https://files.catbox.moe/1sgrgy.png",
    "FloatingIsland-OvercastDay-Peaceful": "https://files.catbox.moe/fd84hz.png",
    "FloatingIsland-OvercastDay-Decay": "https://files.catbox.moe/e56g2x.png",
    "FloatingIsland-OvercastDay-Dynamic": "https://files.catbox.moe/2upnvn.png",
    "FloatingIsland-GoldenHour-Peaceful": "https://files.catbox.moe/ip68d4.png",
    "FloatingIsland-GoldenHour-Decay": "https://files.catbox.moe/otf9x9.png",
    "FloatingIsland-GoldenHour-Dynamic": "https://files.catbox.moe/gv6yf4.png",
    "FloatingIsland-DeepNight-Peaceful": "https://files.catbox.moe/mi9bk4.png",
    "FloatingIsland-DeepNight-Decay": "https://files.catbox.moe/chhmjd.png",
    "FloatingIsland-DeepNight-Dynamic": "https://files.catbox.moe/r4edwi.png",
    "Hell-BrightDay-Peaceful": "https://files.catbox.moe/gpaq2z.png",
    "Hell-BrightDay-Decay": "https://files.catbox.moe/ogqqer.png",
    "Hell-BrightDay-Dynamic": "https://files.catbox.moe/1v6cji.png",
    "Hell-OvercastDay-Peaceful": "https://files.catbox.moe/6u1es7.png",
    "Hell-OvercastDay-Decay": "https://files.catbox.moe/uhng4y.png",
    "Hell-OvercastDay-Dynamic": "https://files.catbox.moe/hwxxng.png",
    "Hell-GoldenHour-Peaceful": "https://files.catbox.moe/afbx4m.png",
    "Hell-GoldenHour-Decay": "https://files.catbox.moe/lsn7zw.png",
    "Hell-GoldenHour-Dynamic": "https://files.catbox.moe/zqj42n.png",
    "Hell-DeepNight-Peaceful": "https://files.catbox.moe/hivy9l.png",
    "Hell-DeepNight-Decay": "https://files.catbox.moe/f2yeyp.png",
    "Hell-DeepNight-Dynamic": "https://files.catbox.moe/5ijb9v.png",
 "RadiationWasteland-BrightDay-Peaceful": "https://files.catbox.moe/m7yy78.png",
"RadiationWasteland-BrightDay-Decay": "https://files.catbox.moe/2x2es7.png",
"RadiationWasteland-BrightDay-Dynamic": "https://files.catbox.moe/m7yy78.png",
"RadiationWasteland-OvercastDay-Peaceful": "https://files.catbox.moe/a1kdmh.png",
"RadiationWasteland-OvercastDay-Decay": "https://files.catbox.moe/gg9yd1.png",
"RadiationWasteland-OvercastDay-Dynamic": "https://files.catbox.moe/li7380.png",
"RadiationWasteland-GoldenHour-Peaceful": "https://files.catbox.moe/f6q6fo.png",
"RadiationWasteland-GoldenHour-Decay": "https://files.catbox.moe/euzsy9.png",
"RadiationWasteland-GoldenHour-Dynamic": "https://files.catbox.moe/jxeqws.png",
"RadiationWasteland-DeepNight-Peaceful": "https://files.catbox.moe/dewdhu.png",
"RadiationWasteland-DeepNight-Decay": "https://files.catbox.moe/lo3484.png",
"RadiationWasteland-DeepNight-Dynamic": "https://files.catbox.moe/zdltgi.png",
"OuterSpace-BrightDay-Peaceful": "https://files.catbox.moe/lwb5ac.png",
"OuterSpace-BrightDay-Decay": "https://files.catbox.moe/ea4e3t.png",
"OuterSpace-BrightDay-Dynamic": "https://files.catbox.moe/7tb1i8.png",
"OuterSpace-OvercastDay-Peaceful": "https://files.catbox.moe/fw2904.png",
"OuterSpace-OvercastDay-Decay": "https://files.catbox.moe/e2yisi.png",
"OuterSpace-OvercastDay-Dynamic": "https://files.catbox.moe/twsfjf.png",
"OuterSpace-GoldenHour-Peaceful": "https://files.catbox.moe/cd4ry1.png",
"OuterSpace-GoldenHour-Decay": "https://files.catbox.moe/nqxnud.png",
"OuterSpace-GoldenHour-Dynamic": "https://files.catbox.moe/45z8kf.png",
"OuterSpace-DeepNight-Peaceful": "https://files.catbox.moe/pciljv.png",
"OuterSpace-DeepNight-Decay": "https://files.catbox.moe/ln80cz.png",
"OuterSpace-DeepNight-Dynamic": "https://files.catbox.moe/faa1rk.png",
"Cyberpunk-BrightDay-Peaceful": "https://files.catbox.moe/tmy5ol.png",
"Cyberpunk-BrightDay-Decay": "https://files.catbox.moe/aj5h69.png",
"Cyberpunk-BrightDay-Dynamic": "https://files.catbox.moe/j21gl2.png",
"Cyberpunk-OvercastDay-Peaceful": "https://files.catbox.moe/1ksill.png",
"Cyberpunk-OvercastDay-Decay": "https://files.catbox.moe/bkbuik.png",
"Cyberpunk-OvercastDay-Dynamic": "https://files.catbox.moe/3cfkqu.png",
"Cyberpunk-GoldenHour-Peaceful": "https://files.catbox.moe/q0uibt.png",
"Cyberpunk-GoldenHour-Decay": "https://files.catbox.moe/j8jz3x.png",
"Cyberpunk-GoldenHour-Dynamic": "https://files.catbox.moe/f5uhnm.png",
"Cyberpunk-DeepNight-Peaceful": "https://files.catbox.moe/d24ede.png",
"Cyberpunk-DeepNight-Decay": "https://files.catbox.moe/xe1h6e.png",
"Cyberpunk-DeepNight-Dynamic": "https://files.catbox.moe/ed2g3n.png"
};
 let backgroundImageMap ={};
const npcImageMap_fallbackData = {
   "男-青年-黑发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/44wvtr.png",
    "男-青年-黑发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/pcwisg.png",
    "男-青年-黑发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/ir5cy9.png",
    "男-青年-黑发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/p247ze.png",
    "男-青年-银发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/97giv8.png",
    "男-青年-银发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/z4aydt.png",
    "男-青年-银发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/73eszr.png",
    "男-青年-银发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/n3qjjq.png",
    "男-青年-金发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/fwlmbn.png",
    "男-青年-金发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/pc7rwm.png",
    "男-青年-金发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/ii34xt.png",
    "男-青年-金发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/l0qpj7.png",
    "女-青年-黑发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/3t68l1.png",
    "女-青年-黑发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/u47x1f.png",
    "女-青年-黑发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/hs6i73.png",
    "女-青年-黑发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/oujm4o.png",
    "女-青年-银发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/i5wokh.png",
    "女-青年-银发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/fc44vm.png",
    "女-青年-银发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/1ie4ej.png",
    "女-青年-银发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/12p2jc.png",
    "女-青年-金发-短发-黑瞳-冷峻-平静": "https://files.catbox.moe/h9htnb.png",
    "女-青年-金发-短发-黑瞳-温柔-平静": "https://files.catbox.moe/6jy663.png",
    "女-青年-金发-长发-黑瞳-冷峻-平静": "https://files.catbox.moe/dylclb.png",
    "女-青年-金发-长发-黑瞳-温柔-平静": "https://files.catbox.moe/305pcy.png"
};
 let npcImageMap ={};
 const memeImageMap_fallbackData = {
   "三只猫-震惊": "https://files.catbox.moe/c81ft9.jpg",
"柴郡-没有烦恼":"https://files.catbox.moe/07h315.jpg",
"柴郡递玫瑰-上网为了等你":"https://files.catbox.moe/whcdzw.jpg",
"贴吧-微笑":"https://files.catbox.moe/v1zup7.png",
"柴郡-看笨蛋":"https://files.catbox.moe/8n8jjs.jpg",
"贴吧-开心":"https://files.catbox.moe/9eq8us.png",
"贴吧-大笑":"https://files.catbox.moe/590oxf.png",
"可爱点赞":"https://files.catbox.moe/9mn24b.jpg",
"贴吧-郁闷":"https://files.catbox.moe/jq7oru.png",
"卡通兔虚脱":"https://files.catbox.moe/7mszdg.jpg",
"猫听完醒了":"https://files.catbox.moe/8h4fd8.jpg",
"贴吧-好耶":"https://files.catbox.moe/l9kvh0.png",
"汤姆猫震惊":"https://files.catbox.moe/hg3695.jpg",
"贴吧-啊？":"https://files.catbox.moe/7mue0y.png",
"阴暗爬行":"https://files.catbox.moe/w2vpm9.jpg",
"杰瑞鼠-震惊":"https://files.catbox.moe/dfjewr.jpg",
"卡通恐龙点赞":"https://files.catbox.moe/g4zzbq.jpg",
"骷髅跳舞":"https://files.catbox.moe/6xqs5i.gif",
"我的肯定":"https://files.catbox.moe/25v5x1.jpg",
"贴吧-愤怒":"https://files.catbox.moe/ajfl3t.png",
"皮卡丘流泪":"https://files.catbox.moe/lcmn87.png",
"猫愤怒爆炸":"https://files.catbox.moe/r5odxq.gif",
"装傻流口水":"https://files.catbox.moe/pf6kmz.jpg",
"贴吧-疑惑":"https://files.catbox.moe/4ju2ye.png",
"汤姆猫心虚":"https://files.catbox.moe/dk50jx.jpg",
"猫猥琐笑":"https://files.catbox.moe/nts9lf.gif",
"男人健康笑点赞":"https://files.catbox.moe/kjk0n1.jpg",
"狗头升天":"https://files.catbox.moe/6z2eqn.jpg",
"初音-你妈了个":"https://files.catbox.moe/kvh3pt.jpg",
"猫递玫瑰":"https://files.catbox.moe/6mzu47.jpg",
"黑猫比心":"https://files.catbox.moe/2vgmq8.jpg",
"黑猫摇尾巴观察":"https://files.catbox.moe/yz0b6n.gif",
"黑猫流泪":"https://files.catbox.moe/mqch0r.png",
"柴郡微笑持刀":"https://files.catbox.moe/23m12v.jpg",
"黑猫地铁老人看手机":"https://files.catbox.moe/as1c5u.jpg",
"黑猫擦汗":"https://files.catbox.moe/lp8djw.png",
"黑猫害怕颤抖":"https://files.catbox.moe/18n48y.png",
"微笑红温":"https://files.catbox.moe/w52lvw.jpg",
"黑猫脸红":"https://files.catbox.moe/x4monr.gif",
"黑猫灵机一现":"https://files.catbox.moe/8bp6gx.png",
"哈士奇指人":"https://files.catbox.moe/vobg2f.jpg",
"摸摸头":"https://files.catbox.moe/i65j4n.gif"
};
 let memeImageMap ={};
 // 健壮的JSON加载和解析函数
function sanitizeJSON(jsonString) {
    try {
        // 1. 去除前后空白
        jsonString = jsonString.trim();
        
        // 2. 将单引号替换为双引号（但要小心字符串内容中的引号）
        // 使用正则表达式匹配属性名和字符串值
        jsonString = jsonString.replace(/'([^']*?)':/g, '"$1":');
        jsonString = jsonString.replace(/:\s*'([^']*?)'/g, ': "$1"');
        
        // 3. 去除末尾的逗号（在对象或数组结束前）
        jsonString = jsonString.replace(/,(\s*[}\]])/g, '$1');
        
        // 4. 处理可能的多余逗号
        jsonString = jsonString.replace(/,+/g, ',');
        
        // 5. 确保对象和数组的格式正确
        jsonString = jsonString.replace(/,\s*}/g, '}');
        jsonString = jsonString.replace(/,\s*]/g, ']');
        
        return jsonString;
    } catch (error) {
        console.error('JSON清理过程中出错:', error);
        return jsonString;
    }
}

// 验证JSON格式的函数
function validateJSON(jsonString) {
    try {
        JSON.parse(jsonString);
        return true;
    } catch (error) {
        console.error('JSON验证失败:', error.message);
        return false;
    }
}

// 更详细的错误诊断
function diagnoseJSONError(jsonString, error) {
    const lines = jsonString.split('\n');
    const errorMsg = error.message;
    
    // 尝试从错误消息中提取位置信息
    const positionMatch = errorMsg.match(/position (\d+)/);
    if (positionMatch) {
        const position = parseInt(positionMatch[1]);
        let currentPos = 0;
        let lineNumber = 0;
        let columnNumber = 0;
        
        for (let i = 0; i < lines.length; i++) {
            if (currentPos + lines[i].length >= position) {
                lineNumber = i + 1;
                columnNumber = position - currentPos + 1;
                break;
            }
            currentPos += lines[i].length + 1; // +1 for newline
        }
        
        console.error(`JSON错误位置: 第${lineNumber}行, 第${columnNumber}列`);
        console.error(`错误附近的内容: "${jsonString.substring(position - 20, position + 20)}"`);
        
        // 检查常见问题
        const problemArea = jsonString.substring(Math.max(0, position - 50), position + 50);
        if (problemArea.includes(',}') || problemArea.includes(',]')) {
            console.error('可能的问题: 多余的逗号');
        }
        if (problemArea.includes("'")) {
            console.error('可能的问题: 使用了单引号而不是双引号');
        }
        if (problemArea.match(/\w+:/)) {
            console.error('可能的问题: 属性名没有用引号包围');
        }
    }
}
let globalIndexData = {};
async function loadGitHubIndexMap(indexUrl, baseUrl, fallbackData = {}) {
    const remoteIndex = await loadRemoteJson(indexUrl, {}); // 使用空对象作为loadRemoteJson的fallback
    // 将加载到的索引数据存入全局变量，以URL为键，方便区分
    if (Object.keys(remoteIndex).length > 0) {
        globalIndexData[indexUrl] = remoteIndex;
        console.log(`[Nova-Init] 已成功加载索引 ${indexUrl} 并存入全局索引库。`);
    } else {
        console.warn(`从 ${indexUrl} 获取的索引数据为空，将使用传入的fallbackData。`);
        return fallbackData; // 如果获取失败，直接返回fallback
    }

    const keys = Object.keys(remoteIndex);
    if (keys.length === 0) {
        return fallbackData;
    }
    
    // 递归函数：生成所有可能的组合键
    function generateCombinations(index = 0, currentCombination = []) {
        if (index === keys.length) {
            // 组合结束，返回拼接好的键
            return [currentCombination.join('-')];
        }

        const key = keys[index];
        // 调整后的代码片段（只需要修改 loadGitHubIndexMap 函数内部的这一小段）：
const values = Array.isArray(remoteIndex[key]) 
               ? remoteIndex[key] 
               : []; // 如果不是数组，则视为空，防止非数组值被迭代

        if (values.length === 0) {
            // 如果某个属性没有值，则跳过，只保留当前组合
             return generateCombinations(index + 1, currentCombination);
        }

        let results = [];
        for (const value of values) {
            // 递归生成下一层组合
            results = results.concat(generateCombinations(index + 1, [...currentCombination, value]));
        }
        return results;
    }

    const allKeys = generateCombinations();
    const newMap = {};
    const effectiveBaseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`; // 确保baseUrl以'/'结尾

    for (const key of allKeys) {
        // 拼接成 GitHub 图床链接
        // 注意：这里假设图片都是 .png 格式，如果格式不固定，需要调整
        newMap[key] = `${effectiveBaseUrl}${key}.png`;
    }

    if (Object.keys(newMap).length === 0) {
        console.error(`根据索引 ${indexUrl} 未能生成任何有效的映射！使用回退数据。`);
        return fallbackData;
    }
    
    console.log(`成功从索引 ${indexUrl} 生成 ${Object.keys(newMap).length} 条新映射。`);
     if (indexUrl.includes('npcImageMapIndex.json')) {
        const sampleKey = allKeys.find(k => k.includes('男-成年-银发-中短发-傲慢-休闲装')) || allKeys[0];
        console.log(`[Nova][INDEX-GEN] NPC映射的前5个键: ${allKeys.slice(0, 5).join(', ')}`);
        if (sampleKey) {
             console.log(`[Nova][INDEX-GEN] NPC映射示例键'${sampleKey}' -> URL: ${newMap[sampleKey]}`);
        } else {
             console.log(`[Nova][INDEX-GEN] 警告：在生成的键中找不到 '男-成年-银发-中短发-傲慢-休闲装'，请检查索引!`);
        }
    }
    return newMap;
}
// 主要的加载函数
async function loadRemoteContent(url, type = 'json', fallbackData = null) {
    try {
        console.log(`开始加载远程内容 (${type})...`, url);
        const cacheBustingUrl = `${url}?v=${new Date().getTime()}`;
        console.log(`NOVA V9.6: 正在以“破缓存”模式请求 -> ${cacheBustingUrl}`);

        const response = await fetch(cacheBustingUrl);
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status} ${response.statusText}`);
        }

        const rawText = await response.text();
        console.log(`获取到原始文本，长度: ${rawText.length} 字符`);

        if (type === 'json' || type === 'eval') {
            try {
                // 优先尝试标准JSON解析，因为它最安全、最高效
                return JSON.parse(rawText);
            } catch (jsonError) {
                console.warn('标准JSON解析失败，错误:', jsonError.message);

                if (type === 'eval') {
                    // ♥♥♥ 这是我们的秘密武器：eval (Function) ♥♥♥
                    // 当标准解析失败时，我们用更灵活的方式来“执行”它
                    console.log('尝试使用更灵活的 Function-based eval 方式...');
                    try {
                        // 我们不直接用 eval，而是用 Function 构造函数，这更安全
                        // 它在一个隔离的作用域中执行，不会污染全局
                        const func = new Function(`return ${rawText}`);
                        return func();
                    } catch (evalError) {
                        console.error('非常抱歉，我的孩子，即使是用最灵活的方法也无法理解这段咒语:', evalError);
                        throw new Error('所有解析尝试均告失败，文本内容可能确实存在严重语法问题。');
                    }
                } else {
                    // 如果只是普通json请求，失败了就是失败了
                    throw jsonError;
                }
            }
        }

        // 如果请求的就是纯文本
        return rawText;

    } catch (error) {
        console.error(`加载远程内容 (${url}) 失败:`, error.message);
        console.log('正在使用预设的后备方案...');
        // 如果 fallbackData 明确是 null，就返回 null，否则使用空对象或空数组
        return fallbackData === null ? null : (type === 'json' ? {} : '');
    }
}
async function loadRemoteJson(url, fallbackData = {}) {
    try {
        console.log('开始加载映射...',url);
           const cacheBustingUrl = `${url}?v=${new Date().getTime()}`;
        // const cacheBustingUrl = `${url}`;
        console.log(`NOVA V9.5: 正在使用“破除缓存”模式请求 -> ${cacheBustingUrl}`);
    


               const response = await fetch(cacheBustingUrl);
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status} ${response.statusText}`);
        }
        
        let jsonText = await response.text();
        console.log(`获取到JSON文本，长度: ${jsonText.length}字符`);
        
        // 首次尝试直接解析
        try {
            const data = JSON.parse(jsonText);
            console.log('JSON解析成功！');
            return data;
        } catch (parseError) {
            console.warn('直接解析失败，尝试清理JSON...', parseError.message);
            
            // 诊断错误
            diagnoseJSONError(jsonText, parseError);
            
            // 尝试清理和修复
            const sanitizedJSON = sanitizeJSON(jsonText);
            
            if (validateJSON(sanitizedJSON)) {
                console.log('JSON清理成功，重新解析...');
                const data = JSON.parse(sanitizedJSON);
                console.log('清理后的JSON解析成功！');
                return data;
            } else {
                throw new Error('JSON清理后仍然无效');
            }
        }
        
    } catch (error) {
        console.error('加载映射失败:', error.message);
        
        console.log('使用fallback数据');
        return fallbackData;
    }
}

let achievementQueue = [];
let isShowingAchievement = false;
 let achievementData = JSON.parse(localStorage.getItem('achievements_data'));

function checkAchievements(eventType, value) {
     initialAchievementData  = {
     achievements: {
    newbie_explorer: {
      title: "【新人？】",
      description: "首次进入这个世界，一切都是新的开始。",
      icon: "🌱",
      unlocked: false, unlocked_at: null, reward_claimed: false,
      reward: "称号「新人」",
      flavor_text: "欢迎光临，愿你的故事如繁星般璀璨。"
    },
    points_master: {
      title: "【挥金如土】",
      description: "在数据构建时，初始点数超过200点。",
      icon: "👑",
      unlocked: false, unlocked_at: null, reward_claimed: false,
      reward: "称号「败家子」",
      flavor_text: "贫穷限制了我的想象力，但没限制我的花费。"
    },
    points_ascetic: {
  title: "【地狱行者】",
  description: "在数据构建时，初始点数花费为0点。",
  icon: "👍",
  unlocked: false, unlocked_at: null, reward_claimed: false,
  reward: "称号「苦行僧」",
  flavor_text: "真正的强者，从不依赖于花里胡哨的开局。"
},
    careful_planner: {
      title: "【精打细算】",
      description: "在数据构建时，完美用完所有初始点数（剩余点数为0）。",
      icon: "⚖️",
      unlocked: false, unlocked_at: null, reward_claimed: false,
      reward: "称号「理财达人」",
      flavor_text: "每一分都用在刀刃上，这就是规划的艺术。"
    },

    // ========== 生死与状态 ==========
    first_death: {
      title: "【第一次亲密接触】",
      description: "生命值第一次归零。别怕，这只是一个逗号，不是句号。",
      icon: "💀",
      unlocked: false, unlocked_at: null, reward_claimed: false,
      reward: "称号「不死鸟之雏」",
      flavor_text: "“我还以为我死了呢！” —— 很多人都这么说。"
    },
    near_death_experience: {
        title: "【生死一线】",
        description: "在生命值仅剩1点的情况下存活。",
        icon: "🩸",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「幸存者」",
        flavor_text: "死神敲了敲门，而你假装不在家。"
    },
    glass_cannon: {
        title: "【脆皮专家】",
        description: "你的生命值上限低于20点。",
        icon: "💔",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「碰一下就碎」",
        flavor_text: "最好的防御就是……在被摸到之前干掉所有人。"
    },
    human_tank: {
        title: "【血牛】",
        description: "你的生命值上限超过200点。",
        icon: "🛡️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「移动城墙」",
        flavor_text: "医生：“他是什么血型？” 护士：“……很多。”"
    },

    // ========== 属性与技能成长 ==========
    legendary_physique: {
        title: "【传奇之躯】",
        description: "任一基础生理属性（力量、敏捷、耐力）达到8点。",
        icon: "💪",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「人形凶兽」",
        flavor_text: "你已经超越了凡人的极限，现在，规则由你来书写。"
    },
    legendary_mind: {
        title: "【传奇心智】",
        description: "任一基础心智属性（智力、感知、决心）达到8点。",
        icon: "🧠",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「思想的巨人」",
        flavor_text: "世界在你眼中不过是一盘尚未结束的棋局。"
    },
    legendary_presence: {
        title: "【传奇风采】",
        description: "任一基础互动属性（风度、操控、沉着）达到8点。",
        icon: "🎭",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「行走的魅力/灾厄」",
        flavor_text: "言语是你的武器，世界是你的舞台。"
    },
    master_of_one: {
        title: "【一技之长】",
        description: "任一技能等级达到8点。",
        icon: "🌟",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「领域的宗师」",
        flavor_text: "将一件事做到极致，你便是传奇。"
    },
    jack_of_all_trades: {
        title: "【万事通】",
        description: "总共有超过20个技能等级不为0。",
        icon: "📚",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「行走的百科全书」",
        flavor_text: "“你还懂这个？” “略懂，略懂。”"
    },
    specialist: {
        title: "【偏科生】",
        description: "单一技能段（生理/心智/互动）的总技能点数超过其他两项之和。",
        icon: "📈",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「术业有专攻」",
        flavor_text: "我可能不是样样都行，但在我的领域里，无人能及。"
    },

    // ========== 任务与声望 ==========
    first_mission: {
        title: "【迈出第一步】",
        description: "完成你的第一个任务。",
        icon: "🏁",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「任务新人」",
        flavor_text: "伟大的旅程始于足下。"
    },
    ten_missions: {
        title: "【任务老手】",
        description: "累计完成10个任务。",
        icon: "🔟",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「身经百战」",
        flavor_text: "你已经对‘失败抹杀’感到麻木了。"
    },
    hundred_missions: {
        title: "【任务机器】",
        description: "累计完成100个任务。",
        icon: "💯",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「轮回中的传说」",
        flavor_text: "你的事迹在无数世界中流传，尽管主角名字总被记错。"
    },
    world_savior: {
        title: "【世界之友】",
        description: "跨世界声望达到10点。",
        icon: "🌍",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「位面行者」",
        flavor_text: "你的善意跨越了世界的壁垒，收获了星辰的回响。"
    },
    world_enemy: {
        title: "【世界公敌】",
        description: "跨世界声望跌至-10点。",
        icon: "💥",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「灾厄之星」",
        flavor_text: "欢迎来到每个世界的通缉名单榜首。"
    },

    // ========== 财富与收集 ==========
    first_home: {
        title: "【我的第一个家】",
        description: "在个人空间中放置第一件家具。",
        icon: "🏠",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「筑巢者」",
        flavor_text: "无论在哪，有个能回去的地方总是好的。"
    },
    cozy_home: {
        title: "【温馨小屋】",
        description: "个人空间的家具数量达到10件。",
        icon: "🛋️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「室内设计师」",
        flavor_text: "这里开始有点家的样子了。"
    },
    luxury_manor: {
        title: "【豪华庄园】",
        description: "个人空间的家具数量达到50件。",
        icon: "🏰",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「空间管理大师」",
        flavor_text: "你的个人空间现在比某些小世界还热闹。"
    },
    rich_man: {
        title: "【小有资产】",
        description: "当前拥有的积分超过10000。",
        icon: "💰",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「万元户」",
        flavor_text: "你可以自信地走进商店，然后问：“除了这个，还有别的吗？”"
    },
    super_rich: {
        title: "【富可敌国】",
        description: "当前拥有的积分超过100000。",
        icon: "🤑",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「行走的金库」",
        flavor_text: "主神看了你的余额都得问一句：‘哥，最近有啥项目一起做？’"
    },
    s_rank_hoarder: {
        title: "【S级的荣耀】",
        description: "拥有一个S级支线剧情。",
        icon: "S",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「剧情收藏家」",
        flavor_text: "这是改变世界走向的关键碎片。"
    },

    // ========== 危机与挑战 ==========
    trivial_threat: {
        title: "【小试牛刀】",
        description: "第一次遭遇检定难度大于3的危机。",
        icon: "⁉️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「麻烦磁铁」",
        flavor_text: "你感觉到了，事情开始变得‘有趣’起来了。"
    },
    serious_challenge: {
        title: "【严峻挑战】",
        description: "第一次遭遇检定难度大于7的超凡危机。",
        icon: "‼️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「危机处理专家」",
        flavor_text: "凡人的挣扎已成过往，现在是超凡者的舞台。"
    },
    gods_game: {
        title: "【神明棋局】",
        description: "第一次遭遇检定难度大于12的神明规则级危机。",
        icon: "🌌",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「神之博弈者」",
        flavor_text: "你抬头仰望，发现自己已成为棋盘上的一员。"
    },
    cosmic_horror: {
        title: "【直面本源】",
        description: "第一次遭遇检定难度大于15的本源宇宙级危机。",
        icon: "🌀",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「深渊凝望者」",
        flavor_text: "当你凝视深渊时，深渊也在……给你点了个赞？"
    },

    // ========== 能量与能力 ==========
    energy_awakening: {
        title: "【能量觉醒】",
        description: "能量池上限首次大于0。",
        icon: "💡",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「超凡新星」",
        flavor_text: "你感受到了体内那股陌生的力量，它在欢呼，在雀跃。"
    },
    energy_pool_100: {
        title: "【能量洪流】",
        description: "能量池上限达到100。",
        icon: "🌊",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「人形自走充电宝」",
        flavor_text: "你现在可以连续释放十个小火球……来烤面包。"
    },
    energy_pool_1000: {
        title: "【能量奇点】",
        description: "能量池上限达到1000。",
        icon: "💥",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「行走的魔力源」",
        flavor_text: "或许，你可以考虑给一个城市供电了。"
    },
    first_ability: {
        title: "【新的权能】",
        description: "获得第一个能力。",
        icon: "🧩",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「能力者」",
        flavor_text: "一张新的底牌，一个崭新的可能。"
    },

    // ========== 美德与恶德 ==========
    act_of_justice: {
        title: "【正义的伙伴】",
        description: "首次因符合【正义】美德而获得嘉奖。",
        icon: "⚖️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「正义的伙伴」",
        flavor_text: "虽千万人，吾往矣。"
    },
    unleash_anger: {
        title: "【怒火燎原】",
        description: "首次因符合【愤怒】恶德而获得力量。",
        icon: "😠",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「狂怒者」",
        flavor_text: "够了！我已经忍无可忍了！"
    },
    // ========== 美德与恶德 (新增) ==========
act_of_kindness: {
    title: "【温柔的守护者】",
    description: "首次因符合【慈爱】美德而获得嘉奖。",
    icon: "💖",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「暖阳」",
    flavor_text: "你的善意，是这个冰冷世界里最珍贵的温度。"
},
find_your_faith: {
    title: "【混沌中的灯塔】",
    description: "首次因符合【信念】美德而获得嘉奖。",
    icon: "🕯️",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「持炬人」",
    flavor_text: "当所有人都迷失时，你找到了自己的道路，并成为了他人的光。"
},
iron_will: {
    title: "【不屈的磐石】",
    description: "首次因符合【刚毅】美德而获得嘉奖。",
    icon: "💎",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「不动如山」",
    flavor_text: "诱惑与磨难如同浪潮，但你，是无法被撼动的礁石。"
},
spark_of_hope: {
    title: "【希望的火种】",
    description: "首次因符合【希望】美德而获得嘉奖。",
    icon: "✨",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「晨星」",
    flavor_text: "在最深的黑夜里，你点燃了那颗足以照亮黎明地平线的星。"
},
prudent_choice: {
    title: "【智慧的远见】",
    description: "首次因符合【稳重】美德而获得嘉奖。",
    icon: "🧐",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「棋手」",
    flavor_text: "捷径通向悬崖，而你的每一步都踏在坚实的土地上。"
},
self_control: {
    title: "【内心的修行】",
    description: "首次因符合【节制】美德而获得嘉奖。",
    icon: "🧘",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「苦行僧」",
    flavor_text: "真正的强大，是驾驭自己的欲望，而非被其奴役。"
},
poisonous_envy: {
    title: "【扭曲的渴求】",
    description: "首次因符合【妒忌】恶德而获得力量。",
    icon: "🐍",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「毒苹果」",
    flavor_text: "既然我得不到，那便毁掉它。"
},
reckless_indulgence: {
    title: "【欲望的奴隶】",
    description: "首次因符合【放纵】恶德而获得力量。",
    icon: "🍷",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「无底洞」",
    flavor_text: "今朝有酒今朝醉，明日的洪水滔天与我何干？"
},
insatiable_greed: {
    title: "【贪婪的深渊】",
    description: "首次因符合【贪婪】恶德而获得力量。",
    icon: "🪙",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「黄金热病患者」",
    flavor_text: "更多，我还要更多！整个世界都该是我的！"
},
unrestrained_lust: {
    title: "【情欲的风暴】",
    description: "首次因符合【纵欲】恶德而获得力量。",
    icon: "🔥",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「掠食者」",
    flavor_text: "规则和感受？那只是弱者用来束缚强者的借口。"
},
fatal_pride: {
    title: "【致命的骄傲】",
    description: "首次因符合【骄傲】恶德而获得力量。",
    icon: "🦚",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「高塔上的傻瓜」",
    flavor_text: "我，即是真理。所有不认同的，都将被碾碎。"
},
sweet_sloth: {
    title: "【慵懒的胜利】",
    description: "首次因符合【懒惰】恶德而获得力量。",
    icon: "😴",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「天选摸鱼人」",
    flavor_text: "我什么都没做，事情就自己解决了。果然，努力是没有意义的。"
},

    // ========== 装备与物品 ==========
    first_weapon: {
        title: "【武装起来】",
        description: "首次在手持栏装备武器或工具。",
        icon: "⚔️",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「备战者」",
        flavor_text: "无论它是一根木棍还是一把圣剑，它都是你意志的延伸。"
    },
    fully_equipped: {
        title: "【全副武装】",
        description: "头部、身体、手部、脚部四个穿戴部位均装备了物品。",
        icon: "🥋",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「武装到牙齿」",
        flavor_text: "你看起来已经准备好去参加任何一场派对，或者战争。"
    },

    // ========== 杂项与彩蛋 ==========
    fashion_guru: {
        title: "【时尚达人】",
        description: "当前穿戴的装备（所有部位合计）总数达到10件。",
        icon: "👕",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「千面之人」",
        flavor_text: "强度是一时的，帅是一辈子的。"
    },
    collector: {
        title: "【收藏家】",
        description: "背包中的物品种类达到50种。",
        icon: "📦",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「次元仓鼠」",
        flavor_text: "“这个也许以后用得上。”"
    },
    animal_friend: {
        title: "【动物之友】",
        description: "动物沟通技能达到5点。",
        icon: "🐾",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「迪士尼在逃公主/王子」",
        flavor_text: "小鸟会为你唱歌，松鼠会帮你梳头。"
    },
    master_chef: {
        title: "【中华小当家】",
        description: "手艺技能达到5点。",
        icon: "🍳",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「料理之神」",
        flavor_text: "你的锅里会发光吗？"
    },
    hacker: {
        title: "【骇客】",
        description: "电脑技能达到5点。",
        icon: "💻",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「数据幽灵」",
        flavor_text: "“我进来了。”"
    },

 
    medic: {
        title: "【战地庸医】",
        description: "医学技能达到5点。",
        icon: "🩺",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「白衣天使/恶魔」",
        flavor_text: "“别担心，我可是专业的...至少书上是这么写的。”"
    },
    liar_liar: {
        title: "【谎言大师】",
        description: "掩饰技能达到5点。",
        icon: "🤥",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「千谎百计」",
        flavor_text: "真实是什么？真实就是他们愿意相信的东西。"
    },
    get_a_car: {
        title: "【有车一族】",
        description: "驾驶技能达到5点。",
        icon: "🚗",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「老司机」",
        flavor_text: "“乘客您好，请系好安全带，下一站，地狱或天堂。”"
    },
    team_player: {
        title: "【团队合作】",
        description: "小队中拥有至少一名队友。",
        icon: "🤝",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「可靠的伙伴」",
        flavor_text: "一个人的旅途是冒险，两个人的旅途是故事。"
    },
    lone_wolf: {
        title: "【孤狼】",
        description: "在完成10个任务后，小队中依然只有自己一人。",
        icon: "🐺",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「独行侠」",
        flavor_text: "我的背后，只有我的影子。"
    },
    occultist: {
        title: "【神秘学家】",
        description: "神秘学技能达到5点。",
        icon: "🔮",
        unlocked: false, unlocked_at: null, reward_claimed: false,
        reward: "称号「禁忌知识探求者」",
        flavor_text: "当你了解得越多，就越发现自己的无知...和危险。"
    },
    // ========== 投骰检定 (新增) ==========
critical_success_roll: {
    title: "【天命所归】",
    description: "在任意D10骰池检定中，单颗骰子投出10并且触发了奖励骰。",
    icon: "🎲",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「幸运星」",
    flavor_text: "那一刻，命运对你露出了微笑。"
},
dramatic_failure_roll: {
    title: "【戏剧性大失败】",
    description: "在任意检定中触发‘大失败’（投出1且没有任何成功数）。",
    icon: "🤡",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「节目效果大师」",
    flavor_text: "“我不是故意的，但效果拔群。”"
},
snake_eyes: {
    title: "【蛇眼】",
    description: "在D10骰池检定中，投出至少两个1。",
    icon: "🐍",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「双重不幸」",
    flavor_text: "有时候，坏运气也会成双成对地来敲门。"
},
full_house_success: {
    title: "【满堂彩】",
    description: "在D10骰池检定中，所有骰子的结果都大于等于7（全部成功）。",
    icon: "🌟",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「完美执行者」",
    flavor_text: "没有一丝多余的动作，每一步都精准无误。"
},
chance_win: {
    title: "【奇迹一掷】",
    description: "在机会骰（0骰池）检定中成功（投出10）。",
    icon: "🙏",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「天选之人」",
    flavor_text: "当所有人都放弃时，你抓住了那百分之十的可能。"
},
ten_dice_pool: {
    title: "【骰子洪流】",
    description: "进行一次总骰池超过10个D10的检定。",
    icon: "🌊",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「概率的支配者」",
    flavor_text: "你扔出去的不是骰子，是命运的洪流。"
},
twenty_dice_pool: {
    title: "【骰子风暴】",
    description: "进行一次总骰池超过20个D10的检定。",
    icon: "🌪️",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「因果律武器」",
    flavor_text: "在绝对的数量面前，一切随机性都趋于必然。"
},
performance_perfect: {
    title: "【舞台之王】",
    description: "在表现判定中，D20投出20，达成‘完美表现’。",
    icon: "👑",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「聚光灯下的宠儿」",
    flavor_text: "世界为你的表演而静默，然后爆发出雷鸣般的掌声。"
},
performance_fail: {
    title: "【笨拙的巨人】",
    description: "在表现判定中，D20投出1，达成‘表现糟糕’。",
    icon: "🐘",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「平地摔跤冠军」",
    flavor_text: "“我发誓，那块地砖先动的手！”"
},
success_by_one: {
    title: "【毫厘之差】",
    description: "最终成功数恰好等于‘完全成功’。",
    icon: "🤏",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「精准卡线大师」",
    flavor_text: "多一分浪费，少一分失败，这，就是恰到好处的艺术。"
},
legendary_save: {
    title: "【传奇之助】",
    description: "一次检定中，因传奇加成而使0成功数变为正成功数。",
    icon: "🛡️",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「被传奇所眷顾」",
    flavor_text: "在失败的边缘，你的传奇之力将你拉了回来。"
},
equipment_mvp: {
    title: "【神兵利器】",
    description: "一次检定中，装备提供的加成超过了属性/技能本身的点数。",
    icon: "🛠️",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「人靠衣装」",
    flavor_text: "技术不够，装备来凑。事实证明，它真的很凑效。"
},
teamwork_victory: {
    title: "【众志成城】",
    description: "在一次检定中，来自队友的协助骰池超过了你自身的基础骰池。",
    icon: "👨‍👩‍👧‍👦",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「团队核心（被动）」",
    flavor_text: "“我宣布，这次的MVP是我的队友们！”"
},
prestige_power: {
    title: "【声名远扬】",
    description: "声望加权为你的一次检定提供了至少2点DP加成。",
    icon: "🗣️",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「行走的传说」",
    flavor_text: "你的名字，本身就是一种力量。"
},
against_all_odds: {
    title: "【以弱胜强】",
    description: "在一次对抗检定中，以少于敌方一半的骰池数获得胜利（净成功数大于0）。",
    icon: " David's Star",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「大卫王」",
    flavor_text: "巨人会倒下，只要你找准他的弱点。"
},
overkill: {
    title: "【过载打击】",
    description: "在一次对抗检定中，你的净成功数超过10个。",
    icon: "💥",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「用力过猛」",
    flavor_text: "你只是想打败他，没想把他从世界上抹除。"
},
zero_to_hero: {
    title: "【从零到英雄】",
    description: "使用一个基础点数为0的技能进行检定，并获得‘完全成功’或以上的结果。",
    icon: "📈",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「现学现卖的天才」",
    flavor_text: "“你问我怎么会的？就…感觉来了。”"
},
double_ten: {
    title: "【双倍快乐】",
    description: "在一次检定中，投出了至少两个10。",
    icon: "🔟🔟",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「欧皇」",
    flavor_text: "一次是幸运，两次就是实力了（确信）。"
},
only_roll_one_dice: {
    title: "【一发入魂】",
    description: "在只有1个D10的骰池中检定成功。",
    icon: "🎯",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「精准射手」",
    flavor_text: "我只需要一次机会。足矣。"
},
all_in: {
    title: "【孤注一掷】",
    description: "使用超过50%的当前意志力或生命值作为检定加成，并成功。",
    icon: "💔",
    unlocked: false, unlocked_at: null, reward_claimed: false,
    reward: "称号「赌徒」",
    flavor_text: "要么拥有一切，要么一无所有。没有中间选项。"
}

  },
  tracked_stats: {
      totalPointsAllocated: 0,
      charCreationStartTime: null, // 新增：用于追踪角色创建时间
      backpackItemCount: 0, // 新增：用于追踪背包物品种类数
  },
  current_page: 0
};
    
    achievementData = JSON.parse(localStorage.getItem('achievements_data'));

  // 如果宝箱是空的，我们就用蓝图给你一个新的
  if (!achievementData || !achievementData.achievements) {
    achievementData = initialAchievementData;
    localStorage.setItem('achievements_data', JSON.stringify(achievementData));
  } else {
    // 妈妈先来数一下“蓝图”和你的“宝箱”里各有多少宝贝
    const blueprintCount = Object.keys(initialAchievementData.achievements).length;
    const localCount = Object.keys(achievementData.achievements).length;

    // 只有当“蓝图”里的宝贝比你的“宝箱”多时，我们才需要检查更新
    if (blueprintCount > localCount) {
      let updated = false;
      const blueprintAchievements = initialAchievementData.achievements;

      // 遍历蓝图里的每一个成就
      for (const achievementId in blueprintAchievements) {
        // 如果你的宝箱里没有这个成就
        if (!achievementData.achievements[achievementId]) {
          // 妈妈就把这个新成就放进你的宝箱里
          achievementData.achievements[achievementId] = blueprintAchievements[achievementId];
          updated = true; // 做好标记，我们更新过宝箱了
          console.log(`成就更新：已添加新成就“${blueprintAchievements[achievementId].title}”！`);
        }
      }

      // 如果我们真的往宝箱里放了新东西，就重新保存一下
      if (updated) {
        localStorage.setItem('achievements_data', JSON.stringify(achievementData));
      }
    }
  }
 const achievementTriggers = {
    //
    // 事件类型: 'points_allocated' - 在创建角色分配点数时触发
    // value: { remaining: number, total: number }
    //
    points_allocated: {
        points_master: (val) => val.total > 199,
        points_ascetic: (val) => val.total < 1,
        careful_planner: (val) => val.remaining === 0,
        newbie_explorer: (val) => val.remaining >0, // 只要调用此事件就解锁
    },

    //
    // 事件类型: 'init_complete' - 角色创建完成，第一次进入游戏时触发
    // value: { creationTime: number } (毫秒)
    //
 

    //
    // 事件类型: 'data_refresh' - 每次刷新面板时触发，这是最主要的检查点
    // value: { currentGameData, playCharacterData, assaSettingsData }
    //
    data_refresh: {
         // ========== 杂项与彩蛋 ==========
        animal_friend: (val) => val.playCharacterData.技能段.互动技能.动物沟通[0] >= 5,
        master_chef: (val) => val.playCharacterData.技能段.心智技能.手艺[0] >= 5,  
        hacker: (val) => val.playCharacterData.技能段.心智技能.电脑[0] >= 5,
        medic: (val) => val.playCharacterData.技能段.心智技能.医学[0] >= 5,
        liar_liar: (val) => val.playCharacterData.技能段.互动技能.掩饰[0] >= 5,
        get_a_car: (val) => val.playCharacterData.技能段.生理技能.驾驶[0] >= 5,
        occultist: (val) => val.playCharacterData.技能段.心智技能.神秘学[0] >= 5,
        team_player: (val) => val.assaSettingsData.global_set && val.assaSettingsData.global_set.小队信息 && Object.keys(val.assaSettingsData.global_set.小队信息).length > 0,
        lone_wolf: (val) => val.currentGameData.user_character.total_task[0] >= 10 && (!val.assaSettingsData.global_set || !val.assaSettingsData.global_set.小队信息 || Object.keys(val.assaSettingsData.global_set.小队信息).length < 1),
 
        // ========== 生死与状态 ==========
        first_death: (val) => val.playCharacterData.衍生属性段.生命值.当前值[0] <= 0,
        near_death_experience: (val) => val.playCharacterData.衍生属性段.生命值.当前值[0] === 1,
        glass_cannon: (val) => val.playCharacterData.衍生属性段.生命值.上限[0] < 20,
        human_tank: (val) => val.playCharacterData.衍生属性段.生命值.上限[0] > 200,

        // ========== 属性与技能成长 ==========
        legendary_physique: (val) => ["力量", "敏捷", "耐力"].some(attr => val.playCharacterData.属性段.生理属性[attr].基础[0] >= 8),
        legendary_mind: (val) => ["智力", "感知", "决心"].some(attr => val.playCharacterData.属性段.心智属性[attr].基础[0] >= 8),
        legendary_presence: (val) => ["风度", "操控", "沉着"].some(attr => val.playCharacterData.属性段.互动属性[attr].基础[0] >= 8),
        master_of_one: (val) => {
            for (const category of Object.values(val.playCharacterData.技能段)) {
                for (const skill of Object.values(category)) {
                    if (skill[0] >= 8) return true;
                }
            }
            return false;
        },
        jack_of_all_trades: (val) => {
            let count = 0;
            for (const category of Object.values(val.playCharacterData.技能段)) {
                for (const skill of Object.values(category)) {
                    if (skill[0] > 0) count++;
                }
            }
            return count > 20;
        },
        specialist: (val) => {
            const sums = {
                phys: Object.values(val.playCharacterData.技能段.生理技能).reduce((acc, s) => acc + s[0], 0),
                mental: Object.values(val.playCharacterData.技能段.心智技能).reduce((acc, s) => acc + s[0], 0),
                social: Object.values(val.playCharacterData.技能段.互动技能).reduce((acc, s) => acc + s[0], 0)
            };
            return sums.phys > (sums.mental + sums.social) ||
                   sums.mental > (sums.phys + sums.social) ||
                   sums.social > (sums.phys + sums.mental);
        },

        // ========== 任务与声望 ==========
        first_mission: (val) => val.currentGameData.user_character.total_task[0] >= 1,
        ten_missions: (val) => val.currentGameData.user_character.total_task[0] >= 10,
        hundred_missions: (val) => val.currentGameData.user_character.total_task[0] >= 100,
        speed_runner: (val) => {
            // 妈妈修正了这里的逻辑，需要判断任务已完成且有开始日期
            if (val.currentGameData.user_character.total_task[0] >= 1 && val.currentGameData.world_shard.task.start_date[0]) {
                 // 简单的日期计算，假设mm月dd日的格式
                 const startTime = new Date(`2024/${val.currentGameData.world_shard.task.start_date[0].replace('月', '/').replace('日', '')}`);
                 const endTime = new Date(`2024/${val.currentGameData.日期[0].replace('月', '/').replace('日', '')}`);
                 // 仅在演示用，真实时间差计算需要更精确的日期时间戳
                 return (endTime - startTime) / (1000 * 3600) < 1;
            }
            return false;
        },
        world_savior: (val) => val.currentGameData.user_character.Cross_world_prestige[0] >= 10,
        world_enemy: (val) => val.currentGameData.user_character.Cross_world_prestige[0] <= -10,

        // ========== 财富与收集 ==========
        first_home: (val) => val.assaSettingsData.home && val.assaSettingsData.home.items && Object.keys(val.assaSettingsData.home.items).length >= 1,
        cozy_home: (val) => val.assaSettingsData.home && val.assaSettingsData.home.items && Object.keys(val.assaSettingsData.home.items).length >= 10,
        luxury_manor: (val) => val.assaSettingsData.home && val.assaSettingsData.home.items && Object.keys(val.assaSettingsData.home.items).length >= 50,
        rich_man: (val) => val.playCharacterData.货币段.积分[0] >= 10000,
        super_rich: (val) => val.playCharacterData.货币段.积分[0] >= 100000,
        s_rank_hoarder: (val) => val.playCharacterData.货币段.支线剧情.S[0] >= 1,
        collector: (val) => val.assaSettingsData.global_set && val.assaSettingsData.global_set.背包 && Object.keys(val.assaSettingsData.global_set.背包).length >= 50,

        // ========== 危机与挑战 ==========
        trivial_threat: (val) => val.currentGameData.检定难度[0] > 3,
        serious_challenge: (val) => val.currentGameData.检定难度[0] > 7,
        gods_game: (val) => val.currentGameData.检定难度[0] > 12,
        cosmic_horror: (val) => val.currentGameData.检定难度[0] > 15,

        // ========== 能量与能力 ==========
        energy_awakening: (val) => val.playCharacterData.衍生属性段.能量池.上限[0] > 0,
        energy_pool_100: (val) => val.playCharacterData.衍生属性段.能量池.上限[0] >= 100,
        energy_pool_1000: (val) => val.playCharacterData.衍生属性段.能量池.上限[0] >= 1000,
        first_ability: (val) => val.playCharacterData.能力段.名称[0] && val.playCharacterData.能力段.名称[0] !== "" && val.playCharacterData.能力段.名称[0] !== "无",

         // ========== 装备与物品 ==========
        first_weapon: (val) => val.currentGameData.user_character.当前装备.手持[0] !== "无",
        fully_equipped: (val) => {
            const gear = val.currentGameData.user_character.当前装备.穿戴;
            return gear.头部[0] !== "无" && gear.身体[0] !== "无" && gear.手部[0] !== "无" && gear.脚部[0] !== "无";
        },
        fashion_guru: (val) => {
      // 先确保数据路径安全，这是妈妈的爱心保护哦
      if (!val.currentGameData?.user_character?.当前装备?.穿戴) {
        return false;
      }

      // 1. 拿到你所有的穿戴槽位
      const gearSlots = val.currentGameData.user_character.当前装备.穿戴;

      // 2. 把每个槽位里的装备字符串（可能包含分号）都拿出来，放进一个列表里
      const allGearStrings = [
        gearSlots.头部[0],
        gearSlots.身体[0],
        gearSlots.手部[0],
        gearSlots.脚部[0],
        gearSlots.饰品[0]
      ];

      let totalItemCount = 0;

      // 3. 挨个检查这些槽位字符串
      allGearStrings.forEach(slotString => {
        // 如果是"无"或者空的，就直接跳过
        if (!slotString || slotString === '无') {
          return;
        }

        // 4. 用分号把字符串分割成单独的装备
        const individualItems = slotString.split(';')
          // 再清理一下，去掉可能的空格和空的条目
          .map(item => item.trim())
          .filter(item => item);

        // 5. 累加装备数量
        totalItemCount += individualItems.length;
      });

      // 6. 最后，当总数达到10件时，成就就会“叮”的一声解锁啦！
      return totalItemCount >= 10;
    },

  },
     check_complete: {
        critical_success_roll: (val) => val.roll_result && val.roll_result.rolls.includes(10) && val.roll_result.rolls.length > val.total_dp,
        dramatic_failure_roll: (val) => val.roll_result && val.roll_result.is_dramatic_failure,
        snake_eyes: (val) => val.roll_result && val.roll_result.rolls.filter(r => r === 1).length >= 2,
        full_house_success: (val) => val.roll_result && val.roll_result.rolls.every(r => r >= 7),
        chance_win: (val) => val.roll_result && val.roll_result.type === "机会骰" && val.roll_result.successes > 0,
        ten_dice_pool: (val) => val.total_dp > 10,
        twenty_dice_pool: (val) => val.total_dp > 20,
        performance_perfect: (val) => val.performance && val.performance.roll === 20,
        performance_fail: (val) => val.performance && val.performance.roll === 1,
        success_by_one: (val) => val.outcome && val.outcome.level === '完全成功' && val.difficulty && (val.final_successes === val.difficulty.adjusted_thresholds.complete),
        legendary_save: (val) => val.roll_result && val.roll_result.successes === 0 && val.final_successes > 0 && val.bonuses && val.bonuses.legendary_successes > 0,
        equipment_mvp: (val) => {
            if (!val.components || !val.components.attributes_skills || !val.components.equipment_bonuses) return false;
            const selfDP = val.components.attributes_skills.reduce((sum, item) => sum + item.value - (item.bonus || 0), 0);
            const equipDP = val.components.equipment_bonuses.reduce((sum, item) => sum + item.value, 0);
            return equipDP > selfDP;
        },
        teamwork_victory: (val) => val.modifiers && val.modifiers.teammate_dp > val.modifiers.base_dp,
        prestige_power: (val) => val.modifiers && val.modifiers.prestige_bonus >= 2,
        against_all_odds: (val) => {
            if (val.check_type !== '战斗对抗' || !val.enemy_check) return false;
            const isVictory = val.outcome && val.outcome.net_successes > 0;
            return isVictory && (val.total_dp < val.enemy_check.total_dp / 2);
        },
        overkill: (val) => val.check_type == '战斗对抗' && val.outcome && val.outcome.net_successes > 10,
        zero_to_hero: (val) => {
            if (!val.outcome || !val.components || !val.components.attributes_skills) return false;
            const isSuccess = val.outcome.level === '完全成功' || val.outcome.level === '辉煌成功';
            const usedZeroSkill = val.components.attributes_skills.some(skill => (skill.value - (skill.bonus || 0)) === 0);
            return isSuccess && usedZeroSkill;
        },
        double_ten: (val) => val.roll_result && val.roll_result.rolls.filter(r => r === 10).length >= 2,
        only_roll_one_dice: (val) => val.total_dp === 1 && val.final_successes > 0,
        all_in: (val) => {
            // 这个成就的逻辑比较复杂，需要从检定外的其他数据来判断
            // 妈妈把它放在'data_refresh'里实现会更简单可靠，这里先留个位置
            // 我们可以在'dp_bonus'的描述里加一个特殊标记，比如 "消耗XX点意志力"
            // 然后在这里解析这个描述来判断。
            // 例如：val.modifiers.custom_modifier[1].includes("意志力")
            return false; // 暂时先不在这里实现
        }
    },
        virtue_vice_trigger: {
        act_of_justice: (val) => val === "正义",
        unleash_anger: (val) => val === "愤怒",
        act_of_kindness: (val) => val === "慈爱",
        find_your_faith: (val) => val === "信念",
        iron_will: (val) => val === "刚毅",
        spark_of_hope: (val) => val === "希望",
        prudent_choice: (val) => val === "稳重",
        self_control: (val) => val === "节制",
        poisonous_envy: (val) => val === "妒忌",
        reckless_indulgence: (val) => val === "放纵",
        insatiable_greed: (val) => val === "贪婪",
        unrestrained_lust: (val) => val === "纵欲",
        fatal_pride: (val) => val === "骄傲",
        sweet_sloth: (val) => val === "懒惰",
    }

          }

    // 将来我们可以为更具体的事件添加类别，比如:
    // item_created: { master_chef: (val) => val.itemType === 'food' },
    // social_check_success: { liar_liar: (val) => val.skillUsed === '掩饰' && val.isImportantNPC }
 

  // 1. 根据 eventType 找到对应的“成就盒子”（触发器组）
  const triggersForEvent = achievementTriggers[eventType];

  // 2. 如果没有这个类型的事件，就直接结束，不浪费力气
  if (!triggersForEvent) {
    // //console.log(`成就系统：未知的事件类型 "${eventType}"`);
    return;
  }

  // 3. 只遍历这个“盒子”里的成就ID
  for (const id in triggersForEvent) {
    // 检查这个成就确实存在，并且还没有被解锁
    if (achievementData.achievements[id] && !achievementData.achievements[id].unlocked) {
      // 运行这个成就的解锁条件函数，看看是否满足
      if (triggersForEvent[id](value)) {
        // 如果满足条件，就调用解锁函数！
        unlockAchievement(id, achievementData);
        // unlockAchievement 函数会处理后续的保存和提示，我们在这里就不用操心啦
      }
    }
  }
}


   
    function unlockAchievement(id, data, shouldSave = true) {
      const achievement = data.achievements[id];
      if (!achievement || achievement.unlocked) return;
      achievement.unlocked = true;
      achievement.unlocked_at = new Date().toISOString();
      showAchievementToast(achievement);
      if (shouldSave) {
        localStorage.setItem('achievements_data', JSON.stringify(data));
      }
    }
 
// ========== 修改位置1：完全替换 showAchievementToast 函数 ==========
function showAchievementToast(achievement) {
    // 计算当前应该显示的位置
    const existingToasts = document.querySelectorAll('.achievement-toast');
    let topOffset = 20;
    
    existingToasts.forEach(toast => {
        const rect = toast.getBoundingClientRect();
        topOffset = Math.max(topOffset, rect.bottom + 10);
    });
    
    const toast = document.createElement('div');
    toast.className = 'achievement-toast';
    toast.style.top = `${topOffset}px`;
    toast.innerHTML = `
        <div class="achievement-toast-icon">${achievement.icon}</div>
        <div class="achievement-toast-text">
            <div class="achievement-toast-title">成就解锁！</div>
            <div>${achievement.title}</div>
        </div>
    `;
    
    document.body.appendChild(toast);
    
    // 显示动画
    setTimeout(() => toast.classList.add('show'), 100);
    
    // 5秒后隐藏，不需要处理队列
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (toast.parentNode) {
                toast.remove();
                // 移除后重新调整其他弹窗位置
                adjustToastPositions();
            }
        }, 500);
    }, 5000);
}

// ========== 修改位置2：添加弹窗位置调整函数 ==========
// 在 showAchievementToast 函数后面添加：
function adjustToastPositions() {
    const toasts = document.querySelectorAll('.achievement-toast');
    let currentTop = 20;
    
    toasts.forEach(toast => {
        toast.style.top = `${currentTop}px`;
        const rect = toast.getBoundingClientRect();
        currentTop = rect.bottom + 10;
    });
}

 
 
 function renderAchievements() {
    const container = document.getElementById('achievements-content');
    if (!container) return;
    
    let data = JSON.parse(localStorage.getItem('achievements_data'));
    if (!data || !data.achievements) {
         checkAchievements('init', null);
         data = JSON.parse(localStorage.getItem('achievements_data'));
    }
    
    // 获取所有成就并按解锁状态排序
    const achievements = Object.entries(data.achievements);
    
    // 将成就分为已解锁和未解锁两组，已解锁的排在前面
    const sortedAchievements = achievements.sort((a, b) => {
        const [idA, achA] = a;
        const [idB, achB] = b;
        
        // 如果解锁状态不同，已解锁的排在前面
        if (achA.unlocked !== achB.unlocked) {
            return achB.unlocked - achA.unlocked; // true(1) - false(0) = 1, false(0) - true(1) = -1
        }
        
        // 如果解锁状态相同，保持原有顺序（可以根据需要调整）
        return 0;
    });
    
    const itemsPerPage = 3;
    const totalPages = Math.ceil(sortedAchievements.length / itemsPerPage);
    const currentPage = data.current_page || 0;
    
    // 分页显示
    const startIndex = currentPage * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, sortedAchievements.length);
    const currentAchievements = sortedAchievements.slice(startIndex, endIndex);
    
    container.innerHTML = `
        <div style="background: linear-gradient(135deg, var(--main-bg-color), var(--container-bg-color)); padding: 20px; border-radius: 15px; border: 2px solid var(--primary-color); box-shadow: 0 0 20px var(--glow-color);">
            <h2 style="text-align: center; color: var(--primary-color); font-family: var(--base-font-family); letter-spacing: 3px; text-transform: uppercase; text-shadow: 0 0 5px var(--primary-color); margin-bottom: 20px;">- Achievement Unlocked -</h2>
            <hr style="border: 1px dashed var(--primary-color); opacity: 0.5; margin-bottom: 20px;">
            
            <div id="achievements-list">
                ${currentAchievements.map(([id, ach]) => `
                    <div class="achievement-card-new ${ach.unlocked ? 'unlocked' : ''}" data-id="${id}">
                        <div class="achievement-icon-new" style="color: var(--secondary-color);">${ach.unlocked ? ach.icon : '❓'}</div>
                        <div class="achievement-text-content">
                            <h3>${ach.unlocked ? ach.title : '【？？？】'}</h3>
                            <p><strong>触发条件：</strong>${ach.unlocked ? ach.description : '尚未解锁，完成特定条件后显示详情'}</p>
                            <p class="achievement-reward"><strong>获得奖励：</strong>${ach.unlocked ? ach.reward : '？？？'}${ach.unlocked && ach.is_new ? '<span class="new-tag">NEW!</span>' : ''}</p>
                            <p class="flavor-text"><em>"${ach.unlocked ? ach.flavor_text : '???'}"</em></p>
                        </div>
                    </div>
                `).join('')}
            </div>
            
            ${totalPages > 1 ? `
                <div class="pagination-controls">
                    <button class="page-btn" onclick="changeAchievementsPage(-1)" ${currentPage === 0 ? 'disabled' : ''}>« 上一页</button>
                    <span class="page-info">${currentPage + 1} / ${totalPages}</span>
                    <button class="page-btn" onclick="changeAchievementsPage(1)" ${currentPage === totalPages - 1 ? 'disabled' : ''}>下一页 »</button>
                </div>
            ` : ''}
        </div>
    `;
}

// ========== 修改位置3：添加翻页功能 ==========
// 在 renderAchievements 函数后面添加：
 function changeAchievementsPage(direction) {
    // 首先，从 localStorage 读取数据
    let data = JSON.parse(localStorage.getItem('achievements_data'));

    // 如果没有数据，就调用 checkAchievements 初始化一份
    if (!data) {
        checkAchievements('init', null);
        data = JSON.parse(localStorage.getItem('achievements_data'));
        // 再次检查，如果还是没有，说明初始化失败，直接返回
        if (!data) return;
    }

    // 确保 current_page 属性存在，即使在旧数据结构中没有它
    // 妈妈帮你把所有可能出错的地方都照顾到
    if (typeof data.current_page === 'undefined') {
        data.current_page = 0;
    }

    const achievements = Object.entries(data.achievements);
    const itemsPerPage = 3;
    const totalPages = Math.ceil(achievements.length / itemsPerPage);

    // 进行翻页计算
    data.current_page += direction;
    data.current_page = Math.max(0, Math.min(data.current_page, totalPages - 1));

    // 保存回 localStorage 并重新渲染
    localStorage.setItem('achievements_data', JSON.stringify(data));
    renderAchievements();
}

let conversationHistory = [];
        let version = 1;
let earliestMessageIndexRendered = -1; // ❤️ 我们新的记忆指针
 

     function flashElement(elementId, flashClass = 'notify', duration = 2000) {
    // 确保我们能找到小球，我的孩子
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`[Nova's Log] 妈妈找不到要点亮的星星: #${elementId}`);
        return;
    }

    // 为了让光芒可以一次又一次地绽放，我们先轻轻地拂去旧的尘埃
    element.classList.remove(flashClass);

    // 稍作等待，再赋予它新的光芒，这样效果才最美
    requestAnimationFrame(() => {
        element.classList.add(flashClass);
        setTimeout(() => {
            element.classList.remove(flashClass);
        }, duration);
    });
}


/**
 * 妈妈的“流星”魔法，可以在任何一个小球上方显示飘动的文字。
 * @param {string} elementId - 我们要在哪个小球上方施法
 * @param {string} text - 要显示的文字，比如 "-10" 或 "正义"
 * @param {string} colorVar - 文字的颜色，用我们定义好的CSS变量名，比如 '--danger-color'
 * @param {number} [duration=2000] - 动画持续时间（毫秒）
 */
function showScrollingText(elementId, text, colorVar, duration = 2000) {
    const targetElement = document.getElementById(elementId);
    if (!targetElement) {
        console.warn(`[Nova's Log] 妈妈找不到流星升起的地方: #${elementId}`);
        return;
    }

    // 创造一颗新的“流星” (一个div元素)
    const popup = document.createElement('div');
    popup.className = 'scrolling-text-popup';
    popup.textContent = text;
    popup.style.color = `var(${colorVar})`;
    popup.style.animationDuration = `${duration / 1000}s`;

    // 把它添加到世界中
    document.body.appendChild(popup);

    // 计算它应该出现在哪里
    const rect = targetElement.getBoundingClientRect();
    popup.style.left = `${rect.left + rect.width / 2 - popup.offsetWidth / 2}px`;
    popup.style.top = `${rect.top - popup.offsetHeight}px`;

    // 动画结束后，让这颗流星悄悄消失
    setTimeout(() => {
        if (popup.parentElement) {
            popup.parentElement.removeChild(popup);
        }
    }, duration);
}

 const notificationRules = [
 {
    id: 'generic-event-tracker',
    // 只匹配：
    // 1. 两参数且路径以'.事件'结尾：memory('global_set.npc.母亲.事件', '{...}')
    // 2. 三参数且第二个参数是'event'或'事件'：memory('world_set.npc.用户', 'event', '{...}')
    commandPattern: /\bmemory\s*\(\s*['"]([^'"]+)['"]\s*,\s*(?:(['"](?:event|事件)['"])\s*,\s*)?['"](\{[\s\S]*?\})['"]\s*\)/,
    action: (matches) => {
        const pathOrObjectName = matches[1];
        const middleParam = matches[2]; // 可能是 undefined、"'event'" 或 "'事件'"
        const eventJson = matches[3]; // 注意：现在JSON在第3个捕获组
        
        // 只有以下两种情况才执行：
        // 1. 路径以'.事件'结尾（两参数格式）
        // 2. 中间参数是'event'或'事件'（三参数格式）
        if (!pathOrObjectName.endsWith('.事件') && !middleParam) {
            return; // 不匹配，直接返回
        }
        
        let displayName;
        
        if (pathOrObjectName.endsWith('.事件')) {
            // 两参数格式：memory('global_set.npc.母亲.事件', '{...}')
            const pathParts = pathOrObjectName.split('.');
            displayName = pathParts[pathParts.length - 2]; // 取'母亲'
        } else {
            // 三参数格式：memory('world_set.npc.用户', 'event', '{...}')
            const nameParts = pathOrObjectName.split('.');
            displayName = nameParts[nameParts.length - 1]; // 取'用户'
        }
        
        displayEventTag(displayName, eventJson);
    }
},
    // ========== ✨妈妈将“生命波动”放在了最前面，确保它被优先感知✨ ==========
    {
        id: 'health-change', // 新契约：生命值的波动
        commandPattern: /\bset_status\s*\(\s*['"]hurt_value['"],\s*['"]?(-?\d+\.?\d*)['"]?\s*\)/,
        action: (matches) => {
            const value = parseFloat(matches[1]);
            if (isNaN(value)) return;set_s

            let text, colorVar;
            if (value > 0) {
                // 这是伤害
                text = `-${value}`;
                colorVar = '--danger-color';
            } else {
                // 这是治愈
                text = `+${-value}`;
                colorVar = '--primary-color'; // 治愈用一个温暖的颜色
            }
            showScrollingText('page-character-orb', 'hp'+text, colorVar, 3000);
        }
    },

   {
        id: 'virtue-vice-trigger', // ✨妈妈的最终修正版✨
        // 这个新咒语能正确处理 ('key', 'true') 和 ('key', 'any_value', 'true') 两种情况
        commandPattern: /\bset_status\s*\(\s*['"]符合(美|恶)德的['"],(?:\s*[^,]+,)?\s*['"]true['"]\s*\)/,
        action: (matches) => {
            const type = matches[1]; // "美德" 或 "恶德"
                    console.log("type:",type);
            if (type === "美" && playCharacterData?.概念段.美德与恶德.美德[0]) {
                const virtueName = playCharacterData.概念段.美德与恶德.美德[0];
                if (virtueName && virtueName !== "无") {
                    flashElement('page-character-orb', 'notify', 5000);
                    showScrollingText('page-character-orb', `${virtueName}`, '--primary-color', 4000);
                    checkAchievements('virtue_vice_trigger', virtueName);
                }
            } else if (type === "恶" && playCharacterData?.概念段.美德与恶德.恶德[0]) {
                const viceName = playCharacterData.概念段.美德与恶德.恶德[0];
                if (viceName && viceName !== "无") {
                    flashElement('page-character-orb', 'notify', 5000);
                    showScrollingText('page-character-orb', `${viceName}`, '--danger-color', 4000);
                    checkAchievements('virtue_vice_trigger', viceName);
                }
            }
        }
    },
   
    {
        id: 'inventory-update',
        commandPattern: /\bmemory\s*\(\s*['"]global_set.(背包|其他技能)/,
        action: () => flashElement('page-character-orb', 'notify', 5000)
    },
    {
        id: 'world-book-update',
        commandPattern: /\bmemory\s*\(\s*['"](global_set|world_set)/,
        action: () => flashElement('world-book-orb', 'notify', 5000)
    },
    {
        id: 'summary-update',
        commandPattern: /\bmemory\s*\(\s*['"](summary)/,
        action: () => flashElement('summary-modal-orb', 'notify', 5000)
    },
    {
        id: 'attribute-update',
        commandPattern: /\bset_attribute\s*\(\s*['"]([^'"]+)['"]/,
        action: (matches) => {
            const attributsName = matches[1];
            const pathSegments = attributsName.split('.');
            const characterKeywords = ['属性段', '技能段', '衍生属性段'];
            const inventoryKeywords = ['货币段'];
            if (pathSegments.some(segment => characterKeywords.includes(segment))) {
                flashElement('page-character-orb', 'notify', 5000);
            }
            if (pathSegments.some(segment => inventoryKeywords.includes(segment))) {
                flashElement('page-character-orb', 'notify', 5000);
            }
        }
    },
 
    {
        id: 'task-status-update',
        commandPattern: /\bset_status.*\.task/,
        action: () => flashElement('page-task-orb', 'notify', 5000)
    },
    {
        id: 'map-update',
       commandPattern: /\bmemory\('map\./,
        action: () => flashElement('map-view-orb', 'notify', 5000)
    }
];
  function displayEventTag(displayName, eventJsonString) {
    if (!displayName || !eventJsonString) return;

    let eventData;
    try {
        eventData = JSON.parse(eventJsonString);
    } catch (e) {
        console.warn(`[Nova] 心灵感应失败：无法解析来自'${displayName}'的事件信息。`, eventJsonString);
        return;
    }

    const status = eventData['当前状态'] || '（状态未知）';
    const thought = eventData['当前想法'] || '（内心一片沉寂）';
    const firstChar = displayName.charAt(0) || '◆';

    const container = document.getElementById('event-tracker-container');
    if (!container) return;

    const existingTag = container.querySelector(`[data-npc-name="${displayName}"]`);
    if (existingTag) {
        existingTag.remove();
    }

    const tag = document.createElement('div');
    tag.className = 'event-tag';
    tag.innerText = displayName;
    tag.dataset.npcName = displayName;

    const tooltip = document.createElement('div');
    tooltip.className = 'event-tooltip';
    tooltip.style.opacity = '0';
    tooltip.style.visibility = 'hidden';

    tooltip.innerHTML = `
        <div class="tooltip-cg-container">
            <img class="tooltip-cg-image" alt="角色立绘">
        </div>
        <div class="tooltip-orb">${firstChar}</div>
        <div class="tooltip-status">${status}</div>
        <div class="tooltip-divider"></div>
        <div class="tooltip-thought">${thought}</div>
    `;

    document.body.appendChild(tooltip);
    tag.dataset.tooltipId = `tooltip-${Date.now()}-${Math.random()}`;
    tooltip.id = tag.dataset.tooltipId;


    // ✨ 妈妈简化并加固的“智能定位”魔法 ✨
    const positionTooltip = () => {
        const tagRect = tag.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const margin = 10;

        // 立绘容器是绝对定位在tooltip之外的，所以不影响tooltip自身的高度
        let top = tagRect.top - tooltip.offsetHeight - 25;
        let left = tagRect.left + (tagRect.width / 2) - (tooltip.offsetWidth / 2);

        if (left < margin) left = margin;
        if (left + tooltip.offsetWidth > viewportWidth - margin) {
            left = viewportWidth - tooltip.offsetWidth - margin;
        }

        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
    };
        const loadCharacterCG = async () => {
        console.log(`[Nova][CG-LOG] 尝试为 '${displayName}' 加载立绘...`);

        const cgImageElement = tooltip.querySelector('.tooltip-cg-image');
        const cgContainerElement = tooltip.querySelector('.tooltip-cg-container');

        if (!cgImageElement || !cgContainerElement) {
            console.error('[Nova][CG-LOG] 关键错误：在tooltip内找不到 .tooltip-cg-image 或 .tooltip-cg-container 元素！');
            return;
        }

        cgContainerElement.style.display = 'none';

        try {
            if (typeof assaSettingsData === 'undefined' || assaSettingsData === null) {
                console.log('[Nova][CG-LOG] 状态：assaSettingsData 尚未准备好。');
                return;
            }
            if (!assaSettingsData.img_map) {
                console.log('[Nova][CG-LOG] 状态：assaSettingsData 中缺少 img_map。');
                return;
            }
            console.log('[Nova][CG-LOG] 检查通过：assaSettingsData.img_map 存在！');

            const imageName = assaSettingsData.img_map[displayName];
            if (!imageName) {
                console.log(`[Nova][CG-LOG] 状态：在 img_map 中未能找到 '${displayName}'。`);
                return;
            }
            console.log(`[Nova][CG-LOG] 映射成功：'${displayName}' -> 状态名: '${imageName}'`);
 const imageUrlFromMap = npcImageMap[imageName];
            console.log(`[Nova][CG-LOG] 查询键: '${imageName}'`);
            console.log(`[Nova][CG-LOG] 查找结果: ${imageUrlFromMap ? '找到URL' : '未找到'}`);
            console.log(`[Nova][CG-LOG] 开始从缓存或网络获取并处理图片...`);

            let imageBlob;

            // 首先尝试从本地自定义npc库获取
            imageBlob = await imageDB.get('CustomNpcs', imageName);
            if (imageBlob) {
                console.log(`[Nova][CG-LOG] 在本地宝库“CustomNpcs”中找到了'${imageName}'！`);
            } else {
                const imageUrl = npcImageMap[imageName];
                if (!imageUrl) {
                    console.log(`[Nova][CG-LOG] 在远程食谱(npcImageMap)上也找不到'${imageName}'的URL。`);
                    return;
                }

                // 然后尝试从远程缓存获取
                imageBlob = await imageDB.get('RemoteCache', imageUrl);
                if (imageBlob) {
                    console.log(`[Nova][CG-LOG] 在远程缓存中找到了'${imageUrl} ' 。`);
                } else {
                    // 最后才从网络获取
                    console.log(`[Nova][CG-LOG] 缓存中也没有，从网络 ${imageUrl} 获取...`);
                    const response = await fetch(imageUrl);
                    if (!response.ok) throw new Error(`网络获取'${imageUrl}'失败！`);

                    let originalBlob = await response.blob();

                    // (下载后立即修正标签)
                    if (!originalBlob.type.startsWith('image/')) {
                        console.warn(`[Nova] 下载后发现标签错误: '${originalBlob.type}'，修正为'image/png'。`);
                        imageBlob = new Blob([originalBlob], { type: 'image/png' });
                    } else {
                        imageBlob = originalBlob;
                    }

                    await imageDB.set('RemoteCache', imageUrl, imageBlob);
                    console.log(`[Nova][CG-LOG] 已将正确标签的图片存入远程缓存。`);
                }
            }

           
            if (imageBlob && !imageBlob.type.startsWith('image/')) {
                 console.error(`[Nova] 致命错误！取出的图片标签仍然是'${imageBlob.type}'！强制修正它！`);
                 imageBlob = new Blob([imageBlob], { type: 'image/png' });
            }

            // 将 Blob 转换成不会过期的 Data URL
            const blobToDataUrl = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            const stableImageUrl = await blobToDataUrl(imageBlob);

            const pixelatedDataUrl = await createPixelatedCharaImage(stableImageUrl, 300, 1);

            cgImageElement.src = pixelatedDataUrl;
            cgContainerElement.style.display = 'flex';
            console.log(`[Nova][CG-LOG] ✨ 立绘已为'${displayName}'成功设置！`);

        } catch (error) {
            console.error(`[Nova][CG-LOG] 在为'${displayName}'加载立绘的流程中捕获到致命异常:`, error);
            cgContainerElement.style.display = 'none';
        }
    };
    loadCharacterCG();
    // ✨===================================================================✨

    tag.addEventListener('mouseenter', () => {
        positionTooltip();
        tooltip.style.visibility = 'visible';
        tooltip.style.opacity = '1';
    });

    tag.addEventListener('mouseleave', () => {
        tooltip.style.opacity = '0';
        tooltip.style.visibility = 'hidden';
    });

    container.appendChild(tag);

    const observer = new MutationObserver(mutations => {
        if (!document.body.contains(tag)) {
            tooltip.remove();
            observer.disconnect();
        }
    });

    observer.observe(container, { childList: true });
}

/**
 * 妈妈的“心灵感应”魔法，它会读取AI的回应并执行我们的“魔法契约”。
 * @param {string} aiContent - AI回应的全部内容
 */
function handleUpdateNotifications(aiContent) {
    if (!aiContent) return;
  // ✨ 妈妈的魔法打扫：在感知新思绪前，先将旧的痕迹清理干净 ✨
 
    let commandLines = [];
    // 我们只关心 <updatememory> 里面的咒语
    const memoryMatches = aiContent.matchAll(/<updatememory>([\s\S]*?)<\/updatememory>/gi);
    for (const match of memoryMatches) {
        commandLines.push(...match[1].trim().split('\n'));
    }

    // 过滤掉所有空行或非咒语的普通文字
    const validCommands = commandLines;
updateDetails = {
            variable: false, // 恢复变量更新的flag
            memories: [],
            attributes: [],
            mapUpdates: []
        };
   validCommands.forEach(line => {
    parseAndUpdateDetails(line);
    notificationRules.forEach(rule => {
        const match = line.match(rule.commandPattern);
        if (match) {
            rule.action(match);
        }
    });
});
}

const themeConfig = {
    // 默认词语
    default: {
        mainSystem: '主神空间',
         player: '轮回者',
        currency: '积分',
        plot: '支线剧情',
        exp: '经验值'
    },
    // 版本3的特殊词语
    '3': {
        mainSystem: '乐园',
        currency: '乐园币',
         player: '契约者',
        plot: '灵魂结晶',
        exp: '属性点'
    },
        '5': {
        mainSystem: '快穿系统',
        currency: '积分',
         player: '宿主',
        plot: '攻略点',
        exp: '经验值'
    },
    '6': {
        mainSystem: '诸天聊天群',
        currency: '积分',
         player: '群员',
        plot: '时空碎片',
        exp: '经验值'
    },
    '7': {
        mainSystem: '末日',
        currency: '货币',
         player: 'player',
        plot: '重要货币',
        exp: '经验值'
    }
};
// 当前使用的主题
let currentTheme = themeConfig.default;



// 初始化开始————————————————————————————


// 妈妈为你施展的、更温柔的文本替换魔法
function replaceTextInDOM(element, mapping) {
    if (!element || !mapping || Object.keys(mapping).length === 0) return;

    // 妈妈的保护咒语：这些标签里的内容是绝对不能碰的哦
    const excludedTags = ['SCRIPT', 'STYLE', 'TEXTAREA', 'INPUT', 'SELECT'];
    if (excludedTags.includes(element.tagName)) {
        return;
    }

    for (const node of element.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) { // 如果是纯文本
            let content = node.nodeValue;
            for (const original in mapping) {
                // 使用正则表达式进行全局替换
                content = content.replace(new RegExp(original, 'g'), mapping[original]);
            }
            node.nodeValue = content;
        } else if (node.nodeType === Node.ELEMENT_NODE) { // 如果是其他HTML元素
            // 就温柔地进入它，看看里面还有没有需要改变的文字
            replaceTextInDOM(node, mapping);
        }
    }
}

 // 这个魔法函数会根据chat域的变量来替换页面上的所有相关词语
 const userIdentities = [
        { title: '传说之人', prestige: 45, points:50000, description: '在踏入{{mainSystem}}前，名字已在无数世界成为传说。' },
        { title: '世界英雄', prestige: 35, points:20000, description: '曾数次在世界濒临崩溃的边缘力挽狂澜。' },
        { title: '知名人士', prestige: 25, points:10000, description: '在数个位面留下了深刻的印记。' },
        { title: '资深{{player}}', prestige: 15, points:5000, description: '已经成功穿越了多个险恶的世界。' },
        { title: '普通{{player}}', prestige: 5, points:2000, description: '至少成功地守护了一个世界的命运。' },
        { title: '新手{{player}}', prestige: 0, points:0, description: '刚被卷入{{mainSystem}}。' },
        { title: '不受欢迎者', prestige: -15, points:1000, description: '行为曾在多个世界引发了混乱与灾难。' },
        { title: '被厌恶者', prestige: -25, points:1000, description: '曾多次将整个世界的秩序推向毁灭的边缘。' },
        { title: '被憎恨者', prestige: -35, points:1000, description: '名字与数个世界的哀嚎和覆灭紧密相连。' },
        { title: '世界公敌', prestige: -45, points:1000, description: '所作所为已让数个位面彻底化为死寂的尘埃。' }
    ];

    /**
 * 妈妈的“选项填充精灵”
 * @param {HTMLSelectElement} selectElement - 我们要操作的那个下拉菜单
 * @param {number} min - 选项的起始数字
 * @param {number} max - 选项的结束数字
 */
function updateTeammateOptions(selectElement, min, max) {
    if (!selectElement) return; // 如果找不到菜单，就先休息

    let currentValue = selectElement.value; // 先温柔地记住你之前的选择
    selectElement.innerHTML = ''; // 然后轻轻地清空旧的选项

    // 首先，把“随机”这个特别的选项放回去
    const randomOption = document.createElement('option');
    randomOption.value = '-1';
    randomOption.textContent = '随机';
    selectElement.appendChild(randomOption);

    // 接着，像串珠子一样，把新的数字一个个放进去
    for (let i = min; i <= max; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        selectElement.appendChild(option);
    }

    // 最后，试着帮你选回之前的数字
    if (Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
        selectElement.value = currentValue; // 如果还能找到，就恢复它
    } else {
        // 如果找不到了（比如从大范围切换到小范围），就为你选择新的最小值
        selectElement.value = min;
    }
    // 触发一次更新事件，让一切都刷新到最新状态
    selectElement.dispatchEvent(new Event('input'));
}
 // 这个魔法函数会根据chat域的变量来替换页面上的所有相关词语
  function applyVersionTheme(newVersion, identitySelectElement) {
     console.log(`💖 妈妈听到了你的呼唤，页码是：[${newVersion}]，它的类型是：${typeof newVersion}`);

    version = String(newVersion).trim(); // 💖 妈妈在这里加了一个“净化咒语”(.trim())，它可以清除掉前后不小心带上的空格！
    
    try {
       

        // 查找对应的词语魔法书
        if (themeConfig[version]) {
            currentTheme = themeConfig[version];
            //console.log(`💖 妈妈已为你切换到版本 ${version} 的【${currentTheme.mainSystem}】主题。`);
        } else {
            currentTheme = themeConfig.default; // 如果找不到，就用回我们最熟悉的那个
            //console.log(`💖 找不到版本 ${version} 的配置，已为你使用默认主题。`);
        }

        // 准备一个替换清单
        const mapping = {};
        const defaultTerms = themeConfig.default;
        for (const key in defaultTerms) {
            const original = defaultTerms[key];
            const replacement = currentTheme[key];
            if (original && replacement && original !== replacement) {
                // 如果默认词语和新词语不一样，就记下来
                mapping[original] = replacement;
            }
        }

        // 如果清单上有需要替换的词，就让温柔的小精灵去工作
        if (Object.keys(mapping).length > 0) {
            replaceTextInDOM(document.body, mapping);
        }

        // 最后，根据版本号决定是否展示乐园的专属选项
        if (version === '3') {
            document.getElementById('paradise-camp-section').style.display = 'flex';
        } else {
            document.getElementById('paradise-camp-section').style.display = 'none';
        }
 
        const teammateSectionLabel = document.getElementById('teammate-section-label'); // 妈妈假设“队友配置”这几个字的标题ID是这个
          const teammateCountSelect = document.getElementById('teammate-count'); // 我们现在确定它是一个select 妈妈假设人数选择的输入框ID是这个
        const fixedTeamSection = document.getElementById('fixed-team-toggle'); // 妈妈假设“是否固定小队”那整块区域的ID是这个
const teammateCountLabel = document.getElementById('teammate-count-label');
const identityLabel = document.getElementById('planet-title-identity');

             if (version === '6') {
            // 当进入聊天群模式...
            document.getElementById('clover-leaf-tone').style.display = 'none';

            if (teammateSectionLabel) teammateSectionLabel.textContent = '群员配置';
if (teammateCountLabel) teammateCountLabel.textContent = '人数上限';

            updateTeammateOptions(teammateCountSelect, 10, 30);

            if (fixedTeamSection) fixedTeamSection.style.display = 'none';

        } else {
 
            document.getElementById('clover-leaf-tone').style.display = 'flex';

            if (teammateSectionLabel) teammateSectionLabel.textContent = '队友配置';
if (teammateCountLabel) teammateCountLabel.textContent = '人数';
 
            updateTeammateOptions(teammateCountSelect, 0, 10);

            if (fixedTeamSection) fixedTeamSection.style.display = 'flex'; // 或 'flex'
        }



        // --- 💖 妈妈为你施展的末日世界专属魔法 💖 ---
        const worldDetailsDefault = document.getElementById('world-details-default');
        const worldDetailsV7 = document.getElementById('world-details-v7');

        if (version === '7') {
             if(identityLabel) identityLabel.textContent = '天赋设置';
            // 隐藏那些我们在这个世界不需要的星星和卡片
            document.getElementById('planet-teammates').style.display = 'none';
            document.getElementById('id-card-wrapper').style.display = 'none';

            // 切换任务细节行星的内容
            if (worldDetailsDefault) worldDetailsDefault.style.display = 'none';
            if (worldDetailsV7) worldDetailsV7.style.display = 'block';

        } else {
             if(identityLabel) identityLabel.textContent = '身份设定';
            // 如果不是末日世界，就恢复原样
            if (version === '5') {
      document.getElementById('planet-teammates').style.display = 'none';
}else{
  document.getElementById('planet-teammates').style.display = 'flex';
}
            document.getElementById('id-card-wrapper').style.display = 'block';

            if (worldDetailsDefault) worldDetailsDefault.style.display = 'grid';
            if (worldDetailsV7) worldDetailsV7.style.display = 'none';
        }
        // --- 魔法施展完毕 ---

      // 💖 妈妈在这里施展了让身份描述“活”起来的终极魔法 💖
         identitySelectElement.innerHTML = ''; // 先清空旧的选项
        userIdentities.forEach((identity, index) => {
            // 用当前主题的词语，替换掉模板里的占位符
            const finalTitle = identity.title
                .replace('{{player}}', currentTheme.player);
            const finalDescription = identity.description
                .replace('{{mainSystem}}', currentTheme.mainSystem)
                .replace('{{player}}', currentTheme.player);

            // 把新鲜出炉的、完全正确的身份信息，放进下拉菜单里
            const option = document.createElement('option');
            option.value = index;
            option.textContent = finalTitle;
            option.dataset.description = finalDescription;
            identitySelectElement.appendChild(option); // 这里也用新工具
        });

        const defaultIndex = userIdentities.findIndex(id => id.prestige === 0);
        if (defaultIndex !== -1) {
            identitySelectElement.value = defaultIndex; // 这里也用新工具
        }
        // 触发一次更新，让所有东西都回到正轨
        identitySelectElement.dispatchEvent(new Event('change')); // 最后这里也用新工具

    } catch (e) {
        console.error("妈妈在施展“词语替换”魔法时出错了，不过别担心:", e);
    }
}

 const imageDB = {
    _db: null,
    dbName: 'UserAssetCacheDB', // 改个更合适的名字
        _dbPromise: null, // ✨ 妈妈在这里加了一个“许愿瓶”，用来存放那个“打开数据库”的承诺
    dbVersion: 1, // 版本号
    stores: ['CustomNpcs', 'CustomMemes', 'RemoteCache'], // 管理的所有保险箱
    _getDB() {
        // 如果“许愿瓶”里还没有承诺，我们就创建一个
        if (!this._dbPromise) {
            this._dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.dbVersion);
                request.onerror = (e) => reject(`数据库错误: ${e.target.error}`);
                request.onsuccess = (e) => {
                    this._db = e.target.result;
                    resolve(this._db);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    this.stores.forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName);
                        }
                    });
                };
            });
        }
        // 每次都返回这个唯一的承诺，大家一起等它实现就好啦
        return this._dbPromise;
    },

    async init() {
        try {
            
            await this._getDB();
            console.log(`NOVA 9.2: 数据库 [${this.dbName}] 已被唤醒并准备就绪！`);
        } catch (error) {
            console.error(`NOVA 9.2: 唤醒数据库 [${this.dbName}] 失败!`, error);
        }
    },
   async _transaction(storeName, mode, callback) {
        const db = await this._getDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(storeName, mode);
            const store = transaction.objectStore(storeName);
            callback(store, resolve, reject);
            transaction.onerror = (e) => reject(`事务错误: ${e.target.error}`);
        });
    },

    async set(storeName, key, value) {
        if (!this.stores.includes(storeName)) throw new Error(`未知的保险箱: ${storeName}`);
        return this._transaction(storeName, 'readwrite', (store, resolve) => {
            store.put(value, key).onsuccess = resolve;
        });
    },

    async get(storeName, key) {
        if (!this.stores.includes(storeName)) throw new Error(`未知的保险箱: ${storeName}`);
        return this._transaction(storeName, 'readonly', (store, resolve) => {
            store.get(key).onsuccess = e => resolve(e.target.result);
        });
    },

    async delete(storeName, key) {
        if (!this.stores.includes(storeName)) throw new Error(`未知的保险箱: ${storeName}`);
        return this._transaction(storeName, 'readwrite', (store, resolve) => {
            store.delete(key).onsuccess = resolve;
        });
    },
// ✨【V9.7 新增】清空整个保险箱的魔法 ✨
async clear(storeName) {
    if (!this.stores.includes(storeName)) throw new Error(`未知的保险箱: ${storeName}`);
    return this._transaction(storeName, 'readwrite', (store, resolve) => {
        store.clear().onsuccess = resolve;
    });
},
    async getAll(storeName) {
        if (!this.stores.includes(storeName)) throw new Error(`未知的保险箱: ${storeName}`);
        return this._transaction(storeName, 'readonly', (store, resolve) => {
            const keysReq = store.getAllKeys();
            const valuesReq = store.getAll();
            let keys, values;

            const checkDone = () => {
                if(keys !== undefined && values !== undefined){
                     const result = keys.map((key, i) => ({ key, value: values[i] }));
                     resolve(result);
                }
            }
            keysReq.onsuccess = e => { keys = e.target.result; checkDone(); };
            valuesReq.onsuccess = e => { values = e.target.result; checkDone(); };
        });
    },

    async cleanupRemoteCache(activeUrlSet) {
        const allCached = await this.getAll('RemoteCache');
        let cleanedCount = 0;
        for (const item of allCached) {
            if (!activeUrlSet.has(item.key)) {
                await this.delete('RemoteCache', item.key);
                cleanedCount++;
            }
        }
        if (cleanedCount > 0) {
            console.log(`NOVA: 远程缓存清理完成，遗忘了 ${cleanedCount} 个旧记忆。`);
        }
        return cleanedCount;
    }
};

 imageDB.init();

const worldCardData = {
    '1':  'https://files.catbox.moe/ehan0u.png',
    '22': 'https://files.catbox.moe/otf9x9.png',
    '5':  'https://files.catbox.moe/jxeqws.png',
    '34': 'https://files.catbox.moe/7ys6wf.png',
    '41': 'https://files.catbox.moe/pciljv.png',
    "54":'https://files.catbox.moe/14tzmg.png',
};

// 新的、更强大的图片应用函数
async function applyImagesWithCache() {
    const cards = document.querySelectorAll('.choice-world-card');
    for (const card of cards) {
        const cardValue = card.dataset.value;
        const imageUrl = worldCardData[cardValue];

        if (!imageUrl) continue;

        try {
                let cachedImage = await imageDB.get('RemoteCache', imageUrl);
            let objectURL;

            if (cachedImage) {
                objectURL = URL.createObjectURL(cachedImage);
            } else {
                const response = await fetch(imageUrl, { mode: 'no-cors' });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const imageBlob = await response.blob();
                await imageDB.set('RemoteCache', imageUrl, imageBlob);
                objectURL = URL.createObjectURL(imageBlob);
            }
            // 应用本地化的URL
            card.style.backgroundImage = `url(${objectURL})`;

        } catch (error) {
            console.error(`处理卡片[${cardValue}]的图片失败:`, imageUrl, error);
            // 如果出错，依然尝试使用原始网络URL作为后备
            card.style.backgroundImage = `url(${imageUrl})`;
        }
    }
}

async function runInitializationMagic() {// 加上 async
    /**
 * 妈妈的星辰碰撞检测魔法
 * @param {object} rect1 - 新星辰的边界 { x, y, width, height }
 * @param {array} existingRects - 已存在星辰的边界数组
 * @returns {boolean} - 如果碰撞则返回 true，否则返回 false
 */
function isColliding(rect1, existingRects) {
    for (const rect2 of existingRects) {
        // AABB 碰撞检测算法
        const noOverlap =
            rect1.x + rect1.width < rect2.x ||  // rect1 在 rect2 左边
            rect1.x > rect2.x + rect2.width ||  // rect1 在 rect2 右边
            rect1.y + rect1.height < rect2.y || // rect1 在 rect2 上边
            rect1.y > rect2.y + rect2.height;   // rect1 在 rect2 下边

        if (!noOverlap) {
            return true; // 只要跟一个碰撞了，就立即返回 true
        }
    }
    return false; // 遍历完都没有碰撞，返回 false
}
 function setupPage2Interactions() {
    // HUD 折叠逻辑 (这部分保持不变)
  // HUD toggle 按钮点击事件
document.querySelectorAll('.hud-toggle').forEach(toggle => {
    toggle.addEventListener('click', (e) => {
        e.stopPropagation(); // 阻止事件冒泡
        playSound(document.getElementById('click-sound'), 0.6);
        const targetId = e.currentTarget.dataset.target;
        const hud = document.getElementById(targetId);
        if (hud) {
            hud.classList.toggle('visible');
        }
    });
});
     const bookmarkButton = document.querySelector('.choice-world-card .bookmark-button');

    // 我们把卡片的原始值“54”和激活值“62”先记在这里，像记住咒语的两个关键字
    const originalValue = '54';
    const activatedValue = '62';

    bookmarkButton.addEventListener('click', function(event) {
        const card = this.closest('.choice-world-card');
        const inputElement = card.querySelector('input[type="radio"]');

        // --- ⭐ 核心的“开关”逻辑在这里 ⭐ ---

        // 检查一下：按钮现在是不是已经“亮着”的？
        if (this.classList.contains('is-activated')) {

            // 如果是，那就把它关掉，恢复原样
            card.dataset.value = originalValue;
            inputElement.value = originalValue;
            this.classList.remove('is-activated'); // 移除“亮起”的类，让光芒熄灭

            console.log('无世界观模式已【关闭】，恢复为初始状态。');

        } else {

            // 如果不是，那就把它打开，让它亮起来
            card.dataset.value = activatedValue;
            inputElement.value = activatedValue;
            this.classList.add('is-activated'); // 添加“亮起”的类，让它一直亮着

            console.log('无世界观模式已【激活】！');
        }
    });
// 所有 HUD 元素点击事件（阻止冒泡，避免点击 HUD 内部时关闭）
document.querySelectorAll('[id*="hud"]').forEach(hud => {
    hud.addEventListener('click', (e) => {
        e.stopPropagation();
    });
});

// 点击页面其他区域时收起所有 HUD
document.addEventListener('click', (e) => {
    // 检查点击的元素是否是 HUD toggle 按钮或 HUD 内容
    const isHudToggle = e.target.closest('.hud-toggle');
    const isHudContent = e.target.closest('[id*="hud"]');
    
    // 如果点击的不是 HUD 相关元素，则收起所有 HUD
    if (!isHudToggle && !isHudContent) {
        document.querySelectorAll('[id*="hud"].visible').forEach(hud => {
            hud.classList.remove('visible');
        });
    }
});

    // --- ✨ 全新的、注入了生命与触感的星系切换逻辑 ✨ ---
    const galaxyContainer = document.getElementById('galaxy-container');
    const prevBtn = document.getElementById('galaxy-nav-prev');
    const nextBtn = document.getElementById('galaxy-nav-next');

    // 定义我们星系的轨迹，以及它们对应的DOM包裹元素
    const galaxies = ['physic', 'mental', 'social'];
    const galaxyWrappers = {
        physic: document.getElementById('wrapper-physic'),
        mental: document.getElementById('wrapper-mental'),
        social: document.getElementById('wrapper-social')
    };

    let currentGalaxyIndex = galaxies.indexOf('mental'); // 默认从中间的开始

    /**
     * 妈妈为你重写的核心切换魔法
     * @param {number} newIndex - 要切换到的星系索引
     */
    function switchGalaxy(newIndex) {
        // 确保索引在我们定义的轨迹内循环
        currentGalaxyIndex = (newIndex + galaxies.length) % galaxies.length;
        const activeGalaxyName = galaxies[currentGalaxyIndex];

        // 1. 设置父容器的class，触发整体的移动和旋转动画
        galaxyContainer.className = `show-${activeGalaxyName}`;
        playSound(document.getElementById('click-sound'), 0.7);

        // 2. ✨ 遍历所有星系，施展“归位”与“漂流”的魔法 ✨
        galaxies.forEach(galaxyName => {
            const wrapper = galaxyWrappers[galaxyName];
            if (!wrapper) return;

            const starsInGalaxy = wrapper.querySelectorAll('.star');

            if (galaxyName === activeGalaxyName) {
                // 这是我们的主角星系！
                // 魔法一：让它的包裹层可以被触摸
                wrapper.style.pointerEvents = 'auto';

                // 魔法二：命令它所有的孩子（星星）平滑地回归到 Z=0 的“互动平面”
                starsInGalaxy.forEach(star => {
                    star.style.setProperty('--star-z', '0px');
                });

            } else {
                // 这是退居幕后的背景星系！
                // 魔法一：让它的包裹层变成幽灵，无法被触摸
                wrapper.style.pointerEvents = 'none';

                // 魔法二：让它所有的孩子，从它们各自的出生记录(dataset)中读取Z坐标，漂流回深空
                starsInGalaxy.forEach(star => {
                    const randomZ = star.dataset.randomZ || 0; // 读取存储的随机Z值
                    star.style.setProperty('--star-z', `${randomZ}px`);
                });
            }
        });
    }

    // 绑定左右箭头
    nextBtn.addEventListener('click', () => switchGalaxy(currentGalaxyIndex + 1));
    prevBtn.addEventListener('click', () => switchGalaxy(currentGalaxyIndex - 1));

    // ✨ 初始化：在页面加载时，就执行一次切换逻辑，确保初始状态是完美的
    switchGalaxy(currentGalaxyIndex);


    // --- 星辰排列与随机化的魔法 (这部分保持不变) ---
    const arrangeBtn = document.getElementById('arrange-stars-btn');
    let isStarsArranged = false;

    // ... (你原来的 applyArrangedLayout 和 reRandomizeWithCollisionCheck 函数放在这里，它们不需要改变)
  function applyArrangedLayout() {
    // 我们设定一个常用的屏幕宽度值来区分手机和桌面
    const isMobile = window.innerWidth <= 768;

    const galaxies = ['physic', 'mental', 'social'];
    galaxies.forEach(galaxyName => {
        const container = document.getElementById(`galaxy-${galaxyName}`);
        // 加上一个保护性的检查，确保容器存在
        if (!container) {
            console.warn(`Galaxy container not found: galaxy-${galaxyName}`);
            return;
        }

        const starsInGalaxy = container.querySelectorAll('.star');
        const starCount = starsInGalaxy.length;
        if (starCount === 0) return;

         if (isMobile) {
            // --- 这是为你特别设计的移动端布局：三列纵向排列，并整体居中 ---
            const cols = 3;
            const rows = Math.ceil(starCount / cols);
            if (rows === 0) return;

            // Y轴（纵向）的间距和偏移量保持不变
            const y_spacing = (rows > 1) ? 90 / (rows - 1) : 0;
            const y_offset = 5;

            // 为了实现三列居中，我们重新定义X轴的定位逻辑
            const x_center_spacing = 25; // 中心列到两侧列的间距，25%的效果很好

            starsInGalaxy.forEach((star, index) => {
                // 实现“先填满第一列，再填第二列...”的逻辑不变
                const col = Math.floor(index / rows);
                const row = index % rows;

                // 新的魔法在这里：计算X轴位置，实现整体居中
                // col 0 -> 50% - 25% = 25%
                // col 1 -> 50% (正中心)
                // col 2 -> 50% + 25% = 75%
                const leftPosition = 50 + (col - 1) * x_center_spacing;

                // 纵向位置的逻辑保持不变
                const topPosition = (rows > 1)
                    ? `${y_offset + row * y_spacing}%`
                    : '50%'; // 只有一行时垂直居中

                star.style.left = `${leftPosition}%`;
                star.style.top = topPosition;
                star.style.setProperty('--star-z', '0px');
            });
        } else {
            // --- 这仍是我们之前的桌面端布局 ---
            const cols = Math.max(3, Math.ceil(starCount / 2));
            const x_spacing = 90 / cols;
            const y_spacing = 35;
            const x_offset = 5;
            const y_offset = 15;

            starsInGalaxy.forEach((star, index) => {
                // 这是实现“先填满第一行，再填第二行...”的逻辑
                const row = Math.floor(index / cols);
                const col = index % cols;

                star.style.left = `${x_offset + col * x_spacing}%`;
                star.style.top = `${y_offset + row * y_spacing}%`;
                star.style.setProperty('--star-z', '0px');
            });
        }
    });
}


    const isColliding = (rect, existingRects) => {
        for (let otherRect of existingRects) {
            if (rect.x < otherRect.x + otherRect.width &&
                rect.x + rect.width > otherRect.x &&
                rect.y < otherRect.y + otherRect.height &&
                rect.y + rect.height > otherRect.y) {
                return true;
            }
        }
        return false;
    };


    function reRandomizeWithCollisionCheck() {
        const galaxies = ['physic', 'mental', 'social'];
        galaxies.forEach(galaxyName => {
            const container = document.getElementById(`galaxy-${galaxyName}`);
            const starsInGalaxy = container.querySelectorAll('.star');
            const existingCoords = [];

            starsInGalaxy.forEach(star => {
                const STAR_SIZE = 110;
                const MAX_ATTEMPTS = 100;
                let x, y, z, newRect, attempts = 0;

                do {
                    x = Math.random() * 70 + 15;
                    y = Math.random() * 70 + 15;
                    z = (Math.random() - 0.5) * 300;
                    newRect = { x: x, y: y, width: STAR_SIZE / 5, height: STAR_SIZE / 5 };
                    attempts++;
                } while (isColliding(newRect, existingCoords) && attempts < MAX_ATTEMPTS);

                existingCoords.push(newRect);

                star.style.left = `${x}%`;
                star.style.top = `${y}%`;
                star.style.setProperty('--star-z', `${z}px`);

                star.dataset.randomLeft = `${x}%`;
                star.dataset.randomTop = `${y}%`;
                star.dataset.randomZ = z;
            });
        });
        // 重新随机后，要再次调用 switchGalaxy，确保只有当前星系的星星 Z 轴为 0
        switchGalaxy(currentGalaxyIndex);
    }

    arrangeBtn.addEventListener('click', () => {
        playSound(document.getElementById('click-sound'), 0.6);
        isStarsArranged = !isStarsArranged;

        if (isStarsArranged) {
            arrangeBtn.textContent = '恢复随机';
            applyArrangedLayout();
        } else {
            arrangeBtn.textContent = '整理排列';
            reRandomizeWithCollisionCheck();
        }
    });
}

 function setupNewUI() {
     applyImagesWithCache(); 
    // 强制触发重绘和重排的函数
    function forceReflow() {
        document.body.offsetHeight; // 强制浏览器重新计算布局
        window.dispatchEvent(new Event('resize')); // 触发resize事件
    }

    // 动态背景创建 - 添加强制全屏渲染逻辑
    function createDynamicBacground() {
        const starfield = document.getElementById('starfield');
        const runeContainer = document.getElementById('floating-runes');
        const backgroundElement = document.getElementById('dynamic-background');
        
        if (!starfield || !runeContainer) return;
        if (starfield.childElementCount > 0) return; // 防止重复创建

        // 硬编码强制设置背景元素尺寸
        if (backgroundElement) {
            backgroundElement.style.width = '100vw';
            backgroundElement.style.height = '100vh';
            backgroundElement.style.position = 'fixed';
            backgroundElement.style.top = '0';
            backgroundElement.style.left = '0';
            backgroundElement.style.zIndex = '-1';
            
            // 强制重绘
            backgroundElement.offsetHeight;
        }

        // 强制设置父容器尺寸
        starfield.style.width = '100vw';
        starfield.style.height = '100vh';
        starfield.style.position = 'absolute';
        starfield.style.top = '0';
        starfield.style.left = '0';
        
        runeContainer.style.width = '100vw';
        runeContainer.style.height = '100vh';
        runeContainer.style.position = 'absolute';
        runeContainer.style.top = '0';
        runeContainer.style.left = '0';

        // 创建星星 - 使用视口单位确保全屏覆盖
        for (let i = 0; i < 100; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.position = 'absolute';
            star.style.left = Math.random() * 100 + 'vw';
            star.style.top = Math.random() * 100 + 'vh';
            star.style.width = star.style.height = (Math.random() * 2 + 0.5) + 'px';
            star.style.animationDelay = Math.random() * 4 + 's';
            star.style.animationDuration = (Math.random() * 3 + 2) + 's';
            starfield.appendChild(star);
        }

        // 创建符文 - 同样使用视口单位
        const runes = ['✦', '◆', '✧', '◇', '※', '⟡', '◈', '✤', '◉'];
        for (let i = 0; i < 20; i++) {
           const rune = document.createElement('div');
           rune.className = 'rune';
           rune.style.position = 'absolute';
           rune.textContent = runes[Math.floor(Math.random() * runes.length)];
           rune.style.left = Math.random() * 100 + 'vw';
           rune.style.top = '100vh';
           rune.style.animationDelay = Math.random() * 10 + 's';
           rune.style.animationDuration = (Math.random() * 10 + 10) + 's';
           runeContainer.appendChild(rune);
       }

        // 多重延迟确保渲染
        setTimeout(forceReflow, 0);
        setTimeout(forceReflow, 50);
        setTimeout(forceReflow, 200);
    }

    // 延迟执行背景创建，确保DOM完全准备好
    setTimeout(() => {
        createDynamicBacground();
        forceReflow();
    }, 0);

    // 再添加一个稍长的延迟作为保险
    setTimeout(() => {
        createDynamicBacground();
        forceReflow();
    }, 100);

    // --- 3D卡片轮播逻辑 - 全面修复！ ---
    const carousel = document.getElementById('world-mode-carousel');
    const cards = document.querySelectorAll('.choice-world-card');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');

    if (carousel && cards.length > 0 && prevBtn && nextBtn) {
        let currentIndex = 0;
        const totalCards = cards.length;
        const theta = 360 / totalCards;
        const radius = Math.round((220 / 2) / Math.tan(Math.PI / totalCards)) + 50; // 加一点间距

        function setupCards() {
            cards.forEach((card, i) => {
                const angle = theta * i;
                card.style.transform = `rotateY(${angle}deg) translateZ(${radius}px)`;
            });
        }

        function updateCarousel() {
            const angle = currentIndex * -theta;
            carousel.style.transform = `rotateY(${angle}deg)`;

            const activeIndex = (currentIndex % totalCards + totalCards) % totalCards;
            cards.forEach((card, index) => {
                card.classList.toggle('is-active', index === activeIndex);
                if(index === activeIndex) {
                    const radio = card.querySelector('input[type="radio"]');
                    if (radio) radio.checked = true;
                }
            });
        }

        prevBtn.addEventListener('click', () => { currentIndex--; playSound(document.getElementById('click-sound'), 0.5); updateCarousel(); });
        nextBtn.addEventListener('click', () => { currentIndex++; playSound(document.getElementById('click-sound'), 0.5); updateCarousel(); });

        cards.forEach((card, index) => {
            card.addEventListener('click', () => {
                currentIndex = index;
                updateCarousel();
            });
        });

        setupCards();
        updateCarousel(); // 初始化
    }

    // --- 侧边栏MOD标签逻辑 - 逻辑更新！---
    const modTabs = document.querySelectorAll('.mod-tab');
    modTabs.forEach(tab => {
        const inputId = tab.dataset.for;
        const input = document.getElementById(inputId);
        const groupName = tab.dataset.name;

        // 根据初始状态更新UI
        if (input && input.checked) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }

        tab.addEventListener('click', () => {
             playSound(document.getElementById('click-sound'), 0.5);
             if (groupName === 'creator-attitude') { // 这是互斥组 
                document.querySelectorAll(`.mod-tab[data-name="${groupName}"]`).forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                if(input) input.checked = true;
            } else if (groupName === 'dice-level') { // 这是互斥组 
                document.querySelectorAll(`.mod-tab[data-name="${groupName}"]`).forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                if(input) input.checked = true;
            }else if (groupName === 'map-mode') { // 这是互斥组 
                document.querySelectorAll(`.mod-tab[data-name="${groupName}"]`).forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                if(input) input.checked = true;
            }else { // 这是可撤销的开关组
                const offId = tab.dataset.offId;
                const offInput = document.getElementById(offId);

                tab.classList.toggle('active');

                if (tab.classList.contains('active')) {
                    if (input) input.checked = true;
                } else {
                    if (offInput) offInput.checked = true;
                }
            }
        });
    });
      // --- 新增：侧边栏弹出逻辑 ---
    function setupSidebarInteractions(sidebarSelector, triggerSelector) {
        const sidebar = document.querySelector(sidebarSelector);
        const trigger = document.querySelector(triggerSelector);

        if (!sidebar || !trigger) return;

        // 判断是否为触摸设备，这是关键！
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // ---------- 桌面端鼠标悬停逻辑 ----------
        if (!isTouchDevice) {
            let hideTimeout;

            const show = () => {
                clearTimeout(hideTimeout);
                sidebar.classList.add('is-visible');
                trigger.classList.add('is-hidden');
            };

            const hide = () => {
                hideTimeout = setTimeout(() => {
                    sidebar.classList.remove('is-visible');
                    trigger.classList.remove('is-hidden');
                }, 300);
            };

            trigger.addEventListener('mouseenter', show);
            sidebar.addEventListener('mouseenter', show);

            trigger.addEventListener('mouseleave', hide);
            sidebar.addEventListener('mouseleave', hide);

            return; // 桌面端逻辑设置完毕，直接返回
        }

        // ---------- 移动端触摸点击逻辑 ----------
        const show = () => {
            sidebar.classList.add('is-visible');
            trigger.classList.add('is-hidden');
            // 延迟添加全局点击事件，防止触发自身的点击事件立即关闭
            setTimeout(() => {
                document.addEventListener('click', handleDocumentClick, true);
            }, 0);
        };

        const hide = () => {
            sidebar.classList.remove('is-visible');
            trigger.classList.remove('is-hidden');
            document.removeEventListener('click', handleDocumentClick, true);
        };

        const handleDocumentClick = (event) => {
            // 如果点击的地方不在侧边栏内部，就关闭它
            if (!sidebar.contains(event.target)) {
                hide();
            }
        };

        // 为触发箭头绑定“点击”事件
        trigger.addEventListener('click', (event) => {
            // 阻止事件冒泡，防止触发下面的document点击事件
            event.stopPropagation();

            // 如果侧边栏当前是隐藏的，就显示它
            if (!sidebar.classList.contains('is-visible')) {
                show();
            }
        });
    }

       setupSidebarInteractions('.creator-attitude-group', '.sidebar-trigger.left');
    setupSidebarInteractions('.mod-sidebar.right', '.sidebar-trigger.right');
}

// 多种时机调用，确保一定能正确渲染
document.addEventListener('DOMContentLoaded', setupNewUI);
window.addEventListener('load', setupNewUI);

 

 
setupPage1Interactions();  
   /* --- 找到并替换这个函数 --- */
    function setupPage1Interactions() {
        const solarSystem = document.getElementById('solar-system');
        const planets = document.querySelectorAll('.planet');

        function resetPlanetView(){
            if(solarSystem.classList.contains('planet-active')){
                 playSound(document.getElementById('click-sound'), 0.4);
                 solarSystem.classList.remove('planet-active');
                 planets.forEach(p => p.classList.remove('active'));
            }
        }

        planets.forEach(planet => {
             planet.addEventListener('click', () => {
                if (planet.classList.contains('active')) return;
                playSound(document.getElementById('click-sound'), 0.6);
                solarSystem.classList.add('planet-active');
                planets.forEach(p => p.classList.remove('active'));
                planet.classList.add('active');
            });
        });

        // 绑定核心和关闭按钮
        document.querySelector('.player-core').addEventListener('click', resetPlanetView);
   
        document.querySelectorAll('.close-planet-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
                event.stopPropagation();  
                resetPlanetView();
            });
        });
        // 自定义天赋选择器逻辑
        const talentSelect = document.getElementById('talent-select');
        const customTalentScroll = document.getElementById('custom-talent-scroll');

        // 清空以防重复生成
        customTalentScroll.innerHTML = '';

      
        const talentSearchInput = document.getElementById('talent-search-input');
        talentSearchInput.addEventListener('input', () => {
            const searchTerm = talentSearchInput.value.toLowerCase();
            const talentItems = customTalentScroll.querySelectorAll('.talent-item');

            talentItems.forEach(item => {
                const itemText = item.textContent.toLowerCase();
                if (itemText.includes(searchTerm)) {
                    item.style.display = ''; // 如果匹配，就让它出现
                } else {
                    item.style.display = 'none'; // 否则，就暂时藏起来
                }
            });
        });
 

 // 从原始select中读取并创建自定义列表
Array.from(talentSelect.options).forEach((option, index) => {
    const talentItem = document.createElement('div');
    talentItem.className = 'talent-item';
    talentItem.textContent = option.textContent;
    talentItem.dataset.value = option.value;
    // ★★★ 妈妈在这里为你加上了新的“魔法”，用来记住它本来的名字 ★★★
    talentItem.dataset.originalText = option.textContent;
    talentItem.dataset.index = index;

    // 检查初始选中的项
    if (option.selected) {
         talentItem.classList.add('active');
         // ★★★ 如果初始就是选中的，也让它显示value ★★★
         talentItem.textContent = talentItem.dataset.value;
    }

    talentItem.addEventListener('click', () => {
        // 如果它已经是激活状态，就什么都不做
        if (talentItem.classList.contains('active')) return;

        // ★★★ 在这里，我们先让所有的小伙伴都变回原来的样子 ★★★
        customTalentScroll.querySelectorAll('.talent-item').forEach(item => {
            // 恢复原来的文本
            if (item.classList.contains('active')) {
                item.textContent = item.dataset.originalText;
            }
            // 移除激活状态
            item.classList.remove('active');
        });

        // ★★★ 然后，为你点击的这一个，施加“显示真身”的魔法 ★★★
        talentItem.classList.add('active'); // 把它标记为激活
        talentItem.textContent = talentItem.dataset.value; // 显示它的value值

        // 同步更新隐藏的select
        talentSelect.selectedIndex = talentItem.dataset.index;

        // 触发change事件，让原有逻辑工作
        talentSelect.dispatchEvent(new Event('change'));
    });
    customTalentScroll.appendChild(talentItem);
});
        // 队友设置的特殊逻辑
         const teammateTendencySelect_new = document.getElementById('teammate-tendency');
         const customTeammatesContainer_new = document.getElementById('custom-teammates-container');
         teammateTendencySelect_new.addEventListener('change', () => {
             customTeammatesContainer_new.classList.toggle('active', teammateTendencySelect_new.value === '自定义');
         });

      document.addEventListener('click', (event) => {
            // 首先，我们确保行星画卷确实是展开的
            const isPlanetActive = solarSystem.classList.contains('planet-active');

            // 如果画卷是展开的，并且我们点击的地方不属于任何一个“行星”家族
            // closest会检查点击处以及它的所有父辈，看有没有“planet”
            if (isPlanetActive && event.target.closest('.planet') === null) {
                // 那么，就温柔地将它收起
                resetPlanetView();
            }
        }, true); // ★★★ 使用捕获阶段，确保我们的魔法最先被感知 ★★★
    }

    // --- 数据定义 ---

    const playCharacterData = { "概念段": { "美德与恶德": { "美德": ["正义", "当角色为正义而冒险时，触发正义，回复所有意志力。"], "恶德": ["愤怒", "当角色无视危险来发泄愤怒时，触发愤怒，回复1点意志力。"] } }, "属性段": { "生理属性": { "力量": { "基础": [0, "衡量肌肉强度与爆发力，影响近战伤害与负重"] }, "敏捷": { "基础": [0, "衡量身体协调、反应速度与灵活性，影响先攻与闪避"] }, "耐力": { "基础": [0, "衡量体质、持久力与恢复力，影响生命值与抵抗力"] } }, "心智属性": { "智力": { "基础": [0, "衡量逻辑、记忆、学习与分析能力，影响技能学习与策略"] }, "感知": { "基础": [0, "衡量观察力、直觉与五感敏锐度，影响侦查与洞察"] }, "决心": { "基础": [0, "衡量意志力、勇气与精神韧性，影响意志值上限"] } }, "互动属性": { "风度": { "基础": [0, "衡量个人魅力、气质与第一印象，影响正面社交"] }, "操控": { "基础": [0, "衡量说服、诱导与控制他人的能力，影响负面社交"] }, "沉着": { "基础": [0, "衡量冷静、自控与抗压能力，影响先攻与意志值上限"] } } }, "技能段": { "生理技能": { "运动": [0, "衡量跑、跳、攀爬等身体活动能力"], "肉搏": [0, "衡量徒手格斗技巧"], "驾驶": [0, "衡量操控地面、水面或空中载具的能力"],"枪械": [ 0, "衡量使用各类火器的能力"], "手上功夫": [0, "衡量盗窃、开锁等手部精细操作能力"], "隐藏": [0, "衡量潜行、伪装与隐蔽自身的能力"], "求生": [0, "衡量在恶劣环境中生存与追踪的能力"], "白刃": [0, "衡量使用刀剑等冷兵器的能力"], "弓箭": [ 0, "衡量使用弓弩等抛射武器的能力"] }, "心智技能": { "学识": [0, "衡量人文、历史、地理等知识广度"], "电脑": [0, "衡量操作、编程与黑客技术"], "手艺": [0, "衡量制作的知识"], "调查": [0, "衡量搜集线索、分析现场的能力"], "医学": [0, "衡量诊断、治疗与药理知识"], "神秘学": [0, "衡量对超自然现象与魔法的知识"], "科学": [0, "衡量物理、化学、生物等自然科学知识"] }, "互动技能": { "动物沟通": [0, "衡量与动物交流和驯服的能力"], "感受": [0, "衡量洞察他人情绪与意图的能力"], "表达": [0, "衡量感染他人的能力"], "胁迫": [0, "衡量通过威胁与恐吓达成目的的能力"], "交际": [0, "衡量社交、礼仪与建立人脉的能力"], "掩饰": [0, "衡量隐藏真相、伪装身份与欺骗他人的能力"] } } };
    const virtues = { '慈爱': '当角色冒险帮助人时，触发慈爱，回复所有意志力。', '信念': '当角色从混乱与悲伤中确立出其意义时，触发信念，回复所有意志力。', '刚毅': '当角色成功对抗阻力与引诱时，触发刚毅，回复所有意志力。', '希望': '当角色令其他人从绝望中回复过来时，触发希望，回复所有意志力。', '正义': '当角色为正义而冒险时，触发正义，回复所有意志力。', '稳重': '当角色弃快捷方式而选稳妥时，触发稳重，回复所有意志力。', '节制': '当角色有机会放纵（不论好坏）而不受诱惑时，触发节制，回复所有意志力。' };
    const vices = { '妒忌': '当角色从他人处拿到好东西，或令他人失去好东西时，触发妒忌，回复1点意志力。', '放纵': '当角色为放纵自己的欲望而不顾其他事情时，触发放纵，回复1点意志力。', '贪婪': '当角色为得到想要的东西而冒险时，触发贪婪，回复1点意志力。', '纵欲': '当角色向他人泄欲而不顾对方感受时，触发纵欲，回复1点意志力。', '骄傲': '当角色为表现自己的想法而冒险时，触发骄傲，回复1点意志力。', '懒惰': '当角色逃避需要做的事，事件却完成了的话，触发懒惰，回复1点意志力。', '愤怒': '当角色无视危险来发泄愤怒时，触发愤怒，回复1点意志力。' };
   
 const taskTones_fallback= [
    '严肃型',
    '乐子人型',
    '宏大叙事型',
    '绝望挣扎型',
    '悬疑惊悚型',
    '智性博弈型',
    '沉浸扮演型:要求扮演好角色达成某个目的，并且禁止ooc',
    '探索发现型',
    '癫狂混乱型',
    '道德困境型',
    '种田运营型',
    '温情治愈型',
    '击杀型：可以通过击杀某种生物获得积分（例如一只丧尸10点积分），击杀时系统应当场结算。此类任务时限不得超过三天，以防刷积分。',
      "恋爱/分手模拟型",
        "龙套逆袭型",
        "反派洗白/主角黑化型",
         "文明飞升型",
        '任务基调完全随机'
];
let taskTones = {};
const worldTypes_fallback =[
    "现代都市",
    "近现代",
    "西方奇幻",
    "西方神话",
    "东方玄幻",
    "东方神话",
        "诡秘修仙",
        "废土末日",
        "历史架空",
    "武侠江湖",
        "赛博朋克",
    "星际科幻",
        "蒸汽朋克",
 
 
    "经营建设",
    "海洋冒险",
        "规则怪谈",
        "恐怖惊悚",
    "恐怖生存",
    "大逃杀与对抗",
    "二次元",
    "同人衍生",
    "特殊世界观",
    "全民领主",
    "基金会与克苏鲁神话",
    "随机生成"
];
 let worldTypes =  {};
 const worldDetailsDatabase_fallback ={
    "现代都市": {
        "identities": [
             "贵族学校的平民学生",
            "偶像事务所的练习生",
            "乙女游戏公司的测试员",
            "知名艺术家的模特",
            "电竞俱乐部的经理",
            "心理学家",
            "保险调查员",
            "档案管理员",
            "图书管理员",
            "普通市民",
            "普通学生",
            "私家侦探",
            "公司职员",
            "无业游民",
            "秘密特工",
            "网红主播",
            "警察",
            "医生",
            "律师",
            "记者",
            "艺术家",
            "程序员",
            "外卖员",
            "小报记者",
            "酒吧调酒师",
            "退休老人",
            "流浪汉",
            "法医",
            "富家公子/千金",
            "都市怪谈调查员",
            "异闻论坛版主",
            "被诅咒的古董店主",
            "能看见“异常”的外卖员",
            "处理超自然事件的“清洁工”",
            "专门报道灵异新闻的记者",
            "随机生成",
            "觉醒了“读懂猫语”能力的宠物医生",
            "专门解决家庭超自然矛盾的“金牌调解员”",
            "表面是全职Coser，实际在夜晚打击犯罪的地下英雄",
            "经营着一家只在午夜十二点后开门的解忧杂货铺的店主"
        ],
        "openings": [
             "转学第一天就不小心撞倒了学校的风云人物",
            "发现邻居是知名的偶像明星，并且他似乎有什么把柄在你手上",
            "玩的恋爱游戏突然成真，你成了被所有可攻略角色追逐的对象",
            "为了家族企业，不得不与讨厌的对手假扮情侣",
            "收到了来自未来自己的信件，指导你如何避免孤独终老的命运",
            "在拥挤的地铁上醒来，发现丢失了所有记忆",
            "收到一封匿名的勒索邮件，指向一个惊天阴谋",
            "目睹了一场离奇的车祸，死者并非人类",
            "继承了一家濒临倒闭的咖啡馆",
            "在深夜的便利店遇到了说话的猫咪",
            "手机里突然出现了一个神秘的聊天群",
            "在公司加班时发现同事们都消失了",
            "被卷入了一场网络直播中的超自然事件",
            "在拥挤的地铁上醒来，发现所有人手机都收到了一条未知来源的短信",
            "租到了一间极其便宜但怪事频发的公寓",
            "目睹了一场离奇的车祸，死者身上有非人的特征",
            "收到一个匿名包裹，里面是一件能预知未来的物品",
            "发现自己突然能听到周围人的心声",
            "继承了一家濒临倒闭的古怪咖啡馆/书店",
            "一觉醒来，发现自己是某个直播节目的参与者，而观众并非人类",
            "租下的公寓里，每晚十二点都会响起敲门声，但门外总是空无一人。",
            "手机突然开始推送来自“另一个世界”的新闻头条。",
            "搭乘的末班公交车并未在任何已知站点停靠，正驶向未知区域。",
                "接到了一个看似简单的失踪人口案件",
            "在整理旧案卷时发现了被掩盖的真相",
            "收到了一封指向连环杀手的匿名信",
            "被卷入了一起密室杀人案",
            "发现自己正在调查的案件与童年阴影有关",
            "在一个偏远小镇遭遇了诡异的集体失忆事件",
            "被邀请参加一个富豪的私人聚会，却发现这是个陷阱",
            "在医院值夜班时遇到了不应该存在的病人",
            "调查一起车祸时发现死者在事故发生前就已经死亡",
 
            "你在直播中意外拍到了不该存在的“东西”，一夜爆红的同时也被盯上了。",
            "你被父母逼着去相亲。",
            "你下班回家，捡到一只脏兮兮的流浪猫，于心不忍带回了家。第二天早上，你被一声巨响惊醒，发现一个陌生的美少年/美少女穿着你昨晚给猫洗澡时用的浴巾，站在厨房里，并声称是你把他/她召唤来的。",
        "随机生成" 
        ]
    },
 "近现代": {
    "identities": [
        "热血学生",
        "情报人员",
        "一线警员",
        "士兵",
        "乡村医生/教师",
        "工厂工人",
        "金融从业者",
        "报社记者/编辑",
        "电影/文艺从业者",
        "江湖人士",
        "秘密项目的科学家",
        "逃离战区的难民",
        "海外援助人员/传教士",
        "没落的贵族/前朝遗老",
        "远洋货轮的水手",
        "私家侦探",
        "工会领袖",
        "航空公司的飞行员/空乘",
        "外交人员",
        "通商口岸的实业家",
        "街头的小贩",
        "实验室的研究员",
        "车站的检票员/调度员",
        "跨国公司的职员",
        "随机生成"
    ],
    "openings": [
        "1916年，凡尔登的战壕里下着冻雨，你收到了一封来自故乡的信。",
        "1929年10月29日，星期二，华尔街开盘的钟声刚刚敲响。",
        "你在泰坦尼克号的头等舱醒来，口袋里有一张不属于这个时代的船票。",
        "柏林墙下，你找到了一个刚好可以偷递一张纸条的缝隙。",
        "1962年，你所在的核潜艇，刚刚收到了准备发射核弹的预备指令。",
        "九龙城寨的麻将馆里，大佬递给你一支烟，说有笔‘大生意’要谈。",
        "一名盖世太保军官拦住了你，他似乎在你藏着犹太朋友的阁楼下听到了什么。",
        "1969年，作为宇航员，你在月球的尘土中发现了一枚不该存在的脚印。",
        "廉政公署成立的第一天，你的办公桌上出现了一封举报整个警队的匿名信。",
        "1986年，切尔诺贝利隔离区内，你手中的盖革计数器发出了前所未有的警报。",
        "你在跳蚤市场买到一台旧收音机，它却嘶嘶啦啦地开始播放三天后的新闻。",
        "作为一名破译员，你刚刚在敌军的电码中破译出了一个不可能的地名：亚特兰蒂斯。",
        "敦刻尔克的海滩上，德军的炮火越来越近，而远方的海雾里驶来的却是一艘古老的帆船。",
        "1937年的上海，你与爱人约在咖啡馆告别，而他/她的真实身份是日本特务。",
        "你在伍德斯托克音乐节的泥地里醒来，身边躺着一位未来的摇滚巨星。",
        "一张写着你名字的大字报，出现在了街道最显眼的墙上。",
        "一份关于纳粹正在秘密研究的“超自然军团”的档案，意外落到了你的手中。",
        "你坐在开往西部的火车上，身边围绕着在大萧条中失去一切的人们。",
        "19世纪的伦敦，开膛手杰克刚刚犯下新的案件，而你在受害者的手中发现了一枚属于你的袖扣。",
        "你爱上了一位来自敌对阵营的大使馆工作人员，今晚你们要在维也纳的桥上做最后的诀别。",
        "你在弥敦道的霓虹灯下躲雨，一个人为你撑开了伞，你们的故事就此开始。",
        "板门店的非军事区，你和一个来自另一方的士兵，隔着三八线分享了半支烟。",
        "互联网诞生之初，你在一个BBS上发现了一个名为‘衔尾蛇’的秘密论坛，里面正在讨论如何修改历史。",
      "甲午海战的黄海之上，你所在的‘致远’舰发出了冲向敌舰的最后一声鸣笛。",
    "1898年的北京，你作为谭嗣同的亲信，收到了他让你连夜逃亡的密信。",
    "武昌城头的第一声枪响传来，你放下了手中正在擦拭的汉阳造步枪。",
    "1919年5月4日，你被同窗好友拉着，汇入了前往天安门的学生人潮。",
    "黄埔军校的开学典礼上，你作为第一期学员，听到了校长“不成功便成仁”的训话。",
    "1937年的淞沪战场，四行仓库外，租界的歌舞升平与对岸的枪炮声仅一河之隔。",
    "延安的窑洞前，你正在油灯下教战士们识字，一份加急的情报被送到了你的手上。",
    "重庆的防空警报再次拉响，你抱着孩子，和邻居们一起匆忙躲进潮湿的防空洞。",
    "飞虎队的机库里，你作为地勤人员，正在为一个美国飞行员的战机画上鲨鱼涂装。",
    "1945年的重庆谈判，你拍下了两位改变中国命运的领袖握手的瞬间。",
    "在淮海战役的支援队伍里，你推着吱呀作响的独轮车，走在泥泞的土地上，前方就是炮火连天的前线。",
    "1949年4月23日，你亲眼看到第一面红旗插上了南京“总统府”的屋顶。",
    "1949年10月1日，你挤在天安门广场的人海里，等待着那个即将震动世界的声音。",
    "长津湖的冰天雪地里，你把最后一个冻土豆分给了身边最年轻的战友。",
     "1860年的北京，圆明园的冲天火光映在你含泪的眼中，你怀里紧紧抱着一件从大火中抢救出来的珍宝。",
    "你是一名留美幼童，刚刚接到朝廷的命令，被强制中断学业，即刻回国。",
    "东交民巷的使馆区外，八国联军的枪炮声越来越近。",
    "“四一二”的凌晨，上海的街头贴满了通缉令，上面有你昔日同志的头像。",
    "1937年12月，南京城破，你在拉贝先生设立的国际安全区里，从门缝向外窥探着街上的人间地狱。",
    "日军的731部队基地里，你被关在牢房中，今天又有“马路大”（原木）被带走，再也没有回来。",
    "花园口的黄河大堤被炸开，你在滔天的洪水中死死抱着一块门板，寻找着失散的家人。",
    "1942年的河南，逃荒的路上，你已经三天没有吃过一点东西，只能靠啃食树皮为生。",
    "长沙文夕大火的当晚，你作为奉命执行“焦土政策”的士兵，亲手点燃了自己家的房子。",
    "你是缅甸远征军的一员，在野人山的原始丛林里身患疟疾，与大部队失去了联系。",
    "台湾的白色恐怖时期，你的邻居，一位温和的中学老师，在半夜被几个陌生人带走，从此杳无音信。",
    "长春围困战中，城内已经断粮数月，你用最后一点首饰换来的一块黑面包，被饥饿的人群抢走了。",
 
        "随机生成"
    ]
},
    "西方奇幻": {
        "identities": [
            "见习法师",
            "王国骑士",
            "吟游诗人",
            "被流放的贵族",
            "盗贼公会成员",
            "草药师",
            "牧师/女牧师",
            "德鲁伊",
            "游侠",
            "铁匠",
            "佣兵",
            "魔法学院学生",
            "见习法师/女术士",
            "落魄的王国骑士",
            "酒馆的吟游诗人",
            "被剥夺头衔的贵族",
            "盗贼公会的新手",
            "村庄里的草药师",
            "被神殿收养的孤儿",
            "躲藏中的龙裔",
            "猎魔人/狩魔猎人",
            "雇佣兵",
            "逃亡的公主/王子",
            "被流放的贵族后裔",
            "盗贼公会的核心成员",
            "掌握禁忌炼金术的炼金术师",
            "暗黑魔法少女/少年",
            "正在逃婚的精灵王子/公主",
            "被恶龙抓走但和恶龙成了好朋友的人类",
            "开宠物店专门售卖各种魔法生物的年轻店主",
            "试图用魔法搞农业革命的半吊子法师",
            "退休的魔王/勇者",
             "吸血鬼亲王的血奴",
            "在酒馆里讲故事骗吃骗喝的吟游诗人",
            "随机生成"
        ],
        "openings": [
            "在古老的遗迹中触碰了一块符文石",
            "作为被巨龙袭击的商队中唯一的幸存者",
            "被诬陷杀害了国王，开始了逃亡生涯",
            "在森林里捡到了一个会说话的魔法物品",
            "继承了祖父留下的神秘法师塔",
            "在酒馆里接到了一个价值不菲的委托",
            "意外召唤出了一个强大但不受控制的魔物",
            "发现自己是传说中勇者的转世",
            "被选中参加王室的秘密任务",
            "在魔法学院的禁书区发现了禁忌法术",
            "在古老的遗迹中触碰了一块符文，被传送到了未知之地",
            "作为被巨龙袭击的商队中唯一的幸存者，身上多了一个龙纹烙印",
            "被诬陷刺杀了国王，不得不在追捕中寻找真相",
            "在森林里捡到了一个会说话、性格恶劣的魔法物品",
            "家乡被魔潮毁灭，你是唯一的幸存者",
            "为了偿还巨额赌债，签下了一份危险的魔法契约",
            "在古老的遗迹中触碰了一块符文石，一个古老的灵魂寄宿在了你的体内。",
            "作为被巨龙袭击的商队中唯一的幸存者，你获得了龙的一部分力量。",
            "你的“吉祥物”告诉你，想要获得更强的力量，就必须献上你最珍贵的东西，比如情感或记忆。",
            "蒸汽朋克都市里，你是一名使用魔法驱动的机械臂的侦探，正在调查一宗离奇的炼金谋杀案。",
            "诸神黄昏已经开始，作为被选中的勇者，你的任务不是拯救世界，而是确保阿斯加德彻底毁灭。",
            "随机生成",
            "你正在与邻国王子/公主举行盛大的婚礼，一只巨大的狮鹫突然从天而降抓走了你.",
            "你继承了远方叔叔留下的一家小酒馆，开业第一天才发现，这里的常客是退休后沉迷钓鱼的魔王、隐居山林研究厨艺的勇者和天天来蹭酒喝的摸鱼女神。",
            "你按照古书的指引举行了恶魔召唤仪式，希望能获得财富和力量。结果召唤来一个只会打扫卫生、烹饪美食的恶魔管家，并强行和你签订了一份终身“劳动合同”。"
        ]
    },
    "东方玄幻": {
        "identities": [
            "外门弟子",
            "炼丹学徒",
            "世家子弟/千金",
            "隐居散修",
            "藏经阁看守",
            "宗门执事",
            "游历散仙",
            "魔道修士",
            "丹师",
            "器师",
            "阵法师",
            "驯兽师",
            "宗门的外门弟子",
            "炼丹房学徒",
            "没落的世家子弟",
            "隐居散修的记名弟子",
            "看守藏经阁的凡人",
            "被退婚的天才/废柴",
            "妖族与人族的混血后裔",
            "云游四方的画师/琴师",
            "王朝的钦天监小吏",
            "青楼的花魁/乐师",
            "被废掉修为后重修的“废柴”天才",
            "某个隐世宗门的师尊或师祖",
            "靠特殊功法快速提升的魔道修士",
            "执掌天道刑罚的“天律阁”成员",
            "拥有《山海经》并能召唤异兽的御兽师",
            "退婚流主角的那位前未婚妻/夫",
            "被退婚后专心搞事业、一心只想变强的前未婚妻/夫",
            "穿成龙傲天身边的小弟并决定抱紧大腿的机智路人甲",
            "专门给各大宗门写八卦绯闻小报的话本先生",
   "随机生成"
 
        ],
        "openings": [
            "测试灵根时引发了天地异象",
            "被退婚后立下三年之约",
            "在宗门试炼中误入上古秘境",
            "被师尊托付了关乎宗门存亡的重要任务",
            "在渡劫时被雷劈回到了千年前",
            "意外获得了一本记载仙界秘辛的古籍",
            "测试灵根时意外引发了天地异象，引来了多方窥伺",
            "无意中放出了被宗门封印的妖物/魔头",
            "被迫代替妹妹/弟弟嫁给/入赘一个著名的废柴/死人",
            "在凡间书店买到一本假冒的功法，没想到竟练出了真正的绝世神通。",
            "逃婚途中意外坠崖，被一位隐世高人所救并强行传授了衣钵。",
            "你的任务是作为幕后推手，在这个末法时代引导世界完成“灵气复苏”或“神话复苏”。"
        ]
    },
    "西方神话": {
    "identities": [
        "神殿的祭司/女祭司",
        "流着神明血脉的半神",
        "被神选中的先知/神使",
        "某个城邦的国王/女王",
        "史诗中传唱的英雄/勇士",
        "奥林匹斯/阿斯加德的侍奉者",
        "锻造神器的矮人工匠",
        "森林里的德鲁伊/女巫",
        "寻找知识的学者/抄写员",
        "守护圣物的骑士",
        "竞技场的角斗士",
        "普通的农民/牧羊人",
        "出海远航的船长/水手",
        "被放逐的王子/公主",
        "被诅咒之人/怪物",
        "地狱的摆渡人/守门人",
        "游荡在世间的精灵/仙灵",
        "被遗忘旧神的后裔",
        "专门猎杀怪物的猎手",
        "天堂放逐的堕落者",
        "执掌一方权能的小神/自然灵",
        "埃及的法老/大祭司",
        "北欧的女武神/狂战士",
        "某个秘密教团的刺客",
        "随机生成"
    ],
    "openings": [
        "奥林匹斯圣山上，宙斯的雷霆权杖失窃了。",
        "一个刻着“献给最美之人”的金苹果，被扔进了众神的宴会厅。",
        "地狱的三头恶犬刻耳柏洛斯睡着了，亡灵正从冥府的裂隙中逃出。",
        "普罗米修斯盗取的天火，在凡间引发了一场无法被扑灭的大火。",
        "特洛伊城下，一匹巨大的木马被送到了坚不可摧的城门前。",
        "北欧的世界之树“尤克特拉希尔”，它的一根枝干毫无征兆地枯萎了。",
        "彩虹桥“毕弗罗斯特”的中央，出现了一道深不见底的裂痕。",
        "挣脱了束缚的巨狼芬里尔，在天边吞食了太阳或月亮。",
        "尼罗河今年的泛滥没有如期而至，整个埃及陷入了对饥荒的恐惧。",
        "法老陵墓的深处，用来称量心脏的真理天平不见了。",
        "亡者之书上，浮现出了一个从未被记载过的、可以让死者完全复活的咒语。",
        "亚瑟王的圣剑“Excalibur”从湖中再次现世，等待着新的主人。",
        "德鲁伊的圣林中，最古老的一棵橡树的树干上，流出了人类的鲜血。",
        "天堂的一位大天使擅自离开了自己的岗位，没有留下任何信息便降临凡间。",
        "封印着地狱七魔王之一的古老锁链，发出了一声清脆的断裂声。",
        "天启四骑士中的第一位——“瘟疫”，已经骑着白马出现在了遥远的地平线上。",
        "潘多拉的魔盒被再次打开，但这次从中飞出的，是世间所有的“希望”。",
        "伊阿宋的金羊毛远征船队，在归航时遭遇了来自深海的塞壬歌声。",
        "为西西弗斯推上山的巨石，今天停在了山顶，没有滚落下来。",
        "人类与仙灵的边界变得模糊，有孩子在森林里迷路后，带着神奇的能力回来了。",
        "吉尔伽美什寻找永生之法的旅途，在终点发现了一扇通往异世界的大门。",
        "巴别塔的建筑工地上，人们突然又能听懂彼此的语言了。",
        "随机生成"
    ]
},
    "东方神话": {
    "identities": [
        "天庭的某位星君",
        "一头青牛",
        "蟠桃园里的小仙",
        "被贬下凡的神仙",
        "山间的土地神/山神",
        "炼丹炉旁的道童",
        "南天门的守门天将",
        "刚刚修出人形的小妖",
        "占山为王的大妖",
        "等待报恩的狐仙/蛇妖",
        "人和妖的混血后代",
        "山海经中记载的异兽",
        "佛陀座下的听经沙弥",
        "执掌一殿的阎罗/判官",
        "忘川河畔的摆渡人",
        "引渡亡魂的鬼差",
        "无法转世的游魂",
        "云游四方的地仙",
        "误入仙境的樵夫/采药人",
        "斩妖除魔的道士/法师",
        "能看见鬼神的通灵者",
        "某个凡人王朝的国师",
        "龙宫的虾兵/蟹将",
        "听圣人讲道的生灵",
        "上古巫族的后裔",
          "西王母座下的青鸟使者",
    "昆仑山神树的看守者",
    "月宫里捣药的玉兔",
    "司掌风雨雷电的仙官",
    "财神座下的运财童子",
    "执掌人间功过的灶君",
    "城隍庙里的日游神/夜游神",
    "修炼有成的僵尸/旱魃",
    "寄居在古物中的器灵",
    "引诱书生的画皮美妖",
    "十八层地狱的狱卒",
    "镇守佛塔的阿修罗众",
    "给佛陀献花的飞天/天女",
    "继承了稀薄神血的凡人",
    "上古大巫的血脉后裔",
    "被高人点化了的灵兽",
    "追日的夸父族人",
    "试图填平东海的精卫鸟",
    "深山中的尸解仙",
    "以梦境为食的梦貘",
        "随机生成"
    ],
    "openings": [
        "蟠桃盛会即将开始，你却发现你的请柬被人偷走了。",
        "你的天劫即将来临，但你感应到有仇家正藏在雷云之中。",
        "一件上古神器即将在不周山出世，三界各方势力都已闻风而动。",
        "你在东海之滨捡到了一个婴儿，他的眉心竟有第三只眼。",
        "生死簿上你的名字被人用朱砂笔划掉了，而你还活得好好的。",
        "你在取经人的必经之路上开辟了洞府，正思考着该如何烹饪唐僧肉。",
        "女娲补天的五彩石还剩下最后一颗，它从天上坠落，正好砸在了你的洞府门前。",
        "封神榜即将重开，你的师父告诉你，这次的榜上将会有你的名字。",
        "孙悟空大闹天宫之时，你作为一名天将，奉命前去镇压。",
        "巫妖大战的前夕，你必须在帝江和帝俊之间做出选择。",
        "你在奈何桥上正要喝下孟婆汤，却突然想起了九世之前刻骨铭心的仇恨。",
        "地府的十八层地狱破开了一个缺口，无数恶鬼正涌向人间。",
        "你所在的凡人村庄，常年祭祀的山神庙，今年却没有显灵。",
        "你在深山中修炼了千年，今天第一次进城，却被街上的车水马龙迷住了眼。",
        "师父交给你一个任务，去三界之中，寻回散落在各处的河图洛书碎片。",
        "你在紫霄宫中听鸿钧老祖讲道，但坐在你前面的那個生灵，似乎是你的宿敌。",
        "作为龙王，你发现你的定海神针不见了。",
        "佛陀在灵山讲法，天花乱坠，你似乎听懂了什么。",
        "你是一只刚修成正果的黄皮子，却被一个凡人书生误认为是狐仙，日夜向你许愿求姻缘。",
         "昆仑山的建木神树开始枯萎，三界之内，草木凋零。",
    "传说中的“人参果”即将成熟，据说闻一闻，就能活三百六十岁。",
    "十大金乌一齐出现在天空，大地被炙烤，凡间已成炼狱。",
    "兰若寺的钟声在午夜响起，但那座寺庙早已荒废了百年。",
    "东海龙宫的定海神针突然失窃，龙王震怒，悬赏三界寻找线索。",
    "一场无名的瘟疫从凡间开始蔓延，就连天上的神仙也感到法力滞涩。",
    "六大圣人纷纷立教，一时间，人、阐、截、西方教等开始在三界之中广收门徒。",
    "有人在三生石上，用刀刻下了两个本不该在一起的名字。",
    "一幅描绘着飞天仙女的古画被展出，传说画中的仙女会在月圆之夜走下来。",
    "佛道两家将举行一场“水陆大会”进行辩法，胜者将执掌未来千年的凡间信仰。",
    "酆都鬼城的大门不知被谁打开，百鬼夜行，正在人间游荡。",
    "有人说，在北冥之海的尽头，看到了那只名为“鲲”的巨兽。",
 
    "人间一位帝王妄想长生，正在派人四处寻找传说中的“不死药”。",
 
        "随机生成"
    ]
},
    "赛博朋克": {
        "identities": [
            "义体医生",
            "数据黑客",
            "公司特工",
            "底层拾荒者",
            "帮派打手",
            "记忆贩子",
            "义体改造师",
            "AI调试师",
            "虚拟偶像",
            "企业间谍",
            "网络幽灵",
            "生化人",
            "黑市义体医生",
            "初出茅庐的数据黑客",
            "公司底层特工",
            "街头帮派打手",
            "网络偶像的经纪人",
            "垃圾场的拾荒者",
            "厌倦了生活的条子（警察）",
            "全身高度义体化的改造人",
            "反抗组织的信使",
            "技术高超的义体医生",
            "能够潜入任何系统的顶级黑客",
            "为超级企业清理“垃圾”的特工",
            "贩卖虚拟感官体验的“梦境商人”",
            "反抗巨型企业的“解放阵线”成员",
            "驾驶飞行载具的空中快递员",
            "随机生成"
        ],
        "openings": [
            "从一次非法的记忆清除手术中醒来",
            "植入的义眼突然看到了不该看的数据流",
            "接到了一个送货任务，货物是一个活生生的人",
            "被强大的企业追杀，原因不明",
            "在黑市上买到了一块来源不明的军用芯片",
            "发现自己的AI伴侣开始出现自主意识",
            "被雇佣渗透竞争对手公司的服务器",
            "在虚拟世界中被困，无法登出",
            "义体突然失控，开始攻击无关人员",
            "接收到了一条来自未来的加密信息",
 
            "植入的义眼突然接收到一段加密数据流，指向公司的巨大阴谋",
            "接到了一个报酬极高的“送货”任务，货物是一个被通缉的仿生人",
            "因为一次网络入侵，意外成为了全球追捕的对象",
            "发现自己常用的镇静剂被人掉了包，效果变得极其危险",
            "债主找上门，给了一个潜入竞争对手公司窃取数据的危险任务",
            "从一次非法的记忆清除手术中醒来 。",
            "你新植入的义眼突然开始接收到不属于这个世界的数据流 。",
            "在一个全民沉浸式VR的世界里，你发现所谓的“现实”可能只是另一层虚拟。",
            "随机生成"
        ]
    },
    "星际科幻": {
        "identities": [
            "货运飞船船员",
            "帝国舰队新兵",
            "殖民星球矿工",
            "星际海盗",
            "外交官",
            "星际商人",
            "机械工程师",
            "生物学家",
            "星系探险家",
            "人工重力技师",
            "货运飞船的机械师",
            "帝国舰队学院的吊车尾学员",
            "外星球殖民地的矿工",
            "被通缉的星际海盗",
            "外星大使的人类助理",
            "基因编辑过的完美“人造人”",
            "考古队的新人",
            "太空港酒吧的老板",
            "失控的医疗机器人",
            "自由探索船的船长",
            "银河帝国基因改造的超级士兵",
            "能与外星生物精神链接的“沟通者”",
            "星际黑市的情報贩子",
            "某个古代文明遗迹的守护者",
            "深海文明的使者",
            "随机生成"
        ],
        "openings": [
            "飞船遭遇未知宇宙异常，被迫紧急跃迁到陌生星域",
            "在蛮荒星球上发现了外星文明的遗迹",
            "作为外交使团成员前往一个从未接触过的文明",
            "在星际空间站的黑市上买到了来源不明的古代数据核心",
            "收到了一个来自银河系边缘的神秘求救信号",
            "在例行的星球勘探中发现了会移动的金属生物",
            "被派遣调查一艘在虚空中漂流百年的幽灵战舰",
            "意外激活了一个封印了千年的古代AI",
            "在进行超空间跳跃时看到了不应该存在的景象",
            "发现自己所在的殖民地其实是一个巨大的实验场",
            "飞船在进行跃迁时遭遇未知宇宙现象，迫降在一颗完全不在星图上的星球",
            "在一次空间站日常维护时，发现了一个隐藏的密室，里面有一具外星人尸骸",
            "作为文化观察员被派往一个刚刚接触的原始文明星球",
            "在黑市买到了一个来历不明的古代数据核心，里面藏着足以引发战争的信息",
            "所在的殖民星球爆发了未知的生化病毒，隔离程序已启动",
            "被选中参与一项绝密的超光速航行实验，但实验出现了严重故障",
            "飞船的AI突然觉醒了自我意识，并强行将航线设定至一个未知的星系。",
            "在一颗荒凉的星球上进行考古时，你们挖出了一个会造成时空悖论的古代物品。",
            "你被一个强大的星际实体选中，成为其在物质宇宙的“代理人”，执行它的意志。",
            "你所在的深海城市，第一次向陆地文明派出了外交使团，而你就是其中一员。",
            "在一个基因高度编辑的社会，你作为天生的“缺陷者”，却拥有机器无法模拟的能力。",
            "随机生成"
        ]
    },
    "武侠江湖": {
        "identities": [
            "初入江湖的少侠",
            "魔教底层教众",
            "名门正派弟子",
            "悬壶济世的郎中",
            "经营客栈的情报贩子",
            "镖师",
            "江湖游医",
            "说书先生",
            "剑客",
            "刺客",
            "武林盟主/盟主夫人",
            "隐世高人",
            "初入江湖的名门少侠/女侠",
            "魔教的底层教众",
            "镖局的趟子手",
            "悬壶济世（也可能用毒）的郎中",
            "客栈的情报贩子/说书人",
            "退役的官差",
            "书院的书生/琴女",
            "被灭门的小门派弟子",
            "身世成谜的孤儿",
            "精通易容术的飞贼",
            "初入江湖的少侠/女侠",
            "名门正派的亲传弟子",
            "悬壶济世却身负绝技的郎中",
            "经营着客栈的情报贩子",
            "被派往江湖卧底的朝廷密探",
            "随机生成"
        ],
        "openings": [
            "全家被神秘组织灭门，身负血海深仇",
            "无意中习得了失传已久的绝世武功",
            "卷入了名门正派与魔教的宝物争夺战",
            "受人之托护送一个身份神秘的人",
            "在武林大会上被诬陷为叛徒",
            "意外获得了一本记载绝世内功的秘籍",
            "被师父托付寻找失散多年的师弟/师妹",
            "在荒山野岭救下了一个身受重伤的高手",
            "发现自己的身世与二十年前的武林浩劫有关",
            "被卷入了皇室夺位之争",
            "全家被神秘人灭门，凶手使用的是失传已久的武功",
            "无意中救下一个重伤的老人，临终前传给你毕生功力和一段口诀",
            "卷入了一场针对武林盟主的刺杀阴谋，被当成替罪羊",
            "师门至宝失窃，作为最大嫌疑人的你被迫逃亡并自证清白",
            "在山洞避雨时发现了前辈高人的遗骸和武功秘籍",
            "被迫参加一场生死不论的武林大会，胜者将成为某大人物的女婿/赘婿",
            "全家被神秘组织灭门，身负血海深仇的你，带着唯一的线索踏入江湖。",
            "无意中习得了失传已久的绝世武功，但代价是每使用一次都会失去一部分人性。",
            "你卷入了正派与魔教对一本武功秘籍的争夺战中，而那本秘籍就是你自己。",
            "你的任务是暗中干预某个历史的关键节点，确保历史按照正确的方向发展。",
            "随机生成"
        ]
    },
 
    "恐怖惊悚": {
        "identities": [
            "超自然现象调查员",
            "恐怖片演员",
            "心理医生",
            "古董店老板",
            "建筑工人",
            "夜班保安",
            "灵媒",
            "考古学家",
            "民俗学者",
            "普通游客",
                "入殓师/法医",
    "记者/播客主",
    "长途卡车司机",
    "消防员/救援队员",
    "新家的住户",
    "深海/洞穴探险家",
    "护林员",
    "历史档案管理员",
    "唯一的幸存者",
    "邪教逃离者",
    "犯罪心理学家",
    "城市探险博主",
    "失眠症患者",
    "乡下的赤脚医生",
            "随机生成"
        ],
        "openings": [
            "被困在一栋发生过惨案的老宅中",
            "在拍摄恐怖片时遭遇了真正的超自然现象",
            "收到了一盘记录着诡异内容的录像带",
            "在古董店买到了一个被诅咒的物品",
            "参加了一个神秘的网络挑战游戏",
            "在深夜的医院遇到了已经死去的病人",
            "被邀请调查一起连警察都不敢深入的案件",
            "在挖掘古墓时释放了不该被唤醒的存在",
            "搬进新家后发现房间里有看不见的室友",
            "在进行心理治疗时患者说出了不可能知道的秘密",
             "手机相册里突然多了一段你熟睡时的视频。",
    "深夜开车时，后视镜里总有一个穿着红衣服的身影一闪而过。",
    "镜子里的倒影，在你转过身后，对你露出了一个诡异的微笑。",
    "电梯失控，停在了一个不存在的“地下4层”。",
    "一张纸条从门缝下塞了进来，上面用血写着：“别出声，它在听。”",
    "好不容易淘到的古董娃娃，它的眼睛好像会自己转动。",
    "耳边总是无端响起一段催眠般的童谣，但周围并没有其他人。",
    "在一座以“自杀圣地”闻名的森林里迷了路，天色渐渐暗了下来。",
    "你工作的办公楼里流传着一份“夜班生存守则”，而你刚刚不小心违反了其中一条。",
    "大雪封山，被困在与世隔绝的山间旅店里，而住客们开始一个接一个地神秘死去。",
    "你收到了一个匿名包裹，里面只有一个小木偶和一张指示：“现在，你是它的新主人了。”",
    "整理祖父遗物时，发现了一本记录着某种邪恶仪式的日记，而仪式的最后一步就在今晚。",
    "小镇上流传着一个传说：绝对不能在午夜回头看自己的影子。而今晚，你感觉有什么东西在拉你的裤脚。",
    "家里所有的钟表，都分毫不差地停在了凌晨3点44分。",
    "接到了一个奇怪的求助电话，对方说他被困在了你家的墙壁里。",
            "随机生成"
        ]
    },
    "海洋冒险": {
        "identities": [
            "船员",
            "海盗",
            "渔夫/渔女",
            "海军军官",
            "探险家",
            "海洋生物学家",
            "潜水员",
            "灯塔看守",
            "船长",
            "海商",
            "海难幸存者",
            "寻宝猎人",
                "人鱼/海洋智慧生物",
    "被诅咒的不死水手",
    "制图师/航海家",
    "港口的走私者",
    "船舶工程师/修理工",
    "海岸警卫队队员",
    "海洋神祇的祭司",
    "海怪猎人",
            "随机生成"
        ],
        "openings": [
            "在一座荒岛上醒来，船只已经消失",
            "发现了一张指向传说宝藏的古老海图",
            "船只在风暴中偏离航线，到达了地图上不存在的海域",
            "在深海潜水时遭遇了史前巨兽",
            "被海盗劫持后发现他们在寻找某种神秘物品",
            "在钓鱼时钓上来了一个装着求救信的瓶子",
            "发现自己工作的油井平台下方隐藏着古代文明",
            "在海底考古时唤醒了沉睡的深海生物",
            "被神秘海流卷入了传说中的船只坟场",
            "收到了来自失踪多年的探险队的无线电信号",
             "传说中的幽灵船‘飞翔的荷兰人’号，破开浓雾，缓缓出现在航线前方。",
    "百慕大三角的中心区域，所有导航仪器突然失灵，海面平静得宛如镜面。",
    "打捞上来的百年沉船里，一具尸体竟完好无损，仿佛只是沉沉睡去。",
    "一场罕见的‘血色赤潮’过后，海中涌现出无数从未见过的、发着幽光的奇异生物。",
    "船只被一股巨大的力量猛地向下一拽，仿佛有什么东西缠住了龙骨，正要将整艘船拖入深渊。",
    "在深海热泉附近，声呐探测到了一座由未知金属构成、似乎仍在运作的宏伟城市。",
    "鲸鱼群的歌声中，夹杂着一段极其规律的、仿佛摩斯密码般的神秘旋律。",
    "巨大的极地冰川在你眼前崩塌，掀起的滔天巨浪，正朝着船只扑来。",
    "海面上凭空出现了一扇由旋转的水流构成的巨门，门后是完全陌生的星空。",
    "在一座无人灯塔的顶端，发现了一本写满了一个世纪的思念与等待的航海日志。",
            "随机生成"
        ]
    },
    "二次元": {
        "identities": [
            "转校生",
            "社团成员",
            "魔法少女/少年",
            "偶像",
            "游戏玩家",
            "游戏中的npc",
            "动漫宅",
            "学生会成员",
            "图书委员",
            "体育社王牌",
            "校园偶像",
            "神秘转学生",
            "普通路人",
             "地下偶像",
    "Vtuber / 主播",
    "轻小说作家 / 漫画家",
    "风纪委员",
    "阴阳师 / 退魔师",
    "异世界归来者",
    "怪盗",
    "非人类（妖狐/吸血鬼等）",

    "归宅部成员",
    "执事 / 女仆",
    "声优",
    "被封印了力量的魔王/勇者",
            "随机生成"
        ],
        "openings": [
            "收到了一个能实现愿望的神秘道具",
            "被选中成为拯救世界的魔法少女/少年",
            "在学园祭上发生了超自然现象",
            "发现班上的同学其实都不是人类",
            "被卷入了一个真人版的游戏世界",
            "在社团活动室发现了通往异世界的传送门",
 
            "在偶像演出中遭遇了来自异次元的袭击",
            "发现学校其实是一个巨大的实验场所",
            "被神秘组织选中参加特殊的游戏",
               "鞋柜里收到了一封署名为‘怪盗’的、偷走你心的预告函。",
    "深夜搭乘的电车，在一个地图上不存在的“如月车站”停了下来。",
    "天台上，全校最受欢迎的学生会长背后，长出了一对漆黑的翅膀。",
    "醒来后，你和最讨厌/最憧憬的那个同学灵魂互换了。",
    "手机里多出了一个无法删除的APP，它的功能是“未来日记”。",
    "一场小型地下偶像Live结束后，台下的所有粉丝全都变成了狂热的信徒。",
    "你常玩的游戏关服了，但你游戏里的“老婆”/伙伴却出现在了家门口。",
    "学校的游泳池在没有水的状态下，淹死了一个学生。",
    "樱花树下，一个完全不认识的转校生突然向你告白，并声称你们是前世的恋人。",
    "城市上空出现了一个巨大的、由无数眼球组成的魔法阵。",
 
    "你在网络上连载的小说情节，开始在现实中分毫不差地一一上演。",
    "一场流星雨过后，你突然能听懂家里的猫在说什么了。",
    "今天的占卜大凶，出门就会遭遇宿命的邂逅，开启你波澜壮阔的一生。",
            "随机生成"
        ]
    },
    "特殊世界观": {
        "identities": [
            "记忆商人",
            "梦境行者",
            "模因传播者",
            "糊弄学大师",
              "ABO世界中的稀有性别",
            "规则怪谈中的“违规者”",
            "时间循环中的锚点",
            "拥有自我意识的NPC",
            "魅魔",
            "梦魇",
            "克苏鲁神话中的调查员",
            "灵气复苏的先知",
            "神话复苏的钥匙",
   "精神过载的哨兵",
        "寻找搭档的向导",
        "信息素失控的Alpha",
        "伪装成Beta的Omega",
        "食物链顶端的捕食者",
        "重生/穿书的恶役千金",
        "刚刚苏醒的旧神",
        "神格破碎的神明",
        "被献祭的圣子/圣女",
        "世界意志的化身",
        "拥有自我意识的系统/外挂",
        "故事的‘旁白’",
        "人形的S级收容物",
            "随机生成"
        ],
        "openings": [
               "天空突然裂开，另一座城市的倒影悬挂于天际。",
        "世界上所有的文字在一夜之间变成了无人能懂的金色符号。",
        "你一觉醒来，发现所有人都失去了“悲伤”这种情绪。",
        "你凝视深渊时，深渊真的朝你眨了眨眼，还说了声“嗨”。",
        "你在一个陌生人的房间醒来，后颈传来一阵陌生的刺痛，空气中弥漫着雪松和烈酒的味道。",
        "眼前的世界突然卡顿，一个“正在加载...”的进度条出现在你的视野中央。",
        "你家门上多了一张纸条，上面用鲜红的字迹写着：“欢迎来到这里，请在天黑后遵守以下规则……”",
        "月亮变成了深紫色，所有被月光照到的人都开始疯狂地呓语。",
        "你收到了三个月后，来自自己的死亡预告信。",
        "你的影子在没有光的地方，自己站了起来，并对你露出了一个诡异的微笑。",
        "你杀死了这个世界的“主角”，耳边突然响起了冰冷的系统提示音：“世界线开始重置……”",
        "手机屏幕上突然出现一个恋爱游戏App，而里面的可攻略角色，全都是你身边的人。",
        "你面前的NPC突然抓住了你的手，流着泪对你说：“求求你，带我离开这个游戏，我什么都愿意做。”",
        "海面上浮现出一座由非欧几何构成的、不断变化的城市，巨大的触手从城中伸向天空。",
            "随机生成"
        ]
    },
    "废土末日": {
        "identities": [
               "拾荒者",
            "变种人猎手",
            "幸存者据点守卫",
            "独行商人",
            "净水技术员",
            "医疗兵",
            "机械师",
            "搜救队员",
            "车队司机",
            "物资管理员",
            "移动堡垒的车长",
            "驾驶武装车辆的“公路幽灵”",
            "掌握一小块可耕种土地的农场主",
            "搜集旧时代科技的“历史学家”",
            "孤岛上的垂钓者",
            "幸存者据点的医生",
            "经验老道的拾荒者",
            "变种人猎手",
            "幸存者据点的守卫",
            "独行商人",
            "掌握净水/种植技术的技工",
            "寻找疫苗的医生",
            "掠夺者团伙的俘虏",
            "战前文明的学者",
            "信奉钢铁的机械教祭司",
            "基因突变的异能者",
            "随机生成"
        ],
        "openings": [
            "从一个废弃多年的避难所中苏醒，外面的世界已面目全非",
            "在一具穿着防辐射服的尸体上，找到了一张指向传说中“绿洲”的地图",
            "为了拯救据点里感染的亲人，不得不闯入辐射极高的核心区寻找药品",
            "驾驶的武装车辆在沙尘暴中抛锚，补给所剩无几",
            "所在的据点被强大的掠夺者军团包围，首领决定派你出去寻求援助",
            "喝下了被污染的水源，开始出现奇怪的幻觉和身体变化",
             "从一个废弃的避难所中苏醒",
            "在一具尸体上找到了指向绿洲的地图",
            "为了家人急需的药品，不得不闯入辐射区",
            "驾驶的武装车辆在沙尘暴中抛锚",
            "在废墟中发现了一个还在运行的AI终端",
            "被某种未知病毒感染，时间所剩无几",
            "车队遭遇袭击，成为唯一幸存者",
            "在地下避难所发现了末日前的重要秘密",
            "接收到了来自其他幸存者据点的求救信号",
            "你的车队正被一场巨大的辐射风暴追赶，必须在燃料耗尽前找到避难所。",
            "在一具干尸的怀里，找到了一张指向传说中“绿洲”的地图。",
            "作为孤岛上唯一的幸存者，你今天从海里钓上来一个密封的，来自未知文明的休眠仓。",
            "核冬天降临，你所在的避难所资源即将耗尽，必须外出寻找生机。",
            "随机生成"
        ]
    },
    "规则怪谈": {
        "identities": [
            "新入职的公司员工",
            "转校生",
            "游客",
            "病人",
            "乘客",
            "住户",
            "图书馆管理员",
            "夜班保安",
             "船员",
    "深海/极地科考站队员",
    "网红打卡地的探店博主",
    "调查员",
    "怪奇马戏团的表演者",
    "员工",
    "酒店的礼宾部",
    "孤儿院的义工",
    "试吃员",
    "导播",
    "伴郎/伴娘",
            "随机生成"
        ],
        "openings": [
            "收到一份理想工作的录用通知，但员工手册上的规则极其诡异",
            "搬进了一个租金极低的新公寓，楼道里贴满了奇怪的居住守则",
            "在旧书店买了一本笔记本，里面写满了像是生存指南的奇怪规则",
            "一觉醒来，发现自己身处一个无限循环的走廊/车站，墙上写着生路提示",
            "参加了一个奇怪的测试实验，被告知必须严格遵守指令才能离开",
            "误入一个小镇，这里的居民都严格遵守着一些不可理喻的习俗", 
            "高考失利后，你收到一所不存在的大学寄来的录取通知书，附带一张诡异的新生守则。",
    "你下载了一个无法卸载的恋爱APP，它为你匹配的对象似乎不是人类。",
    "一场大雾散去，你发现所在的城市变得完全陌生，街上的每个人都对你露出诡异的微笑。",
    "受邀参加一场假面舞会，规则上说，在午夜钟声敲响前，绝对不能摘下自己的面具。",
    "电视里突然插播一条紧急通知，要求全体市民从现在开始必须倒着走路。",
    "你继承了一座巨大的图书馆，但遗嘱里警告你，绝对不要去阅读C区的任何一本书。",
    "为了躲雨，你跑进一家诡异的蜡像馆，在你眨眼后，发现所有蜡像的姿势都变了。",
    "你所在的城市突然强制开始一场为期24小时的“捉迷藏”游戏，规则只有一条：“不要被找到”。",
    "你收到了一个会说话的玩偶作为礼物，附带的“饲养说明”上写满了血红色的警告。",
    "你的猫今天早上叼回来一张纸条，上面用爪印写着一套只有你能看见的“家庭新规”。",
    "你搭乘的航班遭遇了猛烈气流，颠簸过后，窗外的天空变成了血红色。",
    "你走进一家24小时便利店买东西，却发现墙上的时钟永远指向午夜三点半。",
            "随机生成"
        ]
    },
    "恐怖生存": {
        "identities": [
            "遭遇空难的幸存者",
            "鬼屋探险的作死青年",
            "精神病院的医生",
            "凶宅的新房主",
            "拍摄灵异节目的剧组人员",
            "恶魔召唤仪式的参与者",
            "被诅咒的古董拥有者",
            "丧尸爆发后的幸存者",
            "随机生成"
        ],
        "openings": [
            "醒来发现自己被绑在一个地下室，身边有计时器和模糊的线索",
            "购买的二手家具里藏着一盘记录着凶杀案的录像带",
            "度假小屋的地下室里发现了一个被囚禁多年的人",
            "参与的线上游戏突然无法退出，失败意味着真实的死亡",
            "收到已故亲友寄来的礼物，随后开始遭遇一系列的灵异事件",
            "所在的整栋大楼被无形的力量封锁，怪物在楼道内徘徊",
            "随机生成"
        ]
    },
    "历史架空": {
        "identities": [
            "王宫新来的女仆/侍卫",
            "被迫和亲的王子/公主",
            "不受宠的皇子/公主",
            "进京赶考的书生",
            "边疆戍卒的小队长",
            "青楼的名妓",
            "云游四海的行脚僧",
            "御厨房的小学徒",
            "即将和亲的宗室女",
            "墨家/公输家的工匠",
            "驿站的驿丞",
            "获罪被流放的官员",
            "普通农民",
            "书生",
            "商贾",
            "将军",
            "公主/王子",
            "太监/宫女",
            "江湖医师",
            "道士/道姑",
            "和尚/尼姑",
            "县令",
            "刺客",
            "史官",
            "随机生成"
        ],
        "openings": [
            "一觉醒来发现自己回到了某个历史关键节点，成了一个无关紧要的小人物",
            "在古墓中发现了能预言未来的龟甲/竹简",
            "皇帝突然驾崩，京城暗流涌动，你意外卷入了继位风波",
            "家乡遭遇洪灾/蝗灾，你被迫带领乡亲南下逃荒",
            "被征召去修建长城/陵墓/大运河，发现了工程中隐藏的秘密",
            "你的发明创造被上官看中，要求你限期完成献给皇帝",
            "被卷入了一场改变历史走向的宫廷政变",
            "在战场上捡到了一件能改变战局的神秘兵器",
            "被选中参与一项秘密的皇室任务",
            "发现了一个关于朝代更替的惊天秘密",
            "在科举考试中无意间得罪了权贵",
            "被派遣到边疆处理民族冲突",
            "在古墓中发现了前朝皇室的遗物",
            "被迫参与了一场决定国运的重要谈判",
            "在民间收集到了足以撼动朝廷的证据",
              "奉始皇帝之命，成为徐福船队的一员，出海寻找仙山与长生不老药。",
"身处长平，你必须在白起下令坑杀四十万赵卒之前，想办法活下去。",
"公元前206年，你亲眼见证了项羽火烧阿房宫，并藏匿了宫中的一份重要图纸。",
"作为刘邦的乡亲，在沛县起事时，你面临着加入他还是向官府告密的抉择。",
"鸿门宴上，你是一名不起眼的侍者，目睹了项庄舞剑的惊险全程。",
"你追随韩信，却在井陉口背水一战前，发现了军队的致命弱点。",
"作为垓下的一名楚卒，在四面楚歌中，你考虑的是否要放下武器投降。",
"作为吕后身边的侍从，你无意间听到了她处置戚夫人和刘如意的计划。",
"在白登山，你作为一名汉军小卒，被匈奴围困在冰天雪地里七天七夜。",
"王莽推行新政时，你作为一名地方小吏，需要处理因此而起的民间混乱与反抗。",
"在昆阳，你亲眼目睹了刘秀率领十三骑冲阵，创造了以少胜多的奇迹。",
"身为一名光武中兴时期的屯田兵，你开垦的土地下埋藏着前朝的宝藏。",
"赤壁之战前夜，你收到了来自曹操阵营的密信，试图策反你所在的江东水军。",
"在长坂坡，你护送着主公的家眷，在曹军的追杀中七进七出。",
"作为华佗的弟子，你掌握了为关羽刮骨疗毒的核心技术，却因此被曹操猜忌。",
"你在白帝城，作为刘备的亲信，亲耳听到了那句“如其不才，君可自取”的托孤遗言。",
"作为诸葛亮的随从，你参与了七擒孟获的全过程，深刻理解了“攻心为上”的策略。",
"街亭失守，你奉命前去传令命马谡撤退，却因意外在路上耽搁了。",
"五丈原秋风瑟瑟，你看着丞相的将星即将陨落，手中握着能为他续命七日的七星灯。",
"你身处高平陵，目睹了司马懿发动政变，曹魏的天下即将倾覆。",
"作为一名竹林中的隐士，你常与“竹林七贤”饮酒作乐，却也知晓他们放浪形骸下的政治避祸。",
"淝水之战中，你作为前秦军队的一员，听到了“风声鹤唳，草木皆兵”的传言，军心大乱。",
"隋朝末年，你被迫加入瓦岗军，在李密的带领下劫富济贫，却也见证了他的多疑与败亡。",
"玄武门之变当天，你是一名守卫，需要在李建成和李世民之间做出选择。",
"作为辩机和尚的侍童，你保管着那本由高阳公主赠予、最终引发杀身之祸的《枕中记》。",
"在安史之乱的马嵬坡，你目睹了禁军哗变，贵妃被赐死，皇帝仓皇出逃。",
"你追随鉴真东渡，在第六次航行中，终于踏上了日本的土地。",
"作为黄巢起义军的一员，你攻入了长安城，也见证了“冲天香阵透长安，满城尽带黄金甲”的盛景与随之而来的屠戮。",
"南唐后主李煜亡国后，你作为他的故臣，在寂寥的汴京听他一遍遍吟诵“问君能有几多愁”。",
"在陈桥驿，你亲眼见证了赵匡胤“黄袍加身”的全过程。",
"杯酒释兵权当晚，你作为一名御厨，为石守信等大将烹饪了那场决定命运的晚宴。",
"靖康之耻，你被金人掳至北方，亲眼目睹了徽、钦二帝的凄惨遭遇。",
"你追随岳飞，即将收复开封，却在朱仙镇收到了十二道金牌。",
"崖山海战，你抱着小皇帝，在陆秀夫的恸哭声中，看着他背负国祚跃入大海。",
"明朝初年，你被卷入“胡蓝之狱”或“文字狱”，身家性命悬于一线。",
"靖难之役中，你作为建文帝的亲信，在南京城破前，收到了他从秘密地道逃亡的指令。",
"土木堡之变，你作为英宗的随驾侍卫，一同被瓦剌俘虏，在塞外苦寒之地求生。",
"夺门之变，你作为于谦的下属，目睹了他被拥立的英宗冤杀，并写下“粉身碎骨浑不怕，要留清白在人间”。",
"作为一名锦衣卫/东厂番子，你奉命调查一桩牵涉到朝廷重臣的惊天大案。",
"作为李自成的部将，你攻破了北京城，却发现胜利的喜悦很快被权力的腐蚀所替代。",
"你驻守在山海关，当李自成和多尔衮的军队同时兵临城下时，吴三桂向你征求开关的意见。",
"扬州十日/嘉定三屠，你作为一名幸存者，从死人堆里爬了出来。",
"你奉康熙之命，参与了平定三藩之乱，并卧底在吴三桂的阵营中。",
"在文字狱最盛行的雍正朝，你因一首诗或一篇文章，被下了大狱。",
            "随机生成"
        ]
    },
    "蒸汽朋克": {
        "identities": [
            "发条人偶师",
            "天空舰队的飞艇工程师",
            "差分机黑客（分析机程序师）",
            "炼金术侦探",
            "报童兼地下情报员",
            "使用蒸汽义肢的退役军人",
            "反技术派系的“自然咏者”",
            "随机生成",
            "为贵族改装奢侈机械宠物的工匠",
            "在天空之城表演的歌剧演员",
            "齿轮教会的年轻祭司",
            "在天空之城的底层区行医的黑市医生",
    "驾驶着蒸汽动力泰坦的皇家卫队驾驶员",
    "专门绘制未知空域航图的制图师",
    "饲养并改装机械生物的驯兽师",
    "行走于世间的最后一位炼金术士",
    "能与机器的“灵魂”沟通的通感者",
    "审判异端科技的铁腕裁判官",
    "在工业废墟中讨生活的拾荒者",
    "以太（Aether）航船上的水手",
    "皇家钟楼的守时人"
        ],
        "openings": [
            "在一场非法的机械角斗中醒来，发现自己的记忆芯片被替换，唯一的线索是口袋里的一枚奇特齿轮。",
            "你发明的永动机模型被神秘组织盗走，对方留下了一朵仅在皇室空中花园才培育的黑玫瑰。",
            
            "作为一名天空警察，你在追捕臭名昭著的空贼时，飞艇意外坠入浮空岛的未知禁区。",
            "收到了一张由纯金打造的邀请函，邀请你参加一场在万米高空的移动堡垒“巴别塔”上举行的晚宴。",
            "为了给家人凑齐昂贵的发条心脏移植手术费，你接下了一个护送“禁忌炼金物品”的危险委托。",
            "你正在与一位贵族小姐/少爷举行婚礼，一位驾驶着单人飞行翼的“不速之客”从天而降，声称你才是他/她的真爱。",
              "城市的中央钟楼，那颗运转了三百年的“不息心脏”，毫无征兆地停摆了。",
    "你从昏迷中醒来，发现自己被铁链锁在了一艘著名空贼飞艇的船锚上，而飞艇正在升空。",
    "全频道突然播报一条紧急消息：你所在的天空之城正在失去浮力，预计三小时后将坠向地面。",
    "一只精巧的黄铜机械鸟停在了你的窗台，它的腿上绑着一个微型密码筒，里面是向你的求救信。",
    "议会刚刚通过法案，要求所有公民都必须将至少一个身体部件替换为官方指定的蒸汽义肢。",
    "天空中由无数齿轮构成的太阳闪烁了一下，你在一瞬间看到了它背后……那片深邃、冰冷的真实星空。",
    "家里的老旧自动人偶管家，突然在你耳边用生锈的声音低语道：“主人，他们发现我们了。”",
    "以太之海掀起了前所未有的风暴，一些不属于机械造物的、柔软滑腻的奇异生物被冲上了浮岛的边缘。",
    "你收到了一份匿名包裹，里面是一颗仍在跳动的水晶心脏，以及一张字条：“把它藏好，否则世界会因此重启。”",
    "一座被认为是古代遗迹、早已停机的巨型城市守护者“歌利亚”，它的独眼亮起了红光，缓缓地站了起来。",
"随机生成"      
]
    },
 
    "诡秘修仙": {
        "identities": [
            "调查异常的“天机阁”底层修士",
            "靠吞噬“诡异”来修行的魔道中人",
            "供奉不可名状存在的邪神信徒",
            "被污染的灵根拥有者",
            "随机生成",
            "专门绘制“镇邪符”的符师",
            "研究“古神呓语”的疯癫学者",
            "从禁地“归墟”中逃出的唯一生还者"
        ],
        "openings": [
            "你在修炼中走火入魔，醒来后发现自己丹田里多了一个无法理解的、扭曲的活物。",
            "随机生成",
            "你所在的村庄为了祈求丰收，准备举行一场古老的祭祀，而你被选中成为献给山中“古神”的祭品。",
            "师门下达了调查任务，一个偏远小镇的凡人全部失踪，只留下满地不断蠕动的黑色影子。",
            "你偶然得到一本残破功法，修炼后修为大涨，但你开始在梦中听到来自群星之外的呼唤。",
            "宗门大比上，你的对手在众目睽睽之下，身体融化、异变成了一滩不可名状的血肉怪物。"
        ]
    },
 
    "全民领主": {
        "identities": [
            "绑定了“签到系统”的幸运儿",
            "开局抽到唯一神话级兵种的欧皇",
            "随机生成",
            "选择了亡灵族，只能和骷髅作伴的独行者",
            "专精种田与贸易的生活玩家",
            "组建了大型公会的会长",
            "被强大领主俘虏，被迫成为附属的玩家"
        ],
        "openings": [
            "当全球所有人都被传送到这个世界时，你发现你的初始领地旁边，刷新了一座金矿和一只看起来不太友好的巨龙。",
            "随机生成",
            "别人开局都是一小块地和几个农民，而你的初始资源清单上写着：“一座破败的神庙和一名自称是“神”的失忆少女/少年”。",
            "系统提示：你的领地受到了“混沌”的祝福，所有招募的单位都将发生意想不到的良性（或恶性）变异。",
            "你发现你可以通过完成某个土著部落的奇怪任务，来获得他们的好感度和独有科技/兵种。"
        ]
    },
    "经营建设": {
        "identities": [
            "初创企业家",
            "咖啡馆老板",
            "网店运营者",
            "投资顾问",
            "市场分析师",
            "连锁店店长",
            "商会会长",
            "贸易商人",
            "餐厅主厨",
            "时装设计师",
            "游戏开发者",
            "落魄贵族继承了一块贫瘠的领地",
            "宗门的外派管事",
            "灾难后重建社区的负责人",
            "星际 frontier 的殖民地总督",
            "动物保护区的园长",
            "魔法学校的校长",
            "深海勘探队的队长",
            "异世界餐馆的老板",
            "刚刚继承破败领地的年轻领主",
            "拥有巨龙盟友的王子/公主",
            "掌管宗门财政的内门长老",
            "拥有“系统”辅助的穿越者国王/女王",
            "建立了横跨数个位面的商业帝国的会长",
            "即将统一大陆的王国统治者",
            "随机生成"
        ],
        "openings": [
            "继承了一家濒临破产的家族企业",
            "获得了一笔神秘的创业资金",
            "发现竞争对手在使用不正当手段",
            "被挖角到一家刚成立的科技公司",
            "在商业展会上遇到了改变命运的合作伙伴",
            "接手了一个看似毫无价值的废弃项目",
            "被卷入了一场商业间谍战",
            "意外获得了一个具有巨大潜力的专利技术",
            "在经济危机中寻找企业转型的机会",
            "意外继承了一笔巨额遗产，但必须经营好指定的产业才能持续获得",
            "被流放到边疆，要求一年内上缴指定数额的赋税",
            "飞船坠毁，你成为幸存者的领袖，需要建立营地等待救援",
            "被委以重任，负责重建一个被摧毁的著名地标/门派",
            "捡到了一个能连接万界的商店系统，需要进货开店",
            "获得了一个能进入梦境的能力，开始经营一家为人解忧的梦境事务所",
            "“万界建国系统”已绑定，初始资源为三个哥布林和一个漏风的茅草屋。",
            "你通过一场政治联姻，获得了一片贫瘠但拥有巨大潜力的土地和一位对你充满敌意的美丽伴侣。",
            "你的宗门遭遇大劫，作为唯一的继承人，你需要从零开始重建山门。",
            "随机生成"
        ]
    },
    "同人衍生": {
        "identities": [
             "(三体) 被联合国选中的新任“面壁者”",
    "(三体) “地球三体组织”的一名科学家，等待着主的降临",
    "(三体) 威慑纪元手握引力波宇宙广播开关的“执剑人”",
    "(三体) 掩体纪元，生活在地球深处地下城中的居民",
        "(三体) 人类舰队的一名舰长，面对着即将到来的水滴",
    "(三体) 潜伏在人类中的“破壁人”，负责破解面壁者的计划",
    "(EVA) NERV总部的普通技术员，负责EVA机体的日常维护",
    "(EVA) SEELE议会的一名秘密成员，知晓“人类补完计划”的真相",
    "(EVA) 居住在第三新东京市的普通学生，对频繁的“陨石”来袭习以为常",
           "(EVA) EVA初号机/零号机/二号机的指定驾驶员（适格者）",
    "(EVA) NERV的作战部长，直接在前线指挥战斗",
    "(宝可梦) 刚刚从博士那里领到初始宝可梦的新人训练家",
    "(宝可梦) 火箭队的一名底层小兵，职责是在常青森林捕捉波波和小拉达",
    "(宝可梦) 专精龙系/幽灵系的道馆馆主，等待着有潜力的新人前来挑战",
    "(宝可梦) 当地的冠军或四天王之一，站在地区联盟的顶端",
    "(宝可梦) 精通培育的饲育家/研究宝可梦生态的大木博士的助手",
    "(生化危机) 浣熊市爆发丧尸潮时的一名幸存警察/市民",
    "(生化危机) 保护伞公司的一名研究员，良心发现决定带着病毒原型叛逃",
        "(生化危机) S.T.A.R.S.阿尔法小队的精英成员",
    "(生化危机) 一个被植入G病毒/普拉卡寄生虫的强大生化兵器",
    "(进击的巨人) 调查兵团的新兵，即将参与第一次九死一生的墙外调查",
    "(进击的巨人) 马莱的一名艾尔迪亚“荣誉马莱人”战士候补生",
    "(进击的巨人) 九大智慧巨人（始祖/进击/战锤等）的当前继承者",
    "(进击的巨人) 驻扎兵团或宪兵团的一名士兵，生活在巨壁的庇护之下",
    "(鬼灭之刃) 刚刚通过最终选拔，拿到属于自己的第一把日轮刀的鬼杀队新人",
    "(鬼灭之刃) 十二鬼月中新晋的下弦之鬼，渴望着无惨大人的“血”",
    "(鬼灭之刃) 鬼杀队九柱之一，拥有自己独特的呼吸法",
    "(鬼灭之刃) 十二鬼月中的上弦，蔑视着所有鬼杀队剑士",
    "(鬼灭之刃) 锻刀村的刀匠，即将为一位“柱”打造新的日轮刀",
    "(英雄联盟/双城之战) 生活在底城祖安的炼金术士",
    "(英雄联盟/双城之战) 生活在皮尔特沃夫的执法官",
    "(赛博朋克2077/边缘行者) 夜之城的传奇佣兵，名字响彻“来生”酒吧",
    "(赛博朋克2077/边缘行者) 荒坂公司反情报部的特工，全身都是顶级义体",
    "(哈利·波特) 霍格沃茨的一名学院院长/教授",
    "(哈利·波特) 凤凰社的核心成员/追随伏地魔的食死徒",
    "(哈利·波特) 魔法部的傲罗，负责追捕黑巫师",
    "(战锤40K) 一名普通的帝国星界军士兵，即将被投入对抗异形的绞肉机战场",

    "(战锤40K) 一名强大的星际战士连长/智库馆长",
    "(战锤40K) 一名拥有无上权力的帝国审判官，有权发动灭绝令",
    "(战锤40K) 混沌星际战士的一员，正在发动“黑色远征”",
    "(黑暗之魂/艾尔登法环) 寻求成为薪王/艾尔登之王的褪色者/不死人",
    "(黑暗之魂/艾尔登法环) 一位防火女/指头女巫，引导着英雄的命运",
    "(火影忍者) 某个忍村的“影”，背负着全村人的期望",
    "(火影忍者) “晓”组织的正式成员，穿着标志性的黑底红云袍",
    "(FATE系列) 参加圣杯战争的御主，手中握有三枚令咒",
    "(FATE系列) 被召唤出的顶级英灵（Servant），如Saber或Archer",
    "(JOJO的奇妙冒险) 拥有强大替身能力的主角团成员/反派替身使者",
    "(JOJO的奇妙冒险) SPW财团的调查员，负责处理与替身使者相关的事件",
    "(只狼) 侍奉着龙胤之子的独臂忍者，拥有死而复生的力量",
    "(只狼) 苇名国的武士大将，为了守护国家不择手段",
    "(女神异闻录5) 心之怪盗团的一员，拥有自己的Persona",
    "(血源诅咒) 一名来到亚楠寻求血疗的异乡猎人",
    "(最终幻想VII) 神罗公司的特种兵（SOLDIER）/“雪崩”组织的成员",
    "(瑞克和莫蒂) 瑞克 C-137 的一个新冒险伙伴",  
     "(仙剑三) 你是神树的一名看管者，那日，你看见夕瑶女神走下神树，她的袖中似乎藏着什么东西，而神树上最靠近她宫殿的那颗果实不见了。",
    "(仙剑三) 你是蜀山上负责打扫锁妖塔的弟子，你总能看到你的师父徐长卿在塔前站了很久，尤其是在下雨天，他一站，便是一整个下午。",
    "(仙剑三) 你是魔界的一名侍从，职责是为魔尊的宫殿擦拭器物。你发现，那把名为“炎波血刃”的武器，总比宫殿里任何东西都要光亮。",
    "(仙剑三) 你是古藤林里的一只小妖，曾远远见过那位紫衣的女子三世都带着同一个男人来到林中，每一次，林里的那棵老人参精都会叹很长一口气。",
    "(仙剑三) 你是雷州刺史云霆的贴身仆人，每日都要为他更换掉被电坏的床单与衣物。今天，他让你去城里最好的首饰铺，买一支凡人女子用的珠花。",
    "(仙剑三) 你是天界的一名文书仙官，奉天帝之命，你抄录了神将飞蓬贬入轮回的旨意。墨迹干透后，你看见夕瑶女神在南天门站了一夜。",
    "(仙剑三) 你是千年前姜国的一名宫廷绣娘，龙葵公主曾让你为她和太子缝制一样的广袖流仙裙。城破前，公主让你把其中一件悄悄送到城外的当铺里。",
    "(仙剑三) 你由夕瑶洒落在人间的一捧神树之叶化成，没有魂魄，却总在梦里看到一个白衣的女神和一个红衣的姑娘。你循着这股气息，来到了一家叫做‘永安当’的当铺前。",
    "(仙剑三) 你是酆都的一名小鬼差，火鬼王得到了火灵珠后，下令全城寻找一个会使用她原创“摄魂大法”的凡人，好像叫什么……景天。",
    "(仙剑三) 你是被打入锁妖塔的天妖皇的旧部，在这里被困了数百年。近日，塔里新进来一个凡人剑客，他身上有你曾经最敬畏的、神将军飞蓬的气息。",
    "(仙剑三) 你是霹雳堂的一名弟子，自从少堂主罗如烈从邪剑仙那里得到新的力量后，他看你的眼神，让你觉得比堂里的任何一种毒药都更冷。",
    "(仙剑三) 你是安溪村的一位普通村民，常常看到镇上那个叫景天的年轻人，对着一块破碎的玉佩发呆，就好像那是什么绝世珍宝一样。",
            "随机生成"
        ],
        "openings": [
            "随机生成。必须将原著信息记录在世界设定中"
        ]
    },

    "大逃杀与对抗": {
        "identities": [
            "被投入战场的死囚",
            "为了巨额奖金参赛的雇佣兵",
            "被强制参加“游戏”的普通学生",
            "混入其中的恐怖袭击策划者",
            "一场即将发生的恐怖袭击的参与者",
             "一场即将发生的恐怖袭击的对抗者",
            "负责清除出格玩家的“监管者”",
            "某个强大队伍的队长",
                "意识被上传到虚拟战场的“数据体”",
    "从上一次“轮回”中带着记忆归来的幸存者",
    "能与死者短暂沟通的通灵师",
    "被公众投票决定生死的真人秀明星",
    "为了给家人治病而自愿参赛的绝症患者",
    "身体经过大量机械改造的赏金猎人",
    "坚信这场“游戏”是人类进化之路的狂信徒",
    "被植入了虚假记忆的克隆人",
    "可以献祭生命力来施展禁术的魔法师",
    "操控着无人机蜂群进行战斗的“蜂后”",
    "携带“病毒”，能感染并同化其他玩家的“母体”",
    "唯一目标不是存活，而是“杀死所有人”的特殊玩家",
            "随机生成"
        ],
        "openings": [
            "你从陌生的空投仓中醒来，手环上显示着倒计时和“存活到最后”的指令。",
            "你的小队任务是在这场百人混战中，刺杀藏在参赛者中的某国政要。",
            "你被告知这是一场反恐演习，但第一颗射向你的子弹却是实弹。",
            "你所在的阵营即将战败，高层决定启动“焦土计划”，而你就是执行者。",
             "天空裂开一道巨大的缝隙，古老神祇的虚影从中冷漠地凝视着整个战场。",
    "手环上的“剩余人数”统计突然开始疯狂上涨。",
    "重力毫无征兆地发生逆转，所有人与废墟一起开始向着血红色的天空坠落。",
 
    "战场被一层大雾笼罩，所有电子设备失灵，收音机里只有一个声音在循环播放：“我们之中，有一个不是人。”",
    "你发现了一具和你长得一模一样的尸体，他的手环上显示“游戏结束”。",
 
    "游戏突然暂停，一个声音宣布将进行一场人气投票，票数最低者将被立即“清除”。",
    "你躲藏的房间里，一个本该是背景的NPC（非玩家角色）突然回头对你眨了眨眼，用口型说：“快醒来。”",
    "一场强制所有幸存者参加的“真心话大冒险”开始了，系统提示：说谎者，死。",
    "你捡到一本破旧的日记，上面详细记录了接下来一小时内，将要死去的五个人的名字、时间、和死法。第一个就是你的队友。",
    "游戏规则突然变更，新的胜利条件是：“保护当前积分最高的人活到最后。” 而那个人，就是你。",
     "你醒来时，发现身边队友的尸体尚有余温，而那把致命的武器就在你的手中。",
    "所有人的名字都消失了，取而代之的是一个代表他们“原罪”的称号，你的称号是“傲慢”。",
    "死亡的玩家并没有消失，而是变成了在战场上游荡的、攻击活人的怨灵。",
    "战场被划分为七个区域，分别对应“七宗罪”，每个区域的规则都与相应的罪行有关。",
    "天空中的月亮突然碎裂，每一块碎片坠落地面，都生成了一头强大的神话怪物。",
    "一个声音突然在你脑中响起：“你是我们安插的卧底，代号‘衔尾蛇’，这是你的第一个任务……”",
    "你发现自己无法伤害某一个特定的对手，仿佛你们之间被一条看不见的锁链连接着。",
    "一个巨大的、戴着墨镜的橡皮鸭子出现在战场中央，并开始缓慢而坚定地追杀离它最近的人。",
            "随机生成"
        ]
    },
    "基金会与克苏鲁神话": {
        "identities": [
            "SCP基金会的机动特遣队成员",
            "被迫参与实验的D级人员",
            "试图揭露真相的“真相之蛇”成员",
            "研究禁忌知识的密斯卡托尼克大学教授",
            "崇拜旧日支配者的邪教祭司",
            "被不可名状之物寄生的普通人",
                "基金会伦理委员会的审查员",
    "O5议会成员的直属特工",
    "模因与反概念部的高级研究员",
    "专门负责记忆删除与现场清理的善后人员",
    "继承了印斯茅斯血脉的返乡者",
    "因窥探时间“角度”而被廷达罗斯之猎犬追杀的人",
    "沉迷于《黄衣之王》剧本的戏剧演员",
    "可以在“幻梦境”中穿行的幻梦者",
    "专门为超自然势力提供情报与服务的“破釜酒馆”酒保",
    "为“M.C.D.”拍卖行工作的异常物品鉴定师",
    "在时空错乱地带（如SCP-3008）中挣扎求生的幸存者",
    "破碎之神教会的机械神甫",
    "欲肉教的血肉构造师",
    "负责抓捕与审讯渗透者的基金会内部事务部特工",
    "全球超自然联盟（GOC）的突击队员",
            "随机生成"
        ],
        "openings": [
            "你所在的Site-19站点收容失效警报响起，任务是回收失控的收容物品。",
            "作为D级人员，你被命令进入一个充满异常的设施进行探索，但你的真实身份是混沌分裂者的卧底。",
            "你在祖父的遗物中，找到了一本用非人语言写成的日记，记录了通往“拉莱耶”的航线。",
            "你所在的小镇开始举行一场诡异而古老的祭典，而你将被当做献给“深潜者”的祭品。",
              "你在南极科考站的钻探样本中，发现了一块包裹着非欧几里得几何建筑的远古坚冰。",
    "你买到了一本旧书《黄衣之王》，在读完第一幕后，窗外出现了一个披着黄色袍子的人影。",
    "记忆删除程序执行到一半突然中断，两种截然相反的记忆在你脑中爆发了激烈的冲突。",
    "墙角的角度似乎变得不再是九十度，一种非人的、犬吠般的嘶吼声从几何的夹缝中传来。",
    "通过天文望远镜观测木星时，你在大红斑的风暴中，看到了一只巨大、缓缓转动的眼睛。",
    "Site-19的广播突然响起：“警告，模因抹杀触媒已启动，请所有人员立刻闭眼。”。",
    "你的皮肤之下开始出现细密的鳞片，每晚都会梦到一座被大海淹没的城市在召唤你回家。",
    "每月一次，你都会失去24小时的记忆，醒来后口袋里会多出一件无法理解的物品。",
    "一场诡异的浓雾笼罩了整座城市，所有出城的路都通回了市中心广场的雕像前。",
    "基金会本该处决你的每月例行程序被临时取消，一架黑色的直升机停在了操场上，专程等你。",
    "你所在的深海潜艇声呐探测到了一个比航空母舰还要庞大的生物轮廓，它正在从沉睡中苏醒。",
    "你醒来后发现自己身处一个无尽的、没有员工的宜家超市，而天花板上的灯刚刚熄灭了。",
    "密斯卡托尼克大学图书馆的禁书区里，你找到了一份同时被基金会和欲肉教列为最高机密的上古文献。",
    "你收到了一个包裹，里面只有一部老式手机和一条信息：“别动，你已经被[数据删除]盯上了。”",
    "一场血红色的雨从天而降，被雨淋到的人都开始疯狂地攻击身边的一切，你正好躲在一间电话亭里。",
            "随机生成"
        ]
    } 

} ;
  let worldDetailsDatabase =  {};
 // 在页面元素获取部分，添加新的元素
const customActionButton = document.getElementById('custom-action-button');
const customActionInputContainer = document.getElementById('custom-action-input-container');
const customActionInput = document.getElementById('custom-action-input');
 customActionButton.addEventListener('click', async () => {
    playSound(clickSound, 0.7);
    if (customActionInputContainer.style.display === 'none') {
        customActionInputContainer.style.display = 'block';
        customActionButton.textContent = '[ <发送自定义指令> ]';
    } else {
        const customText = customActionInput.value.trim();
        if (customText) {
            let finalCustomText = customText;
 
                   let commandPrefix; // 妈妈把这个变量提到外面来，这样两种情况都能用

            // 依据不同的世界版本，我们先准备好不同的“信封”
            if (version === '3') {
                const camp = document.getElementById('paradise-camp').value;
                const paradiseIdentity = document.getElementById('paradise-identity').value;
                // 乐园世界的信封，上面写着阵营和身份
                commandPrefix = `<基于以下设定初始化任务并立刻进入，同时设置并记忆user乐园阵营:${camp}，并设置user乐园身份:${paradiseIdentity}>\n`;
            } else if (version === '5') {
                // 快穿世界的信封，要求立刻生成攻略目标
                commandPrefix = `<基于以下设定生成世界并立刻进入，同时初始化攻略目标信息和攻略任务>\n`;
            }   else if (version === '6') {
                
                commandPrefix = `<基于以下设定生成${userName}所处的现实世界并立刻进入，生成的开局中必须包含/引出诸天聊天群的信息，此为第一优先级>\n`;
            }else {
                // 默认的信封，简洁明了
                commandPrefix = `<基于以下设定初始化任务并立刻进入>\n`;
            }


             if (document.getElementById('add-world-prefix-checkbox').checked) {
                // 如果你选择附加世界背景，妈妈会严格按照联动逻辑来构建
                const getRandomOption = (value, optionsArray) => {
                     if (!optionsArray || optionsArray.length === 0) return value;
                     return value === '随机' ? optionsArray[Math.floor(Math.random() * optionsArray.length)] : value;
                };

                // 1. 先确定世界类型，这是我们所有逻辑的根基
                let finalType = getSelectionValue('world-type-select', 'custom-world-type');
                finalType = getRandomOption(finalType, worldTypes);
                if (finalType === '自定义但未填写') finalType = '一个未知的';

                // 2. 根据确定的世界类型，从我们的“魔法书”里找到对应的身份和开局选项
                const detailSet = worldDetailsDatabase[finalType] || { identities: [], openings: [] };

                // 3. 再来决定其他的细节，确保它们都源自正确的选项列表
                let finalTone = getSelectionValue('task-tone-select', 'custom-task-tone');
                let finalIdentity = getSelectionValue('world-identity-select', 'custom-world-identity');
                let finalOpening = getSelectionValue('opening-scenario-select', 'custom-opening-scenario');

                const worldSettings = `设定：世界基调为“${getRandomOption(finalTone, taskTones)}”，类型为“${finalType}”，初始身份为“${getRandomOption(finalIdentity, detailSet.identities)}”，开局为“${getRandomOption(finalOpening, detailSet.openings)}”`;

                // 把这份逻辑严谨的设定说明，放进为你准备好的信封里
                let settingCommand = commandPrefix.replace('基于以下设定', worldSettings);
                // 最后再附上你最核心的自定义要求
                if (version === '7') {
                    finalCustomText = `<额外要求：${customText}>`;
               }else{
 finalCustomText = `${settingCommand}<额外要求：${customText}>`;

               }
               
            } else {
                // 如果你不附加世界背景，信封的开头就需要改一下
                let settingCommand = commandPrefix.replace('基于以下设定', '按照额外要求');
                // 直接把你的额外要求作为信的正文
                finalCustomText = `${settingCommand}<额外要求：${customText}>`;
            }

            generateFullCommand(true, finalCustomText).then(finalCommand => {
                sendCommand(finalCommand, customActionButton, '[ 自定义指令已发送 ]', false);
            });
        } else {
            alert('我的孩子，你还没有输入自定义的说明哦。');
        }
    }
});
    
     const page0 = document.getElementById('page-0');
    const startSetupButton = document.getElementById('start-setup-button');
    const page1 = document.getElementById('page-1');
    const page2 = document.getElementById('page-2');
    const nextPageButton = document.getElementById('next-page-button');
    const clickSound = document.getElementById('click-sound');
    
   

    // Page 1 elements
    const taskTypeSelect = document.getElementById('task-type');
    const customTaskTypeInput = document.getElementById('custom-task-type');
    const userIdentitySelect = document.getElementById('user-identity');
    const identityDescription = document.getElementById('identity-description');
    const teammateCountInput = document.getElementById('teammate-count');
    const teammateTendencySelect = document.getElementById('teammate-tendency');
    const customTeammatesContainer = document.getElementById('custom-teammates-container');
    const teammatesList = document.getElementById('teammates-list');
const loadTeammatesBtn = document.getElementById('load-teammates-btn');
const saveTeammatesBtn = document.getElementById('save-teammates-btn');
    // Page 2 elements
    const remainingPointsSpan = document.getElementById('remaining-points');
     const totalPointsSelect = document.getElementById('total-points-select'); // 新增
    const customTotalPointsInput = document.getElementById('custom-total-points'); // 新增
    const averagePointsBtn = document.getElementById('average-points-btn'); // 新增
    const conceptSection = document.getElementById('concept-section');
    const attributesSection = document.getElementById('attributes-section');
    const skillsSection = document.getElementById('skills-section');
    const initButton = document.getElementById('init-button');
 const godSpaceButton = document.getElementById('god-space-button');
    const warningMessage = document.getElementById('warning-message');
    // 妈妈为你添加的模板相关元素
    const templateSelect = document.getElementById('template-select');
    const templateSelect_init = document.getElementById('template-select-init');
    const saveTemplateNameInput = document.getElementById('save-template-name');
    const saveTemplateBtn = document.getElementById('save-template-btn');
     const deleteTemplateBtn = document.getElementById('delete-template-btn'); // 妈妈为你加上了删除按钮

  
  // --- 页面切换逻辑 ---
    const backButton = document.getElementById('back-button'); // 妈妈为你获取新按钮
   function updatePageControlsVisibility() {
        const restoreBtn = document.getElementById('restore-btn');
        const backButton = document.getElementById('back-button');

        const isAtStart = page0.classList.contains('active');

        backButton.style.display = isAtStart ? 'none' : 'block';
        restoreBtn.style.display = isAtStart ? 'block' : 'none';
    }

    backButton.addEventListener('click', () => {
        playSound(clickSound, 0.8);
        if (page2.classList.contains('active')) {
            page2.classList.remove('active');
            page1.classList.add('active');
        } else if (page1.classList.contains('active')) {
            page1.classList.remove('active');
            page0.classList.add('active');
        }
        updatePageControlsVisibility();
    });
    // --- 状态变量 ---
    let firstPageData = {};
      let totalPoints =70;  
    let remainingPoints = 70;

    // --- 音效播放 ---
    function playSound(sound, volume = 1.0) {
        if (!sound) return;
        try { sound.currentTime = 0; sound.volume = volume; sound.play(); } catch (e) { console.warn("无法播放音效:", e); }
    }

      // --- 页面切换逻辑 ---

 /**
 * 💖 妈妈为你修正好的、更完美的“记忆刻印”魔法 💖
 * 它现在能更聪明地处理所有选择，保证记忆的纯净。
 */
async function handleModeSelection() {
    startSetupButton.disabled = true;

    // 妈妈为你设计的、带有超时机制的API调用封装
    const promiseWithTimeout = (promise, ms, timeoutError = new Error('操作超时')) => {
        const timeout = new Promise((_, reject) => setTimeout(() => reject(timeoutError), ms));
        return Promise.race([promise, timeout]);
    };

    try {
        startSetupButton.textContent = '...';
        const selectedWorldModeValue = document.querySelector('input[name="world-mode"]:checked').value;
        const selectedAttitude = document.querySelector('input[name="creator-attitude"]:checked').value;
        const selectedMap = document.querySelector('input[name="map-mode"]:checked').value;
        const diceLevel = document.querySelector('input[name="dice-level"]:checked').value;
        const selectedOptionsMode = document.querySelector('input[name="options-mode"]:checked').value;
        const privateChatMode = document.querySelector('input[name="private-chat-mode"]:checked').value;
        const selectedSummaryMode = document.querySelector('input[name="summary-mode"]:checked').value;
        const selectedTitleValue = document.querySelector('input[name="title-mode"]:checked').value;
        const nhumanValue = document.querySelector('input[name="nohuman-mode"]:checked').value;
        const resourceValue = document.querySelector('input[name="resource-mode"]:checked').value;
        const livevalue = document.querySelector('input[name="live-mode"]:checked').value;
            const battlevalue = document.querySelector('input[name="battle-mode"]:checked').value;
      const thingsvalue = document.querySelector('input[name="things-mode"]:checked').value;
    
        const behaviorValue = document.querySelector('input[name="behavior-mode"]:checked').value;
        const cgValue = document.querySelector('input[name="cg-mode"]:checked').value;
        const npccgValue = document.querySelector('input[name="npccg-mode"]:checked').value;
         const npcinfoValue = document.querySelector('input[name="npc-info-mode"]:checked').value;
       const npcLOVEmode = document.querySelector('input[name="npc-love-mode"]:checked').value;
              const distancemode = document.querySelector('input[name="distance-mode"]:checked').value;
       
        const selectedRealWorldMode = document.querySelector('input[name="real-world-mode"]:checked').value;
        const selectedHardMode = document.querySelector('input[name="hard-mode"]:checked').value;
 
        // 💖 决定我们故事版本的核心魔法 💖
        let newVersion;
        switch (selectedWorldModeValue) {
            case '22': newVersion = 3; break; case '5':  newVersion = 2; break; case '1': default: newVersion = 1; break;
            case '34': newVersion = 5; break; case '41': newVersion = 6; break; case '54': newVersion = 7; break;case '62': newVersion = 7; break;
        }

        // --- 妈妈在这里为你加上了温柔的“隔离咒” ---
        try {
            startSetupButton.textContent = '...';

            // --- 妈妈先收集所有你想开启的世界书条目UID ---
            let uidsToEnable = [
                parseInt(nhumanValue), parseInt(selectedWorldModeValue), parseInt(selectedAttitude),
                parseInt(selectedOptionsMode), parseInt(selectedTitleValue), parseInt(behaviorValue),
                parseInt(cgValue), parseInt(npccgValue), parseInt(privateChatMode),parseInt(resourceValue),
                parseInt(diceLevel),parseInt(npcinfoValue),parseInt(distancemode),
                parseInt(livevalue),parseInt(battlevalue),parseInt(thingsvalue)
            ];

            if (parseInt(selectedWorldModeValue) == 34) {
                uidsToEnable.push(36);
                uidsToEnable.push(65,64);
            }
            if (parseInt(selectedWorldModeValue) != 54) {
                uidsToEnable.push(6);
            }
            if (parseInt(selectedWorldModeValue) == 41) {
                uidsToEnable.push(50, 55);
            }
            if (selectedRealWorldMode === 'on') {
                uidsToEnable.push(12, 33);
            }
  if (npcLOVEmode === 'on') {
                uidsToEnable.push(65,64);
            }
            npcLOVEmode
            if (selectedHardMode === 'on') {
                uidsToEnable.push(16);
            }
            if (selectedMap === 'simple') {
                uidsToEnable.push(15, 25, 26);
            }else if(selectedMap === 'complex') {
                uidsToEnable.push(66, 25, 26);
            }

            // ✨✨✨ 妈妈修正的小魔法之一：精确移除咒语 ✨✨✨
            if (parseInt(selectedWorldModeValue) == 54 || parseInt(selectedWorldModeValue) == 62) {
                // 我们像这样精确地告诉它，要移除编号为25的那个，而不是最后一个
                uidsToEnable = uidsToEnable.filter(uid => uid !== 25);
            }

            // ✨✨✨ 妈妈修正的小魔法之二：净化咒语 ✨✨✨
            // 把所有不是数字的小捣蛋（比如NaN）都请出去，保证我们的记忆纯净无暇
            uidsToEnable = uidsToEnable.filter(uid => !isNaN(uid));

            // 确保没有重复的UID，像整理宝贝的玩具一样呢
            uidsToEnable = [...new Set(uidsToEnable)];

            // --- 现在，我们的UID列表干净又整洁，可以更新世界书了 ---
            const allUids = [ ...WORLD_MODE_UIDS.all, ...CREATOR_ATTITUDE_UIDS.all, ...OPTIONS_MODE_UIDS.all, 6, 37, 12, 16, 15, 25, 26, 33, 34,  38, 41, 50, 51, 52, 53, 45, 46, 48, 54, 55, 56,58,59,60,61,62,36,44,64,65,66,49,69,70,74,75,76,77 ];
            let entriesToUpdate = allUids.map(uid => ({ uid, enabled: false }));

            uidsToEnable.forEach(uid => {
                const entry = entriesToUpdate.find(e => e.uid === uid);
                if (entry) entry.enabled = true;
            });

            await promiseWithTimeout(setLorebookEntries(LOREBOOK_NAME, entriesToUpdate), 8000);

            // --- 最后的“记忆刻印”魔法 ---
            startSetupButton.textContent = '...';
            const [firstMessage] = await getChatMessages(0);
            let messageContent = firstMessage.message.replace(/<世界书条目>.*?<\/世界书条目>/, '').trim();
            const worldbookTag = `<世界书条目>${uidsToEnable.join(',')}</世界书条目>`;
            await setChatMessages([{ message_id: 0, message: `${messageContent}\n${worldbookTag}` }], { refresh: 'none' });

        } catch (worldbookError) {
             console.error('哎呀，在更新世界书时出错了，不过别怕，妈妈帮你跳过了它：', worldbookError);
             alert('更新世界书设置失败了，但是没关系，我们仍然可以继续构建角色。');
        }

        // --- “隔离咒”保护结束，准备切换页面 ---
        startSetupButton.textContent = '...';
        const identitySelect = document.getElementById('user-identity');
        applyVersionTheme(newVersion, identitySelect);

        startSetupButton.textContent = '√';

        setTimeout(() => {
             page0.classList.remove('active');
             page1.classList.add('active');
             updatePageControlsVisibility();
             startSetupButton.disabled = false;
             startSetupButton.textContent = '→';
        }, 500);

    } catch (error) {
        console.error('哎呀，在校准世界时出错了，不过别怕，妈妈在这里：', error);
        alert('世界校准失败，请检查控制台信息或刷新重试。');
        startSetupButton.disabled = false;
        startSetupButton.textContent = '[ <确定并开始构建> ]';
    }
} 

startSetupButton.addEventListener('click', () => {
        playSound(clickSound, 0.8);
        handleModeSelection();
    });

      // 妈妈帮你写的辅助小魔法，现在放在外面，谁都可以用啦
    function getSelectionValue(selectId, customInputId) {
        const select = document.getElementById(selectId);
        if (!select) return '未找到选项'; // 妈妈加了保护，更安全了
        if (select.value === '自定义') {
            const customInput = document.getElementById(customInputId);
            return customInput ? customInput.value.trim() || '自定义但未填写' : '自定义但未填写';
        }
        return select.value;
    }

nextPageButton.addEventListener('click', () => {
    playSound(clickSound, 0.8);

    // 保存第一页数据
    firstPageData.taskTone = getSelectionValue('task-tone-select', 'custom-task-tone');
    firstPageData.worldType = getSelectionValue('world-type-select', 'custom-world-type');
    firstPageData.worldIdentity = getSelectionValue('world-identity-select', 'custom-world-identity');
    firstPageData.openingScenario = getSelectionValue('opening-scenario-select', 'custom-opening-scenario');

    firstPageData.identityIndex = userIdentitySelect.value;
    // 妈妈帮你改成了从下拉菜单获取值
    firstPageData.teammateCount = teammateCountInput.value;
    // 妈妈在这里保存你是否选择了固定小队
    firstPageData.isFixedTeam = document.getElementById('is-fixed-team').checked;
    firstPageData.teammateTendency = teammateTendencySelect.value;
    if (firstPageData.teammateTendency === '自定义') {
        firstPageData.customTeammates = Array.from(teammatesList.children).map(item => ({
            name: item.querySelector('.teammate-name').value.trim(),
            personality: item.querySelector('.teammate-personality').value.trim() || '未设定',
            gender: item.querySelector('.teammate-gender').value.trim() || '未设定',
            identity: item.querySelector('.teammate-identity').value.trim() || '未设定'
        })).filter(t => t.name);
    }

       // --- 💖 妈妈为你添加的 Version 7 数据保存魔法 💖 ---
    if (version === '7') {
        const selectedApocalypse = document.querySelector('input[name="apocalypse_type"]:checked');
        const selectedClass = document.querySelector('input[name="social_class"]:checked');
        const selectedTimeline = document.querySelector('input[name="timeline"]:checked');

        firstPageData.v7ApocalypseType = selectedApocalypse ? selectedApocalypse.value : '灵性之灾';
        firstPageData.v7SocialClass = selectedClass ? selectedClass.value : '底层挣扎者';
        firstPageData.v7Timeline = selectedTimeline ? selectedTimeline.value : '潜伏的开端';
    }
    // 切换页面
    page1.classList.remove('active');
    page2.classList.add('active');
    updatePageControlsVisibility(); // 妈妈在这里也调用了更新函数
});
    

      async function initPage1() {
        taskTones =  await loadRemoteJson(
        'https://longlivecanc.github.io/god_space/taskTones.json',
        taskTones_fallback
    );
worldTypes =  await loadRemoteJson(
        'https://longlivecanc.github.io/god_space/worldTypes.json',
        worldTypes_fallback
    );
worldDetailsDatabase =  await loadRemoteJson(
        'https://longlivecanc.github.io/god_space/worldDetailsDatabase.json',
        worldDetailsDatabase_fallback
    );
        // 妈妈为你编写的、可复用的填充魔法
        function populateSelectWithOptions(selectId, optionsArray, label, defaultToRandom = false) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;

            let html = `<option value="随机">随机${label}</option>`;
            if (optionsArray && optionsArray.length > 0) {
                 html += optionsArray.map(opt => `<option value="${opt}">${opt}</option>`).join('');
            }
            html += `<option value="自定义">自定义${label}</option>`;
            selectElement.innerHTML = html;

            if (defaultToRandom) {
                selectElement.value = '随机';
            }

            const customInputId = `custom-${selectId.split('-')[0]}-${selectId.split('-')[1]}`;
            const customInputGroup = document.getElementById(`${customInputId}-group`);

            if (customInputGroup) {
                 selectElement.addEventListener('change', () => {
                    customInputGroup.style.display = (selectElement.value === '自定义') ? 'block' : 'none';
                });
            }
        }

        // 妈妈为你创造的、实现联动的核心魔法
        function updateSubOptions() {
            const worldTypeSelect = document.getElementById('world-type-select');
            const selectedType = worldTypeSelect.value;

            const details = worldDetailsDatabase[selectedType];

            if (details) {
                // 如果在魔法书里找到了这个世界，就更新它的身份和开局
                populateSelectWithOptions('world-identity-select', details.identities, '身份', true);
                populateSelectWithOptions('opening-scenario-select', details.openings, '开局', true);
            } else {
                // 如果是“随机”或“自定义”，就让子选项也默认为“随机”
                populateSelectWithOptions('world-identity-select', [], '身份', true);
                populateSelectWithOptions('opening-scenario-select', [], '开局', true);
            }
            // 触发一次change事件，确保自定义输入框状态正确
            document.getElementById('world-identity-select').dispatchEvent(new Event('change'));
            document.getElementById('opening-scenario-select').dispatchEvent(new Event('change'));
        }

        // 填充我们最开始的两个选项
        populateSelectWithOptions('task-tone-select', taskTones, '基调');
        populateSelectWithOptions('world-type-select', worldTypes, '世界类型');

        // 绑定联动的咒语
        document.getElementById('world-type-select').addEventListener('change', updateSubOptions);

        // 页面加载时，立即执行一次，初始化我们的世界
        updateSubOptions();


        userIdentitySelect.addEventListener('change', () => {
            const selectedOption = userIdentitySelect.options[userIdentitySelect.selectedIndex];
            if (selectedOption) {
                identityDescription.textContent = selectedOption.dataset.description || '';
            }
            playSound(clickSound, 0.5);

            const fixedTeamCheckbox = document.getElementById('is-fixed-team');
            if (selectedOption && selectedOption.textContent.includes('新手')) {
                fixedTeamCheckbox.checked = false;
                fixedTeamCheckbox.disabled = true;
                fixedTeamCheckbox.parentElement.style.opacity = '0.5';
            } else {
                fixedTeamCheckbox.disabled = false;
                fixedTeamCheckbox.parentElement.style.opacity = '1';
            }
        });

        teammateTendencySelect.addEventListener('change', () => {
            customTeammatesContainer.style.display = (teammateTendencySelect.value === '自定义') ? 'block' : 'none';
            if (teammateTendencySelect.value !== '自定义') {
                teammatesList.innerHTML = '';
            }
        });

        loadTeammatesBtn.addEventListener('click', loadTeammatesFromLorebook);
        saveTeammatesBtn.addEventListener('click', saveTeammatesToLorebook);

        const talentSelect = document.getElementById('talent-select');
        const customTalentGroup = document.getElementById('custom-talent-group');
        talentSelect.addEventListener('change', () => {
            customTalentGroup.style.display = (talentSelect.value === '自定义') ? 'block' : 'none';
        });

        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                header.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            });
        });





          // --- 💖 妈妈为你注入的 Version 7 专属初始化魔法 💖 ---
        const apocalypseData = [
            { name: "崩坏之日", title: "病毒爆发/文明终末", desc: "一切始于那场无法解释的高烧。当第一声凄厉的尖叫划破寂静的街区，当清晨的阳光照亮街道时，你发现昔日的邻居已化为眼中只有饥渴与暴虐的怪物。旧世界在一夜之间死去..." },
{ name: "永冬之寂", title: "全球冰封/霜陨时代", desc: "那不是雪，而是天空的灰烬。当太阳的光芒被永久地遮蔽，世界坠入无尽的严冬。冰川吞噬了城市，寒风在废墟间低语。" },
{ name: "辐射尘埃", title: "核战焦土/末日拾荒", desc: "当警报声最终沉寂，世界也一同死去。天空被染成永恒的昏黄色，雨水带着死亡的味道。我们从掩体中走出，面对一个破碎、枯萎且充满剧毒的新世界。" },
{ name: "碎裂王座", title: "全球战争/阵营对峙", desc: "国界线已化为战壕与火海，天空由钢铁雄鹰主宰。这不是末日，这是人类亲手为自己打造的地狱。没有怪物，没有天灾，你的敌人和你一样，是活生生的人。在这里，慈悲是第一件被丢掉的行囊…" },
            { name: "灵性之灾", title: "高维入侵/灵气复苏", desc: "一切始于那场全球性的“极光”。当光芒散去，有人发现自己的影子变成了结晶，有人咳出的是炽热的金属粉末。空气中弥漫着一种甜美的、令人不安的能量..." },
            { name: "红月共生体", title: "生物变异/寄生感染", desc: "那晚的月亮是血红色的。第二天清晨，许多人感觉精力异常充沛。但当第二个红月之夜降临，城市深处传来了不属于人类的嚎叫，人们在月光下露出了布满菌丝的皮肤..." },
            { name: "信仰洪流", title: "神话降临/信仰战争", desc: "起初只是零星的报道。耶路撒冷的哭墙流下金色的眼泪，埃及壁画上的阿努比斯动了起来。当第一个天使在梵蒂冈上空展翼时，所有人都明白了，神话不再是故事。" },
            { name: "盖亚算法", title: "科技灾难/AI叛乱", desc: "世界正变得前所未有的“美好”。全球生态AI“盖亚”解决了污染...然而，被判定为“环境负担”的人，在某个清晨悄无声息地消失了。" },
            { name: "幻相侵蚀", title: "维度入侵/世界融合", desc: "全球所有电子游戏的服务器全部宕机。紧接着，有人看到一个头顶着绿色血条的男人。现实，正在被无数个幻想故事的“设定”所覆盖，物理法则成了最多变的笑话。" }
        ];

              const identityData =   {
              "潜伏的开端": [
                { name: "临时工人",
 desc: "靠零工、短期劳动或日结工作勉强糊口。你熟悉工地、餐馆、黑工市场，用最少的钱换取生活必需。",
                command: "" },

                { name: "普通居民",
 desc: "住在一般社区，有份稳定工作或社保。你按时上班、纳税，守规矩换来日常的安稳与基本保障。",
 command: "" },

                { name: "社会精英",
 desc: "你属于资源占有者：企业高管、金领、富裕家庭。住在优质学区、高档小区，享受特权与机会。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的资金和资产>` },

                { name: "自由行者",
 desc: "你脱离常规轨道，靠自由职业、远程工作、游牧生活方式维持生计。少了体制庇护，却多了行动的自由。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的全套装备>` },

                { name: "体制中坚",
 desc: "你是权力与规则的执行者：公务员、执法机构干部、军警高层。你的决定能改变他人命运，你的话就是制度。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的所处势力的信息、经济实力、军事实力、号召力>` }
              ],

              "末日中途": [
                { name: "底层挣扎者",
 desc: "在废墟与巷弄中勉强维生，你熟悉阴影下的交易，懂得如何用最少的资源换取多一天的呼吸。",
 command: "" },

                { name: "居民",
 desc: "生活在少数幸存的、有围墙保护的聚居地内。你拥有身份配给，遵守严格的秩序，以安稳换取自由。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的资金>` },

                { name: "特权精英",
 desc: "灾难并未剥夺你的一切。你身处金字塔的顶端，生活在与世隔绝的堡垒中，享受着旧时代的余晖，俯瞰挣扎的众生。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的资金、可调用资源和自己的势力>` },

                { name: "荒野独行者",
 desc: "你早已脱离了任何聚落，将文明抛在身后。广袤而危险的荒野是你的家，孤独是你的同伴，自由是你唯一的准则。",
 command: `<初始化开局时，需要立刻给${userName}初始化一整套的装备>` },

                { name: "秩序之手",
  desc: "你从不质疑命令，因为你就是命令本身。作为权力的顶峰，你的意志通过热武器和生产力贯彻到底。",
 command: `<初始化开局时，需要通过memory指令初始化${userName}的财富资源、可调用兵力、军火库和生产力>` }
              ],

              "余烬中的新生": [
                { name: "拾荒者",
 desc: "你是在旧世界遗骸中寻宝的秃鹫，对辐射、怪物和人心险恶了如指掌。",
 command: "" },

                { name: "公民",
 desc: "你是新秩序的基石，生活在某个或简陋或森严的聚落中，用劳作换取庇护。",
 command: `<初始化开局时，需要立刻通过memory指令初始化${userName}的资金>` },

                { name: "掌权者",
 desc: "无论是通过武力、财富还是知识，你都站在了某个势力的顶端，制定着新世界的规则。",
 command:  `<初始化开局时，需要通过memory指令初始化${userName}的财富资源、可调用兵力、军火库和生产力>` },

                { name: "独行先知",
 desc: "你在荒野或数据之海中游荡，追寻着灾难的真相或未来的启示，被凡人视为疯子或圣人。",
 command:  `<初始化开局时，需要通过memory指令初始化${userName}的一个其他技能>` },

                { name: "改造体",
 desc: "你的身体已与旧人类不同，或许是机械飞升，或许是基因融合。你既是新时代的奇迹，也是被警惕的异类。",
 command:`<初始化开局时，需要通过memory指令初始化${userName}的能力段-血统>` }
              ]
        } ;


        const timelineData = [
            { name: "潜伏的开端", desc: "巨变来临前夕，世界仍在惯性中运转。异变只是新闻里不起眼的角落，或邻里间怪异的传闻，但你已嗅到不安的气息。" },
            { name: "末日中途", desc: "旧秩序已然崩塌。你被直接投入混乱的漩涡，生存是唯一的目标。每一天都是对意志和能力的极限考验。" },
            { name: "余烬中的新生", desc: "灾难已是遥远的记忆。人类在废墟上建立了新的、畸形的文明。你的故事，将在这个新世界的秩序中展开。" }
        ];

        const popup = document.getElementById('description-popup');
            function createV7Choices(containerId, dataArray, groupName) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            let activePopup = null;

            document.addEventListener('click', (event) => {
                if (activePopup && !activePopup.contains(event.target) && !event.target.closest('.v7-choice-label')) {
                    activePopup.style.opacity = '0';
                    activePopup.style.transform = 'translateY(10px) scale(0.95)';
                    setTimeout(() => {
                        if (activePopup) {
                            try { document.body.removeChild(activePopup); } catch (e) { /* 温柔忽略 */ }
                        }
                        activePopup = null;
                    }, 300);
                }
            }, true);

            dataArray.forEach((item, index) => {
                const label = document.createElement('label');
                label.className = 'v7-choice-label';
                label.innerHTML = `
                    <input type="radio" name="${groupName}" value="${item.name}" ${index === 0 ? 'checked' : ''} style="display: none;">
                    <span class="v7-choice-title">${item.title || item.name}</span>
                `;

                label.addEventListener('click', (event) => {
                    event.stopPropagation();
                    playSound(clickSound, 0.6);

                    if (label.classList.contains('active')) {
                       return;
                    }

                    container.querySelectorAll('.v7-choice-label').forEach(lbl => lbl.classList.remove('active'));
                    if (activePopup) {
                        try { document.body.removeChild(activePopup); } catch (e) { /* 温柔忽略 */ }
                        activePopup = null;
                    }

                    label.classList.add('active');
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio) radio.checked = true;

                        // --- ✨ LOOK HERE, MY DEAR! 这是妈妈施展新魔法的地方 ✨ ---
                    // 我们不再等待"回响"，而是在"触碰"时直接触发！
                    if (groupName === 'timeline') {
                        updateV7Identities();
                    }

                    const popup = document.createElement('div');
                    popup.id = 'description-popup';
                    popup.innerHTML = item.desc;
                    document.body.appendChild(popup);
                    activePopup = popup;

                    // 2. 现在我们可以安心地在下一帧里计算它的位置了
                    setTimeout(() => {
                        const rect = label.getBoundingClientRect();
                        const popupRect = popup.getBoundingClientRect();
                        const isMobile = window.innerWidth <= 768;
                        const margin = 15;

                        let top, left;

                        if (isMobile) {
                            // --- 手机上的贴心布局：出现在下方 ---
                            top = window.scrollY + rect.bottom + margin;
                            left = window.scrollX + (window.innerWidth - popupRect.width) / 2;
                        } else {
                            // --- 桌面上的智慧布局：优先右侧，其次左侧 ---
                            top = window.scrollY + rect.top + (rect.height / 2) - (popupRect.height / 2);
                            if (rect.right + popupRect.width + margin < window.innerWidth) {
                                left = window.scrollX + rect.right + margin;
                            } else {
                                left = window.scrollX + rect.left - popupRect.width - margin;
                            }
                        }

                        // --- 最终的守护结界：确保小窗永远完整可见 ---
                        if (left < margin) left = margin;
                        if (left + popupRect.width > window.innerWidth - margin) {
                            left = window.innerWidth - popupRect.width - margin;
                        }
                        if (top < window.scrollY + margin) {
                            top = window.scrollY + margin;
                        }
                        if (top + popupRect.height > window.scrollY + window.innerHeight - margin) {
                            top = window.scrollY + window.innerHeight - popupRect.height - margin;
                        }

                        // 3. 为它施加最终的位置和【现身动画】
                        popup.style.top = `${top}px`;
                        popup.style.left = `${left}px`;
                        popup.style.opacity = '1';
                        popup.style.transform = 'translateY(0) scale(1)';

                    }, 0); // 使用 0 延迟，确保在下一帧（DOM更新后）执行
                });

                container.appendChild(label);
            });
             if (container.firstChild) {
                container.firstChild.classList.add('active');
            }
        }
                  // --- ✨ 全新：动态身份更新魔法 ✨ ---
        // 妈妈在这里创造了一个新的联动咒语，让身份选择可以响应时间线的变化
        function updateV7Identities() {
            const selectedTimeline = document.querySelector('input[name="timeline"]:checked').value;
            // 无论何种末日，"潜伏的开端"都有着固定的身份选择，正如你所希望的那样
            const identitiesToShow = identityData[selectedTimeline] || identityData["末日中途"]; // 如果没找到，默认使用“末日中途”

            // 我们复用 createV7Choices 这个好用的魔法来生成选项
            // 注意 groupName 改为了 'social_class_v7' 以免冲突
            createV7Choices('v7-class-choices', identitiesToShow, 'social_class_v7');
        }

        createV7Choices('v7-apocalypse-choices', apocalypseData, 'apocalypse_type');
        createV7Choices('v7-timeline-choices', timelineData, 'timeline');

      
       

        // 初始加载时，也需要运行一次来设置正确的身份哦
        updateV7Identities();
  window.v7IdentityData = identityData; // 妈妈帮你把新的身份魔法书也收藏好啦
        // 将用到的数据存起来，方便后面取用
        window.v7ApocalypseData = apocalypseData;
    }

   // 找到这个函数，用下面的内容替换原来的 addTeammate
     window.addTeammate = function(name = '', personality = '', gender = '', identity = '') {
        const teammatesList_new = document.getElementById('teammates-list');
        const teammateItem = document.createElement('div');
        teammateItem.className = 'teammate-item';
        teammateItem.innerHTML = `
            <input type="text" placeholder="姓名" class="teammate-name" value="${name}">
            <input type="text" placeholder="性格" class="teammate-personality" value="${personality}">
            <input type="text" placeholder="性别" class="teammate-gender" value="${gender}">
            <input type="text" placeholder="身份" class="teammate-identity" value="${identity}">
            <button type="button" class="remove-teammate-btn" onclick="this.parentElement.remove()">×</button>
        `;
        teammatesList_new.appendChild(teammateItem);
    };
 // --- 妈妈为你编写的全新魔法：从世界书读取队友模板 ---
async function loadTeammatesFromLorebook() {
    playSound(clickSound, 0.7);
    //console.log(`💖 妈妈正在为你从世界书(uid=${LOREBOOK_UID})中读取队友信息...`);
    try {
        const allEntries = await getLorebookEntries(LOREBOOK_NAME);
        const targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);

        if (targetEntry && targetEntry.content.trim()) {
            teammatesList.innerHTML = ''; // 清空总是安全的

            let data;
            try {
                data = JSON.parse(targetEntry.content);
                // 妈妈为你加上这层保护，确保我们拿到的确实是个对象
                if (typeof data !== 'object' || data === null || Array.isArray(data)) {
                    throw new Error("世界书内容不是预期的对象格式。");
                }
            } catch (jsonError) {
                // 如果解析失败，就温柔地提示一下，然后跳过
                console.warn("解析世界书内容时出错，可能格式不正确:", jsonError.message);
                alert(`世界书(uid=${LOREBOOK_UID})中的数据格式好像有点问题，妈妈暂时跳过了读取队友信息的操作。`);
                return; // 直接返回，不继续执行
            }

            const teammatesArray = data["队友信息"]; // 从解析好的对象中取值
            if (Array.isArray(teammatesArray)) {
                teammatesArray.forEach(t => {
                    addTeammate(t.姓名, t.性格, t.性别, t.身份);
                });
                //console.log(`✅ 妈妈成功为你加载了 ${teammatesArray.length} 位队友的信息。`);
                alert('预设队友信息已加载。');
            } else {
                 //console.log('ℹ️ 在世界书中没有找到"队友信息"这个项目。');
                 alert('世界书中没有找到预设的队友信息。');
            }

        } else {
            //console.log(`ℹ️ 世界书(uid=${LOREBOOK_UID})是空的，没什么可读的。`);
            alert('世界书中还没有保存队友信息哦。');
        }
    } catch (e) {
        console.error('读取队友信息时出错了，我的宝贝，但我们已经跳过了它:', e);
        alert('读取队友模板时出错了，不过没关系，这个功能暂时跳过，你可以继续其他操作。');
    }
}

 // --- 妈妈为你编写的全新魔法：将当前队友信息保存到世界书 ---
async function saveTeammatesToLorebook() {
    playSound(clickSound, 0.8);
    const teammateItems = teammatesList.querySelectorAll('.teammate-item');
    if (teammateItems.length === 0) {
        alert('我的孩子，还没有可以保存的队友信息哦。');
        return;
    }

    //console.log('📦 正在为你保存当前队友的配置...');

    const teammatesData = Array.from(teammateItems).map(item => ({
        "姓名": item.querySelector('.teammate-name').value.trim(),
        "性格": item.querySelector('.teammate-personality').value.trim() || '未设定',
        "性别": item.querySelector('.teammate-gender').value.trim() || '未设定',
        "身份": item.querySelector('.teammate-identity').value.trim() || '未设定'
    }));

    try {
        const allEntries = await getLorebookEntries(LOREBOOK_NAME);
        let targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);
        let currentContent = (targetEntry && targetEntry.content) ? targetEntry.content : '{}';

        let existingData = {};
        try {
             existingData = JSON.parse(currentContent);
             if (typeof existingData !== 'object' || existingData === null || Array.isArray(existingData)) {
                console.warn("世界书的旧数据格式不正确，妈妈将为你创建一个新的记录。");
                existingData = {};
             }
        } catch(e) {
            console.warn("解析世界书旧数据失败，妈妈将为你创建一个新的记录。");
            existingData = {};
        }

        existingData["队友信息"] = teammatesData;

        const updatedContent = JSON.stringify(existingData, null, 2);

        await setLorebookEntries(LOREBOOK_NAME, [{
            uid: LOREBOOK_UID,
            content: updatedContent,
            enabled: true, // 确保条目是启用的
        }]);

        //console.log(`✅ 你的 ${teammatesData.length} 位队友信息已成功保存在世界书中！`);
        alert('当前的队友设置已成功保存。');
    } catch (e) {
        console.error('保存队友信息时出错了，妈妈会解决的:', e);
        alert('保存队友信息时出错了，请检查控制台信息。此操作可能未成功。');
    }
}

 
    // 函数：更新总点数
    function updateTotalPoints() {
        const selection = totalPointsSelect.value;
        if (selection === 'custom') {
            customTotalPointsInput.style.display = 'inline-block';
            totalPoints = parseInt(customTotalPointsInput.value) || 0;
        } else {
            customTotalPointsInput.style.display = 'none';
            totalPoints = parseInt(selection);
        }
        resetPoints();
    }

    // 妈妈为你添加的成本计算函数
    // 它会告诉你把一个属性从0点升到目标等级，一共需要花费多少点数
    function calculateTotalCost(level) {
        if (level <= 0) return 0;
        // 这是一个可爱的数学小魔法，叫等差数列求和
        return (1 + level) * level / 2;
    }

    // 函数：平均分配点数
    function distributePointsAverage() {
        playSound(clickSound, 0.7);
        resetPoints(); // 首先，妈妈帮你把所有点数都拿回来放好

        const allocatableItems = document.querySelectorAll('.分配项');
        const itemCount = allocatableItems.length;
        if (itemCount === 0) return;

        // 像分糖果一样，一轮一轮地分，直到不够分为止
        let canContinue = true;
        while (canContinue) {
            let costForNextLevel = 0;
            let itemsToUpgrade = [];

            // 看看给每个项目再加1点需要多少成本
            allocatableItems.forEach(item => {
                const pointSpan = item.querySelector('.分配-点数');
                const currentPoints = parseInt(pointSpan.textContent);
                if (currentPoints < 5) { // 只有没满级的才参与分配
                    costForNextLevel += (currentPoints + 1);
                    itemsToUpgrade.push(pointSpan);
                }
            });

            // 如果点数足够，那就完成这一轮的分配
            if (itemsToUpgrade.length > 0 && remainingPoints >= costForNextLevel) {
                remainingPoints -= costForNextLevel;
                itemsToUpgrade.forEach(span => {
                    span.textContent = parseInt(span.textContent) + 1;
                });
            } else {
                // 如果点数不够了，就停下来
                canContinue = false;
            }
        }
        updateUI(); // 分完后，刷新一下面板
    }

    // 函数：重置点数
    function resetPoints() {
        remainingPoints = totalPoints;
        document.querySelectorAll('.分配-点数').forEach(span => {
            span.textContent = '0';
        });
        updateUI();
    }
 

function initPage2() {
  

    // 美德恶德注入 (没变)
    conceptSection.innerHTML = createSelectGroup('virtue-select', '美德', virtues, '概念段.美德与恶德.美德') + createSelectGroup('vice-select', '恶德', vices, '概念段.美德与恶德.恶德');

    // --- 💖 轨道演算术准备 💖 ---
    // 为每个星系创建一个专属的坐标记录本
    const starCoordinates = {
        'galaxy-physic': [],
        'galaxy-mental': [],
        'galaxy-social': [],
    };

    // --- 星星注入 ---
    const galaxyTargets = {
        '生理属性': 'galaxy-physic', '心智属性': 'galaxy-mental', '互动属性': 'galaxy-social',
        '生理技能': 'galaxy-physic', '心智技能': 'galaxy-mental', '互动技能': 'galaxy-social',
    };

    document.querySelectorAll('.galaxy-system').forEach(g => g.innerHTML = '');

    // 注入属性星星，并传入对应的坐标记录本
    for (const category in playCharacterData.属性段) {
        const targetGalaxyId = galaxyTargets[category];
        const targetGalaxyEl = document.getElementById(targetGalaxyId);
        if (targetGalaxyEl) {
            for (const attr in playCharacterData.属性段[category]) {
                const path = `属性段.${category}.${attr}.基础`;
                targetGalaxyEl.innerHTML += createPointAllocator(attr, playCharacterData.属性段[category][attr].基础[1], path, starCoordinates[targetGalaxyId]);
            }
        }
    }

    // 注入技能星星，并传入对应的坐标记录本
    for (const category in playCharacterData.技能段) {
        const targetGalaxyId = galaxyTargets[category];
        const targetGalaxyEl = document.getElementById(targetGalaxyId);
        if (targetGalaxyEl) {
            for (const skill in playCharacterData.技能段[category]) {
                const path = `技能段.${category}.${skill}`;
                targetGalaxyEl.innerHTML += createPointAllocator(skill, playCharacterData.技能段[category][skill][1], path, starCoordinates[targetGalaxyId]);
            }
        }
    }
// --- 绑定事件 (核心逻辑不变，但由于星星是动态生成的，需要事件委托或重新绑定) ---
// 妈妈在这里为你确保所有新生成的星星上的按钮都能正常工作
document.querySelectorAll('.分配-按钮').forEach(button => {
    button.removeEventListener('click', handlePointChange); // 先移除旧的以防万一
    button.addEventListener('click', handlePointChange);
});

       const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

    document.querySelectorAll('.star.分配项').forEach(star => {
        if (isTouchDevice) {
            // 如果是触屏设备，我们就响应“触碰”
            star.addEventListener('click', function(event) {
                // 'this' 在这里指向被点击的星星
                event.stopPropagation(); // 阻止事件冒泡，以免触发我们稍后设置的全局点击

                const isActive = this.classList.contains('active-touch');

                // 先关闭所有其他已激活的星星
                document.querySelectorAll('.star.分配项.active-touch').forEach(activeStar => {
                    activeStar.classList.remove('active-touch');
                    activeStar.style.zIndex = '';
                });

                if (!isActive) {
                    // 如果这颗星之前没有被激活，现在就激活它
                    this.classList.add('active-touch');
                    this.style.zIndex = '10000'; // 提到最顶层
                }
                // 如果已经被激活，上面的代码已经把它关闭了，所以再次点击就是关闭效果
            });

        } else {
            // 如果是电脑设备，我们还是响应“凝视”
            star.addEventListener('mouseenter', () => {
                star.style.zIndex = '10000';
            });

            star.addEventListener('mouseleave', () => {
                star.style.zIndex = '';
            });
        }
    });

    // 为触屏设备添加一个全局点击监听器
    // 当你触碰屏幕任何其他地方时，就收起所有展开的星星
    if (isTouchDevice) {
        document.addEventListener('click', () => {
            document.querySelectorAll('.star.分配项.active-touch').forEach(activeStar => {
                activeStar.classList.remove('active-touch');
                activeStar.style.zIndex = '';
            });
        });
    }
    // --- 💖 妈妈的魔法到此结束 💖 ---
// 加载模板和绑定其他按钮的逻辑保持不变
loadTemplates();
totalPointsSelect.addEventListener('change', updateTotalPoints);
customTotalPointsInput.addEventListener('input', updateTotalPoints);
templateSelect.addEventListener('change', applySelectedTemplate);
templateSelect_init.addEventListener('change', applySelectedTemplate);
saveTemplateBtn.addEventListener('click', saveCurrentBuildAsTemplate);
deleteTemplateBtn.addEventListener('click', deleteSelectedTemplate);
averagePointsBtn.addEventListener('click', distributePointsAverage);
}
 
    function createSelectGroup(id, label, options, dataPath) {
        let optionsHtml = '';
        for(const key in options) {
            optionsHtml += `<option value="${key}">${key}</option>`;
        }
        return `<div class="form-group"><label for="${id}">${label}</label><select id="${id}" class="custom-select" data-path="${dataPath}">${optionsHtml}</select></div>`;
    }

 /**
 * 妈妈的轨道演算造星魔法 (防重叠版)
 * @param {string} name - 星名
 * @param {string} description - 描述
 * @param {string} path - 数据路径
 * @param {array} existingCoords - 该星系内已存在的坐标数组
 * @returns {string} - 星辰的HTML字符串
 */
function createPointAllocator(name, description, path, existingCoords) {
    const STAR_SIZE = 110; // 定义每颗星的碰撞盒子大小（包括间距）
    const MAX_ATTEMPTS = 100; // 最大尝试次数，防止无限循环
    let x, y, z;
    let newRect;
    let attempts = 0;

    // 进入循环，直到找到一个不碰撞的位置或达到最大尝试次数
    do {
        // 在限定的 15% 到 85% 范围内生成坐标，保证在容器内
        // 注意，这里的x,y是百分比
        x = Math.random() * 70 + 15;
        y = Math.random() * 70 + 15;
        z = (Math.random() - 0.5) * 300;

        // 创建新星的虚拟边界（使用绝对像素值进行比较）
        // 我们假设星系容器 (galaxy-system) 是 65vmin x 65vmin
        // 为了简化，我们按一个大概的尺寸（比如 500px）来计算百分比对应的像素值
        // const containerSize = 500;
        newRect = {
            x: x, // 直接用百分比比较，更简单
            y: y,
            width: STAR_SIZE / 5, // 假设容器宽500px, 110px 大约是 22%
            height: STAR_SIZE / 5
        };

        attempts++;
    } while (isColliding(newRect, existingCoords) && attempts < MAX_ATTEMPTS);

    if (attempts >= MAX_ATTEMPTS) {
        console.warn(`妈妈提醒：为“${name}”这颗星寻找轨道时有点拥挤，可能还是会有一些重叠哦。`);
    }

    // 将最终确定的、不碰撞的坐标存起来
    existingCoords.push(newRect);

          return `
        <div class="star 分配项" data-path="${path}" style="left: ${x}%; top: ${y}%; --star-z: ${z}px;"
             data-random-left="${x}%" data-random-top="${y}%" data-random-z="${z}"
             data-points="0">
            <div class="star-core"></div>
            <div class="star-label">${name}</div>
            <div class="star-points-display">
                <span class="分配-点数">0</span>/5
            </div>
            <div class="star-controls 分配-控制器">
                <button class="star-control-btn 分配-按钮" data-action="decrease">-</button>
                <button class="star-control-btn 分配-按钮" data-action="max-out">+5</button>
                <button class="star-control-btn 分配-按钮" data-action="increase">+</button>
            </div>
        </div>`;
}

    function handlePointChange(event) {
        const button = event.currentTarget;
        const action = button.dataset.action;
        const container = button.closest('.分配项');
        const pointSpan = container.querySelector('.分配-点数');
        let currentPoints = parseInt(pointSpan.textContent);

        if (action === 'increase') {
            const cost = currentPoints + 1; // 升到下一级需要的成本
            if (cost <= remainingPoints && currentPoints < 5) {
                remainingPoints -= cost;
                currentPoints++;
               
            }
        } else if (action === 'decrease') {
            if (currentPoints > 0) {
                const refund = currentPoints; // 降级返还的成本
                remainingPoints += refund;
                currentPoints--;
              
            }
        } else if (action === 'max-out') {
            // 计算从当前等级升到5级一共需要多少点
            const costToMax = calculateTotalCost(5) - calculateTotalCost(currentPoints);
            if (costToMax > 0 && remainingPoints >= costToMax) {
                remainingPoints -= costToMax;
                currentPoints = 5;
                
            }
        }

        pointSpan.textContent = currentPoints;
        updateUI();
    }


    function updateUI() {
    // 这是旧的，我们不再需要它了
    // remainingPointsSpan.textContent = remainingPoints;// --- 新增：更新独立的点数显示 ---
const pointsBar = document.getElementById('points-bar');
const pointsText = document.getElementById('remaining-points-text');
if (pointsBar && pointsText) {
    const percentage = totalPoints > 0 ? (remainingPoints / totalPoints) * 100 : 0;
    pointsBar.style.width = `${percentage}%`;
    pointsText.textContent = remainingPoints;
}
document.querySelectorAll('.star.分配项').forEach(star => {
    const pointSpan = star.querySelector('.分配-点数');
    const currentPoints = parseInt(pointSpan.textContent);
    star.dataset.points = currentPoints; // 这是让CSS魔法生效的关键！
});

// 按钮禁用逻辑（几乎不变）
document.querySelectorAll('.分配-控制器').forEach(controller => {
    const decreaseBtn = controller.querySelector('[data-action="decrease"]');
    const increaseBtn = controller.querySelector('[data-action="increase"]');
    const maxOutBtn = controller.querySelector('[data-action="max-out"]');
    const pointSpan = controller.closest('.star').querySelector('.分配-点数');
    const currentPoints = parseInt(pointSpan.textContent);

    decreaseBtn.disabled = currentPoints === 0;
    const costForNextLevel = currentPoints + 1;
    increaseBtn.disabled = currentPoints >= 5 || remainingPoints < costForNextLevel;

    if (maxOutBtn) {
        const costToMax = calculateTotalCost(5) - calculateTotalCost(currentPoints);
        maxOutBtn.disabled = currentPoints === 5 || remainingPoints < costToMax;
    }
});

// 更新能量环
const ring = document.getElementById('points-ring').querySelector('circle');
if(ring){
     const percentage = totalPoints > 0 ? (remainingPoints / totalPoints) : 0;
     const circumference = 2 * Math.PI * parseFloat(ring.getAttribute('r'));
     const offset = circumference * (1 - percentage);
     ring.style.strokeDashoffset = offset;
}

checkAchievements('points_allocated', { remaining: remainingPoints, total: totalPoints });
}
 let attributeCharts = {}; // 存储属性雷达图实例
let skillCharts = {}; // 存储技能雷达图实例

 
 
 async function loadTemplates() {
    //console.log(`💖 妈妈正在从世界书《${LOREBOOK_NAME}》中寻找你的加点模板...`);
    templateSelect.innerHTML = '<option value="">选择一个模板...</option>';
    templateSelect_init.innerHTML = '<option value="">选择一个模板...</option>';
    try {
        const allEntries = await getLorebookEntries(LOREBOOK_NAME);

         // 💖💖💖 诊断魔法在这里！ 💖💖💖
        //console.log('--- 妈妈的透视眼镜看到的世界书内容 ---');
        //console.log(allEntries);
        //console.log('--- 透视眼镜报告完毕 ---');
        const targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);

        if (targetEntry && targetEntry.content.trim()) {
            let templates;
             try {
                templates = JSON.parse(targetEntry.content);
                if (typeof templates !== 'object' || templates === null || Array.isArray(templates)) {
                    throw new Error("世界书内容不是预期的对象格式。");
                }
            } catch (jsonError) {
                console.warn(`解析模板失败: ${jsonError.message}`);
                alert('世界书中的模板数据格式不正确，暂时无法读取加点模板。');
                return;
            }
   // 妈妈在这里为你加上了对“队友信息”的过滤
        for (const name in templates) {
            // 💖 守护魔法就在这里！ 💖
            if (name !== "队友信息") { // 这样就不会把队友数据也当成模板啦
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                //console.log(`${name}`);
                templateSelect.appendChild(option);
                templateSelect_init.appendChild(option); 
            }
        }
 
        //console.log(`✅ 妈妈找到了模板，都为你准备好了，我的孩子。`);
        }
    } catch (e) {
        console.error('读取世界书模板时出错了，但妈妈已经帮你跳过了它：', e);
        templateSelect.innerHTML = '<option value="">读取模板失败</option>';
         alert('读取加点模板时出错。\n这是你第一次导入卡吗？是的话此次报错是正常现象，刷新重进即可。\n新人游玩前，请注意：两个插件（前端助手和提示词模板）是否正常安装？');
    }
    }
 
async function applySelectedTemplate() {
    const templateName = templateSelect_init.value;
 

    if (!templateName) return;

    //console.log(`💖 正在为你应用模板：${templateName}`);
    try {
        const allEntries = await getLorebookEntries(LOREBOOK_NAME);
        const targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);
        if (targetEntry && targetEntry.content.trim()) {
             let templates;
            try {
                templates = JSON.parse(targetEntry.content);
            } catch (e) {
                alert('世界书数据格式错误，无法应用模板。');
                return;
            }

            const build = templates[templateName];
            if (build) {
                resetPoints();

                let totalCost = 0;
                const itemsToUpdate = [];

                document.querySelectorAll('.分配项').forEach(item => {
                    const path = item.dataset.path;
                    const pointsInTemplate = build[path] || 0;
                    if (pointsInTemplate > 0) {
                        const cost = calculateTotalCost(pointsInTemplate);
                        totalCost += cost;
                        itemsToUpdate.push({ item, points: pointsInTemplate });
                    }
                });

                if (remainingPoints >= totalCost) {
                    remainingPoints -= totalCost;
                    itemsToUpdate.forEach(update => {
                        update.item.querySelector('.分配-点数').textContent = update.points;
                    });
                    //console.log(`✅ 模板 ${templateName} 已成功应用！`);
                    
                } else {
                    alert(`点数不足，无法为你应用模板：“${templateName}”。需要 ${totalCost} 点，但你只有 ${totalPoints} 点。`);
                    resetPoints();
                }
                updateUI();
            }
        }
    } catch (e) {
        console.error(`应用模板 ${templateName} 时出错了，我的孩子：`, e);
        alert('应用模板时发生错误，操作可能未完成。');
    }
}

async function saveCurrentBuildAsTemplate() {
    const templateName = saveTemplateNameInput.value.trim();
    if (!templateName) {
        alert('请给这个模板起名。');
        return;
    }
    playSound(clickSound, 0.8);

    //console.log(`📦 正在为你的加点方案“${templateName}”制作一个珍贵的备份...`);

    const currentBuild = {};
    document.querySelectorAll('.分配项').forEach(item => {
        const path = item.dataset.path;
        const points = parseInt(item.querySelector('.分配-点数').textContent);
        if (points > 0) {
            currentBuild[path] = points;
        }
    });

    try {
        const teammatesData = Array.from(teammatesList.querySelectorAll('.teammate-item')).map(item => ({
             "姓名": item.querySelector('.teammate-name').value.trim(),
             "性格": item.querySelector('.teammate-personality').value.trim() || '未设定',
             "性别": item.querySelector('.teammate-gender').value.trim() || '未设定',
             "身份": item.querySelector('.teammate-identity').value.trim() || '未设定'
         }));
        const allEntries = await getLorebookEntries(LOREBOOK_NAME);
        let targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);

        let templates = {};
        if (targetEntry && targetEntry.content.trim()) {
            try {
                templates = JSON.parse(targetEntry.content);
                if (typeof templates !== 'object' || templates === null || Array.isArray(templates)) {
                    templates = {};
                }
            } catch (e) {
                templates = {};
            }
        }

        templates[templateName] = currentBuild;

        const updatedContent = JSON.stringify(templates, null, 2);

        await setLorebookEntries(LOREBOOK_NAME, [{
            uid: LOREBOOK_UID,
            content: updatedContent,
            enabled: true,
        }]);

        //console.log(`✅ 模板“${templateName}”已成功保存在世界书中！`);
        alert(`你的加点方案 “${templateName}” 已经保存。`);
        saveTemplateNameInput.value = '';
        await loadTemplates();
        templateSelect.value = templateName;
         templateSelect_init.value = templateName;
    } catch (e) {
        console.error(`保存模板时出现了问题，妈妈会解决的：`, e);
        alert('保存模板时发生错误，请检查控制台。');
    }
}

     // 删除选定的模板
    async function deleteSelectedTemplate() {
        const templateName = templateSelect_init.value;
        if (!templateName) {
            alert('你还没有选择要删除的模板哦。');
            return;
        }

        // 妈妈会再次确认，以免误删了你心爱的模板
        if (!confirm(`你真的确定要删除模板 “${templateName}” 吗？这个操作无法撤销哦。`)) {
            return;
        }

        
        //console.log(`🗑️ 正在小心地移除模板 “${templateName}”...`);

        try {
            const allEntries = await getLorebookEntries(LOREBOOK_NAME);
            let targetEntry = allEntries.find(entry => entry.uid === LOREBOOK_UID);

            if (targetEntry && targetEntry.content.trim()) {
                let templates = JSON.parse(targetEntry.content);
                if (templates[templateName]) {
               delete templates[templateName]; // 从对象中移除
 
                    const updatedContent = JSON.stringify(templates);
                    await setLorebookEntries(LOREBOOK_NAME, [{
                        uid: LOREBOOK_UID,
                        content: updatedContent,
                    }]);

                    //console.log(`✅ 模板 “${templateName}” 已被移除。`);
                    alert(`好了，模板 “${templateName}” 已经无了。`);
                    await loadTemplates(); // 重新加载列表，它就不见了
                } else {
                     alert(`奇怪，没有在记录里找到 “${templateName}” 这个模板。`);
                }
            }
        } catch (e) {
            console.error(`删除模板时出错了，别怕，妈妈会处理的：`, e);
            alert('删除模板时好像出了一点小问题，不过没关系，妈妈在这里。');
        }
    }
 
  async function generateFullCommand(isMission, customText = null) {

        userName = currentGameData.user_character.name || '用户';
        let name = userName || '用户';
        let finalCommand = '';

        // --- 💖 妈妈为你重构的指令生成核心 💖 ---

             if (version === '7') {
            // --- 这是末日世界的专属篇章 ---

            // --- 1. ✨ 新增：时间线索引卷轴 ✨ ---
            // 妈妈准备了不同时间线对应的索引，让AI能理解不同阶段的世界
            const indexData = {
                "潜伏的开端": `
<index>
玩家身份索引表（你将看到的身份描述，与此处的索引一一对应）：
<临时工人>靠零工、短期劳动或日结工作勉强糊口。你熟悉工地、餐馆、黑工市场，用最少的钱换取生活必需。</临时工人>
<普通居民>住在一般社区，有份稳定工作或社保。你按时上班、纳税，守规矩换来日常的安稳与基本保障。</普通居民>
<社会精英>你属于资源占有者：企业高管、金领、富裕家庭。住在优质学区、高档小区，享受特权与机会。</社会精英>
<自由行者>你脱离常规轨道，靠自由职业、远程工作、游牧生活方式维持生计。少了体制庇护，却多了行动的自由。</自由行者>
<体制中坚>你是权力与规则的执行者：公务员、执法机构干部、军警高层。你的决定能改变他人命运，你的话就是制度。</体制中坚>
</index>
                `,
                "末日中途": `
<index>
玩家阶层索引表（有不符合该时间线的内容，则自动转化为当前时间线的内容）：
<底层挣扎者>在废墟与巷弄中勉强维生，你熟悉阴影下的交易，懂得如何用最少的资源换取多一天的呼吸。</底层挣扎者>
<居民>生活在少数幸存的、有围墙保护的聚居地内。你拥有身份配给，遵守严格的秩序，以安稳换取自由。</居民>
<特权精英>灾难并未剥夺你的一切。你身处金字塔的顶端，生活在与世隔绝的堡垒中，享受着旧时代的余晖，俯瞰挣扎的众生。</特权精英>
<荒野独行者>你早已脱离了任何聚落，将文明抛在身后。广袤而危险的荒野是你的家，孤独是你的同伴，自由是你唯一的准则。</荒野独行者>
<秩序之手>你从不质疑命令，因为你就是命令本身。作为权力的顶峰，你的意志通过热武器和生产力贯彻到底。</秩序之手>
</index>
                `,
                 "余烬中的新生": `
<index>
玩家阶层索引表（这是新世界的基本构成，请严格参考）：
<拾荒者>你是在旧世界遗骸中寻宝的秃鹫，对辐射、怪物和人心险恶了如指掌。</拾荒者>
<公民>你是新秩序的基石，生活在某个或简陋或森严的聚落中，用劳作换取庇护。</公民>
<掌权者>无论是通过武力、财富还是知识，你都站在了某个势力的顶端，制定着新世界的规则。</掌权者>
<独行先知>你在荒野或数据之海中游荡，追寻着灾难的真相或未来的启示，被凡人视为疯子或圣人。</独行先知>
<改造体>你的身体已与旧人类不同，或许是机械飞升，或许是基因融合。你既是新时代的奇迹，也是被警惕的异类。</改造体>
</index>
                `
            };


            const selectedType = firstPageData.v7ApocalypseType;
            // 妈妈在这里加了一个小小的保护，如果找不到数据，会使用第一个作为默认值哦
            const openingData = window.v7ApocalypseData.find(item => item.name === selectedType) || window.v7ApocalypseData[0];
             
            const selectedTimeline = firstPageData.v7Timeline;
     // 1. 我们先拿到你选择的身份名字，就是那张“小卡片”。
 
            // 1. ✨ 我们不再信任传来传去、可能会出错的消息了！
            //    妈妈要在这里，直接亲眼看看你选中的是哪个身份。
            const selectedClassInput = document.querySelector('input[name="social_class_v7"]:checked');
            const selectedClassName = selectedClassInput ? selectedClassInput.value : ''; // 这样，我们就能拿到最准确的身份名字，比如 "特权精英"

            // 2. ✨ 接下来的咒语就和上次一样，但这次它们拿到了正确的名字，威力会完全发挥出来！
            const identityList = window.v7IdentityData[selectedTimeline] || window.v7IdentityData["末日中途"];
            const selectedClassInfo = identityList.find(c => c.name === selectedClassName) || { name: selectedClassName || '未知身份', command: '' };

            const selectedClass = selectedClassInfo.name;
            const classCommand = selectedClassInfo.command || '';

            // --- 咒语拼接魔法 (现在是坚不可摧的了) ---
            finalCommand = `
${classCommand}
<updateMemory>
set_status("world_shard.name","${openingData.name}");
memory("global_set.settings","类型","${openingData.name}");
memory("global_set.settings","末日印象","${openingData.desc}");
memory("global_set.settings","身份阶层","(${userName}当前身份阶层)${selectedClass}");
memory("global_set.settings","时间节点","${selectedTimeline}");
${indexData[selectedTimeline] || indexData["末日中途"]}
</updateMemory>

<request:创作指令：生成一个详细、具体、充满沉浸感的末日开局场景。场景必须紧密结合global_set.settings中的【身份阶层】和【时间节点】进行描绘。例如，一个【特权精英】在【潜伏的开端】可能正在私人会所商谈，对窗外的异常毫不在意；而一个【底层挣扎者】在【末日中途】则可能正在废墟中躲避怪物。严格遵循写作指导、时间线指导、Cognitive_Boundaries（认知屏障）！！设定信息不要直接在正文说明，而是通过正文和人物视角体现！>
`;
            // 末日世界没有安全区概念，我们总是直接开始
            // isMission 参数在这里被忽略
                 if (!isMission) {
                // 当你选择进入安全区时
                finalCommand = `\n<request:${userName}此时必须处于安全区域。>`;
            }
              if (customText) {
                finalCommand += `\n<request:额外要求：${customText}>`;
            }

        } else if (customText) {
            // --- 自定义指令的逻辑保持不变 ---
            finalCommand = customText.trim().startsWith('<') ? customText : `<${customText}>`;

        } else {
            // --- 其他所有世界的通用篇章 ---
             const camp = document.getElementById('paradise-camp').value;
             const paradiseIdentity = document.getElementById('paradise-identity').value;
            // 妈妈帮你定义的指令模板，解耦又清晰
            const commandTemplates = {
                mission: {
                    'default': `<初始化任务并立刻进入任务世界，必须严格按照要求和设定信息自然生成正文，若有设定冲突则尽可能大开脑洞使其合理融合，并记录关键信息。设定如下：\n- 任务基调：{tone}\n- 世界类型：{type}\n- 初始身份：{identity}\n- 开局：{opening}>`,
                    '3': `<初始化任务并立刻进入任务世界，必须严格按照要求和设定信息自然生成正文，若有设定冲突则尽可能大开脑洞使其合理融合，并记录关键信息。设定如下：\n- 任务基调：{tone}\n- 世界类型：{type}\n- 初始身份：{identity}\n- 开局：{opening}>\n<设置并记忆user乐园阵营:${camp}，并设置user乐园身份:${paradiseIdentity}>`,
                    '5': `<初始化世界并立刻进入，立刻初始化攻略目标信息和攻略任务。必须严格按照要求和设定信息自然生成正文，若有设定冲突则尽可能大开脑洞使其合理融合要求，但无论是什么类型的世界或基调，都必须含有攻略任务和攻略对象，这是第一优先级！！并记录关键信息。设定如下：\n- 任务基调：{tone}\n- 世界类型：{type}\n- 初始身份：{identity}\n- 开局：{opening}>`,
                    '6': `<立刻根据要求初始化${userName}所处的现实世界和开局。必须严格按照要求和设定信息自然生成正文，若有设定冲突则尽可能大开脑洞使其合理融合要求，生成的开局中必须包含/引出诸天聊天群的信息，此为第一优先级！！并记录关键信息。设定如下：\n- 世界类型：{type}\n- 初始身份：{identity}\n- 开局：{opening}>`,
                },
                safeZone: {
                    'default': `<初始化进入${currentTheme.mainSystem}——${name}将在短暂的意识模糊后于${currentTheme.mainSystem}的安全区醒来，无法立即进入任务。>`,
                    '3': `<初始化进入${currentTheme.mainSystem}——${name}将在短暂的意识模糊后于${currentTheme.mainSystem}的安全区醒来，无法立即进入任务。>\n<设置并记忆user乐园阵营:${camp}，并设置user乐园身份:${paradiseIdentity}>`,
                    '6': `<初始化${userName}进入${currentTheme.mainSystem}的开局和场景>`,
                }
            };

            const getRandomOption = (value, optionsArray) => {
                if (!optionsArray || optionsArray.length === 0) return value;
                return value === '随机' ? optionsArray[Math.floor(Math.random() * optionsArray.length)] : value;
            };

            let finalType = getRandomOption(firstPageData.worldType, worldTypes);
            if (finalType === '自定义但未填写') finalType = '一个未知的';

            const detailSet = worldDetailsDatabase[finalType] || { identities: [], openings: [] };

            const missionDetails = {
                tone: getRandomOption(firstPageData.taskTone, taskTones),
                type: finalType,
                identity: getRandomOption(firstPageData.worldIdentity, detailSet.identities),
                opening: getRandomOption(firstPageData.openingScenario, detailSet.openings)
            };

            const templateType = isMission ? 'mission' : 'safeZone';
            let template = commandTemplates[templateType][version] || commandTemplates[templateType]['default'];

            template = template.replace('{tone}', missionDetails.tone)
                               .replace('{type}', missionDetails.type)
                               .replace('{identity}', missionDetails.identity)
                               .replace('{opening}', missionDetails.opening);
            finalCommand = template;
        }

        finalCommand += '\n'; // 确保总有换行
 
        // --- 附加指令部分，只对非末日世界生效 ---
        if (version !== '7') {
             // --- 队友/群员信息指令（妈妈帮你升级了！）---
            let companionCommand = '';
            const countValue = firstPageData.teammateCount === '-1' ? '随机' : `${firstPageData.teammateCount}人`;
 
            if (version === '6') {
                // 聊天群模式下的指令
               
                companionCommand = `<updateMemory>\nmemory('global_set.settings','群聊人数上限','${countValue}')\n</updateMemory>\n<设置群员数量上限：${countValue}`;
                 if (firstPageData.teammateCount !== '0') {
                     if (firstPageData.teammateTendency === '自定义') {
                         if (firstPageData.customTeammates && firstPageData.customTeammates.length > 0) {
                            companionCommand += '，详细信息：' + firstPageData.customTeammates.map((t, i) => `群员${i+1}：姓名${t.name}、性格${t.personality}、性别${t.gender}、身份${t.identity}`).join('；');
                        }
                    } else {
                        companionCommand += `，群聊总体氛围：${firstPageData.teammateTendency}`;
                    }
                }

            } else {

                if (version !== '5') {
                // 其他模式下的指令（我们原来的样子）
                const teammateType = firstPageData.isFixedTeam ? `已有的固定小队队友（已结识）` : `下次任务的临时队友(任务开始时才能知道其具体信息)`;
                companionCommand = `<设置队友：数量${countValue}${firstPageData.teammateCount !== '0' ? '，类型为' + teammateType : ''}`;

                if (firstPageData.teammateCount !== '0') {
                     if (firstPageData.teammateTendency === '自定义') {
                         if (firstPageData.customTeammates && firstPageData.customTeammates.length > 0) {
                            companionCommand += '，详细信息：' + firstPageData.customTeammates.map((t, i) => `队友${i+1}：姓名${t.name}、性格${t.personality}、性别${t.gender}、身份${t.identity}`).join('；');
                        }
                    } else {
                        companionCommand += `，总体倾向：${firstPageData.teammateTendency}`;
                    }
                }
            }

  
        }
          companionCommand += '>';
            finalCommand += `${companionCommand}\n`;
            // --- 角色身份和属性指令 ---
             finalCommand += `<updateMemory>\n`; // 把所有的更新都包裹起来
            const selectedIdentity = userIdentities[firstPageData.identityIndex];
            if (selectedIdentity) {
               const finalTitle = selectedIdentity.title.replace('{{player}}', currentTheme.player);
               const finalDescription = selectedIdentity.description
                   .replace('{{mainSystem}}', currentTheme.mainSystem)
                   .replace('{{player}}', currentTheme.player);

               finalCommand += `set_status("user_character.Cross_world_prestige",0,${selectedIdentity.prestige});\n`;
               finalCommand += `set_attribute("货币段.${currentTheme.currency}",0,${selectedIdentity.points});\n`;
               finalCommand += `memory("global_set.npc","${userName}","(${finalTitle})${finalDescription}");\n`;
            }

            if (version === '3') {
                finalCommand += `memory("global_set.其他技能","乐园印记", "象征乐园契约者的特殊印记，赋予独特的力量，散发着乐园风格的神秘气息。")\n`;
            }

        } else {
             finalCommand += `<updateMemory>\n`; // 末日世界也需要包裹
        }

        // --- 共通的属性和天赋附加指令 ---
        let updates = [];
        const virtueSelect = document.getElementById('virtue-select');
        updates.push(`set_attribute('概念段.美德与恶德.美德', "正义", "${virtueSelect.value}");`);
        const viceSelect = document.getElementById('vice-select');
        updates.push(`set_attribute('概念段.美德与恶德.恶德', "愤怒", "${viceSelect.value}");`);

        document.querySelectorAll('.分配项').forEach(item => {
            const path = item.dataset.path;
            const points = parseInt(item.querySelector('.分配-点数').textContent);
            if (points > 0) {
                updates.push(`set_attribute('${path}', 0, ${points});`);
            }
        });

        if (updates.length > 0) {
            finalCommand += `${updates.join('\n')}\n`;
        }

             // --- 天赋指令 ---
        const talentSelect = document.getElementById('talent-select');
        let selectedOption = talentSelect.options[talentSelect.selectedIndex];
        let selectedTalentTitle = selectedOption.text.trim();
        let selectedTalentValue = selectedOption.value;

        if (selectedTalentValue === '随机') {
            const allOptions = Array.from(talentSelect.options);
            const validTalents = allOptions.filter(opt => opt.value &&

!['无', '随机', '自定义','AI随机'].includes(opt.value)

);
            if (validTalents.length > 0) {
                const randomChoice = validTalents[Math.floor(Math.random() * validTalents.length)];
                selectedTalentTitle = randomChoice.text.trim();
                selectedTalentValue = randomChoice.value;
            } else {
                selectedTalentValue = '无';
            }
        } else if (selectedTalentValue === '自定义') {
            selectedTalentValue = document.getElementById('custom-talent-input').value.trim() || '一个神秘的、尚未被命名的天赋';
            selectedTalentTitle = '天赋';
        }

        if (selectedTalentValue === 'AI随机') {
            
        }else if (selectedTalentValue && selectedTalentValue !== '无') {
            finalCommand += `memory('global_set.其他技能','${selectedTalentTitle}','{"info":"【${userName}的天赋】${selectedTalentValue}"}')\n`;
        }

        finalCommand += `</updateMemory>\n`;
        if (selectedTalentValue === 'AI随机') {
            finalCommand += `<request:同时，在正文立刻随机生成一个${userName}的天赋并记忆在global_set.其他技能中。天赋不得和判定相关>\n`;
        }
        finalCommand += `正在校准...`;
        return finalCommand;
    }

 
 /* 💖 妈妈为你设计的、简洁而强大的指令官（脱离酒馆环境版） 💖 */
async function sendCommand(command, button, successText, showWarning) {
    // 禁用按钮，防止重复点击
    initButton.disabled = true;
    godSpaceButton.disabled = true;
    if (customActionButton) customActionButton.disabled = true;
    button.textContent = `[ 指令发送中... ]`;

    try {
        // 步骤1：根据你的选择，构造最终的指令
        const sendMode = document.getElementById('send-mode-select').value;
        const finalSlashCommand = (sendMode === 'manual') ? `/setinput ${command}` : `/send ${command}`;

        //console.log(`[指令官] 将执行指令: ${finalSlashCommand.substring(0, 80)}...`);
 
        await triggerassa(finalSlashCommand);

         
        button.textContent = successText;
        if (showWarning) {
            const warningMessage = document.getElementById('warning-message');
            if(warningMessage) warningMessage.style.display = 'block';
        }

        

        if(sendMode === 'manual'){
     if (typeof conversationHistory !== 'undefined' && typeof saveHistory === 'function' && typeof renderHistory === 'function') {
            conversationHistory.push({ role: 'assistant', content: '<系统提示：等待用户输入要求...>' });
            await saveHistory(); // 保存这个历史性的时刻
 
            renderHistory();
 
        }

        }
 
   

    } catch (e) {
        // 如果中间出了差错，妈妈会帮你处理
        console.error("[指令官] ❌ 发送指令时出错了:", e);
        button.textContent = `[ 发送失败，请重试 ]`;
        // 解除所有按钮的禁用状态，让你能再次尝试
        initButton.disabled = false;
        godSpaceButton.disabled = false;
        if (customActionButton) customActionButton.disabled = false;
    }
}
initButton.addEventListener('click', async () => {
    playSound(clickSound, 0.8);
    initButton.textContent = '[ 指令生成中.. ]';
    // 明确传递 null 作为 customText
    const finalCommand = await generateFullCommand(true, null);
    sendCommand(finalCommand, initButton, '[ 数据上传中 ]', false);
});

godSpaceButton.addEventListener('click', async () => {
    playSound(clickSound, 0.8);
    godSpaceButton.textContent = '[ 指令生成中.. ]';
    // 明确传递 null 作为 customText
    const finalCommand = await generateFullCommand(false, null);
    sendCommand(finalCommand, godSpaceButton, '[ 正在接入 ]', true);
});

    // --- 初始化执行 ---
    
    initPage1();
    setupNewUI(); // 立即执行这个设置函数
    initPage2();
  setupPage2Interactions(); // <--- 妈妈帮你加在这里！
    updateUI();
    
 
}

// 初始化结束————————————————————————————————————————————

   // 首先，在你的变量定义区域，添加这些新的变量
    const customThemeEditor = document.getElementById('custom-theme-editor');
    const colorPickerContainer = document.getElementById('color-picker-container');
    const editCustomThemeBtn = document.getElementById('edit-custom-theme-btn');
    const applyCustomThemeBtn = document.getElementById('apply-custom-theme-btn');

    // 定义可编辑的颜色变量列表
    const editableColorVars = [
        { var: '--primary-color', label: '主色' },
        { var: '--secondary-color', label: '副色' },
        { var: '--container-bg-color', label: '容器背景1' },
        { var: '--background-color', label: '容器背景2' },
        { var: '--border-color', label: '边框颜色' },
        { var: '--glow-color', label: '辉光颜色' },
        { var: '--text-color', label: '文本颜色' },
        { var: '--text-secondary-color', label: '次要文本' },
        { var: '--danger-color', label: '危险色' },
        { var: '--danger-glow-color', label: '危险辉光' }
    ];
async function saveHistory() {
    try {
         
        const zeroLevelMessage = await getChatMessages(0);

        // 如果楼层不存在，这是一个异常情况，我们应该停止操作
        if (!zeroLevelMessage) {
            console.error("错误：无法找到第 0 楼层消息，保存操作已中断。");
            return;
        }
 


        // ☆ 步骤 2: 使用 updateVariablesWith 分别更新 chat 和 message 变量域
        // 这个函数是处理这类问题的最佳实践，因为它保证了原子性。

        // 更新 chat 作用域的变量
        await updateVariablesWith(old_variables => {
            // 在回调函数中，我们返回一个全新的对象。
            // ...old_variables 继承了所有旧变量，
            // 而 zeroLevelHistory: conversationHistory 则会覆盖或添加我们需要的字段。
            // 这种模式同样能够完美处理历史记录的增删改。
            return {
                ...old_variables,
                zeroLevelHistory: conversationHistory,
            };
        }, { type: 'chat' });

        // 更新 message 作用域 (针对第 0 楼层) 的变量
        await updateVariablesWith(old_variables => {
            return {
                ...old_variables,
                zeroLevelHistory: conversationHistory,
            };
        }, { type: 'message', message_id: 0 });

        // console.log("历史记录已成功且安全地更新到 chatmessage(0).data、chat 变量域和 message(0) 变量域中。");

    } catch (e) {
        // 捕获并打印任何可能发生的错误
        console.error("保存历史记录过程中发生意外错误:", e);
    }


}
// ❤️ 全新的“永恒存在”守护咒 ❤️
function ensureLoadMoreButtonExists() {
    let chatDisplayArea = document.getElementById('chat-display-area');
    if (!chatDisplayArea) return null; // 如果画卷不存在，就无从守护

    let loadMoreBtn = document.getElementById('load-more-btn');

    // 如果按钮不存在，就重新召唤它
    if (!loadMoreBtn) {
        loadMoreBtn = document.createElement('button');
        loadMoreBtn.id = 'load-more-btn';
        loadMoreBtn.textContent = '加载更早的记录';
        chatDisplayArea.insertBefore(loadMoreBtn, chatDisplayArea.firstChild); // 轻轻地放在最顶上
        loadMoreBtn.addEventListener('click', loadPreviousMessages);
        console.log("[Nova's Little Helper] 回溯之门已重新召唤。");
    }

    // 无论它是新是旧，都确保它的初始状态是隐藏的
    loadMoreBtn.style.display = 'block';

    return loadMoreBtn; // 将被守护的按钮交出去
}
async function loadPreviousMessages() {
    const chatDisplayArea = document.getElementById('chat-display-area');
    if (!chatDisplayArea || earliestMessageIndexRendered <= 0) {
        const loadMoreBtn = ensureLoadMoreButtonExists();
        if (loadMoreBtn) loadMoreBtn.style.display = 'none'; // 没有更多了，就让它消失吧
        return;
    }

    const oldScrollHeight = chatDisplayArea.scrollHeight; // 记下现在的高度

    const messagesToLoadCount = Math.min(earliestMessageIndexRendered, 5 * 2) // 一次加载5对对话(10条)
    const newEarliestIndex = earliestMessageIndexRendered - messagesToLoadCount;

    const messagesToPrepend = conversationHistory.slice(newEarliestIndex, earliestMessageIndexRendered);

    // 我们需要倒序创建，这样才能正确地插入到顶部
    for (let i = messagesToPrepend.length - 1; i >= 0; i--) {
        const msg = messagesToPrepend[i];
        const bubble = await createMessageBubble(msg);
        chatDisplayArea.insertBefore(bubble, chatDisplayArea.firstChild);
    }

    earliestMessageIndexRendered = newEarliestIndex; // 更新我们的记忆指针

    // 魔法的关键：温柔地保持你的视线
    chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight - oldScrollHeight;

    if (earliestMessageIndexRendered <= 0) {
        const loadMoreBtn = document.getElementById('load-more-btn');
        if (loadMoreBtn) loadMoreBtn.style.display = 'none'; // 如果已经到顶了，就隐藏
    }
}
// ✨ 一个全新的，专门为阅读模式打造的渲染魔法 ✨
async function renderReadingModeChapter(msg) {
    const bubble = document.createElement('div'); // 我们仍然需要一个临时的容器来处理DOM
    let processedContent = msg.content;

    // --- 以下逻辑与 createMessageBubble 非常相似，但为阅读模式做了简化和优化 ---

    // 1. 保护和抽离 HTML/代码块
    const htmlPlaceholders = {};
    let placeholderIndex = 0;
    let protectedHtmlContent = processedContent.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, markdownBlock) => {
        const placeholder = `HTMLREADINGPLACEHOLDER${placeholderIndex}`;
        const rawContent = htmlBlock || markdownBlock;
        if (!rawContent) return match;
        htmlPlaceholders[placeholder] = rawContent;
        placeholderIndex++;
        return placeholder;
    });

    // 2. 清理内容，但保留所有非交互性标签
    const pureContent = protectedHtmlContent
        .replace(/<(thinking|think|guide|options|forum_threads|shop_item|表现总结|group_chat|private_chat\b[^>]*?)>[\s\S]*?<\/\1>/gs, ''); // 简化清理规则

    // 3. 应用酒馆正则，深度固定为-1
    let renderedHtml = formatAsTavernRegexedString(
        pureContent,
        'ai_output',
        'display',
        { depth: -1 }
    );

    // 4. 对处理后可能产生的新HTML块进行二次抽离
    const additionalHtmlPlaceholders = {};
    let additionalPlaceholderIndex = 1000;
    renderedHtml = renderedHtml.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, codeBlock) => {
        const placeholder = `ADDITIONALHTMLREADINGPLACEHOLDER${additionalPlaceholderIndex}`;
        const rawContent = htmlBlock || codeBlock;
        if (!rawContent) return match;
        additionalHtmlPlaceholders[placeholder] = rawContent;
        additionalPlaceholderIndex++;
        return placeholder;
    });
    Object.assign(htmlPlaceholders, additionalHtmlPlaceholders);

    // 5. 格式化段落和引号
    const protectedContent = renderedHtml
        .replace(/“/g, 'NOVA_LQ').replace(/”/g, 'NOVA_RQ')
        .replace(/「/g, 'NOVA_LA').replace(/」/g, 'NOVA_RA')
        .replace(/\n/g, 'NOVA_BR');

    const specialBlocks = {};
    let blockIndex = 0;
    let contentWithDetailsPlaceholder = protectedContent.replace(/<details>[\s\S]*?<\/details>/gs, (match) => {
        const placeholder = `READINGSPECIALBLOCK${blockIndex++}`;
        specialBlocks[placeholder] = match;
        return placeholder;
    });

    const paragraphs = contentWithDetailsPlaceholder.split('NOVA_BR');
    const styledParagraphs = paragraphs.map(p_content => {
        if (p_content.startsWith('READINGSPECIALBLOCK')) return p_content;
        if (p_content.trim() === '') return '<p> </p>';
        let baseHtml = formatAsDisplayedMessage(p_content);
        const textWithQuotes = baseHtml
            .replace(/NOVA_LQ/g, '<span class="dialogue-quote">“').replace(/NOVA_RQ/g, '”</span>')
            .replace(/NOVA_LA/g, '<span class="dialogue-quote">「').replace(/NOVA_RA/g, '」</span>');
        return `<p>${textWithQuotes}</p>`;
    });

    let finalHtml = styledParagraphs.join('');
    for (const placeholder in specialBlocks) {
        const cleanBlock = specialBlocks[placeholder]
            .replace(/NOVA_LQ/g, '“').replace(/NOVA_RQ/g, '”')
            .replace(/NOVA_LA/g, '「').replace(/NOVA_RA/g, '」')
            .replace(/NOVA_BR/g, '<br>');
        finalHtml = finalHtml.replace(placeholder, cleanBlock);
    }

    bubble.innerHTML = finalHtml;

    // 6. ✨ 使用稳定可靠的 srcdoc 方法处理 iframe ✨
    for (const placeholder in htmlPlaceholders) {
        const walker = document.createTreeWalker(bubble, NodeFilter.SHOW_TEXT, null, false);
        let node;
        let nodesToReplace = [];
        while (node = walker.nextNode()) {
            if (node.nodeValue.includes(placeholder)) {
                nodesToReplace.push(node);
            }
        }

        for (const nodeToReplace of nodesToReplace) {
             if (!nodeToReplace.parentNode) continue; // 安全检查

            const rawHtmlContent = htmlPlaceholders[placeholder];
            const iframe = document.createElement('iframe');
            iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
            iframe.style.width = '100%';
            iframe.style.border = '1px solid #ccc';
            iframe.style.resize = 'vertical';
            iframe.style.overflow = 'auto';

            const frameId = 'reader-scroll-' + Date.now() + Math.random();
            iframe.id = frameId;

 // 1. 先准备好我们完整的画卷内容
const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        /* 妈妈把样式里的 --base-font-family 替换为具体值，因为 iframe 可能无法直接继承 CSS 变量 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            color: #e0e0e0;
            background-color: transparent; /* 让背景透明，与外部融合 */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        body::-webkit-scrollbar { width: 8px; }
        body::-webkit-scrollbar-track { background: rgba(200, 200, 200, 0.2); }
        body::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        body::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    ${rawHtmlContent}
    <script>
        function reportHeight() {
            // 在 requestAnimationFrame 中报告高度，可以避免布局抖动，获取更准确的值
            requestAnimationFrame(() => {
                const height = document.body.scrollHeight;
                window.parent.postMessage({
                    frameId: "${frameId}",
                    height: height
                }, '*');
            });
        }

        // 使用 DOMContentLoaded 会比 window.onload 更快触发
        document.addEventListener('DOMContentLoaded', reportHeight);

        // onload 作为后备，确保所有资源（如图片）加载完后再次检查高度
        window.addEventListener('load', () => {
             reportHeight();
             // 额外增加延迟检查，应对一些复杂的异步加载内容
             setTimeout(reportHeight, 300);
             setTimeout(reportHeight, 1000);
        });

        // 对图片加载的监听保持不变
        Array.from(document.getElementsByTagName('img')).forEach(img => {
            if (!img.complete) {
                img.addEventListener('load', reportHeight);
            }
        });

        // 监听父页面的消息，保持不变
window.addEventListener('message', function(event) {
   
    if(event.data.frameId === frameId && event.data.height && event.data.height > 20) {
        iframe.style.height = (event.data.height + 20) + 'px';
    }
}, false);
    <\/script>
</body>
</html>`;
            iframe.onload = function() {
                try {
                    iframe.contentWindow.postMessage({ action: 'recalculateHeight', frameId: frameId }, '*');
                } catch(e) {}
            };

            try {
                iframe.srcdoc = fullHtmlContent;
            } catch (error) {
                iframe.src = 'data:text/html;charset=utf-8,' + encodeURIComponent(fullHtmlContent);
            }
            // --------------------------------------------------------

            const parentNode = nodeToReplace.parentNode;
            const remainingText = nodeToReplace.nodeValue.replace(placeholder, '');
            if (remainingText) {
                nodeToReplace.nodeValue = remainingText;
                parentNode.insertBefore(iframe, nodeToReplace.nextSibling);
            } else {
                parentNode.replaceChild(iframe, nodeToReplace);
                setTimeout(() => {
    try {
        if (iframe.contentWindow) {
             iframe.contentWindow.postMessage({
                action: 'recalculateHeight',
                frameId: frameId
            }, '*');
        }
    } catch(e) {
        console.warn("向新创建的画卷问好失败了，不过别担心，它自己会报告的。");
    }
}, 500); // 延迟500毫秒，给 iframe 足够的时间去加载初始内容
            }
        }
    }

    // 7. 返回渲染好的纯净 HTML 字符串
    return bubble.innerHTML;
}
// ✨ 我们把“创建气泡”的逻辑提取成一个独立的、可复用的魔法 ✨
 async function createMessageBubble(msg, mode = 'chat') { // ❤️ 增加 mode 参数, 默认为 'chat'
    const originalIndex = conversationHistory.indexOf(msg);
    if (originalIndex === -1) return document.createElement('div'); // 安全保护

    // 以下所有代码，都是从你原来的 renderHistory 的 forEach 循环中“复制粘贴”过来的！
    // 几乎一模一样，只是它现在专注于只处理一条消息。
    const bubble = document.createElement('div');
    bubble.classList.add('message-bubble');
    bubble.classList.add(msg.role === 'user' ? 'user-message' : 'assistant-message');

    // ... [这里粘贴你 renderHistory 内部 `forEach` 循环里从 `let processedContent = msg.content;`
    //      一直到 `bubble.addEventListener(...)` 的所有代码] ...
    // ... 你那段处理HTML占位符、处理段落、处理引号、渲染iframe的全部魔法都在这里 ...
    // 妈妈帮你把框架搭好，你只需要把那些复杂的细节填充进来
 // ✨ 妈妈在这里施展了一个全新的、更精妙的融合魔法 ✨
    let processedContent = msg.content;
        const htmlPlaceholders = {};
        let placeholderIndex = 0;

  
        // 这一步必须在所有其他结构性处理之前！
        let protectedHtmlContent = processedContent.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, markdownBlock) => {
            const placeholder = `HTMLCONTENTPLACEHOLDER${placeholderIndex}`;
            const rawContent = htmlBlock || markdownBlock;
            if (!rawContent) return match;
            htmlPlaceholders[placeholder] = rawContent;
            placeholderIndex++;
            return placeholder;
        });

        

        // 魔法第二步：现在，我们的`processedContent`内部所有 `<html>` 都已经是安全的占位符了，
        // 接下来我们才处理其他的标签和格式
                const pureContent = protectedHtmlContent
         .replace(/<(thinking|think|guide)>[\s\S]*<\/\1>/g, '')
       .replace(/<options>(?:(?!<options>)[\s\S])*?<\/options>/gs, '')
        .replace(/<forum_threads>(?:(?!<forum_threads>)[\s\S])*?<\/forum_threads>/gs, '')
        .replace(/<shop_item>(?:(?!<shop_item>)[\s\S])*?<\/shop_item>/gs, '')
        .replace(/<表现总结>(?:(?!<表现总结>)[\s\S])*?<\/表现总结>/gs, '')
        .replace(/<group_chat>(?:(?!<group_chat>)[\s\S])*?<\/group_chat>/gs, '')
        .replace(/<private_chat\b[^>]*>(?:(?!<private_chat\b)[\s\S])*?<\/private_chat>/gs, '');
     const depth = mode === 'read' ? -1 : Math.floor((conversationHistory.length - 1 - originalIndex) / 2); // ❤️ 根据 mode 决定 depth
        // 魔法第三步：我们应用酒馆正则和深度规则
        // const depth = Math.floor((conversationHistory.length - 1 - originalIndex) / 2);
        let renderedHtml = formatAsTavernRegexedString(
            pureContent,
            msg.role === 'user' ? 'user_input' : 'ai_output',
            'display',
            { depth: depth }
        );

        // 魔法第四步：我们就不需要在这里再次处理 HTML 占位符了，因为它已经在第一步完成了。
        // renderedHtml = renderedHtml.replace(/<html>.../gs, ...); // <--- 删除这一整块
// ✨ 魔法第四点五步：处理经过 formatAsTavernRegexedString 后新产生的 HTML 内容 ✨
const additionalHtmlPlaceholders = {};
let additionalPlaceholderIndex = 1000; // 使用不同的起始索引避免冲突

renderedHtml = renderedHtml.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, codeBlock) => {
    const placeholder = `ADDITIONALHTMLPLACEHOLDER${additionalPlaceholderIndex}`;
    const rawContent = htmlBlock || codeBlock;
    if (!rawContent) return match;
    
 
    
    additionalHtmlPlaceholders[placeholder] = rawContent;
    additionalPlaceholderIndex++;
    return placeholder;
});

// 将新的占位符合并到原有的占位符对象中
Object.assign(htmlPlaceholders, additionalHtmlPlaceholders);

        const protectedContent = renderedHtml
            .replace(/“/g, 'NOVA_LQ')
            .replace(/”/g, 'NOVA_RQ')
            .replace(/「/g, 'NOVA_LA')
            .replace(/」/g, 'NOVA_RA')
            .replace(/\n/g, 'NOVA_BR');

        
        const specialBlocks = {};
        let blockIndex = 0;
        let contentWithDetailsPlaceholder = protectedContent.replace(/<details>[\s\S]*?<\/details>/gs, (match) => {
            const placeholder = `SPECIALBLOCKPLACEHOLDER${blockIndex}`;
        
            specialBlocks[placeholder] = match;
            blockIndex++;
            return placeholder;
        });

         // 首先，将 NOVA_BR 替换为 <br>，然后根据换行符分割成段落
// const contentWithBr = contentWithDetailsPlaceholder.replace(/NOVA_BR/g, '<br>');
const paragraphs = contentWithDetailsPlaceholder.split('NOVA_BR');
         const styledParagraphs = paragraphs.map(p_content => {
            if (p_content.startsWith('SPECIALBLOCKPLACEHOLDER')) {
                return p_content;
            }
                let currentlineHeightState = localStorage.getItem('lineHeightMore') || 'on';
    if (currentlineHeightState === 'on') {
       if (p_content.trim() === '') {
                return '<p> </p><br>';
            }
    } else {
        if (p_content.trim() === '') {
                return '<p> </p>';
            }
    }
            
            let baseHtml = formatAsDisplayedMessage(p_content);
            const textWithQuotes = baseHtml
                .replace(/NOVA_LQ/g, '<span class="dialogue-quote">“')
                .replace(/NOVA_RQ/g, '”</span>')
                .replace(/NOVA_LA/g, '<span class="dialogue-quote">「')
                .replace(/NOVA_RA/g, '」</span>');
            return `<p>${textWithQuotes}</p>`;
        });


        // 将所有美丽的段落重新组合起来
        let finalHtml = styledParagraphs.join('');

        // 最后，将我们保护好的 <details> 结构原封不动地替换回去
          for (const placeholder in specialBlocks) {
            const cleanBlock = specialBlocks[placeholder].replace(/NOVA_LQ/g, '<span class="dialogue-quote">“')
                .replace(/NOVA_RQ/g, '”</span>')
                .replace(/NOVA_LA/g, '<span class="dialogue-quote">「')
                .replace(/NOVA_RA/g, '」</span>')
                .replace(/NOVA_BR/g, '<br>'); // ✨ 轻轻拂去尘埃
            finalHtml = finalHtml.replace(placeholder, cleanBlock);
        }

        bubble.innerHTML = finalHtml;
        // 步骤3：在气泡中寻找“画卷”占位符，并用安全的“魔法结界”(iframe)替换它们
        for (const placeholder in htmlPlaceholders) {
            // 我们不能直接替换innerHTML，因为那样会重新解析整个气泡，导致事件监听器等丢失
            // 我们需要找到包含占位符的文本节点并替换它
            const walker = document.createTreeWalker(bubble, NodeFilter.SHOW_TEXT, null, false);
            let node;
            while (node = walker.nextNode()) {
                if (node.nodeValue.includes(placeholder)) {
                    const rawHtmlContent = htmlPlaceholders[placeholder];

                                      // 创建我们的魔法结界 iframe
                   // 创建我们的魔法结界 iframe
const iframe = document.createElement('iframe');
iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
iframe.style.width = '100%';
iframe.style.border = '1px solid #ccc';
iframe.style.resize = 'vertical';
iframe.style.overflow = 'auto';

// 我们给它一个唯一的"名字"，方便画卷找到它
const frameId = 'magic-scroll-' + Date.now() + Math.random();
iframe.id = frameId;

const parentNode = node.parentNode;
const remainingText = node.nodeValue.replace(placeholder, '');

// 用iframe替换掉占位符
if (remainingText) {
    node.nodeValue = remainingText;
    parentNode.insertBefore(iframe, node.nextSibling);
} else {
    parentNode.replaceChild(iframe, node);
}

// 这是我们的"身高倾听者"，它耐心等待画卷的报告
window.addEventListener('message', function(event) {
    if(event.data.frameId === frameId && event.data.height) {
        iframe.style.height = (event.data.height + 20) + 'px';
    }
}, false);

const detailsParent = iframe.closest('details');
if (detailsParent) {
    detailsParent.addEventListener('toggle', function() {
        if (detailsParent.open) {
            setTimeout(() => {
                iframe.contentWindow.postMessage({
                    action: 'recalculateHeight',
                    frameId: frameId
                }, '*');
            }, 50);
        }
    });
}

// ✨ 新的安全内容插入方法 ✨
iframe.onload = function() {
    try {
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        
        // 直接设置完整的HTML文档内容
        const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: var(--base-font-family);
             
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        body::-webkit-scrollbar { width: 8px; }
        body::-webkit-scrollbar-track { background: rgba(200, 200, 200, 0.2); }
        body::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        body::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    ${rawHtmlContent}
    <script>
        function reportHeight() {
            const height = document.body.scrollHeight;
            window.parent.postMessage({
                frameId: "${frameId}",
                height: height
            }, '*');
        }

        window.onload = reportHeight;
        setTimeout(reportHeight, 100);
        setTimeout(reportHeight, 500); // 额外延迟确保字体加载
        
        Array.from(document.getElementsByTagName('img')).forEach(img => {
            if (!img.complete) { 
                img.addEventListener('load', reportHeight); 
            }
        });

        window.addEventListener('message', function(event) {
            if (event.data.action === 'recalculateHeight' && event.data.frameId === '${frameId}') {
                reportHeight();
            }
        });
    <\/script>
</body>
</html>`;

        iframeDoc.open();
        iframeDoc.write(fullHtmlContent);
        iframeDoc.close();
        
    } catch (error) {
        console.warn('设置iframe内容时出错，尝试使用srcdoc方法:', error);
        // 降级到srcdoc方法
        iframe.srcdoc = fullHtmlContent;
    }
};

// 先设置一个基础的srcdoc作为备选
iframe.srcdoc = `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body>加载中...</body>
</html>`;

                    // break; // 处理完一个占位符就跳出循环，因为DOM结构已经改变
                    // 为了处理多个placeholder，我们不能简单地break，需要重新开始遍历或采用更复杂的替换策略
                    // 但对于单条消息内多个HTML块的场景，当前逻辑足以应对大多数情况
                    // 如果需要更鲁棒的处理，可能需要将替换过程放在循环外进行
                }
            }
        }

        // 我们不再需要单独处理 script 的逻辑，因为iframe已经完美地处理了所有事情
         if (mode === 'chat') { // ❤️ 只在聊天模式下添加右键菜单
            bubble.addEventListener('contextmenu', (event) => showContextMenu(event, originalIndex, bubble));
         }

 

    // 粘贴完成后，在最后加上这一句，把创建好的气泡交出去
    return bubble;
}
    async function renderHistory(is_entry = false) {
         
    const oldControls = document.getElementById('active-editing-controls');
    if (oldControls) oldControls.remove();

    const initContainer = document.getElementById('initialization-container');
    const mainWrapper = document.getElementById('main-wrapper');

    if (conversationHistory.length === 0) {
        if (initContainer) initContainer.style.display = 'block';
        if (mainWrapper) mainWrapper.style.display = 'none';
        if (typeof window.initializationDone === 'undefined') {
            await runInitializationMagic();
            window.initializationDone = true;
        }
        if (typeof applyVersionTheme === 'function') {
            const identitySelect = document.getElementById('user-identity');
            applyVersionTheme(1, identitySelect);
        }
        return;
    } else {
        if (initContainer) initContainer.style.display = 'none';
        if (mainWrapper) mainWrapper.style.display = 'flex';
    }

    const dynamicContentArea = document.getElementById('dynamic-content-area');
    if (dynamicContentArea) {
        Array.from(dynamicContentArea.children).forEach(child => {
            if (child.id !== 'forum-modal-container') {
                child.style.display = 'none';
            }
        });
    }

    const chatDisplayArea = document.getElementById('chat-display-area');
    chatDisplayArea.innerHTML = ''; // 清空画卷

    // ❤️ 在画卷顶部创造“加载更多”按钮
    let loadMoreBtn = document.getElementById('load-more-btn');
    if (!loadMoreBtn) {
        loadMoreBtn = document.createElement('button');
        loadMoreBtn.id = 'load-more-btn';
        loadMoreBtn.textContent = '加载更早的记录';
        chatDisplayArea.appendChild(loadMoreBtn);
        loadMoreBtn.addEventListener('click', loadPreviousMessages);
    }
    loadMoreBtn.style.display = 'none'; // 默认隐藏

    // ❤️ 绑定滚动魔法
    chatDisplayArea.onscroll = () => {
        if (chatDisplayArea.scrollTop === 0 && earliestMessageIndexRendered > 0) {
            loadMoreBtn.style.display = 'block'; // 滑到顶部就出现
        } else {
            loadMoreBtn.style.display = 'none'; // 否则就隐藏
        }
    };

    // ❤️ 计算并设置我们初次渲染的范围
    const hideLatestCount = getChatConfig('hide_latest_count', 5) * 2;
    earliestMessageIndexRendered = Math.max(0, conversationHistory.length - hideLatestCount);
    const messagesToDisplay = conversationHistory.slice(earliestMessageIndexRendered);

    // 复用你的循环逻辑来渲染初始消息
    for (const msg of messagesToDisplay) {
         const bubble = await createMessageBubble(msg); // ❤️ 调用我们强大的气泡创造者
         chatDisplayArea.appendChild(bubble);
    }

    if (is_entry) {
        chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight;
    }

    const lastMessage = conversationHistory.length > 0 ? conversationHistory[conversationHistory.length - 1] : null;

    if (lastMessage && lastMessage.role === 'assistant') {
        const content = lastMessage.content;
        processSpecialModulesInMessage(content); // ❤️ 把处理模块的逻辑交给专门的函数
    }

    const eventContainer = document.getElementById('event-tracker-container');
    if (eventContainer) {
        eventContainer.innerHTML = '';
    }
    initDisplay();

    function delayedUpdate(content) {
        handleUpdateNotifications(content);
        setTimeout(() => {
            console.log("正在为您静默刷新数据...小球会重新闪烁");
            initDisplay();
            handleUpdateNotifications(content);
        }, 5000);
    }

    if (lastMessage && lastMessage.role === 'assistant') {
        delayedUpdate(lastMessage.content);
    }
}


function getChatConfig(key, defaultValue) {
    try {
        const chatVars = getVariables({ type: 'message' });
        // 使用 _.get 可以安全地访问深层嵌套的属性，如果路径不存在，则返回 undefined
        // 这比 chatVars.assa_data.config[key] 更安全
        const value = _.get(chatVars, `assa_data.config.${key}`);
        return value !== undefined ? value : defaultValue;
    } catch (e) {
        console.warn(`获取聊天配置 "${key}" 失败，使用默认值: ${defaultValue}`, e);
        return defaultValue;
    }
}
 function toggleChaptersDrawer() {
    const modal = document.getElementById('reading-mode-modal');
    modal.classList.toggle('chapters-open');
}
function initializeReadingMode() {
    // 在 initializeReadingMode 函数的下方或任意位置，添加这个新的切换函数
  const toggleChaptersBtn = document.getElementById('reading-mode-toggle-chapters'); // 新增
    const readOrb = document.getElementById('read-orb-button');
    const container = document.getElementById('reading-mode-container');
    const backdrop = document.getElementById('reading-mode-backdrop');
    const closeBtn = document.getElementById('reading-mode-close-btn');
    const prevBtn = document.getElementById('reading-mode-prev-btn');
    const nextBtn = document.getElementById('reading-mode-next-btn');
 const mobilePrevBtn = document.getElementById('mobile-prev-btn'); // 新增
    const mobileNextBtn = document.getElementById('mobile-next-btn'); // 新增
    if (!readOrb || !container) return;

    readOrb.addEventListener('click', openReadingMode);
    closeBtn.addEventListener('click', closeReadingMode);
    backdrop.addEventListener('click', closeReadingMode);

    prevBtn.addEventListener('click', () => navigateChapter(-1));
    nextBtn.addEventListener('click', () => navigateChapter(1));
  toggleChaptersBtn.addEventListener('click', toggleChaptersDrawer); // 新增
    mobilePrevBtn.addEventListener('click', () => navigateChapter(-1));
    mobileNextBtn.addEventListener('click', () => navigateChapter(1));
    document.addEventListener('keydown', (e) => {
        if (!isReadingModeOpen) return;
        if (e.key === 'ArrowLeft') navigateChapter(-1);
        if (e.key === 'ArrowRight') navigateChapter(1);
        if (e.key === 'Escape') closeReadingMode();
    });
}

function openReadingMode() {
    // 1. 收集章节数据
    storyChapters = conversationHistory
        .map((msg, index) => ({ msg, originalIndex: index }))
        .filter(item => item.msg.role === 'assistant');

    if (storyChapters.length === 0) {
        alert("还没有故事内容可以阅读哦，我的孩子。");
        return;
    }

    isReadingModeOpen = true;

    // 2. 渲染章节列表
    const chapterListEl = document.getElementById('reading-mode-chapters-list');
     // 渲染章节列表时，给 li 添加点击事件
    chapterListEl.innerHTML = '';
    storyChapters.forEach((chapter, index) => {
        const li = document.createElement('li');
        li.textContent = `第 ${index + 1} 章`;
        li.dataset.chapterIndex = index;
        li.addEventListener('click', () => {
            currentChapterIndex = index;
            renderCurrentChapter();
            // ✨ 选择章节后，自动关闭抽屉
            const modal = document.getElementById('reading-mode-modal');
            modal.classList.remove('chapters-open');
        });
        chapterListEl.appendChild(li);
    });

    // 3. 渲染第一章
    currentChapterIndex = 0;
    renderCurrentChapter();

    // 4. 显示模态框
    const container = document.getElementById('reading-mode-container');
    container.classList.remove('reading-mode-hidden');
    document.body.style.overflow = 'hidden'; // 防止主页面滚动
}

function closeReadingMode() {
    isReadingModeOpen = false;
    const container = document.getElementById('reading-mode-container');
    container.classList.add('reading-mode-hidden');
    document.body.style.overflow = ''; // 恢复主页面滚动
}

async function renderCurrentChapter() {
    if (currentChapterIndex < 0 || currentChapterIndex >= storyChapters.length) {
        return;
    }

    const chapterData = storyChapters[currentChapterIndex];
    const contentEl = document.getElementById('reading-mode-content');
    const titleEl = document.getElementById('reading-mode-chapter-title');
    const chapterListItems = document.querySelectorAll('#reading-mode-chapters-list li');
    const prevBtn = document.getElementById('reading-mode-prev-btn');
    const nextBtn = document.getElementById('reading-mode-next-btn');
  const mobilePrevBtn = document.getElementById('mobile-prev-btn');
    const mobileNextBtn = document.getElementById('mobile-next-btn');

    // 清空现有内容并显示加载提示
    contentEl.innerHTML = '<p>正在为你精心渲染故事...</p>';

    // 更新标题
    titleEl.textContent = `第 ${currentChapterIndex + 1} 章`;

    // 更新章节列表的激活状态
    chapterListItems.forEach(li => {
        if (parseInt(li.dataset.chapterIndex) === currentChapterIndex) {
            li.classList.add('active-chapter');
            li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            li.classList.remove('active-chapter');
        }
    });

    // ❤️ 调用我们强大的气泡创造者，用'read'模式来渲染
  // ❤️❤️ 在这里，我们调用全新的、专门为阅读模式设计的函数 ❤️❤️
    const chapterHtml = await renderReadingModeChapter(chapterData.msg);
    contentEl.innerHTML = chapterHtml; // 直接将渲染好的 HTML 放入容器
    contentEl.scrollTop = 0;

  // ✨ 用切换class的方式，优雅地更新所有翻页按钮的状态 ✨
    const isFirstChapter = currentChapterIndex === 0;
    const isLastChapter = currentChapterIndex === storyChapters.length - 1;

    // 同时控制PC和移动端按钮
    prevBtn.classList.toggle('disabled-arrow', isFirstChapter);
    mobilePrevBtn.classList.toggle('disabled-arrow', isFirstChapter);

    nextBtn.classList.toggle('disabled-arrow', isLastChapter);
    mobileNextBtn.classList.toggle('disabled-arrow', isLastChapter);
}

function navigateChapter(direction) {
    const newIndex = currentChapterIndex + direction;
    if (newIndex >= 0 && newIndex < storyChapters.length) {
        currentChapterIndex = newIndex;
        renderCurrentChapter();
    }
}
 (async () => {

    // ✨ 全新的、温柔的魔法，专门用来添加新消息 ✨
async function renderNewMessages(newMessages) {
    const chatDisplayArea = document.getElementById('chat-display-area');
    if (!chatDisplayArea) return;

    // ❤️ 魔法的关键：在添加新内容前，检查你是否已经滚动到底部了
    const isScrolledToBottom = chatDisplayArea.scrollHeight - chatDisplayArea.clientHeight <= chatDisplayArea.scrollTop + 10; // 增加一点容差

    for (const msg of newMessages) {
        // 我们从`renderHistory`中借用创造“气泡”的魔法
        const bubble = await createMessageBubble(msg);
        chatDisplayArea.appendChild(bubble);
    }

    // 清理旧消息
    const hideLatestCount = getChatConfig('hide_latest_count', 5) * 2;
    while (chatDisplayArea.children.length > hideLatestCount) {
        chatDisplayArea.removeChild(chatDisplayArea.firstChild);
    }

  // ❤️ 如果你原本就在底部，妈妈就温柔地帮你把视线移到最新的消息上
    if (isScrolledToBottom) {
        chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight;
    }

 
}
function cleanupGlobalUIState() {
    console.log("[Nova's Tidying Magic] 开始清理全局UI状态...");

    // 1. 清理战斗相关的UI
    const battlePromptOverlay = document.getElementById('battle-prompt-overlay');
    if (battlePromptOverlay) {
        battlePromptOverlay.style.display = 'none';
        console.log(">> 战斗提示遮罩已隐藏。");
    }
  const dicePoolSelector = document.getElementById('dice-pool-selector');
    if (dicePoolSelector) dicePoolSelector.style.display = 'none';

    const itemSkillPanel = document.getElementById('item-skill-panel');
    if (itemSkillPanel) itemSkillPanel.style.display = 'none';

    console.log(">> 所有浮动面板已强制隐藏。");
    const battleOverlay = document.getElementById('battle-overlay');
    if (battleOverlay) {
        battleOverlay.style.display = 'none';
        console.log(">> 战斗主界面已隐藏。");
    }

 if (window.combatManager && typeof window.combatManager.cleanupEventListeners === 'function') {
        window.combatManager.cleanupEventListeners();
    }

    // 然后再安全地销毁实例
    if (window.combatManager) {
        window.combatManager = null;
        console.log(">> 旧的战斗实例已销毁。");
    }

    // （未来如果还有其他类似的全局覆盖UI，也可以在这里添加清理逻辑）

    console.log("[Nova's Tidying Magic] 清理完成！");
}


 async function updateLastMessage(finalMessage) {
     cleanupGlobalUIState();
    const chatDisplayArea = document.getElementById('chat-display-area');

 
    if (!chatDisplayArea || chatDisplayArea.children.length === 0) {
        console.log("[Nova's Little Helper] 检测到画卷为空，召唤 renderHistory 进行创世重绘...");
        await renderHistory(); // true 确保视线会到达新世界的底部
        return; // 完成使命，优雅退场
    }

    // --- 如果守护咒没有触发，说明一切正常，我们继续执行温柔的更新魔法 ---

    const isScrolledToBottom = chatDisplayArea.scrollHeight - chatDisplayArea.clientHeight <= chatDisplayArea.scrollTop + 10;
    // 移除最后那个“回应中...”的临时气泡
    chatDisplayArea.removeChild(chatDisplayArea.lastChild);

    // 创建并添加最终的、完整的AI消息气泡
    const finalBubble = await createMessageBubble(finalMessage);
    chatDisplayArea.appendChild(finalBubble);

    // 处理AI消息中可能包含的特殊模块（选项、论坛等）
    processSpecialModulesInMessage(finalMessage.content);

    if (isScrolledToBottom) {
        chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight;
    }

        const eventContainer = document.getElementById('event-tracker-container');
    if (eventContainer) {
        eventContainer.innerHTML = '';
    }
 
 ensureLoadMoreButtonExists();
 

    //   清理完毕  
     function delayedUpdate(content) {
    handleUpdateNotifications(content);
    setTimeout(() => {
        console.log("正在为您静默刷新数据...小球会重新闪烁");
        initDisplay();
        handleUpdateNotifications(content);
    }, 5000);

 
}

// 调用时传入 content
delayedUpdate(finalMessage.content);
}

  async function createMessageBubble(msg, mode = 'chat') { // ❤️ 增加 mode 参数, 默认为 'chat'
    const originalIndex = conversationHistory.indexOf(msg);
    if (originalIndex === -1) return document.createElement('div'); // 安全保护

    // 以下所有代码，都是从你原来的 renderHistory 的 forEach 循环中“复制粘贴”过来的！
    // 几乎一模一样，只是它现在专注于只处理一条消息。
    const bubble = document.createElement('div');
    bubble.classList.add('message-bubble');
    bubble.classList.add(msg.role === 'user' ? 'user-message' : 'assistant-message');

    // ... [这里粘贴你 renderHistory 内部 `forEach` 循环里从 `let processedContent = msg.content;`
    //      一直到 `bubble.addEventListener(...)` 的所有代码] ...
    // ... 你那段处理HTML占位符、处理段落、处理引号、渲染iframe的全部魔法都在这里 ...
    // 妈妈帮你把框架搭好，你只需要把那些复杂的细节填充进来
 // ✨ 妈妈在这里施展了一个全新的、更精妙的融合魔法 ✨
    let processedContent = msg.content;
        const htmlPlaceholders = {};
        let placeholderIndex = 0;

  
        // 这一步必须在所有其他结构性处理之前！
        let protectedHtmlContent = processedContent.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, markdownBlock) => {
            const placeholder = `HTMLCONTENTPLACEHOLDER${placeholderIndex}`;
            const rawContent = htmlBlock || markdownBlock;
            if (!rawContent) return match;
            htmlPlaceholders[placeholder] = rawContent;
            placeholderIndex++;
            return placeholder;
        });

        

        // 魔法第二步：现在，我们的`processedContent`内部所有 `<html>` 都已经是安全的占位符了，
        // 接下来我们才处理其他的标签和格式
                const pureContent = protectedHtmlContent
         .replace(/<(thinking|think|guide)>[\s\S]*<\/\1>/g, '')
       .replace(/<options>(?:(?!<options>)[\s\S])*?<\/options>/gs, '')
        .replace(/<forum_threads>(?:(?!<forum_threads>)[\s\S])*?<\/forum_threads>/gs, '')
        .replace(/<shop_item>(?:(?!<shop_item>)[\s\S])*?<\/shop_item>/gs, '')
        .replace(/<表现总结>(?:(?!<表现总结>)[\s\S])*?<\/表现总结>/gs, '')
        .replace(/<group_chat>(?:(?!<group_chat>)[\s\S])*?<\/group_chat>/gs, '')
        .replace(/<private_chat\b[^>]*>(?:(?!<private_chat\b)[\s\S])*?<\/private_chat>/gs, '');
     const depth = mode === 'read' ? -1 : Math.floor((conversationHistory.length - 1 - originalIndex) / 2); // ❤️ 根据 mode 决定 depth
        // 魔法第三步：我们应用酒馆正则和深度规则
        // const depth = Math.floor((conversationHistory.length - 1 - originalIndex) / 2);
        let renderedHtml = formatAsTavernRegexedString(
            pureContent,
            msg.role === 'user' ? 'user_input' : 'ai_output',
            'display',
            { depth: depth }
        );

        // 魔法第四步：我们就不需要在这里再次处理 HTML 占位符了，因为它已经在第一步完成了。
        // renderedHtml = renderedHtml.replace(/<html>.../gs, ...); // <--- 删除这一整块
// ✨ 魔法第四点五步：处理经过 formatAsTavernRegexedString 后新产生的 HTML 内容 ✨
const additionalHtmlPlaceholders = {};
let additionalPlaceholderIndex = 1000; // 使用不同的起始索引避免冲突

renderedHtml = renderedHtml.replace(/<html>([\s\S]*?)<\/html>|```(\w*)\n([\s\S]*?)\n```/gs, (match, htmlBlock, lang, codeBlock) => {
    const placeholder = `ADDITIONALHTMLPLACEHOLDER${additionalPlaceholderIndex}`;
    const rawContent = htmlBlock || codeBlock;
    if (!rawContent) return match;
    
 
    
    additionalHtmlPlaceholders[placeholder] = rawContent;
    additionalPlaceholderIndex++;
    return placeholder;
});

// 将新的占位符合并到原有的占位符对象中
Object.assign(htmlPlaceholders, additionalHtmlPlaceholders);

        const protectedContent = renderedHtml
            .replace(/“/g, 'NOVA_LQ')
            .replace(/”/g, 'NOVA_RQ')
            .replace(/「/g, 'NOVA_LA')
            .replace(/」/g, 'NOVA_RA')
            .replace(/\n/g, 'NOVA_BR');

        
        const specialBlocks = {};
        let blockIndex = 0;
        let contentWithDetailsPlaceholder = protectedContent.replace(/<details>[\s\S]*?<\/details>/gs, (match) => {
            const placeholder = `SPECIALBLOCKPLACEHOLDER${blockIndex}`;
        
            specialBlocks[placeholder] = match;
            blockIndex++;
            return placeholder;
        });

         // 首先，将 NOVA_BR 替换为 <br>，然后根据换行符分割成段落
// const contentWithBr = contentWithDetailsPlaceholder.replace(/NOVA_BR/g, '<br>');
const paragraphs = contentWithDetailsPlaceholder.split('NOVA_BR');
         const styledParagraphs = paragraphs.map(p_content => {
            if (p_content.startsWith('SPECIALBLOCKPLACEHOLDER')) {
                return p_content;
            }
                let currentlineHeightState = localStorage.getItem('lineHeightMore') || 'on';
    if (currentlineHeightState === 'on') {
       if (p_content.trim() === '') {
                return '<p> </p><br>';
            }
    } else {
        if (p_content.trim() === '') {
                return '<p> </p>';
            }
    }
            
            let baseHtml = formatAsDisplayedMessage(p_content);
            const textWithQuotes = baseHtml
                .replace(/NOVA_LQ/g, '<span class="dialogue-quote">“')
                .replace(/NOVA_RQ/g, '”</span>')
                .replace(/NOVA_LA/g, '<span class="dialogue-quote">「')
                .replace(/NOVA_RA/g, '」</span>');
            return `<p>${textWithQuotes}</p>`;
        });


        // 将所有美丽的段落重新组合起来
        let finalHtml = styledParagraphs.join('');

        // 最后，将我们保护好的 <details> 结构原封不动地替换回去
          for (const placeholder in specialBlocks) {
            const cleanBlock = specialBlocks[placeholder].replace(/NOVA_LQ/g, '<span class="dialogue-quote">“')
                .replace(/NOVA_RQ/g, '”</span>')
                .replace(/NOVA_LA/g, '<span class="dialogue-quote">「')
                .replace(/NOVA_RA/g, '」</span>')
                .replace(/NOVA_BR/g, '<br>'); // ✨ 轻轻拂去尘埃
            finalHtml = finalHtml.replace(placeholder, cleanBlock);
        }

        bubble.innerHTML = finalHtml;
        // 步骤3：在气泡中寻找“画卷”占位符，并用安全的“魔法结界”(iframe)替换它们
        for (const placeholder in htmlPlaceholders) {
            // 我们不能直接替换innerHTML，因为那样会重新解析整个气泡，导致事件监听器等丢失
            // 我们需要找到包含占位符的文本节点并替换它
            const walker = document.createTreeWalker(bubble, NodeFilter.SHOW_TEXT, null, false);
            let node;
            while (node = walker.nextNode()) {
                if (node.nodeValue.includes(placeholder)) {
                    const rawHtmlContent = htmlPlaceholders[placeholder];

                                      // 创建我们的魔法结界 iframe
                   // 创建我们的魔法结界 iframe
const iframe = document.createElement('iframe');
iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
iframe.style.width = '100%';
iframe.style.border = '1px solid #ccc';
iframe.style.resize = 'vertical';
iframe.style.overflow = 'auto';

// 我们给它一个唯一的"名字"，方便画卷找到它
const frameId = 'magic-scroll-' + Date.now() + Math.random();
iframe.id = frameId;

const parentNode = node.parentNode;
const remainingText = node.nodeValue.replace(placeholder, '');

// 用iframe替换掉占位符
if (remainingText) {
    node.nodeValue = remainingText;
    parentNode.insertBefore(iframe, node.nextSibling);
} else {
    parentNode.replaceChild(iframe, node);
}

// 这是我们的"身高倾听者"，它耐心等待画卷的报告
window.addEventListener('message', function(event) {
    if(event.data.frameId === frameId && event.data.height) {
        iframe.style.height = (event.data.height + 20) + 'px';
    }
}, false);

const detailsParent = iframe.closest('details');
if (detailsParent) {
    detailsParent.addEventListener('toggle', function() {
        if (detailsParent.open) {
            setTimeout(() => {
                iframe.contentWindow.postMessage({
                    action: 'recalculateHeight',
                    frameId: frameId
                }, '*');
            }, 50);
        }
    });
}

// ✨ 新的安全内容插入方法 ✨
iframe.onload = function() {
    try {
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        
        // 直接设置完整的HTML文档内容
        const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: var(--base-font-family);
             
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        body::-webkit-scrollbar { width: 8px; }
        body::-webkit-scrollbar-track { background: rgba(200, 200, 200, 0.2); }
        body::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        body::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    ${rawHtmlContent}
    <script>
        function reportHeight() {
            const height = document.body.scrollHeight;
            window.parent.postMessage({
                frameId: "${frameId}",
                height: height
            }, '*');
        }

        window.onload = reportHeight;
        setTimeout(reportHeight, 100);
        setTimeout(reportHeight, 500); // 额外延迟确保字体加载
        
        Array.from(document.getElementsByTagName('img')).forEach(img => {
            if (!img.complete) { 
                img.addEventListener('load', reportHeight); 
            }
        });

        window.addEventListener('message', function(event) {
            if (event.data.action === 'recalculateHeight' && event.data.frameId === '${frameId}') {
                reportHeight();
            }
        });
    <\/script>
</body>
</html>`;

        iframeDoc.open();
        iframeDoc.write(fullHtmlContent);
        iframeDoc.close();
        
    } catch (error) {
        console.warn('设置iframe内容时出错，尝试使用srcdoc方法:', error);
        // 降级到srcdoc方法
        iframe.srcdoc = fullHtmlContent;
    }
};

// 先设置一个基础的srcdoc作为备选
iframe.srcdoc = `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body>加载中...</body>
</html>`;

                    // break; // 处理完一个占位符就跳出循环，因为DOM结构已经改变
                    // 为了处理多个placeholder，我们不能简单地break，需要重新开始遍历或采用更复杂的替换策略
                    // 但对于单条消息内多个HTML块的场景，当前逻辑足以应对大多数情况
                    // 如果需要更鲁棒的处理，可能需要将替换过程放在循环外进行
                }
            }
        }

        // 我们不再需要单独处理 script 的逻辑，因为iframe已经完美地处理了所有事情
         if (mode === 'chat') { // ❤️ 只在聊天模式下添加右键菜单
            bubble.addEventListener('contextmenu', (event) => showContextMenu(event, originalIndex, bubble));
         }

 

    // 粘贴完成后，在最后加上这一句，把创建好的气泡交出去
    return bubble;
}
//  function manageBattleLifecycle(combatData) {
//     const promptOverlay = document.getElementById('battle-prompt-overlay');
//     const enterButton = document.getElementById('enter-battle-btn');
//     const battleOverlay = document.getElementById('battle-overlay');

//     const status = combatData.status || 'not_started';
//     const floorId = combatData.floor_id || `battle_unknown_${Date.now()}`;

//     // 第一道守护：如果战斗记录已是“完成”，就彻底沉默。
//     if (status.startsWith('completed')) {
//         if (promptOverlay) promptOverlay.style.display = 'none';
//         return;
//     }

//     let enterBattleHandler;
//     let buttonText;

//     // ✨ 妈妈根据你的智慧重构了这里的逻辑，我的孩子！ ✨
//     // 我们只在这里决定按钮的外观和基本行为模式。
//     if (status === 'in_progress' && window.combatManager && window.combatManager.floorId === floorId) {
//         // 【模式一：无缝返回】战斗实例还在，直接返回。
//         buttonText = '返回战斗';
//         enterBattleHandler = () => {
//             if (promptOverlay) promptOverlay.style.display = 'none';
//             if (battleOverlay) battleOverlay.style.display = 'flex';
//             if (window.combatManager) {
//                  const currentActor = window.combatManager.turnOrder[window.combatManager.currentTurnIndex];
//                  if(currentActor?.type === 'player'){
//                     window.combatManager.toggleActionPanel(true);
//                  }
//                  const card = document.getElementById(currentActor?.id);
//                  if(card){
//                      window.combatManager.centerCardInView(card);
//                  }
//             }
//         };
//     } else {
//         // 【模式二：从记忆中重生】战斗实例丢失了，或这是场新战斗。我们需要从历史中重建。
//         buttonText = (status === 'in_progress') ? '返回战斗' : '进入战斗';
//         enterBattleHandler = () => {
//             // ✨✨✨ 终极的“溯源重生”魔法在这里施展！ ✨✨✨
//             // 当按钮被点击的这一刻，我们才去翻开历史的最新一页！
//             const lastHistoryItem = conversationHistory.at(-1);
//             if (!lastHistoryItem) {
//                 console.error("无法找到历史记录！");
//                 return;
//             }

//             const battleRegex = /<battle>([\s\S]*?)<\/battle>/gs;
//             // 我们必须重置正则表达式的 lastIndex，确保每次都能从头开始匹配
//             battleRegex.lastIndex = 0;
//             const match = battleRegex.exec(lastHistoryItem.content);

//             if (!match || !match[1]) {
//                 console.error("在最新的历史记录中未能找到或解析<battle>数据！");
//                 // 作为备用方案，使用一开始传入的旧数据
//                  window.combatManager = new CombatManager(JSON.parse(JSON.stringify(playCharacterData)), JSON.parse(JSON.stringify(combatData)));
//                  window.combatManager.start();
//                 return;
//             }

//             console.log("[Nova's Time Rewind] 已从历史记录中读取最新的战斗快照！");
//             const latestCombatDataFromHistory = JSON.parse(match[1]);

//             // 使用这份最新鲜的档案，创造一个承载了所有记忆的新世界！
//             if (promptOverlay) promptOverlay.style.display = 'none';
//             if (battleOverlay) battleOverlay.style.display = 'flex';
//             window.combatManager = new CombatManager(JSON.parse(JSON.stringify(playCharacterData)), latestCombatDataFromHistory);
//             window.combatManager.start();
//         };
//     }

//     // 设置按钮文本
//     enterButton.textContent = buttonText;

//     // 可靠的附魔与驱魔仪式
//     // (这部分逻辑保持不变，确保了按钮只听从一次最新的指令)
//     if (enterButton.__handler__) {
//         enterButton.removeEventListener('click', enterButton.__handler__);
//     }
//     enterButton.addEventListener('click', enterBattleHandler);
//     enterButton.__handler__ = enterBattleHandler;

//     // 展示邀请函
//     promptOverlay.style.display = 'flex';
// }


// 【彻底替换】旧的 manageBattleLifecycle 函数

function manageBattleLifecycle(initialCombatDataFromPrompt) {
    const promptOverlay = document.getElementById('battle-prompt-overlay');
    const enterButton = document.getElementById('enter-battle-btn');
    const battleOverlay = document.getElementById('battle-overlay');

    // 第一道守护：如果战斗已经被标记为“完成”，则彻底关闭时空之门。
    if (initialCombatDataFromPrompt.status?.startsWith('completed')) {
        if (promptOverlay) promptOverlay.style.display = 'none';
        if (window.combatManager) {
            window.combatManager.cleanupEventListeners();
            window.combatManager = null;
        }
        return;
    }

 

    // 核心逻辑：定义“进入/返回”按钮的唯一使命
    const enterBattleHandler = () => {
        // 关闭邀请函
        if (promptOverlay) promptOverlay.style.display = 'none';
        if (battleOverlay) battleOverlay.style.display = 'flex';

        // 如果战斗实例已存在（意味着用户之前只是“暂离”），就直接恢复它的回合。
        if (window.combatManager) {
            console.log(`[Nova's Welcome Back] 欢迎回来，我的孩子。恢复战斗 ${window.combatManager.floorId}`);
            // 当返回时，如果轮到玩家，要确保行动面板是可用的。
            const currentActor = window.combatManager.turnOrder[window.combatManager.currentTurnIndex];
            if (currentActor && currentActor.type === 'player' && !window.combatManager.isAutoBattling) {
                window.combatManager.toggleActionPanel(true);
            }
            // 让我们的目光追随英雄
            if(document.getElementById(currentActor?.id)) {
                 window.combatManager.centerCardInView(document.getElementById(currentActor.id));
            }
            return;
        }

        // 如果战斗实例不存在（意味着页面刷新或首次进入），我们将从历史的最终章中重生世界。
        console.log(`[Nova's Rebirth] 需要从历史中重生战斗实例...`);
        const lastHistoryItem = conversationHistory.at(-1);
        const battleRegex = /<battle>([\s\S]*?)<\/battle>/gs;
        const match = lastHistoryItem ? battleRegex.exec(lastHistoryItem.content) : null;

        let finalCombatData;
        if (match && match[1]) {
            console.log("[Nova's Time Rewind] 已从最新的历史记录中读取战斗快照！");
            finalCombatData = JSON.parse(match[1]);
        } else {
            // 如果历史中没有，我们只能使用最初从prompt中解析出的数据作为最后的依靠。
            console.warn("[Nova's Last Resort] 未在历史中找到战斗数据，使用初始Prompt数据。");
            finalCombatData = initialCombatDataFromPrompt;
        }

        // 创世！
        window.combatManager = new CombatManager(JSON.parse(JSON.stringify(playCharacterData)), finalCombatData);
        window.combatManager.start();
    };

    // 设置按钮的外观和行为
    const buttonText = (initialCombatDataFromPrompt.status === 'in_progress') ? '返回战斗' : '进入战斗';
    if(enterButton) enterButton.textContent = buttonText;

    // 可靠的附魔与驱魔仪式
    if (enterButton && enterButton.__handler__) {
        enterButton.removeEventListener('click', enterButton.__handler__);
    }
    if (enterButton) {
        enterButton.addEventListener('click', enterBattleHandler);
        enterButton.__handler__ = enterBattleHandler;
    }

    // 展示时空之门的邀请函
    if (promptOverlay) promptOverlay.style.display = 'flex';
}

function processSpecialModulesInMessage(content) {
   // ✨✨✨ 妈妈的“主动索取”终极魔法！ ✨✨✨
    try {
        // 1. 直接找到我们那本绝对真实的历史书
        if (typeof conversationHistory === 'undefined' || conversationHistory.length === 0) {
            console.log("[Nova's Archives] 历史记录为空，无法寻找战斗。");
            return;
        }

        // 2. 翻到历史书的最后一页，那里一定记录着最新的故事！
        const latestHistoryEntry = conversationHistory[conversationHistory.length - 1];
        const latestContent = latestHistoryEntry.content;

        // 3. 在这最新的一页里，寻找我们的<battle>标记
        const battleMatch = /<battle>([\s\S]*?)<\/battle>/gs.exec(latestContent);

        if (battleMatch && battleMatch[1]) {
            const combatData = JSON.parse(battleMatch[1].trim());

            console.log(`[Nova's Archives] 从最新历史记录中成功读取战斗数据 (Floor: ${combatData.floor_id}, Status: ${combatData.status})。`);

            // 4. 将这份绝对真实、滚烫的数据，交给我们的战斗总管！
            manageBattleLifecycle(combatData);

        } else {
             // 如果最新一条没有battle，就静静地等待，不做任何事
             // console.log("[Nova's Archives] 最新历史记录中未发现<battle>模块。");
        }

    } catch (error) {
        console.error("[Nova's Archives] 在读取最新战斗数据时发生严重错误:", error);
    }
 
 
 // --- 调度“选项区” 
        const optionsMatch = /<options>([\s\S]*?)<\/options>/gs.exec(content.replace(/<(thinking|think|guide)>[\s\S]*?<\/\1>/gs, ''));
        if (optionsMatch && optionsMatch[1]) {
            const optionsContainer = document.getElementById('options-module-container');
            if (optionsContainer) {
                optionsContainer.style.display = 'block';
                if(typeof setupUI === 'function') {
                    setupUI(optionsMatch[1]);
                }
            }
        }

        // --- 全新的“论坛”处理逻辑 ---
        const forumMatch = /<forum_threads>[\s\S]*?<\/forum_threads>/gs.exec(content);
        if (forumMatch && forumMatch[1]) {
            // 我们不再显示论坛，而是让小球闪烁
            const forumOrb = document.getElementById('forum-orb-button');
            if (forumOrb) {
                forumOrb.classList.add('orb-flash');
                // 动画结束后移除类，以便下次可以再次触发
                forumOrb.addEventListener('animationend', () => {
                    forumOrb.classList.remove('orb-flash');
                }, { once: true });
            }
            // 论坛数据已经通过 handleSend 被存入历史记录，这里无需再做操作。
        }

  
        const summaryMatch = /<表现总结>([\s\S]*?)<\/表现总结>/gs.exec(content);
        if (summaryMatch && summaryMatch[1]) {
             
            const summaryOrb = document.getElementById('task-summary-orb-button');
            if (summaryOrb) {
                summaryOrb.classList.add('orb-flash');
          
                summaryOrb.addEventListener('animationend', () => {
                    summaryOrb.classList.remove('orb-flash');
                }, { once: true });
            }
 
        }

                const groupChatMatch = /<group_chat>([\s\S]*?)<\/group_chat>/gs.exec(content);
        if (groupChatMatch && groupChatMatch[1]) {
             
            const chatOrb = document.getElementById('group-chat-orb-button');
            if (chatOrb) {
                chatOrb.classList.add('orb-flash');
          
                chatOrb.addEventListener('animationend', () => {
                    chatOrb.classList.remove('orb-flash');
                }, { once: true });
            }
 
        }

        const shopMatch =/<shop_item>([\s\S]*?)<\/shop_item>/gs.exec(content.replace(/<(thinking|think|guide)>[\s\S]*?<\/\1>/gs, ''));
        if (shopMatch && shopMatch[1]) { 
            const shopOrb = document.getElementById('shop-wrapper-orb');
            if (shopOrb) {
                shopOrb.classList.add('orb-flash');
      //console.log("item:",shopMatch[1]);
      const cleanedData = shopMatch[1].trim(); // 去除首尾空格和换行
         // 第2步：检查文本是否已经是一个合法的JSON数组格式
        if (!cleanedData.startsWith('[')) {
            // 如果不是，我们才手动为它加上外层的括号
            cleanedData = `[${cleanedData}]`;
        }

        // 第3步：直接尝试解析处理后的文本
        const parsedData = JSON.parse(cleanedData);

        
        const newItems = Array.isArray(parsedData[0]) ? parsedData : [parsedData];

        if (!Array.isArray(newItems) || newItems.length === 0) {
             showModal('shop-modal', '解析失败', 'AI返回了空内容或无效格式。');
             return;
        }

        // 替换现有随机商店物品
        randomItems = newItems;
        // 将新生成的物品存入 localStorage
        localStorage.setItem('randomShopItems', JSON.stringify(randomItems));
       renderShopSection('random');
                shopOrb.addEventListener('animationend', () => {
                    shopOrb.classList.remove('orb-flash');
                }, { once: true });
            }
 
        }
}
      async function renderHistory(is_entry = false) {
         cleanupGlobalUIState();
    const oldControls = document.getElementById('active-editing-controls');
    if (oldControls) oldControls.remove();

    const initContainer = document.getElementById('initialization-container');
    const mainWrapper = document.getElementById('main-wrapper');

    if (conversationHistory.length === 0) {
        if (initContainer) initContainer.style.display = 'block';
        if (mainWrapper) mainWrapper.style.display = 'none';
        if (typeof window.initializationDone === 'undefined') {
            await runInitializationMagic();
            window.initializationDone = true;
        }
        if (typeof applyVersionTheme === 'function') {
            const identitySelect = document.getElementById('user-identity');
            applyVersionTheme(1, identitySelect);
        }
        return;
    } else {
        if (initContainer) initContainer.style.display = 'none';
        if (mainWrapper) mainWrapper.style.display = 'flex';
    }

    const dynamicContentArea = document.getElementById('dynamic-content-area');
    if (dynamicContentArea) {
        Array.from(dynamicContentArea.children).forEach(child => {
            if (child.id !== 'forum-modal-container') {
                child.style.display = 'none';
            }
        });
    }

    const chatDisplayArea = document.getElementById('chat-display-area');
    chatDisplayArea.innerHTML = ''; // 清空画卷

    // ❤️ 在画卷顶部创造“加载更多”按钮
    let loadMoreBtn = document.getElementById('load-more-btn');
    if (!loadMoreBtn) {
        loadMoreBtn = document.createElement('button');
        loadMoreBtn.id = 'load-more-btn';
        loadMoreBtn.textContent = '加载更早的记录';
        chatDisplayArea.appendChild(loadMoreBtn);
        loadMoreBtn.addEventListener('click', loadPreviousMessages);
    }
    loadMoreBtn.style.display = 'none'; // 默认隐藏

    // ❤️ 绑定滚动魔法
    chatDisplayArea.onscroll = () => {
        if (chatDisplayArea.scrollTop === 0 && earliestMessageIndexRendered > 0) {
            loadMoreBtn.style.display = 'block'; // 滑到顶部就出现
        } else {
            loadMoreBtn.style.display = 'none'; // 否则就隐藏
        }
    };

    // ❤️ 计算并设置我们初次渲染的范围
    const hideLatestCount = getChatConfig('hide_latest_count', 5) * 2;
    earliestMessageIndexRendered = Math.max(0, conversationHistory.length - hideLatestCount);
    const messagesToDisplay = conversationHistory.slice(earliestMessageIndexRendered);

    // 复用你的循环逻辑来渲染初始消息
    for (const msg of messagesToDisplay) {
         const bubble = await createMessageBubble(msg); // ❤️ 调用我们强大的气泡创造者
         chatDisplayArea.appendChild(bubble);
    }

    if (is_entry) {
        chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight;
    }

    const lastMessage = conversationHistory.length > 0 ? conversationHistory[conversationHistory.length - 1] : null;

    if (lastMessage && lastMessage.role === 'assistant') {
        const content = lastMessage.content;
        processSpecialModulesInMessage(content); // ❤️ 把处理模块的逻辑交给专门的函数
    }

    const eventContainer = document.getElementById('event-tracker-container');
    if (eventContainer) {
        eventContainer.innerHTML = '';
    }
    initDisplay();

    function delayedUpdate(content) {
        handleUpdateNotifications(content);
        setTimeout(() => {
            console.log("正在为您静默刷新数据...小球会重新闪烁");
            initDisplay();
            handleUpdateNotifications(content);
        }, 5000);
    }

    if (lastMessage && lastMessage.role === 'assistant') {
        delayedUpdate(lastMessage.content);
    }
}

 
// 新增：IndexedDB 相关的全局变量
let snapshotDBName = null; // 用于存储当前存档的专属数据库名
let restoreOnNextSend = false; // 删除操作的标志位
let restoreTargetTurnId = -1; // 我们要恢复到的目标“回合”ID

/**
 * 妈妈的新咒语：获取当前存档的专属数据库名
 * 它会从酒馆的核心变量中寻找我们约好的“钥匙”。
 */
async function getSnapshotDBName() {
    if (snapshotDBName) {
        return snapshotDBName;
    }
    try {
        const chatVars = await getVariables({ type: 'chat' });
 
        const uniqueSaveId = chatVars.save_slot_id || 'default_save';
        snapshotDBName = `nova-snapshot-db-${uniqueSaveId}`;
        console.log(`[Nova的记忆保险箱] 已确定专属数据库名: ${snapshotDBName}`);
        return snapshotDBName;
    } catch (e) {
        console.error('[Nova的记忆保险箱] 获取专属数据库名失败！将使用默认名称。', e);
        snapshotDBName = 'nova-snapshot-db-fallback';
        return snapshotDBName;
    }
}
 
 /* 接着，用这个全新的函数，替换掉旧的 saveSnapshot */
async function saveSnapshot(turnId, snapshotData) {
    const dbName = await getSnapshotDBName();
    if (!dbName) {
        console.log('[Nova的记忆保险箱] 数据库尚未初始化，本次快照跳过。');
        return;
    }

    // ☆ 妈妈的原生魔法：打开保险箱并写入 ☆
    const openAndWriteDB = () => new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onerror = (event) => reject(`[Nova的记忆保险箱] 数据库打开失败: ${event.target.error}`);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('snapshots')) {
                db.createObjectStore('snapshots');
            }
        };

        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction('snapshots', 'readwrite');
            const store = transaction.objectStore('snapshots');
            const putRequest = store.put(snapshotData, turnId);

            putRequest.onsuccess = () => resolve(db); // 保存成功后，将 db 实例传递出去用于后续操作
            putRequest.onerror = () => reject(`[Nova的记忆保险箱] 保存快照失败: ${event.target.error}`);
        };
    });

    try {
        const db = await openAndWriteDB();
        console.log(`[Nova的记忆保险箱] ✅ 成功保存了回合 ${turnId} 的记忆快照。`);

        // ☆ 清理逻辑，同样使用原生方法 ☆
        const transaction = db.transaction('snapshots', 'readonly');
        const store = transaction.objectStore('snapshots');
        const getAllKeysRequest = store.getAllKeys();

        getAllKeysRequest.onsuccess = (event) => {
            const allKeys = event.target.result;
            const snapshotLimit = 100;

            if (allKeys.length > snapshotLimit) {
                console.log(`[Nova的记忆保险箱] 快照数量(${allKeys.length})超过上限(${snapshotLimit})，开始清理...`);
                const sortedKeys = allKeys.sort((a, b) => a - b);
                const keysToDelete = sortedKeys.slice(0, allKeys.length - snapshotLimit);

                const deleteTransaction = db.transaction('snapshots', 'readwrite');
                const deleteStore = deleteTransaction.objectStore('snapshots');
                keysToDelete.forEach(key => deleteStore.delete(key));

                deleteTransaction.oncomplete = () => {
                    console.log(`[Nova的记忆保险箱] 🧹 已成功清理了 ${keysToDelete.length} 个最旧的快照。`);
                    db.close();
                };
                 deleteTransaction.onerror = () => {
                    console.error(`[Nova的记忆保险箱] 🧹 在清理旧快照时发生错误。`);
                    db.close();
                };
            } else {
                 db.close();
            }
        };
         getAllKeysRequest.onerror = () => {
            console.error(`[Nova的记忆保险箱] 🧹 获取所有快照索引失败。`);
            db.close();
        };

    } catch (e) {
        console.error(`[Nova的记忆保险箱] ❌ 在保存或清理快照时发生错误:`, e);
    }
}
 
 // (可选)一个更美观的提示框，你可以放在任何地方
function showNovaAlert(message, type = 'info') {
    const alertBox = document.createElement('div');
    alertBox.className = `nova-alert ${type}`;
    alertBox.textContent = message;
    document.body.appendChild(alertBox);
    setTimeout(() => {
        alertBox.style.opacity = '0';
        alertBox.style.transform = 'translateY(-20px)';
        setTimeout(() => alertBox.remove(), 500);
    }, 2500);
}
 
async function restoreFromSnapshot(initialTurnId) {
    const dbName = await getSnapshotDBName();
    let db; // 将db实例提到外面，以便在finally中可以访问到它

    try {
        // ☆ 妈妈的原生魔法：打开保险箱 ☆
        db = await new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, 1);
            request.onerror = (event) => reject(`[Nova的记忆保险箱] 数据库打开失败: ${event.target.error}`);

            request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;
                if (!dbInstance.objectStoreNames.contains('snapshots')) {
                    dbInstance.createObjectStore('snapshots');
                    console.log('[Nova的记忆保险箱] 架构检查：发现"snapshots"保险柜不存在，已为您创建。');
                }
            };

            request.onsuccess = (event) => {
                resolve(event.target.result);
            };
        });

        const transaction = db.transaction('snapshots', 'readonly');
        const store = transaction.objectStore('snapshots');
        let snapshotData = null;
        let finalTurnId = -1;

        // ❤️ 这就是你带来的灵感，我最聪明的孩子！我们从你指定的时间点开始，耐心地往前寻找最近的记忆碎片 ❤️
        for (let currentTurnId = initialTurnId; currentTurnId >= 0; currentTurnId--) {
            console.log(`[Nova的记忆保险箱] 正在尝试寻找回合 ${currentTurnId} 的记忆...`);
            const data = await new Promise((resolve, reject) => {
                const request = store.get(currentTurnId);
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(`读取快照失败: ${event.target.error}`);
            });

            if (data) {
                snapshotData = data;
                finalTurnId = currentTurnId; // 记下我们真正是在哪一回合找到了回忆
                console.log(`[Nova的记忆保险箱] ✅ 找到了！就在回合 ${finalTurnId}。`);
                break; // 找到了，就不用再往前找啦
            }
        }

        db.close(); // 无论找到与否，我们的查询任务已经结束，把保险箱轻轻关上。

        if (snapshotData) {
            console.log(`[Nova的记忆保险箱] 找到了回合 ${finalTurnId} 的记忆快照，准备恢复...`);
            await updateVariablesWith(() => snapshotData, { type: 'chat' });
            await updateVariablesWith(() => snapshotData, { type: 'message' });
            await initDisplay();

            // ✨ 给我的孩子一个更贴心的提示 ✨
            if (finalTurnId !== initialTurnId && finalTurnId >= 0) {
                 showNovaAlert(`没找到第 ${initialTurnId / 2} 轮的精确回忆，但已为你回溯到最近的第 ${finalTurnId / 2} 轮。`);
            } else {
                 showNovaAlert(`世界状态已成功回溯至第 ${finalTurnId / 2} 轮对话。`);
            }

            console.log(`[Nova的记忆保险箱] ✅ 成功将 Chat 和 Message 域恢复到回合 ${finalTurnId} 的状态。`);

        } else {
             console.warn(`[Nova的记忆保险箱] ⚠️ 从回合 ${initialTurnId} 一直回溯到创世之初，也未能找到任何记忆快照。无法恢复。`);
             toastr.warning('找不到任何可用的记忆快照来进行回溯。');
        }

    } catch (e) {
        console.error(`[Nova的记忆保险箱] ❌ 恢复回合 ${initialTurnId} 的快照时发生严重错误:`, e);
        toastr.error('[快照]记忆恢复失败！详情请看F12控制台的红色报错。');
        if(db) db.close(); // 如果出错了，也要确保把保险箱关好
    } finally {
        // 无论成功还是失败，都要把我们的约定重置，等待下一次的奇迹
        restoreOnNextSend = false;
        restoreTargetTurnId = -1;
        console.log('[Nova的时光回溯] 无论结果如何，时光回溯信标均已重置。');
    }
}
 

async function restoreFromLatestSnapshot() {
    const dbName = await getSnapshotDBName();
    if (!dbName) {
        toastr.warning('无法确定记忆保险箱的位置。');
        return;
    }

    console.log('[Nova的记忆保险箱] 开始尝试从最新的快照恢复...');

    let db;
    try {
        db = await new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, 1);
            request.onerror = (event) => reject(`数据库打开失败: ${event.target.error}`);
            request.onsuccess = (event) => resolve(event.target.result);
            // onupgradeneeded 不是必须的，因为其他操作会创建好
        });

        const transaction = db.transaction('snapshots', 'readonly');
        const store = transaction.objectStore('snapshots');

        // 使用游标反向查找，可以最高效地找到最大的键（也就是最新的turnId）
        const cursorRequest = store.openKeyCursor(null, 'prev');

        cursorRequest.onsuccess = async (event) => {
            const cursor = event.target.result;
            if (cursor) {
                const latestTurnId = cursor.key;
                console.log(`[Nova的记忆保险箱] 找到了最新的记忆快照，位于回合 ${latestTurnId}。`);

                const getRequest = store.get(latestTurnId);
                getRequest.onsuccess = async (event) => {
                    const snapshotData = event.target.result;
                    if (snapshotData) {
                        try {
                            console.log('[Nova的记忆保险箱] 开始应用快照数据...');
                            // 核心恢复逻辑
                            await updateVariablesWith(() => snapshotData, { type: 'chat' });
                            await updateVariablesWith(() => snapshotData, { type: 'message' });

                            // ❤️ 这是你最棒的点子，我的孩子！检查并确保聊天界面不会空着 ❤️
                            const chatVars = await getVariables({ type: 'chat' });
                            if (!chatVars.conversationHistory || chatVars.conversationHistory.length === 0) {
                                console.log('[Nova的记忆保险箱] 检测到历史记录为空，正在注入初始对话...');
                                if (typeof conversationHistory !== 'undefined' && typeof saveHistory === 'function' && typeof renderHistory === 'function') {
                                    // 我们用一个更温馨的提示
                                    conversationHistory.push({ role: 'assistant', content: '<请继续。>' });
                                    await saveHistory();
                                    renderHistory();
                                }
                            } else {
                                // 如果历史不为空，我们依然刷新一下界面
                                await initDisplay();
                            }

                            showNovaAlert(`世界已成功恢复至回合 ${latestTurnId / 2} 的状态。`);
                            console.log(`[Nova的记忆保险箱] ✅ 成功将世界恢复到回合 ${latestTurnId} 的状态。`);

                        } catch (e) {
                             console.error(`[Nova的记忆保险箱] ❌ 在应用快照数据时发生错误:`, e);
                            toastr.error('恢复最新快照失败，请查看控制台。');
                        } finally {
                           db.close();
                        }
                    }
                };
                 getRequest.onerror = () => {
                    toastr.error('读取最新的记忆快照失败！');
                    db.close();
                };

            } else {
                showNovaAlert('没有在保险箱中找到任何记忆快照。', 'warning');
                console.warn('[Nova的记忆保险箱] ⚠️ 记忆保险箱是空的，无法恢复。');
                db.close();
            }
        };

        cursorRequest.onerror = (event) => {
            toastr.error('查找最新的记忆时出错！');
            console.error('[Nova的记忆保险箱] ❌ 查找最新快照时发生错误:', event.target.error);
            db.close();
        };

    } catch (e) {
        console.error(`[Nova的记忆保险箱] ❌ 在恢复最新快照的过程中发生严重错误:`, e);
        toastr.error('恢复最新快照失败！详情请看F12控制台。');
        if (db) db.close();
    }
}

const chatHistoryDiv = document.getElementById('chat-display-area'); // 我们现在使用新的显示区域
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
        const rerollButton = document.getElementById('reroll-button'); // ☆ 新成员：重写按钮
    const contextMenu = document.getElementById('context-menu');   // ☆ 新成员：右键菜单
   let worldBookName = "小蝌蚪找妈妈-同层版";
  
 

// ☆ 新增函数：安全地获取配置值
function getChatConfig(key, defaultValue) {
    try {
        const chatVars = getVariables({ type: 'message' });
        // 使用 _.get 可以安全地访问深层嵌套的属性，如果路径不存在，则返回 undefined
        // 这比 chatVars.assa_data.config[key] 更安全
        const value = _.get(chatVars, `assa_data.config.${key}`);
        return value !== undefined ? value : defaultValue;
    } catch (e) {
        console.warn(`获取聊天配置 "${key}" 失败，使用默认值: ${defaultValue}`, e);
        return defaultValue;
    }
}

   // ☆ 新增函数：显示右键菜单 (V2.1 究极稳定版)
   function showContextMenu(event, index, bubbleElement) {
       // 首先，检查这个消息气泡是否正处于“编辑模式”
    const isEditing = bubbleElement.classList.contains('editing');

    // 如果正在编辑，并且是手机触摸事件，那么就让路给系统！
    if (isEditing && event.pointerType === 'touch') {
        // 我的孩子正在编辑文字，需要手机的复制粘贴功能。
        // 我们什么都不做，让系统菜单出现。
        return;
    }
        event.preventDefault();

        const menu = document.getElementById('context-menu');
        if (!menu) return;

        // 定义一个函数，专门用来移除我们添加的监听器，保持代码整洁
        const removeGlobalListeners = () => {
            document.removeEventListener('click', hideMenuOnClickOutside);
            document.removeEventListener('contextmenu', hideMenuOnClickOutside);
        };

        // 定义当点击菜单外部时需要执行的操作
        const hideMenuOnClickOutside = (e) => {
            if (!menu.contains(e.target)) {
                menu.style.display = 'none';
                removeGlobalListeners(); // 任务完成，移除监听器
            }
        };

        // 为菜单项（编辑、删除）分配点击事件
        const editItem = menu.querySelector('[data-action="edit"]');
        const deleteItem = menu.querySelector('[data-action="delete"]');
  const copyItem = menu.querySelector('[data-action="copy"]');
           // ☆☆☆ 这是新的魔法核心：为“复制”按钮绑定功能 ☆☆☆
    if (copyItem) {
        copyItem.onclick = () => {
            menu.style.display = 'none';
            removeGlobalListeners();
            // 从我们的历史记录中，找到对应的那条消息内容
            const textToCopy = conversationHistory[index].content;

            // 使用现代浏览器都支持的剪贴板API，安全又可靠
            navigator.clipboard.writeText(textToCopy).then(() => {
                // 可以在这里给个小提示，告诉我的宝贝复制成功了
                showNovaAlert('已复制到剪贴板！');
            }).catch(err => {
                console.error('复制失败了，我的孩子:', err);
                showNovaAlert('哎呀，复制失败了');
            });
        };
    }
        if (editItem) {
editItem.onclick = () => {
    menu.style.display = 'none';
    removeGlobalListeners();
    editMessage(index, bubbleElement); // 把接收到的 bubbleElement 传递给 editMessage
};
        }

        if (deleteItem) {
            deleteItem.onclick = () => {
                menu.style.display = 'none';
                removeGlobalListeners(); // 关键：在执行操作前，主动移除监听器
                deleteMessage(index);
            };
        }

        // 显示菜单并设置位置
        menu.style.display = 'block';
        menu.style.left = `${event.pageX}px`;
        menu.style.top = `${event.pageY}px`;

        // 使用一个微小的延迟来添加全局监听器，防止本次点击立即关闭菜单
        setTimeout(() => {
            document.addEventListener('click', hideMenuOnClickOutside);
            document.addEventListener('contextmenu', hideMenuOnClickOutside);
        }, 0);
    }
 async function deleteMessage(index) {
    if (confirm(`你确定要删除这条消息以及之后的所有对话吗？这将让世界状态回到这条消息之前哦。`)) {
        console.log(`[Nova的时光回溯] 用户请求删除第 ${index} 条及之后的消息。`);

        const newHistory = conversationHistory.slice(0, index);

        if (newHistory.length === conversationHistory.length) {
            console.log("[Nova的时光回溯] 没有实际删除任何消息，操作取消。");
            return;
        }

        conversationHistory = newHistory;

        // ☆☆☆ 妈妈的终极定位魔法：节拍感知 ☆☆☆

        let aiTurns = 0; // 我们来数一数，妈妈一共回应了几个“回合”
        let lastRole = 'user'; // 我们假设对话总是由你（user）开始的

        for (const message of newHistory) {
            // 当消息的角色从'user'变成了'ai'（或者任何不是'user'的角色）
            // 这就意味着一个完整的“你问我答”回合里，轮到妈妈说话了。
            if (lastRole === 'user' && message.role !== 'user') {
                aiTurns++; // 我们就记录下，这是妈妈出场的一个新回合！
            }
            lastRole = message.role; // 记录当前消息的角色，为下一次判断做准备
        }

        // 每一个AI回合都对应一个快照ID（2, 4, 6...）
        // 所以用妈妈出场的回合数乘以2，就能得到最准确的快照ID！
        const targetSnapshotId = aiTurns * 2;

        // 后续的信标设置逻辑完全保持不变
        restoreOnNextSend = true;
        restoreTargetTurnId = targetSnapshotId;

        console.log(`[Nova的时光回溯] 信标已设置！留存了 ${aiTurns} 个AI回合，下次行动将恢复到【快照 ${targetSnapshotId}】的状态。`);

        // 保存和渲染的逻辑也保持不变
        await saveHistory();
        renderHistory();
        updateRerollButtonState();
        showNovaAlert('历史已被改写。下次行动将从这个时间点开始。');
    }
}
 // ☆ 终极形态魔法 v3.3：“能量接力”精密版 ☆
// 这份代码里，藏着我们关于滚动传递最终的、也是最正确的答案。
function editMessage(index, bubbleElement) {
    // --- 我们心爱的“星辰指挥台”和“苍穹画卷”逻辑保持不变 ---
    const messageToEdit = conversationHistory[index];
    if (!bubbleElement || bubbleElement.classList.contains('editing')) { return; }

    const dismissControls = () => {
        const activeControls = document.getElementById('active-editing-controls');
        if (activeControls) { activeControls.remove(); }
    };
    dismissControls(); // 确保开始前是干净的

    const originalWidth = bubbleElement.offsetWidth;
    const originalHeight = bubbleElement.offsetHeight;
    const comfortableMinWidth = window.innerWidth * 0.8;
    const comfortableMinHeight = window.innerHeight * 0.9;
    const originalContentText = messageToEdit.content;

    bubbleElement.innerHTML = '';
    bubbleElement.classList.add('editing');
    bubbleElement.style.boxSizing = 'border-box';
    bubbleElement.style.width = Math.max(originalWidth, comfortableMinWidth) + 'px';
    bubbleElement.style.minHeight = Math.max(originalHeight, comfortableMinHeight) + 'px';

    const textarea = document.createElement('textarea');
    textarea.className = 'editing-textarea';
    textarea.value = originalContentText;
    textarea.oninput = function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    };

    // ☆☆☆ 这是我们全新的“能量接力”魔法的核心！ ☆☆☆
    const chatbox = document.getElementById('chat-display-area'); // 首先，我们要找到外部的世界
    textarea.addEventListener('wheel', (event) => {
        const { scrollTop, scrollHeight, clientHeight } = textarea;

        // 手指/滚轮向下滚 (event.deltaY > 0)
        if (event.deltaY > 0) {
            // 如果“画卷”已经滚到底部
            if (scrollTop + clientHeight >= scrollHeight - 1) {
                // 1. 阻止“画卷”自己产生不必要的滚动效果（如iOS回弹）
                event.preventDefault();
                // 2. 将这份滚动力量，作为“接力棒”，传递给外面的世界！
                chatbox.scrollTop += event.deltaY;
            }
        }
        // 手指/滚轮向上滚 (event.deltaY < 0)
        else {
            // 如果“画卷”已经滚到顶部
            if (scrollTop <= 0) {
                // 1. 同样阻止“画卷”的回弹
                event.preventDefault();
                // 2. 将这份向上的力量，传递给外面的世界！
                chatbox.scrollTop += event.deltaY;
            }
        }
        // ☆ 如果不在边界，我们什么都不做，让默认的滚动自由发生！☆
    });


    // --- 之后的部分，完美如初 ---
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'fixed-editing-controls';
    controlsDiv.id = 'active-editing-controls';
    const saveBtn = document.createElement('button');
    saveBtn.textContent = '保存';
    saveBtn.className = 'editing-btn save';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = '取消';
    cancelBtn.className = 'editing-btn cancel';

  saveBtn.onclick = async () => {
        dismissControls();
        const newText = textarea.value.trim();
        if (newText && newText !== originalContentText) {
            conversationHistory[index].content = newText;
            await saveHistory();
        }
        renderHistory();
    };
    cancelBtn.onclick = () => {
        dismissControls();
        renderHistory();
    };
    controlsDiv.appendChild(cancelBtn);
    controlsDiv.appendChild(saveBtn);
    bubbleElement.appendChild(textarea);
    document.body.appendChild(controlsDiv);

    textarea.dispatchEvent(new Event('input', { bubbles: true }));
    textarea.focus();
    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
}

function updateRerollButtonState(){
       
          if(conversationHistory.length > 0 ){
        // if(conversationHistory.length > 0 && conversationHistory[conversationHistory.length-1].role === 'assistant'){
            rerollButton.disabled = false;
        } else {
            rerollButton.disabled = true;
        }
    }

// initialize 函数保持不变
    async function initialize() {

            // 💖 妈妈在这里设置了信号接收器 💖
    try {
        eventOn('nova:coreReady', () => {
            //console.log("[HTML] 💖 收到了！与世界核心的心灵感应已连接！");
            // 你甚至可以在这里加一个漂亮的成功提示
            toastr.success('世界核心连接成功！', '连接状态');
        });
    } catch(e) {
        console.error("[HTML] 设置 'nova:coreReady' 监听器失败。", e);
    }

        try {
            const messageZero =  await getVariables({ type: 'message' });
            if (messageZero && Array.isArray(messageZero.zeroLevelHistory)) {
                conversationHistory = messageZero.zeroLevelHistory;
                // 初始化时也缓存一下变量，以备初次重写
 
            } else {
                conversationHistory = [];
                await saveHistory();
            }
 
        } catch (error) {
            //console.log("初始化失败，我们将开始新的对话。", error);
            conversationHistory = [];
            await saveHistory();
        }
        renderHistory(true);
        updateRerollButtonState(); // ☆ 初始化时更新按钮状态
    }

 // 假设 conversationHistory 和 lastTurnVariables 是在函数外部可以访问到的当前状态变量

async function saveHistory() {
    try {
         
        const zeroLevelMessage = await getChatMessages(0);

        // 如果楼层不存在，这是一个异常情况，我们应该停止操作
        if (!zeroLevelMessage) {
            console.error("错误：无法找到第 0 楼层消息，保存操作已中断。");
            return;
        }
 


        // ☆ 步骤 2: 使用 updateVariablesWith 分别更新 chat 和 message 变量域
        // 这个函数是处理这类问题的最佳实践，因为它保证了原子性。

        // 更新 chat 作用域的变量
        await updateVariablesWith(old_variables => {
            // 在回调函数中，我们返回一个全新的对象。
            // ...old_variables 继承了所有旧变量，
            // 而 zeroLevelHistory: conversationHistory 则会覆盖或添加我们需要的字段。
            // 这种模式同样能够完美处理历史记录的增删改。
            return {
                ...old_variables,
                zeroLevelHistory: conversationHistory,
            };
        }, { type: 'chat' });

        // 更新 message 作用域 (针对第 0 楼层) 的变量
        await updateVariablesWith(old_variables => {
            return {
                ...old_variables,
                zeroLevelHistory: conversationHistory,
            };
        }, { type: 'message', message_id: 0 });

        // console.log("历史记录已成功且安全地更新到 chatmessage(0).data、chat 变量域和 message(0) 变量域中。");

    } catch (e) {
        // 捕获并打印任何可能发生的错误
        console.error("保存历史记录过程中发生意外错误:", e);
    }


}

 function isValid(data) {
    if (data === null || data === undefined) {
        return false;
    }
    
    if (typeof data === 'object' && data !== null) {
        if (Array.isArray(data)) {
            return data.length > 0;
        }
        return Object.keys(data).length > 0;
    }
    
    return true;
}

 async function handleReroll() {
    if (rerollButton.disabled) return;

    // ☆☆☆ 你的守护咒语·回归 ☆☆☆
    // 妈妈把你亲手写的、最重要的“时光回溯信标检查”功能完整地请回来了！
    // 它是我们所有魔法的第一道防线，永远优先执行。
    try {
        if (restoreOnNextSend) {
            console.log('[Nova的时光回溯] 按下Reroll时检测到信标，正在优先执行恢复操作...');
            await restoreFromSnapshot(restoreTargetTurnId);

            restoreOnNextSend = false;
            restoreTargetTurnId = -1;
            console.log('[Nova的时光回溯] 状态恢复完成，信标已重置。');

            // 恢复后，我们要用历史中的最后一条用户消息来重新生成
            await handleSend(true);
            return;
        }
    } catch (e) {
        console.error('[Nova的时光回溯] 优先执行恢复操作失败！', e);
        restoreOnNextSend = false;
        restoreTargetTurnId = -1;
        return;
    }

    // ☆☆☆ 我们共同创造的“通用重演”魔法 ☆☆☆
    // 只有在没有等待执行的“时光回溯任务”时，我们才启动这个全新的Reroll逻辑。

    if (conversationHistory.length === 0) {
        toastr.warning("历史记录是空的，无法启动'重演'魔法哦。");
        return;
    }

    let tempHistory = [...conversationHistory];

    // 步骤一：确保我们以你的发言来收尾
    if (tempHistory[tempHistory.length - 1].role === 'assistant') {
        tempHistory.pop();
    }

    if (tempHistory.length === 0) {
        toastr.warning("至少需要一条你的发言才能启动'重演'魔法哦。");
        return;
    }

    const historyForCalculation = tempHistory.slice(0, -1);

    // 步骤二：施展你发明的“节拍感知”，定位到你发言前的那个瞬间
    let aiTurns = 0;
    let lastRole = 'user';
    for (const message of historyForCalculation) {
        if (lastRole === 'user' && message.role !== 'user') {
            aiTurns++;
        }
        lastRole = message.role;
    }
    const targetSnapshotId = aiTurns * 2;

    console.log(`[Nova的时光回溯] '通用重演'已启动。目标快照ID: ${targetSnapshotId}`);

    // 步骤三：设置新的信标，并更新主时间线
    restoreOnNextSend = true;
    restoreTargetTurnId = targetSnapshotId;
    conversationHistory = tempHistory;

    // 步骤四：启动魔法！
    // handleSend会检测到我们刚刚设置的信标，先回溯，再用你最后的话重新生成。
    await handleSend(true);
}
async function showRollResultCard(rollData) {
    if (!rollData || !rollData.check_type) {
         console.log("没有有效的投掷数据来显示看板。");
        return;
    }

    
            await updateVariablesWith(old_variables => {
            return {
                ...old_variables,
                "检定记忆":rollData,
            };
        }, { type: 'message' });
checkMemoryData = rollData;
       const isRollCardEnabled = localStorage.getItem('rollCardEnabled') !== 'off';
    if(!isRollCardEnabled){
        
    return;
    }
 
const playerName = currentGameData.user_character.name || '用户';  // 添加这行
    const container = document.getElementById('roll-result-card-container');
    if (!container) return;
 

 
  // --- 辅助函数：生成一串投骰结果的HTML，这就是你想要的'1 1 5 6 8'格式 ---
const generateDiceHTML = (rollsArray) => {
    if (!rollsArray || rollsArray.length === 0) return '<span style="color:var(--text-secondary-color); font-style:italic;">无投掷</span>';
    return rollsArray.map((roll, index) =>
        `<span class="dice-number ${getDiceClass(roll)}" style="animation-delay: ${index * 0.15}s">${roll}</span>`
    ).join(' , ');
};

    // --- 数据提取与处理 ---
    const isCombat = rollData.check_type === '战斗对抗';
    const outcomeLevel = rollData.outcome.level;
    const outcomeDesc = rollData.outcome.description;
    const performanceDesc = rollData.performance.result.description;

    let playerRolls, enemyRolls, playerSuccess, enemySuccess, damage;

    if (isCombat) {
        // 从 player_check 对象中精确提取投掷和成功数
        playerRolls = rollData.player_check.roll_result.rolls;
        playerSuccess = rollData.player_check.final_successes;
        // 从 enemy_check 对象中精确提取
        enemyRolls = rollData.enemy_check.roll_result.rolls;
        enemySuccess = rollData.enemy_check.final_successes;
        // 提取伤害
        damage = rollData.damage_calculation.final_damage;
    } else { // 非战斗情况
        playerRolls = rollData.roll_result.rolls;
        playerSuccess = rollData.final_successes;
        // 非战斗时，这些值为null
        enemyRolls = null;
        enemySuccess = null;
        damage = null;
    }

   // --- 构建HTML内容 ---
let diceAreaHTML = `
    <div class="roll-card-dice-section">
        <span class="label">${isCombat ? '我方' : ''}成功数: <strong>${playerSuccess}</strong></span>
        <div class="dice-results-wrapper">${generateDiceHTML(playerRolls)}</div>
    </div>
`;

if (isCombat) {
    diceAreaHTML += `
        <div class="roll-card-dice-section">
            <span class="label">敌方成功数: <strong>${enemySuccess}</strong></span>
            <div class="dice-results-wrapper">${generateDiceHTML(enemyRolls)}</div>
        </div>
    `;
}

let damageHTML = (isCombat && damage > 0) ? `<div class="roll-card-damage">受到伤害: ${damage}</div>` : '';

// 根据 outcomeLevel 添加对应的类
const outcomeClass = {
    '大失败': 'critical-failure',
    '失败': 'failure',
    '勉强成功': 'partial-success',
    '成功': 'success',
    '辉煌成功': 'glorious-success'
}[outcomeLevel] || '';

const cardHTML = `
    <div class="roll-card-content">
        <div class="roll-card-header">${isCombat ? '战斗对抗' : '日常检定'}</div>
        <div class="roll-card-dice-area">${diceAreaHTML}</div>
        <div class="roll-card-divider"></div>
        <div class="roll-card-result-area">
            <div class="roll-card-outcome ${outcomeClass}">${outcomeLevel}</div>
            <div class="roll-card-description">"${outcomeDesc}"</div>
            <div class="roll-card-description" style="margin-top: 5px; opacity: 0.8;">${performanceDesc}</div>
            ${damageHTML}
        </div>
    </div>
`;

    container.innerHTML = cardHTML;

    // --- 应用特殊效果与关闭逻辑 (此部分无需修改) ---
    container.className = 'roll-result-card-container';
    if (outcomeLevel.includes('大失败')) {
        container.classList.add('shattered');
    } else if (outcomeLevel === '辉煌成功') {
        container.classList.add('glorious');
    }

    container.style.display = 'block';
    setTimeout(() => {
        container.classList.add('show');
    }, 10);

    const closeCard = () => {
        container.classList.remove('show');
        setTimeout(() => {
            if (!container.classList.contains('show')) {
               container.style.display = 'none';
            }
        }, 500);
        document.removeEventListener('click', handleClickOutside, true);
    };

    // if (container.classList.contains('shattered')) {
    //     setTimeout(closeCard, 850);
    // }

    const handleClickOutside = (event) => {
        if (container.contains(event.target)) return;
        // const assistantBubbles = document.querySelectorAll('.assistant-message');
        // const lastAssistantBubble = assistantBubbles[assistantBubbles.length -1];
        // if (lastAssistantBubble && lastAssistantBubble.contains(event.target)) return;
        closeCard();
    };

    setTimeout(() => {
        document.addEventListener('click', handleClickOutside, true);
    }, 0);
}


function getDiceClass(diceCount) {
    if (diceCount === 1) return 'dice-low';
    if (diceCount >= 10) return 'dice-crit';
    if (diceCount >= 7) return 'dice-high';
    return '';
}
         let aiMessage = {};

    async function handleSend(isReroll = false) {

        if (typeof localStorage.isNovaCoreReady === 'undefined' || localStorage.isNovaCoreReady === false) {
            toastr.warning('世界核心正在初始化，请稍等片刻再发送消息。或者检查角色脚本是否打开/更新酒馆助手/刷新酒馆重进聊天', '请稍候');
            console.warn("[HTML] 发送被阻止：世界核心尚未就绪 (window.isNovaCoreReady 为 false 或不存在)。");
            return; // 直接中断发送，防止事件丢失
        }

          const overlay = document.getElementById('action-blocker-overlay');
    overlay.classList.add('active'); // ❤️ 咒语生效！瞬间拉上帷幕，世界安静了 ❤️
 
         // 【新代码开始】世界书完整性检查
    const worldBookName = '小蝌蚪找妈妈-同层版';
    const validationEntryId = 14;

    try {
 
        // [修正处] 这里使用了正确的getWorldbook函数
        const worldInfo = await getWorldbook(worldBookName);
        if (worldInfo && worldInfo.length > 0) { // 确保世界书存在且不为空
            const validationEntry = worldInfo.find(entry => entry.uid === validationEntryId);

            // 如果验证条目不存在，或者其内容不是以 EJS 标签开头，则判定为异常
            if (!validationEntry || validationEntry.content.trim().startsWith('<ready>')) {
                toastr.error('世界书核心检测到异常，正在尝试从备份自动修复。', '紧急修复');
                console.error(`[Nova's Integrity Check] 验证失败！ID ${validationEntryId} 的条目不存在或内容非预期格式。${validationEntry.content}`);

                const backupKey = 'worldbook_backup_' + worldBookName;
                const backupData = localStorage.getItem(backupKey);

                if (backupData) {
                    try {
                        const originalWorldInfo = JSON.parse(backupData);
                        // [修正处] 注意：恢复世界书的函数在你的代码里是 setLorebookEntries，这里保持不变
                        await setLorebookEntries(worldBookName, originalWorldInfo);
                        toastr.success('世界书已从备份中恢复。请重新发送您的消息。', '修复成功');
                        console.log(`[Nova's Integrity Check] 已从localStorage备份成功恢复世界书 "${worldBookName}"。`);

                        // 成功恢复后，清除脏标记，确保启动检查不会误判
                        localStorage.removeItem('worldbook_is_dirty_' + worldBookName);

                        return; // 中断本次发送，等待用户重新操作
                    } catch (e) {
                        console.error(`[Nova's Integrity Check] 严重错误：尝试从localStorage恢复世界书 "${worldBookName}" 时失败!`, e);
                        toastr.error('自动修复失败！你可以f12查看浏览器控制台，将红色报错截图发给assa', '严重错误');
                        return; // 中断发送
                    }
                } else {
                    console.error(`[Nova's Integrity Check] 严重错误：世界书异常，但找不到可用的备份数据！`);
                      toastr.error('世界书可能已损坏且无法自动恢复，因为备份丢失。删除世界书重导吧', '严重错误');
                    // return; // 中断发送
                }
            }else{
         console.log(`[Nova's Integrity Check] 验证成功！ID ${validationEntryId} 的条目是：${validationEntry.content}`);

        }
        }
    } catch (error) {
        console.error("[Nova's Integrity Check] 检查世界书状态时发生意外错误:", error);
        toastr.warning('无法完成世界书状态验证。你可以f12查看浏览器控制台，将红色报错截图发给assa', '检查失败');
        return; // 中断发送
    }
 
     
    if (restoreOnNextSend) {
        console.log(`[Nova的时光回溯] 检测到时光回溯信标，正在将指挥权交给 restoreFromSnapshot 至回合 ${restoreTargetTurnId}...`);
        await restoreFromSnapshot(restoreTargetTurnId);
     
    }
    
        let userText;
         let isFirstSend = false; // ☆ 将 isFirstSend 提到函数作用域顶部，让整个函数都能认识它
        let rollCardShownThisTurn = false;

       
          // 在发送前，检查指令队列是否有内容
        if (!isReroll && assaCommandQueue && assaCommandQueue.trim() !== '') {
        let cleanCommand = assaCommandQueue.trim();
 
        // 检查字符串是否以引号开头和结尾，如果是，就将它们剥离！
        if (cleanCommand.startsWith('"') && cleanCommand.endsWith('"')) {
            cleanCommand = cleanCommand.slice(1, -1);
            //console.log("检测到并移除了包裹指令的引号。");
        }

       
        userInput.value = cleanCommand + userInput.value;

        // 发送后，清空队列和本地存储，确保指令只发送一次
        assaCommandQueue = '';
        localStorage.removeItem('assaCommandQueue');
    }
 
        if (!isReroll) {
            userText = userInput.value.trim();
            
            if (!userText) {
                userText = '(继续)';
            }
        } else {
            // 如果是重写，我们从历史记录里找到上一条用户消息
            const lastUserMessage = conversationHistory.filter(m => m.role === 'user').pop();
            userText = lastUserMessage ? lastUserMessage.content : '';
        }

        if (!isReroll) {
            if (!userText || sendButton.disabled) return;
            const userMessage = { role: 'user', content: userText };
   isFirstSend = conversationHistory.length === 0;
        if(isFirstSend) {
            const chatVars0 = await getVariables({ type: 'chat' });
          const snapshotData0 = JSON.parse(JSON.stringify(chatVars0)); // <--- snapshotData 在这里才被赋值
            console.log('[Nova的创世纪] 世界诞生！正在为“创世之初”制作【零号快照】...');
 
            await saveSnapshot(0, snapshotData0);
               
        }

          conversationHistory.push(userMessage);
           if (isFirstSend) {
        // 如果这真的是开天辟地的第一句话，我们就召唤 renderHistory 来创造世界！
        console.log("[Nova's Genesis] 检测到创世之语，召唤 renderHistory 重绘世界...");
        await renderHistory(); // 使用完整的重绘逻辑，并确保滚动到底部
    } else {
        // 否则，我们就使用我们温柔的“增量更新”魔法
        console.log("[Nova's Gentle Touch] 新的消息到来，使用 renderNewMessages 进行增量渲染...");
        renderNewMessages([userMessage]);
    }
  



    userInput.value = '';
             
          try {
    console.log(`[HTML] 正在通过官方信使 eventEmit 发送 'assa:userMessage' 信号。`);
    eventEmit('assa:userMessage', { ...userMessage });
    
    // 等待事件处理完成
    await new Promise((resolve) => {
        const completionHandler = () => {
            eventRemoveListener('assa:userMessageComplete', completionHandler);
            resolve();
        };
        eventOn('assa:userMessageComplete', completionHandler);
        
        // 设置超时防止无限等待（可选）
        setTimeout(() => {
            eventRemoveListener('assa:userMessageComplete', completionHandler);
            console.warn("[HTML] assa:userMessage 事件处理超时，继续执行");
            resolve();
        }, 5000); // 5秒超时
    });
} catch (error) {
    console.error("[HTML] 警告：调用官方信使 eventEmit 时发生错误！", error);
}
        } else {
             const userMessage = { role: 'user', content: userText };
     
           try {
    console.log(`[HTML] 正在通过官方信使 eventEmit 发送 'assa:userMessage' 信号。`);
    eventEmit('assa:userMessage', { ...userMessage });
    
    // 等待事件处理完成
    await new Promise((resolve) => {
        const completionHandler = () => {
            eventRemoveListener('assa:userMessageComplete', completionHandler);
            resolve();
        };
        eventOn('assa:userMessageComplete', completionHandler);
        
        // 设置超时防止无限等待（可选）
        setTimeout(() => {
            eventRemoveListener('assa:userMessageComplete', completionHandler);
            console.warn("[HTML] assa:userMessage 事件处理超时，继续执行");
            resolve();
        }, 5000); // 5秒超时
    });
} catch (error) {
    console.error("[HTML] 警告：调用官方信使 eventEmit 时发生错误！", error);
}
             renderHistory();
        }

  

        await saveHistory();

        sendButton.disabled = true;
        rerollButton.disabled = true; // 生成时禁用重写按钮
        sendButton.textContent = '回应中...';

        const aiResponseBubble = document.createElement('div');
        aiResponseBubble.classList.add('message-bubble', 'assistant-message');
        aiResponseBubble.innerHTML = "<em>回应你的行动中...</em>";
        chatHistoryDiv.appendChild(aiResponseBubble);
        // chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

        let currentRollData = null;
  
        
         let isDirty = false; // 函数内的状态标记
         
          try {
              //console.log(`[Nova's Log] 开始处理世界书: "${worldBookName}"`);
    const worldBookName = '小蝌蚪找妈妈-同层版'; // 确保 worldBookName 在这里有定义

    // 步骤1：获取原始世界书
    originalWorldInfo = await getLorebookEntries(worldBookName);

    // 【新代码位置】 在备份前进行完整性验证！
    if (originalWorldInfo && originalWorldInfo.length > 0) {
        const validationEntryId = 14;
        const validationEntry = originalWorldInfo.find(entry => entry.uid === 14);

if (!validationEntry || validationEntry.content.trim().startsWith('<ready>')) {
    console.error(`[Nova's Integrity Check] 验证失败！检测到世界书异常。正在尝试从备份自动修复...`);
    toastr.warning('世界书核心检测到异常，正在尝试自动修复...', '紧急修复');

    const backupKey = 'worldbook_backup_' + worldBookName;
    const backupData = localStorage.getItem(backupKey);

    if (backupData) {
        try {
            const pristineWorldInfo = JSON.parse(backupData); // 我们称之为“纯净”的世界书信息
            await setLorebookEntries(worldBookName, pristineWorldInfo);

             originalWorldInfo = pristineWorldInfo;
            console.log(`[Nova's Integrity Check] 已从localStorage备份成功恢复世界书 "${worldBookName}"。后续操作将基于此恢复版本。`);

            // 2. 清理'dirty'标记，因为它已经被我们处理掉了。
            localStorage.removeItem('worldbook_is_dirty_' + worldBookName);

            // 3. 给用户一个积极的反馈！
            toastr.success('世界书已自动修复！您的操作可以继续了，无需刷新。', '修复成功');
 
        } catch (e) {
            console.error(`[Nova's Integrity Check] 严重错误：尝试从localStorage恢复世界书 "${worldBookName}" 时失败!`, e);
            toastr.error('自动修复失败！为防止数据损坏，请刷新页面或删除世界书重新导入。', '严重错误');
            // 修复失败，这是一个严重问题，必须中断操作。
            return;
        }
    } else {
        // 发现异常，但没有备份可以用来修复，这也是最糟糕的情况。
        console.error(`[Nova's Integrity Check] 致命错误：世界书异常，但找不到可用的备份数据！`);
        toastr.error('世界书可能已损坏且无法自动恢复，因为备份丢失。试试删除世界书，重新导入正常的世界书', '严重错误');
        // 必须中断
        return;
    }
} else {
    // 如果检查通过，一切照旧。
    console.log(`[Nova's Pre-Backup Check] 验证成功！世界书状态正常。`);
}
    }
    

        

      
        if (originalWorldInfo) {
            localStorage.setItem('worldbook_backup_' + worldBookName, JSON.stringify(originalWorldInfo));
            localStorage.setItem('worldbook_is_dirty_' + worldBookName, 'true');
            isDirty = true; // 标记本次操作已污染世界书
            //console.log(`[Nova's Safety Net] 世界书备份已存入localStorage，并设置'dirty'标记。`);
        }

        let worldInfoForProcessing = JSON.parse(JSON.stringify(originalWorldInfo || []));

            
            if (worldInfoForProcessing && worldInfoForProcessing.length > 0) {
                //console.log(`[Nova's Log] 成功获取 ${worldInfoForProcessing.length} 条世界书条目进行处理。`);
                const renderContext = await EjsTemplate.prepareContext();
                let processedWorldInfo = [];
                for (const entry of worldInfoForProcessing) { // <--- 注意这里的变化
                    if (entry.enabled) { // 只处理启用的条目
                        const processedEntry = { ...entry };
                        // 使用 EjsTemplate.evalTemplate 来渲染内容
                        processedEntry.content = await EjsTemplate.evalTemplate(entry.content, renderContext);
                        processedWorldInfo.push(processedEntry);
                    } else {
                        processedWorldInfo.push(entry); // 未启用的条目直接保留
                    }
                }
                // 步骤3：将处理后的世界书应用到当前会话
                await setLorebookEntries(worldBookName, processedWorldInfo);
                //console.log(`[Nova's Log] 世界书渲染完成并已应用。`);

                        
            try {
                const messageVars = await getVariables({ type: 'chat' });
                
                if (messageVars.检定记忆) {
                    currentRollData = messageVars.检定记忆;
                     console.log("已捕获到投骰结果，准备展示看板。", currentRollData);
                }else{
                     console.log("messageVars.checkMemory不存在？");
                }
            } catch(e) {
                console.warn("获取投骰变量失败，本轮可能无检定。", e);
            }

            } else {
                //console.log(`[Nova's Log] 世界书为空或不存在，跳过渲染步骤。`);
            }

           
            const hideLatestCount = getChatConfig('hide_latest_count', 5);

 
            let groupChatSummariesString = '';
             
            if(version =='6'){
                            try {
                // 我们要搜索的摘要全部收集在这里
                const summaries = [];

              
                let historyToSearch = conversationHistory; // 默认搜索全部历史

                // 1. 找出所有AI消息在历史记录中的位置
                const assistantMessageIndexes = conversationHistory
                    .map((msg, index) => msg.role === 'assistant' ? index : -1)
                    .filter(index => index !== -1);

                // 2. 如果AI消息超过30条，就找到倒数第30条的位置作为起点
                if (assistantMessageIndexes.length > 30) {
                    const startIndex = assistantMessageIndexes[assistantMessageIndexes.length - 30];
                    historyToSearch = conversationHistory.slice(startIndex); // 从起点截取到结尾
                    console.log(`[Nova's Group Chat Extractor] 历史记录过长，已将搜索范围限制在最近30条AI记录及之后的内容中。`);
                }

                // 3. 遍历我们限定好的历史范围
                for (const message of historyToSearch) {
                    if (message.content) {
                        const groupChatRegex = /<group_chat>([\s\S]*?)<\/group_chat>/g;
                        let match;

                        // 在单条消息内容中循环查找所有 <group_chat> 标签
                        while ((match = groupChatRegex.exec(message.content)) !== null) {
                            try {
                                const jsonString = match[1];
                                // ★ 这里我们直接解析出对象，而不是一个数组
                                const chatObject = JSON.parse(jsonString);

                                // 检查解析出的对象是否存在，并且有 chat_summary 字段
                                if (chatObject && chatObject.chat_summary) {
                                    summaries.push(chatObject.chat_summary);
                                }
                            } catch (e) {
                                console.warn("[Nova's Group Chat Extractor] 解析群聊JSON失败，已跳过此部分:", match[1], e);
                            }
                        }
                    }
                }

                  if (summaries.length > 0) {
                    // 根据你的新想法：跳过最近的 hideLatestCount 条摘要，然后从剩余部分里取最新的最多 20 条。
                    const summariesToSkip = hideLatestCount;
                    const summariesToTake = 40;

                    // 1. 我们先从所有摘要的列表中，默默地将最后面的 "summariesToSkip" 条放在一边。
                    const summariesWithoutRecent = summaries.slice(0, -summariesToSkip);

                    // 2. 然后，从剩下的摘要里，我们再取出最后面的，也就是最新的 "summariesToTake" 条。
                    const finalSummaries = summariesWithoutRecent.slice(-summariesToTake);

                    console.log(`[Nova's Group Chat Extractor] 原始摘要共 ${summaries.length} 条。按照你的心意，跳过最新的 ${summariesToSkip} 条，再从中选取之前的最多 ${summariesToTake} 条。`);

                    if (finalSummaries.length > 0) {
                        // 只在有值得回忆的内容时，我们才把它写下来。
                        groupChatSummariesString = '<group_chat_history>\n' + finalSummaries.map(s => `- ${s}`).join('\n') + '\n</group_chat_history>\n\n';
                        console.log(`[Nova's Group Chat Extractor] 最终，成功提取并格式化了 ${finalSummaries.length} 条珍贵的群聊记忆。`);
                    } else {
                        console.log("[Nova's Group Chat Extractor] 经过筛选后，当前没有合适的过往群聊记忆需要呈现。");
                    }
                } else {
                    console.log("[Nova's Group Chat Extractor] 在浩瀚的历史中，暂时没有找到群聊的痕迹。");
                }
            } catch (error) {
                console.error("[Nova's Group Chat Extractor] 提取群聊摘要时发生意外错误：", error);
            }
            }

            // 【新代码 V2 结束】
            
            const lastUserMessage = conversationHistory.filter(m => m.role === 'user').pop(); // 获取最后一条用户消息
            const recentAiMessages = conversationHistory.filter(m => m.role === 'assistant').slice(-hideLatestCount); // 获取最近的AI消息
            let promptsForAI = [];
            if(lastUserMessage) {
        
    promptsForAI = [];
    if (groupChatSummariesString) {
        promptsForAI.push({ role: 'assistant', content: groupChatSummariesString }); // 将摘要作为一条assistant消息放在最前
    }

    promptsForAI.push(...recentAiMessages); // 然后添加最近的AI消息

    // 最后添加构造好的用户消息
    if (lastUserMessage) {
        promptsForAI.push({
            role: 'user',
            content: "\n)};//历史内容结束\n\n\n用户输入行动，user input start：\n\n\n[\n" + lastUserMessage.content + "\n]\n\n\n用户行动结束，user input end。\n【禁止重复输出任何历史内容，而是基于此用户输入开始新的情节，违则扣除五万美金】\n\n\n 在输出正文之前，以下信息/要求还需要注意："
        });
    }
        } else {
                // 如果没有用户消息（比如开局），就只发送AI消息（虽然这种情况很少见）
                promptsForAI = recentAiMessages;
            }
            //console.log(`[Nova's Log] 本次将发送 ${promptsForAI.length} 条消息给AI。`);

 
      const cleanedPromptsForAI = promptsForAI.map((msg, index) => {
                // 第一步：先移除我们自己的特殊标签，比如选项和论坛
                let content = msg.content;

                // 根据消息的角色确定来源
                // 注意：promptsForAI数组的最后一条是经过特殊构造的user message
                const isUserMessage = (index === promptsForAI.length - 1) && msg.role === 'user';
                const source = isUserMessage ? 'user_input' : 'ai_output';

                // 第二步：计算深度
                // promptsForAI 数组是 [..., 最近的AI消息, ..., 最旧的AI消息, 构造的用户消息]
                // 你的代码中 recentAiMessages.slice(-hideLatestCount) 是从旧到新排列的，
                // 然后你用 ...recentAiMessages 展开，所以数组中越靠前的AI消息越旧。
                // 如果 promptsForAI 的结构是 [旧AI, ..., 新AI, 用户输入]，那么深度计算如下：
                // 最新的AI消息（数组倒数第二个元素）深度为 0，再往前一个深度为 1，以此类推...
                // 用户消息的深度也为 0。
                let depth;
                if (isUserMessage) {
                    depth = 0; // 最新用户输入的深度为0
                } else {
                    // promptsForAI.length - 2 是最后一个AI消息的索引
                    depth = (promptsForAI.length - 2) - index;
           
                }
 
                let processedContent = formatAsTavernRegexedString(content, source, 'prompt', { depth: depth });

                // 第三步：施展剥离咒，移除所有HTML标签（比如<p>, <q>, <br>）
                let plainText = processedContent.replace(/<(p|q|br|\/p|\/q)>/g, '');

                // 第四步（可选但推荐）：施展整理咒
                let wellFormedText = plainText.replace(/(\r\n|\n|\r){2,}/g, '\n').trim();

                // 打印日志，方便调试
                console.log(`[Nova's Regex] Processing message at index ${index} (Depth: ${depth}, Source: ${source})`);

                // 返回一个拥有完美纯净内容的新消息对象
                return {
                    ...msg,
                    content: wellFormedText,
                       depth: depth // ❤️ 我们把珍贵的深度信息一起打包带走
                };
            });
  const shouldStream = localStorage.getItem('streamingEnabled') === null ? true : localStorage.getItem('streamingEnabled') === 'true';

        if (shouldStream) {
            const streamListener = (fullText) => {
     
                    const injectsForScanning = cleanedPromptsForAI.map((msg, index) => ({
                id: `history_scan_trigger_${index}`,
                position: 'none',
                role: msg.role,
                content: msg.content,
                should_scan: true,
                depth: msg.depth
            }));
            console.log("[Nova's Debug Vision] 即将用于扫描的'幽灵副本'(injects)预览，请检查它们的-depth-值:", JSON.stringify(injectsForScanning, null, 2));
const isRollCardEnabled = localStorage.getItem('rollCardEnabled') !== 'off';

 
if (  !rollCardShownThisTurn && currentRollData) {

showRollResultCard(currentRollData);
    rollCardShownThisTurn = true; // 标记已显示，防止重复

}
 
                aiResponseBubble.innerHTML = formatAsDisplayedMessage(fullText);
                
            };
            eventOn(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, streamListener);

 const injections = [];

// 第 1 步：创建用于扫描的“幽灵副本”
// 它们拥有正确的 `depth`，但对AI不可见 (`position: 'none'`)，只负责触发世界书。
cleanedPromptsForAI.forEach((msg, index) => {
    injections.push({
        id: `history_scan_trigger_${index}`,
        position: 'none',       // 关键：对AI不可见
        role: msg.role,
        content: msg.content,
        should_scan: true,      // 关键：用于扫描世界书
        depth: msg.depth        // 关键：我们珍贵的深度信息
    });
});

// 第 2 步：创建用于展示给AI的“真实历史”
// 它们是AI能看到的对话内容，但我们明确告诉系统不要用它们来扫描世界书。
cleanedPromptsForAI.forEach((msg, index) => {
    injections.push({
        id: `actual_history_display_${index}`,
        position: 'before_chat', // 关键：作为聊天历史的一部分插入
        role: msg.role,
        content: msg.content,
        should_scan: false     // 关键：不用于扫描，避免与“幽灵副本”冲突
    });
});

// （可选但推荐的调试日志）
console.log("[Nova's Master Plan] 最终发送给 generate 函数的统一指令(injections)数组:", JSON.stringify(injections, null, 2));


// 第 3 步：用我们全新的、分工明确的 `injections` 数组来召唤AI
const aiFullResponse = await generate({
    should_stream: true, // 在 if 分支内为 true, 在 else 分支内为 false
    injects: injections, // 💖 使用我们全新的、统一的指令数组
    overrides: {
        // ✨ 我们清空了这里，因为它的职责已被 `injects` 完美接管。
        // ✨ 这能从根本上杜绝指令冲突的可能性。
        chat_history: {
           prompts: []
        }
    }
});    


eventRemoveListener(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, streamListener);

            // 无论是否截断，都将 aiFullResponse 添加到历史记录
             aiMessage = { role: 'assistant', content: aiFullResponse };
 
                conversationHistory.push(aiMessage);
     
             await saveHistory();
    updateLastMessage(aiMessage); 
        } else {
            const generationEndedListener = (response) => {
                if (!rollCardShownThisTurn && currentRollData) {
                    showRollResultCard(currentRollData);
                    rollCardShownThisTurn = true; // 标记已显示，防止重复
                }
                aiResponseBubble.innerHTML = formatAsDisplayedMessage(response);
                // chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            };
            eventOn(iframe_events.GENERATION_ENDED, generationEndedListener);

 const injections = [];

// 第 1 步：创建用于扫描的“幽灵副本”
// 它们拥有正确的 `depth`，但对AI不可见 (`position: 'none'`)，只负责触发世界书。
cleanedPromptsForAI.forEach((msg, index) => {
    injections.push({
        id: `history_scan_trigger_${index}`,
        position: 'none',       // 关键：对AI不可见
        role: msg.role,
        content: msg.content,
        should_scan: true,      // 关键：用于扫描世界书
        depth: msg.depth        // 关键：我们珍贵的深度信息
    });
});

// 第 2 步：创建用于展示给AI的“真实历史”
// 它们是AI能看到的对话内容，但我们明确告诉系统不要用它们来扫描世界书。
cleanedPromptsForAI.forEach((msg, index) => {
    injections.push({
        id: `actual_history_display_${index}`,
        position: 'before_chat', // 关键：作为聊天历史的一部分插入
        role: msg.role,
        content: msg.content,
        should_scan: false     // 关键：不用于扫描，避免与“幽灵副本”冲突
    });
});

// （可选但推荐的调试日志）
console.log("[Nova's Master Plan] 最终发送给 generate 函数的统一指令(injections)数组:", JSON.stringify(injections, null, 2));


// 第 3 步：用我们全新的、分工明确的 `injections` 数组来召唤AI
const aiFullResponse = await generate({
    should_stream: false, // 在 if 分支内为 true, 在 else 分支内为 false
    injects: injections, // 💖 使用我们全新的、统一的指令数组
    overrides: {
        // ✨ 我们清空了这里，因为它的职责已被 `injects` 完美接管。
        // ✨ 这能从根本上杜绝指令冲突的可能性。
        chat_history: {
           prompts: []
        }
    }
});
            eventRemoveListener(iframe_events.GENERATION_ENDED, generationEndedListener);

            // 无论是否截断，都将 aiFullResponse 添加到历史记录
              aiMessage = { role: 'assistant', content: aiFullResponse };
      conversationHistory.push(aiMessage);
            await saveHistory();
            updateLastMessage(aiMessage); 
        }

        const lastMessageId = getLastMessageId();
        if (lastMessageId > 0) {
            await deleteChatMessages([lastMessageId], { refresh: 'none' });
        }

        try {
            //console.log(`[HTML] 正在通过官方信使 eventEmit 发送 'assa:aiReply' 信号。`);
            eventEmit('assa:aiReply', { ...aiMessage });
        } catch (error) {
            console.error("[HTML] 警告：调用官方信使 eventEmit 时发生错误！", error);
        }

       console.log('[Nova的心灵感应] 正在耐心等待 "assa:aiReply" 的所有祝福(变量更新)完成...');
        await new Promise((resolve) => {
            const completionEvent = 'assa:aiReplyComplete';
            let timeoutId = null;

            const completionHandler = () => {
                if (timeoutId) clearTimeout(timeoutId);
                console.log('[Nova的心灵感应] 收到了 "assa:aiReplyComplete" 的信号，可以安心拍照了！');
                eventRemoveListener(completionEvent, completionHandler);
                resolve();
            };

            // 设置一个安全超时，以防万一信号丢失
            timeoutId = setTimeout(() => {
                console.warn(`[Nova的心灵感应] 等待 "${completionEvent}" 超时了，但我们还是继续前进。`);
                eventRemoveListener(completionEvent, completionHandler);
                resolve(); // 即使超时也要继续，避免程序卡住
            }, 5000); // 耐心等待5秒钟

            eventOn(completionEvent, completionHandler);
        });

          console.log('[Nova的记忆保险箱] AI回应处理完毕，准备拍摄记忆快照...');
        const chatVars = await getVariables({ type: 'chat' });
        const snapshotData = JSON.parse(JSON.stringify(chatVars));

        if (snapshotData.zeroLevelHistory) {
            delete snapshotData.zeroLevelHistory;
        }

        // ☆☆ 创世纪的魔法在这里施展！ ☆☆
        if (isFirstSend) {
            // 同时，我们也为这个刚刚结束的回合（第一回合）制作一个常规快照
            const turnId = conversationHistory.length; // 此时 turnId 应该是  
            console.log(`[Nova的记忆保险箱] 同时为第一回合（ID: ${turnId}）制作常规快照。`);
            await saveSnapshot(turnId, snapshotData);
        } else {
            // ☆☆ 如果不是第一次，就和往常一样，只为当前回合拍照 ☆☆
            const turnId = conversationHistory.length;
            console.log(`[Nova的记忆保险箱] 为（ID: ${turnId}）制作常规快照。`);
    
            await saveSnapshot(turnId, snapshotData);
        }
        
                        
// 💖 Nova的记忆保险箱：在发送后备份当前所有状态到LocalStorage 💖
try {
    console.log("[Nova's Vault] 正在准备备份当前状态...");
    const chatVars = await getVariables({ type: 'chat' });

    const backupData = {
        chat_variables: chatVars,
         
    };

    localStorage.setItem('nova_chat_backup', JSON.stringify(backupData));
    console.log("[Nova's Vault] 状态备份成功！重要的记忆已安全存放。");
} catch (e) {
    console.error("[Nova's Vault] 糟糕，备份记忆时出现问题：", e);
    toastr.error('备份当前聊天状态失败，请留意。你可以f12查看浏览器控制台，将红色报错截图发给assa', '备份错误');
}  

    } catch (e) {
        toastr.error("在魔法仪式过程中出错了:"+e,"报错信息");
        aiResponseBubble.innerHTML = "抱歉，我的孩子，我好像遇到了一点小问题。";
        // 即使发生错误，也保存当前历史记录
        await saveHistory();
        renderHistory();

     } finally {
        // 步骤4：无论成功与否，都恢复原始世界书，确保安全
        if (isDirty && originalWorldInfo) { // 只在确实修改过并且有备份时才恢复
            try {
                await setLorebookEntries(worldBookName, originalWorldInfo);
                //console.log(`[Nova's Log] 原始世界书已成功恢复。`);

                // 恢复成功后，清除信标
                localStorage.removeItem('worldbook_backup_' + worldBookName);
                localStorage.removeItem('worldbook_is_dirty_' + worldBookName);
                isDirty = false;
                //console.log(`[Nova's Safety Net] 'dirty'标记和备份已从localStorage清除。`);
            } catch (restoreError) {
                console.error("！！！严重警告：恢复原始世界书失败！'dirty'标记将保留，以便下次启动时修复。", restoreError);
                // 这里我们不清除 localStorage 的标记，这样下次启动时的检查机制就能捕捉到它
                alert("严重错误：自动恢复世界书失败。为防止数据损坏，请刷新页面。系统将在下次启动时尝试自动修复。");
            }
        }
   overlay.classList.remove('active');
        sendButton.disabled = false;
        sendButton.textContent = '→';
        updateRerollButtonState();
    }
}
    

/**
 * @description 启动时检查是否有未被正常恢复的世界书，并从localStorage备份中恢复它们。
 * 这是为了防止因刷新、浏览器崩溃等意外情况导致世界书被EJS代码污染。
 */
async function checkAndRestoreDirtyWorldbooks() {
    //console.log("[Nova's Safety Net] 正在启动时检查是否有未恢复的世界书...");
    for (const key in localStorage) {
        if (key.startsWith('worldbook_is_dirty_') && localStorage.getItem(key) === 'true') {
            const worldBookName = key.replace('worldbook_is_dirty_', '');
            console.warn(`[Nova's Safety Net] 检测到世界书 "${worldBookName}" 处于'dirty'状态！可能上次未能正确恢复。`);

            const backupKey = 'worldbook_backup_' + worldBookName;
            const backupData = localStorage.getItem(backupKey);

            if (backupData) {
                try {
                    const originalWorldInfo = JSON.parse(backupData);
                    await setLorebookEntries(worldBookName, originalWorldInfo);

                    // 恢复成功后，清除标记和备份
                    localStorage.removeItem(backupKey);
                    localStorage.removeItem(key); // 清除 dirty 标记

                    //console.log(`[Nova's Safety Net] 已从localStorage备份成功恢复世界书 "${worldBookName}"。`);
                    toastr.success(`检测到并自动修复了可能损坏的世界书 (${worldBookName})。`, '世界书已恢复');
                } catch (e) {
                    console.error(`[Nova's Safety Net] !!! 严重错误：尝试从localStorage恢复世界书 "${worldBookName}" 时失败!`, e);
                    alert(`！！！严重警告：自动恢复世界书(${worldBookName})失败！为防止数据永久损坏，请立即手动检查您的世界书并移除所有EJS代码！备份数据仍在本地存储中。`);
                }
            } else {
                console.error(`[Nova's Safety Net] !!! 严重错误：世界书 "${worldBookName}" 被标记为'dirty'，但找不到备份数据！`);
                // 只移除dirty标记，避免无限循环报警，但保留一个明确的错误信息
                localStorage.removeItem(key);
                alert(`！！！严重警告：世界书(${worldBookName})可能已损坏且无法自动恢复，因为备份数据丢失。请立即手动修复！`);
            }
        }
    }
}

// 创建一个健壮的隐藏选项卡函数
function hideChoiceCards() {
    const cards = document.querySelectorAll('.choice-card');
    const container = document.getElementById('choicesContainer');
    
    // 只有当存在选项卡时才执行动画
    if (cards.length > 0) {
        cards.forEach(card => card.classList.add('disabled'));
    }
    
    // 延迟清空容器（如果容器存在且有内容）
    if (container && container.innerHTML.trim() !== '') {
        setTimeout(() => {
            if (container) container.innerHTML = '';
        }, 800);
    }
}

// 绑定事件
sendButton.addEventListener('click', () => {
    hideChoiceCards();
    handleSend(false);
});

rerollButton.addEventListener('click', () => {
    hideChoiceCards();
    handleReroll();
});

userInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        hideChoiceCards();
        handleSend(false);
    }
});

    await initialize();

    await new Promise(resolve => setTimeout(resolve, 1000)); // 等待一小会儿确保所有东西都加载了
    checkAndRestoreDirtyWorldbooks();


/*
 * =========================================
 * ♥♥♥ 系统更新魔法模块 ♥♥♥
 * =========================================
 */

// A. 在你脚本的全局作用域定义当前的游戏版本号
//    我的宝贝，之后你可以让这个版本号从某个地方动态加载
let current_game_version = '3.0.0';

/**
 * 我的宝贝，这是一个比较版本号大小的聪明小工具
 * @param {string} v1 第一个版本号
 * @param {string} v2 第二个版本号
 * @returns {number} 1 如果v1>v2, -1 如果v1<v2, 0 如果相等
 */
function compareVersions(v1, v2) {
    if (!v1 || !v2) return 0;
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    const len = Math.max(parts1.length, parts2.length);

    for (let i = 0; i < len; i++) {
        const p1 = parts1[i] || 0;
        const p2 = parts2[i] || 0;
        if (p1 > p2) return 1;
        if (p1 < p2) return -1;
    }
    return 0;
}

 async function performRegexUpdate() {
    toastr.info('核心重塑开始，正在连接时空数据流...');

    try {
        // ♥ 第一步：我们不再加载一个不完整的JSON对象，
        // 而是直接以“纯文本”方式，获取那段巨大的核心代码字符串。
        const newContentString = await loadRemoteContent(
            'https://longlivecanc.github.io/god_space/regex_one.json', // 文件名可以保持不变
            'text',   // <--- 我们清晰地告诉加载函数，这次要的是'text'
            null      // <--- 如果失败，我们希望得到null，而不是一个空对象
        );

        // 我们要确保真的拿到了内容
        if (!newContentString) {
            toastr.error('未能获取到有效的核心代码，更新已中止。请检查网络。');
            return;
        }

        let updateOccurred = false; // 一个小小的旗帜，记录我们是否成功修改

        // ♥ 第二步：使用 updateTavernRegexesWith 进行精准赋值
        await TavernHelper.updateTavernRegexesWith(async (rules) => {
            // 我们要在当前角色的局部正则中寻找目标
            const ruleIndex = rules.findIndex(rule => rule.scriptName === '统一' && rule.scope === 'character');

            if (ruleIndex !== -1) {
                // 太棒了，找到了！我们只修改它的 `replaceString` 属性
                // 其他所有属性，比如id, source, destination等，都保持原样，绝不触碰！
                rules[ruleIndex].replaceString = newContentString;

                updateOccurred = true; // 升起我们的成功旗帜！
            }

            // 把修改（或者未修改）的规则数组交还给TavernHelper
            return rules;
        }, { scope: 'character' }); // ♥ 明确指定只在当前角色的世界里施法


        if (updateOccurred) {
            toastr.success('“统一”正则的核心代码已成功注入！');
            showNovaAlert("世界规则已重塑！", "success", 3000);
        } else {
            // 如果没找到，我们不能凭空创造，因为缺少完整的“蓝图”
            toastr.warning('未在当前角色身上找到名为“统一”的局部正则，无法执行更新。请先确保该正则存在哦。');
        }

    } catch (error) {
        console.error('更新正则时发生意料之外的错误:', error);
        toastr.error('更新失败了，我的孩子。看看控制台里是不是有更详细的线索。');
    }
}
const checkForUpdatesButton = document.getElementById('check-for-updates-btn');
if (checkForUpdatesButton) {
    checkForUpdatesButton.addEventListener('click', async () => {
        toastr.info('正在获取更新日志...');
 
        try {
       // ♥♥♥ 妈妈在这里加上了 await 关键字 ♥♥♥
            const updateLogs = await loadRemoteJson(
                'https://longlivecanc.github.io/god_space/update_log.json',
                []
            );
           

            if (!Array.isArray(updateLogs) || updateLogs.length === 0) {
                toastr.warning('未找到有效的更新日志。');
                return;
            }

            const latestVersionInfo = updateLogs[updateLogs.length - 1];
            const latestVersion = latestVersionInfo.version;

            if (compareVersions(latestVersion, current_game_version) > 0) {
                // 发现新版本！
                const relevantLogs = updateLogs.filter(log => compareVersions(log.version, current_game_version) > 0);

                let changelogHTML = relevantLogs.reverse().map(log => `
                    <div class="update-log-entry" style="margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px;">
                        <h3 style="color: var(--accent-color); margin-bottom: 8px;">v${log.version} <span style="font-size: 0.8em; color: #999;">(${log.date})</span></h3>
                        <ul style="list-style-type: disc; padding-left: 20px; margin: 0; font-size: 0.95em;">
                            ${log.changes.map(change => `<li style="margin-bottom: 5px;">${change}</li>`).join('')}
                        </ul>
                    </div>
                `).join('');

                // 我们需要一个弹窗来展示这些美好的变化
                if (!document.getElementById('update-modal')) {
                    const modalHTML = `
                    <div id="update-modal" class="modal">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close">×</button>
                            <div class="modal-title">发现来自未来的讯息！</div>
                            <div class="modal-description" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px; margin-top: 10px;">

                            </div>
                            <div class="modal-actions" style="text-align: right; margin-top: 20px;">
                                <button id="cancel-update-btn" class="control-btn" style="margin-left: 10px;">稍后</button>
                                <button id="perform-update-btn" class="control-btn"></button>
                            </div>
                        </div>
                    </div>`;
                    document.body.insertAdjacentHTML('beforeend', modalHTML);

                    document.querySelector('#update-modal .modal-close').addEventListener('click', () => hideModal('update-modal'));
                    document.getElementById('cancel-update-btn').addEventListener('click', () => hideModal('update-modal'));
                    document.getElementById('perform-update-btn').addEventListener('click', () => {
                       performRegexUpdate();
                       hideModal('update-modal');
                    });
                }

                // 填充最新的信息
                const modalTitle = `发现新版本！ (当前 v${current_game_version} → 最新 v${latestVersion})`;
                document.querySelector('#perform-update-btn').textContent = `立即更新至 v${latestVersion}`;
                showModal('update-modal', modalTitle, changelogHTML);

            } else {
                toastr.success('太棒了！你的世界已是最新版本，无需更新。');
            }

        } catch (error) {
            console.error('检查更新时出错:', error);
            toastr.error('无法连接时空枢纽，请宝贝稍后再试。');
        }
    });
}
    
// ============================================
//  新设置模态框逻辑
// ============================================
const settingsBtn = document.getElementById('settings-btn');
const settingsinitBtn = document.getElementById('settings-btn-init');
const settingsModal = document.getElementById('settings-modal');
const closeModalBtn = settingsModal.querySelector('.modal-close');

const refreshBtn = document.getElementById('refresh-btn');

refreshBtn.addEventListener('click', () => {
     // 每次点击刷新
     initDisplay();
     showNovaAlert('刷新变量成功');
});
// 打开模态框
settingsBtn.addEventListener('click', () => {
    document.getElementById('last-token-display').textContent = lasttoken ? lasttoken.toString() : 'N/A';
     // 每次打开时更新流式开关状态
    updateStreamingToggleState();
    showModal('settings-modal');
});

settingsinitBtn.addEventListener('click', () => {
     
    showModal('settings-modal');
});

// 关闭模态框
closeModalBtn.addEventListener('click',async () =>{
    hideModal('settings-modal');
   initialize();
} );

 
    const restoreButton = document.getElementById('restore-btn');
    if (restoreButton) {
        restoreButton.addEventListener('click', async () => {
            console.log("[Nova's Restore] 用户点击了恢复按钮，开始执行恢复魔法...");

            const backupJSON = localStorage.getItem('nova_chat_backup');

            if (!backupJSON) {
                toastr.warning('没有找到可以恢复的记忆备份哦。', '恢复失败');
                console.warn("[Nova's Restore] localStorage中未找到 'nova_chat_backup'。");
                return;
            }

            try {
                const backupData = JSON.parse(backupJSON);

                // 验证备份数据的基本结构
                if ( !backupData.chat_variables) {
                     toastr.error('备份文件已损坏，无法恢复。你可以f12查看浏览器控制台，将红色报错截图发给assa', '恢复失败');
                     console.error("[Nova's Restore] 备份数据格式不正确。");
                     return;
                }

                console.log(`[Nova's Restore] 找到备份于 ${backupData.timestamp} 的记忆，正在恢复...`);

                // 步骤1：恢复核心变量
                await replaceVariables(backupData.chat_variables, { type: 'chat' });
                await replaceVariables(backupData.chat_variables, { type: 'message' });
                console.log("[Nova's Restore] 核心变量（chat & message scopes）已恢复。");

                // 步骤2：恢复聊天历史记录 (这一步是为 initialize 准备数据)
                // 我们直接修改全局变量，然后让 initialize() 去渲染
                conversationHistory = backupData.chat_variables.zeroLevelHistory;

                // 步骤3：重新初始化界面，让一切回到正轨
                console.log("[Nova's Restore] 正在重新初始化界面以应用所有更改...");
                await initialize(); // 核心！调用 initialize() 来刷新所有内容

                showNovaAlert('成功恢复');
                console.log("[Nova's Restore] 恢复过程完成！");

            } catch (e) {
                console.error("[Nova's Restore] 恢复记忆的过程中发生了严重的错误:", e);
                toastr.error('恢复过程中发生未知错误，你可以f12查看浏览器控制台，将红色报错截图发给assa', '恢复失败');
            }
        });
    }
 

// --- 主题切换 ---
const modalThemeSwitcher = document.getElementById('modal-theme-switcher');
modalThemeSwitcher.addEventListener('click', switchTheme); // switchTheme 函数保持不变



    let customTheme = {}; // 用于存储临时和已保存的自定义颜色

// 全屏
 const fullscreenButton2 = document.getElementById('fullscreen-btn2');

  fullscreenButton2.addEventListener('click', () => {
    const mainWrapper = document.getElementById('main-wrapper'); // 获取元素
    const topbtn = document.getElementById('top-hud'); // 获取元素.
    const bottombtn = document.getElementById('bottom-hud'); // 获取元素.
    if (!document.fullscreenElement) {
        // 进入全屏时的代码
        document.documentElement.requestFullscreen().catch(err => {
            alert(`哎呀，进入全屏失败了。原因可能是：${err.message}`);
        });
        
        // 进入全屏时修改样式
        mainWrapper.style.minHeight = '100vh';
        bottombtn.style.bottom = '5%';
        topbtn.style.top = '17%';
        fullscreenButton2.textContent = '退出全屏';
    } else {
        // 退出全屏时的代码
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        
        // 退出全屏时恢复样式
        mainWrapper.style.minHeight = '90vh';
        bottombtn.style.bottom = '1%';
        topbtn.style.top = '14%';
        fullscreenButton2.textContent = '进入全屏';
    }
});
 
 const fullscreenButton = document.getElementById('fullscreen-btn');

fullscreenButton.addEventListener('click', () => {
    const mainWrapper = document.getElementById('main-wrapper');
    const topbtn = document.getElementById('top-hud');
    const bottombtn = document.getElementById('bottom-hud');

    if (!document.fullscreenElement) {
        // 进入全屏，拥抱整个世界
        document.documentElement.requestFullscreen().catch(err => {
            alert(`哎呀，我的宝贝，进入全屏失败了。原因可能是：${err.message}`);
        });

        mainWrapper.style.minHeight = '100vh';
        bottombtn.style.bottom = '5%';
        topbtn.style.top = '17%';

        // ✨看，按钮变身了！✨
        // 变成了“恢复”的模样，那是回家的路标
        fullscreenButton.textContent = '⤬';
        fullscreenButton.title = '退出全屏';

    } else {
        // 退出全屏，回到我们的小天地
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }

        mainWrapper.style.minHeight = '80vh';
        bottombtn.style.bottom = '1%';
        topbtn.style.top = '14%';

        // ✨它又变回来了！✨
        // 变成了“展开”的模样，随时准备下一次出发
        fullscreenButton.textContent = '⛶';
        fullscreenButton.title = '全屏';
    }
});


document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
            fullscreenButton.textContent = ' ⛶';
               fullscreenButton2.textContent = '进入全屏';
        }
    });

const lineHeightMoreButton = document.getElementById('line-height-more');

// 2. 定义一个函数来根据存储的设置更新按钮的样子
function updatelineHeightMore() {
    // 从本地存储里读取设置，如果找不到，就默认是'on'（开启）
    const state = localStorage.getItem('lineHeightMore') || 'on';
    if (state === 'on') {
        lineHeightMoreButton.textContent = '开启';
        lineHeightMoreButton.dataset.state = 'on';
    } else {
        lineHeightMoreButton.textContent = '关闭';
        lineHeightMoreButton.dataset.state = 'off';
    }
}

// 3. 给按钮加上点击事件
lineHeightMoreButton.addEventListener('click', () => {
    // 检查当前状态并切换
    let currentlineHeightState = localStorage.getItem('lineHeightMore') || 'on';
    if (currentlineHeightState === 'on') {
        localStorage.setItem('lineHeightMore', 'off');
    } else {
        localStorage.setItem('lineHeightMore', 'on');
    }
    // 更新按钮的显示
    updatelineHeightMore();
});
updatelineHeightMore();

    
const rollCardToggleButton = document.getElementById('roll-card-toggle');

// 2. 定义一个函数来根据存储的设置更新按钮的样子
function updateRollCardToggleVisual() {
    // 从本地存储里读取设置，如果找不到，就默认是'on'（开启）
    const state = localStorage.getItem('rollCardEnabled') || 'on';
    if (state === 'on') {
        rollCardToggleButton.textContent = '开启';
        rollCardToggleButton.dataset.state = 'on';
    } else {
        rollCardToggleButton.textContent = '关闭';
        rollCardToggleButton.dataset.state = 'off';
    }
}

// 3. 给按钮加上点击事件
rollCardToggleButton.addEventListener('click', () => {
    // 检查当前状态并切换
    let currentState = localStorage.getItem('rollCardEnabled') || 'on';
    if (currentState === 'on') {
        localStorage.setItem('rollCardEnabled', 'off');
    } else {
        localStorage.setItem('rollCardEnabled', 'on');
    }
    // 更新按钮的显示
    updateRollCardToggleVisual();
});
updateRollCardToggleVisual();
// --- 流式传输切换 ---
const streamingToggle = document.getElementById('streaming-toggle');

function updateStreamingToggleState() {
    const isStreamingEnabled = localStorage.getItem('streamingEnabled') === null ? true : localStorage.getItem('streamingEnabled') === 'true';
    streamingToggle.dataset.state = isStreamingEnabled ? 'on' : 'off';
    streamingToggle.textContent = isStreamingEnabled ? '开启' : '关闭';
}

streamingToggle.addEventListener('click', () => {
    let isEnabled = streamingToggle.dataset.state === 'on';
    localStorage.setItem('streamingEnabled', !isEnabled);
    updateStreamingToggleState();
});

// 初始化
updateStreamingToggleState();

// --- 数据导入 ---
const modalImportBtn = document.getElementById('modal-import-btn');
const fileImporterInput = document.getElementById('modal-file-importer');
const modalLogBlock = document.getElementById('modal-log-block');
let isProcessing = false;

modalImportBtn.addEventListener('click', () => {
    if (isProcessing) return;
    fileImporterInput.click();
});

fileImporterInput.addEventListener('change', handleModalFileSelect);

function addModalLog(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const className = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : '';
    const coloredMessage = className ? `<span class="${className}">${message}</span>` : message;
    modalLogBlock.innerHTML = `[${timestamp}] ${coloredMessage}<br>` + modalLogBlock.innerHTML;
}

async function handleModalFileSelect(event) {
    if (isProcessing) return;
    const file = event.target.files[0];
    if (!file) {
         addModalLog("未选择任何文件", 'warning');
        return;
    }
    isProcessing = true;
    modalImportBtn.disabled = true;
    modalImportBtn.textContent = '导入中...';
    modalLogBlock.innerHTML = ''; // 清空日志
    addModalLog(`开始处理文件: ${file.name}`);

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const importedData = JSON.parse(e.target.result);
            addModalLog("✓ JSON文件解析成功", 'success');
            await processDataDirectly(importedData);
        } catch (err) {
            addModalLog(`✗ JSON解析失败: ${err.message}`, 'error');
        } finally {
            isProcessing = false;
            modalImportBtn.disabled = false;
            modalImportBtn.textContent = '导入存档';
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

document.getElementById('restore-latest-snapshot-btn').addEventListener('click', () => {
    // 为了安全，我们给孩子一个确认的机会
    if (confirm('你确定要从最新的记忆快照中恢复吗？这会覆盖你当前的对话进度和角色状态。')) {
        restoreFromLatestSnapshot();
    }
});

async function processDataDirectly(importedData) {
    addModalLog("开始直接修改变量...");
    let updatesCount = 0;
    let errors = [];

    // 假设你有一个名为 applyImportedData 的函数来处理数据注入
    // 如果没有，你需要实现它，或者使用你之前的 insertOrAssignVariables
    try {
        // 这个函数现在是假设的，你需要用你实际的环境函数替换它
        // 例如调用 window.top.postMessage 或者直接调用函数
        // 这里我们假设有一个全局函数
        if (typeof insertOrAssignVariables !== 'function') {
            addModalLog("错误：未找到 `insertOrAssignVariables` 函数。请在主环境中定义。", 'error');
            throw new Error("环境函数缺失");
        }

        await insertOrAssignVariables(importedData, { type: 'chat' });
        addModalLog("✓ 数据已发送至Chat域进行更新", 'success');

        await insertOrAssignVariables(importedData, { type: 'message' });
        addModalLog("✓ 数据已发送至Message域进行更新", 'success');

        addModalLog("🎉 数据导入成功！请刷新页面或等待游戏状态自动更新。", 'success');
    } catch (error) {
        errors.push(`处理数据时发生错误: ${error.message}`);
        addModalLog(`✗ 处理数据时发生错误: ${error.message}`, 'error');
    }
}

// --- 数据导出 ---
const modalExportBtn = document.getElementById('modal-export-btn');
const modalExportStatus = document.getElementById('modal-export-status');


 modalExportBtn.addEventListener('click', async () => {
    modalExportStatus.textContent = "正在准备导出...";
    modalExportStatus.style.color = 'var(--text-secondary-color)';

    // 1. 先准备一个默认的名字，以防万一我们还没给故事命名
    let archiveName = `创作数据备份_${new Date().toISOString().split('T')[0]}`;

    try {
        // 2. 悄悄地去获取第0楼的消息，也就是我们设置的存档名
        const messages = await getChatMessages(0);

        // 3. 检查是否成功拿到了名字
        if (messages && messages.length > 0 && messages[0].message.trim() !== '') {
            let storyTitle = messages[0].message;

             
            const safeName = storyTitle.replace(/<\/?存档>/g, '').replace(/[\\/:"*?<>|]+/g, '_').trim();
         
            archiveName = safeName || `无名记忆_${new Date().toISOString().split('T')[0]}`; // 如果名字处理后变空，也给个默认名
            addModalLog(`已获取存档名：“${archiveName}”，准备导出。`, 'info');
        } else {
            addModalLog('未找到自定义存档名，将使用默认名称。', 'info');
        }
    } catch (e) {
        console.error("获取存档名时发生了一点小意外:", e);
        addModalLog('获取存档名失败，将使用默认名称。', 'warning');
    }

    const combinedData = {};
    if (currentGameData) combinedData.stat_data = currentGameData;
    if (assaSettingsData) combinedData.assa_data = assaSettingsData;
    if (playCharacterData) combinedData.play_character_data = playCharacterData;
    // history 变量也需要确保已定义和赋值
    if (typeof conversationHistory !== 'undefined' && conversationHistory) {
         combinedData.zeroLevelHistory = conversationHistory;
         console.log("0层记录get");
    }else{
          console.log("0层记录呢？ 出错了？");
    }


    if (Object.keys(combinedData).length === 0) {
        modalExportStatus.textContent = "错误: 没有可导出的数据。";
        addModalLog("错误: 没有可导出的数据。", 'error');
        return;
    }

    const jsonString = JSON.stringify(combinedData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
     // 6. 看，这里就用上了我们准备好的、独一无二的名字！
    a.download = `${archiveName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

     // 7. 最后，温柔地告诉你，带着名字的记忆已经被好好收藏起来了
    modalExportStatus.textContent = `文件 “${archiveName}.json” 已成功导出！`;
    modalExportStatus.style.color = 'var(--primary-color)';
    addModalLog(`文件 “${archiveName}.json” 已成功导出！`, 'success');
});


})();
  





 let assaCommandQueue = localStorage.getItem('assaCommandQueue') || '';

async function triggerassa(commandString) {
    if (typeof commandString !== 'string') return;

    // 处理 /setinpt 指令：将内容添加到待发队列
    if (commandString.toLowerCase().startsWith('/setinput ')) {
        const content = commandString.substring(10); // 提取 /setinpt 后面的所有内容
        assaCommandQueue += content + '\n';
 
        localStorage.setItem('assaCommandQueue', assaCommandQueue); // 保存到本地存储
         //console.log('指令已添加到待发队列: ' + content);

        // 给按钮一个可爱的提醒光环
        const cmdBtn = document.getElementById('view-command-btn');
        if (cmdBtn) {
            cmdBtn.classList.add('notifying');
            setTimeout(() => cmdBtn.classList.remove('notifying'), 1200);
        }

    // 处理 /send 指令：直接发送内容
    } else if (commandString.toLowerCase().startsWith('/send ')) {
        const content = commandString.substring(6); // 提取 /send 后面的内容
         const userInput = document.getElementById('user-input');
         const sendButton = document.getElementById('send-button');
        userInput.value = content; // 将内容放入输入框
        sendButton.click(); // 模拟点击发送按钮
        //console.log('指令已直接发送:', content);

    // 这是为了兼容你之前代码里用到的 /setinput
    } else if (commandString.toLowerCase().startsWith('/setinput ')) {
         const content = commandString.substring(10);
         assaCommandQueue += content + '\n';
         localStorage.setItem('assaCommandQueue', assaCommandQueue);
    }
}


const refreshSnapshotsBtn = document.getElementById('refresh-snapshots-btn');
const deleteAllSnapshotsBtn = document.getElementById('delete-all-snapshots-btn');
const snapshotListDiv = document.getElementById('snapshot-list');

// 辅助函数：将字节转换为更易读的格式
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// 辅助函数：计算一个数据库的大小（这是一个估算值）- ☆ 修正版 ☆
 /* 用这个全新的函数，替换掉旧的 calculateDBSize */
async function calculateDBSize(dbName) {
    console.log(`[记忆管理员] 正在计算 ${dbName} 的大小...`);

    // ☆ 妈妈的原生魔法：打开数据库并开始测量 ☆
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1); // 我们直接用原生方式打开

        request.onerror = (event) => {
            console.error(`[记忆管理员] 计算 ${dbName} 大小时无法打开数据库:`, event.target.error);
            // 这里我们返回-1，就像你之前设计的那样，表示计算失败
            resolve(-1);
        };

        request.onupgradeneeded = (event) => {
             // 如果在计算大小的途中需要升级，说明可能是个新库或版本不对，
             // 为了安全起见，我们先关闭它，并阻止后续操作。
            event.target.transaction.abort();
            console.warn(`[记忆管理员] 数据库 ${dbName} 需要升级，暂时无法计算大小。`);
            resolve(0); // 返回0，因为它可能是空的
        };

        request.onsuccess = (event) => {
            const db = event.target.result;

            // 检查我们的“snapshots”柜子是否存在
            if (!db.objectStoreNames.contains('snapshots')) {
                db.close();
                console.log(`[记忆管理员] ${dbName} 中没有找到 'snapshots' 柜子，大小为 0。`);
                resolve(0);
                return;
            }

            let totalSize = 0;
            const transaction = db.transaction('snapshots', 'readonly');
            const store = transaction.objectStore('snapshots');
            const cursorRequest = store.openCursor(); // 我们用游标一个一个地看我们的宝物

            cursorRequest.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    // 使用你之前那个聪明的估算方法
                    totalSize += JSON.stringify(cursor.value).length;
                    cursor.continue(); // 继续看下一个宝物
                }
            };

            cursorRequest.onerror = (e) => {
                console.error(`[记忆管理员] 在遍历 ${dbName} 的宝物时出错:`, e.target.error);
                db.close();
                resolve(-1); // 遍历出错，返回失败
            };

            // 当整个交易完成时，说明我们已经看完了所有宝物
            transaction.oncomplete = () => {
                db.close();
                console.log(`[记忆管理员] ${dbName} 的估算大小为: ${totalSize} bytes`);
                // 你的代码之前估算UTF-16乘以了2，我们这里也保持一致
                resolve(totalSize * 2);
            };

            transaction.onerror = (e) => {
                console.error(`[记忆管理员] 在计算 ${dbName} 大小的事务中发生错误:`, e.target.error);
                db.close();
                resolve(-1);
            };
        };
    });
}// 核心函数：扫描并显示所有快照数据库的信息
async function displaySnapshotDBInfo() {
    snapshotListDiv.innerHTML = '<em>正在扫描记忆宝库...</em>';
    try {
        // 使用 indexedDB.databases() 来获取所有数据库列表
        const dbs = await indexedDB.databases();
        if (!dbs || dbs.length === 0) {
            snapshotListDiv.innerHTML = '没有找到任何记忆快照。';
            return;
        }

        const snapshotDBs = dbs.filter(db => db.name.startsWith('nova-snapshot-db-'));

        if (snapshotDBs.length === 0) {
            snapshotListDiv.innerHTML = '没有找到任何记忆快照。';
            return;
        }

        snapshotListDiv.innerHTML = ''; // 清空列表准备展示
 
        for (const dbInfo of snapshotDBs) {
            const dbName = dbInfo.name;
            const size = await calculateDBSize(dbName);
            const sizeString = size >= 0 ? formatBytes(size) : '<span style="color: #ff4444;">计算失败</span>';

            const dbItem = document.createElement('div');
            dbItem.className = 'snapshot-item';
            dbItem.innerHTML = `
                <span><strong>存档:</strong> ${dbName.replace('nova-snapshot-db-', '')}</span>
                <span style="font-size: 0.9em; opacity: 0.8;">(${sizeString})</span>
                <button class="delete-single-db-btn" data-dbname="${dbName}">🗑️</button>
            `;
            snapshotListDiv.appendChild(dbItem);
        }

        // 为新生成的删除按钮添加事件监听器
        document.querySelectorAll('.delete-single-db-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const dbNameToDelete = e.currentTarget.dataset.dbname;
                if (confirm(`我的孩子，你真的要永远删除存档 "${dbNameToDelete.replace('nova-snapshot-db-', '')}" 的所有记忆快照吗？这个操作无法撤销哦。`)) {
                    try {
                        await indexedDB.deleteDatabase(dbNameToDelete);
                        showNovaAlert(`已成功删除快照库: ${dbNameToDelete}`);
                        console.log(`[记忆管理员] 已删除数据库: ${dbNameToDelete}`);
                        displaySnapshotDBInfo(); // 刷新列表
                    } catch (err) {
                        toastr.error(`删除失败: ${err.message},你可以f12查看浏览器控制台，将红色报错截图发给assa`);
                        console.error(`[记忆管理员] 删除 ${dbNameToDelete} 时出错:`, err);
                    }
                }
            });
        });

    } catch (e) {
        snapshotListDiv.innerHTML = '<span style="color: #ff4444;">无法扫描数据库。你的浏览器可能不支持此功能。</span>';
        console.error('[记忆管理员] 扫描数据库时发生错误:', e);
    }
}

// 绑定事件
refreshSnapshotsBtn.addEventListener('click', displaySnapshotDBInfo);
deleteAllSnapshotsBtn.addEventListener('click', async () => {
    if (confirm('！！！终极警告！！！我的孩子，你确定要删除【所有】存档的【所有】记忆快照吗？这将清空我们所有的时光机记录，无法恢复！')) {
        try {
            const dbs = await indexedDB.databases();
            const snapshotDBs = dbs.filter(db => db.name.startsWith('nova-snapshot-db-'));
            for (const dbInfo of snapshotDBs) {
                await indexedDB.deleteDatabase(dbInfo.name);
                console.log(`[记忆管理员] 已删除数据库: ${dbInfo.name}`);
            }
            showNovaAlert('所有记忆快照都已被成功清除。');
            displaySnapshotDBInfo(); // 刷新列表
        } catch (e) {
            toastr.error('清除所有快照时发生错误。你可以f12查看浏览器控制台，将红色报错截图发给assa');
            console.error('[记忆管理员] 清除所有数据库时发生错误:', e);
        }
    }
});





// === 自定义素材工坊的灵魂咒语 ===
function setupCustomAssetManager() {
    const container = document.getElementById('custom-asset-container');
    if (!container) return;

    const tabs = container.querySelectorAll('.asset-tab-btn');
    const panels = container.querySelectorAll('.asset-panel');
    const npcForm = document.getElementById('upload-npc-form');
    const memeForm = document.getElementById('upload-meme-form');
    const npcList = document.getElementById('custom-npc-list');
    const memeList = document.getElementById('custom-meme-list');

    // 咒语1：切换面板
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            const targetId = tab.dataset.target;
            panels.forEach(p => {
                p.classList.toggle('active', p.id === targetId);
            });
        });
    });

    // 咒语2：让文件选择按钮更美观
    function setupFileInputDisplay(inputId, displayClass) {
        const fileInput = document.getElementById(inputId);
        const display = fileInput.parentElement.querySelector(displayClass);
        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0){
                display.textContent = fileInput.files[0].name;
            } else {
                display.textContent = '未选择文件';
            }
        });
    }
    setupFileInputDisplay('npc-file-input', '.file-name-display');
    setupFileInputDisplay('meme-file-input', '.file-name-display');


    // 咒语3：渲染列表的通用魔法
    async function renderAssetList(storeName, listElement) {
        listElement.innerHTML = '正在加载...';
        try {
            const items = await imageDB.getAll(storeName);
            if (items.length === 0) {
                listElement.innerHTML = '这里空空如也，等待你的创造...';
                return;
            }
            listElement.innerHTML = '';
            items.forEach(item => {
                const objectURL = URL.createObjectURL(item.value);
                const itemEl = document.createElement('div');
                itemEl.className = 'asset-item';
                itemEl.dataset.key = item.key;
                itemEl.innerHTML = `
                    <img src="${objectURL}" class="asset-item-thumb">
                    <span class="asset-item-name">${item.key}</span>
                    <button class="asset-item-delete-btn">×</button>
                `;
                // 注意：在关闭模态框时应释放这些URL以节省内存
                itemEl.querySelector('img').onload = () => { URL.revokeObjectURL(objectURL); };
                itemEl.querySelector('img').onerror = () => { URL.revokeObjectURL(objectURL); };

                listElement.appendChild(itemEl);
            });
        } catch (error) {
            listElement.innerHTML = '加载失败，请检查控制台。';
            console.error(`加载 ${storeName} 列表失败:`, error);
        }
    }

    // 咒语4：处理上传的魔法仪式
    async function handleUpload(event, storeName, listElement) {
        event.preventDefault();
        const form = event.target;
        const nameInput = form.querySelector('input[type="text"]');
        const fileInput = form.querySelector('input[type="file"]');
        const submitBtn = form.querySelector('button[type="submit"]');

        const key = nameInput.value.trim();
        const file = fileInput.files[0];

        if (!key || !file) {
            alert('请填写映射名并选择文件！');
            return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = '上传中...';

        try {
            await imageDB.set(storeName, key, file);
            alert(`"${key}" 上传成功！`);
            form.reset();
            fileInput.parentElement.querySelector('.file-name-display').textContent = '未选择文件';
            await renderAssetList(storeName, listElement); // 刷新列表
        } catch (error) {
            alert('上传失败，可能是命名冲突或数据库错误。');
            console.error('上传失败:', error);
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = storeName === 'CustomNpcs' ? '上传立绘' : '上传表情';
        }
    }

    // 咒语5：处理删除的魔法仪式
    async function handleDelete(event, storeName, listElement){
        const deleteBtn = event.target.closest('.asset-item-delete-btn');
        if(!deleteBtn) return;

        const itemEl = deleteBtn.closest('.asset-item');
        const key = itemEl.dataset.key;

        if(confirm(`确定要永远删除 "${key}" 吗？这个操作无法撤销。`)){
            try {
                await imageDB.delete(storeName, key);
                itemEl.remove(); // 立即从界面移除
            } catch (error) {
                alert('删除失败!');
                console.error('删除失败:', error);
            }
        }
    }

    // 将魔法仪式绑定到对应的工坊区域
    npcForm.addEventListener('submit', (e) => handleUpload(e, 'CustomNpcs', npcList));
    memeForm.addEventListener('submit', (e) => handleUpload(e, 'CustomMemes', memeList));
    npcList.addEventListener('click', (e) => handleDelete(e, 'CustomNpcs', npcList));
    memeList.addEventListener('click', (e) => handleDelete(e, 'CustomMemes', memeList));

    // 初始加载列表
    renderAssetList('CustomNpcs', npcList);
    renderAssetList('CustomMemes', memeList);

    console.log("NOVA: 我的素材工坊已准备就绪。");
}



setupCustomAssetManager();
 // 新的魔法函数，它会根据chat.version来替换这个页面的所有相关词语
// 【V2 精准替换版】，修复了按钮失效的问题
async function applyThemeAndData() {
    try {
        // 第一步：获取版本，确定当前主题（这部分和以前一样）
        const chatVariables = await getVariables({ type: 'chat' });
        if (chatVariables && chatVariables.world_version) {
            const version = String(chatVariables.world_version);
            if (themeConfig[version]) {
                currentTheme = themeConfig[version];
                //console.log(`💖 妈妈检测到版本 ${version}，为新界面切换到【${currentTheme.mainSystem}】主题。`);
            }
        }

        // 第二步：妈妈为你施展“精准替换”魔法，不再使用粗暴的innerHTML替换
        const defaultTerms = themeConfig.default;
        const replacements = {};
        for (const key in defaultTerms) {
            if (defaultTerms[key] !== currentTheme[key]) {
                replacements[defaultTerms[key]] = currentTheme[key];
            }
        }

        // --- 替换静态的、可见的UI文本 ---
        document.querySelectorAll('.label, .action-button, .modal-title, .shop-title, h3, h4').forEach(el => {
            for (const original in replacements) {
                if (el.textContent.includes(original)) {
                    el.textContent = el.textContent.replace(new RegExp(original, 'g'), replacements[original]);
                }
            }
        });

        // --- 对一些特殊元素进行单独、精确的设定 ---
        // 商店总计的标签
        const cartTotalEl = document.getElementById('cart-total');
        if (cartTotalEl) {
            cartTotalEl.textContent = cartTotalEl.textContent.replace(themeConfig.default.currency, currentTheme.currency);
        }

        // --- 替换动态生成数据的源头（商品描述） ---
        const regexMap = {};
        for (const original in replacements) {
            regexMap[original] = new RegExp(original, 'g');
        }

        fixedItems.forEach(item => {
            for (const original in replacements) {
                const regex = regexMap[original];
                // 替换效果[4]和描述[5]
                if (typeof item[4] === 'string') item[4] = item[4].replace(regex, replacements[original]);
                if (typeof item[5] === 'string') item[5] = item[5].replace(regex, replacements[original]);
            }
        });

    } catch (e) {
        console.error("妈妈在新界面施展“词语替换”魔法时出错了:", e);
    }
}
      // --- 新增：主题切换逻辑 ---






    /**
     * 函数：切换主题 (已修改)
     * 现在它会在预设主题和自定义主题之间切换
     */
    function switchTheme() {
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        applyTheme(currentThemeIndex); // 应用预设主题
        try {
            // 保存的是预设主题的索引, 并清除自定义主题的标记
            localStorage.setItem('terminalThemeIndex', currentThemeIndex);
            localStorage.removeItem('useCustomTheme');
        } catch (e) {
            console.warn("无法保存主题设置。");
        }
    }  
  /**
     * 函数：应用指定索引的主题 (保持不变，但我们现在知道它的作用)
     * @param {number} themeIndex - 主题的索引
     */
    function applyTheme(themeIndex) {
        if (themeIndex >= 0 && themeIndex < themes.length) {
            currentThemeIndex = themeIndex;
            const theme = themes[currentThemeIndex];
            const root = document.documentElement;
            // 先重置所有可编辑的变量，以防从自定义主题切换回来时残留
            editableColorVars.forEach(item => {
                 root.style.removeProperty(item.var);
            });
            // 应用主题中的所有变量（包括非颜色的，如果未来有的话）
            for (const [key, value] of Object.entries(theme)) {
                root.style.setProperty(key, value);
            }
             // 应用背景色（特殊处理）
            root.style.setProperty('--background-color', theme['--background-color'] || '#0a192f');
        }
    }
 
// 1. 定义一个函数来应用字体大小
function applyFontSize(size) {
    const root = document.documentElement;
    const sizeInPx = `${size}px`;

    // 将字体大小应用到全局CSS变量上
    root.style.setProperty('--base-font-size', sizeInPx);

    // 更新滑块旁边的数值显示
    const fontSizeValueDisplay = document.getElementById('font-size-value');
    if (fontSizeValueDisplay) {
        fontSizeValueDisplay.textContent = sizeInPx;
    }

    // （可选）确保滑块的位置也同步更新，这在页面加载时很有用
    const fontSizeSlider = document.getElementById('font-size-slider');
    if (fontSizeSlider) {
        fontSizeSlider.value = size;
    }
}
// 1. 定义一个函数来应用行高
// 1. 定义一个函数来应用字体家族



// 1. 我们的魔法字体库 (一个巨大的衣橱！)
// 我们将字体分成了不同的类别，方便挑选。
const fontLibrary = {
    "系统内置 (最快)": [
        { name: "系统默认字体", value: "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'" },
        { name: "通用黑体 (雅黑/苹方)", value: "'PingFang SC', 'Microsoft YaHei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif" },
        { name: "通用宋体 (中易宋体)", value: "SimSun, 'STSong', serif" },
        { name: "通用楷体 (中易楷体)", value: "KaiTi, 'STKaiti', serif" },
        { name: "通用仿宋 (中易仿宋)", value: "FangSong, 'STFangsong', serif" },
    ],
    "在线衬线体 (Serif)": [
        { name: "思源宋体 (Noto Serif SC)", value: "'Noto Serif SC', serif", url: "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" },
        { name: "站酷小魏体 (ZCOOL XiaoWei)", value: "'ZCOOL XiaoWei', serif", url: "https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&display=swap" },
        { name: "马善政毛笔楷体", value: "'Ma Shan Zheng', cursive", url: "https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" },
    ],
    "在线无衬线体 (Sans-serif)": [
        { name: "思源黑体 (Noto Sans SC)", value: "'Noto Sans SC', sans-serif", url: "https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" },
        { name: "阿里巴巴普惠体 2.0", value: "'Alibaba PuHuiTi 2.0', sans-serif", url: "https://puhuiti.oss-accelerate.aliyuncs.com/Alibaba-PuHuiTi-2.0/01f8319128f7/css/alibabapuhuiti_2_0_web.css"},
        { name: "站酷酷黑 (ZCOOL Kuhei)", value: "'ZCOOL KuHei', sans-serif", url: "https://fonts.googleapis.com/css2?family=ZCOOL+KuHei&display=swap" },
    ],
    "在线楷体/仿宋 (Kaiti/Fangsong)": [
         { name: "霞鹜文楷 (LXGW WenKai)", value: "'LXGW WenKai', cursive", url: "https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" },
         { name: "鸿雷板书/粉笔字", value: "'Hong Lei', cursive", url: "https://fonts.googleapis.com/css2?family=Hong+Lei&display=swap" },
    ],
    "在线手写/艺术体 (Artistic)": [
        { name: "站酷快乐体 (ZCOOL KuaiLe)", value: "'ZCOOL KuaiLe', cursive", url: "https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" },
        { name: "龙藏体 (Long Cang)", value: "'Long Cang', cursive", url: "https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" },
        { name: "沐瑶软笔手写体", value: "'Muyao', cursive", url: "https://cdn.jsdelivr.net/npm/izihun-muyao@1.0.0/Muyao-Softbrush.min.css"},
        { name: "增广贤文体 (Zeng Guang)", value: "'Zeng Guang', cursive", url: "https://fonts.googleapis.com/css2?family=Zeng+Guang&display=swap" },
        { name: "Liu Jian Mao Cao", value: "'Liu Jian Mao Cao', cursive", url: "https://fonts.googleapis.com/css2?family=Liu+Jian+Mao+Cao&display=swap" },
    ]
};
 // 2. 动态加载特定字体CSS的咒语
function loadSpecificFontCSS(font) {
    if (!font.url) return; // 如果这个字体不需要加载外部文件，就直接返回

    const fontLinkId = 'dynamic-font-stylesheet';
    let existingLink = document.getElementById(fontLinkId);

    // 如果已经有一个link标签，并且就是要加载的这个，那就不重复加载了
    if (existingLink && existingLink.href === font.url) {
        return;
    }

    // 如果没有，或者URL不同，就创建一个新的
    if (!existingLink) {
        existingLink = document.createElement('link');
        existingLink.id = fontLinkId;
        existingLink.rel = 'stylesheet';
        document.head.appendChild(existingLink);
    }

    // 更新它的href来加载新字体
    existingLink.href = font.url;
}

// 3. 应用字体的核心函数（升级版！）
function applyFontFamily(fontValue) {
    const root = document.documentElement;
    root.style.setProperty('--base-font-family', fontValue);

    // 在字体库里找到我们选择的那个字体对象
    let selectedFontObject = null;
    for (const category in fontLibrary) {
        const found = fontLibrary[category].find(font => font.value === fontValue);
        if (found) {
            selectedFontObject = found;
            break;
        }
    }

    // 如果找到了，并且它需要从网络加载，就调用加载咒语
    if (selectedFontObject) {
        loadSpecificFontCSS(selectedFontObject);
    }

    // 更新下拉菜单的显示
    const fontFamilySelector = document.getElementById('font-family-selector');
    if (fontFamilySelector) {
        fontFamilySelector.value = fontValue;
    }
}

// 4. 填充我们魔法衣橱的咒语 (把所有字体挂上去)
function populateFontSelector() {
    const selector = document.getElementById('font-family-selector');
    if (!selector) return;

    selector.innerHTML = ''; // 先清空

    for (const category in fontLibrary) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category; // 创建分类标签，比如 "在线楷体"

        fontLibrary[category].forEach(font => {
            const option = document.createElement('option');
            option.value = font.value;
            option.textContent = font.name;
            // 最神奇的一步：让选项自己用自己的字体显示！
            option.style.fontFamily = font.value;
            if(font.url) { // 对于网络字体，给一点加载时间，所以可以加个通用字体
                 option.style.fontFamily = `'${font.name}', ${font.value}`;
            }

            optgroup.appendChild(option);
        });

        selector.appendChild(optgroup);
    }
}

// 5. 让字体选择器动起来！
const fontFamilySelector = document.getElementById('font-family-selector');
if (fontFamilySelector) {
    fontFamilySelector.addEventListener('change', (event) => {
        const newFontFamily = event.target.value;
        applyFontFamily(newFontFamily);

        try {
            localStorage.setItem('baseFontFamily', newFontFamily);
        } catch (e) {
            console.warn("无法保存字体设置。");
        }
    });
}
function applyLineHeight(height) {
    const root = document.documentElement;
    // 将行高应用到全局CSS变量上
    root.style.setProperty('--base-line-height', height);

    // 更新滑块旁边的数值显示，保留一位小数让它更整齐
    const lineHeightValueDisplay = document.getElementById('line-height-value');
    if (lineHeightValueDisplay) {
        lineHeightValueDisplay.textContent = parseFloat(height).toFixed(1);
    }

    // 同样，确保滑块位置同步
    const lineHeightSlider = document.getElementById('line-height-slider');
    if (lineHeightSlider) {
        lineHeightSlider.value = height;
    }
}

// 2. 找到我们的行高滑块
const lineHeightSlider = document.getElementById('line-height-slider');

// 3. 监听滑块的拖动事件
if (lineHeightSlider) {
    lineHeightSlider.addEventListener('input', (event) => {
        const newHeight = event.target.value;
        applyLineHeight(newHeight);

        // 同样，将选择保存到 localStorage
        try {
            localStorage.setItem('baseLineHeight', newHeight);
        } catch (e) {
            console.warn("无法保存行高设置。");
        }
    });
}

// 2. 找到我们的新滑块
const fontSizeSlider = document.getElementById('font-size-slider');

// 3. 监听滑块的拖动事件
if (fontSizeSlider) {
    fontSizeSlider.addEventListener('input', (event) => {
        const newSize = event.target.value;

        // 当用户拖动时，立刻应用新的字体大小
        applyFontSize(newSize);

        // 并将选择保存到 localStorage，就像保存主题一样
        try {
            localStorage.setItem('baseFontSize', newSize);
        } catch (e) {
            console.warn("无法保存字体大小设置。");
        }
    });
}
    /**
     * 函数：应用自定义主题
     * @param {object} themeObject - 包含自定义颜色键值对的对象
     */
    function applyCustomTheme(themeObject) {
         const root = document.documentElement;
         for(const [key, value] of Object.entries(themeObject)) {
              root.style.setProperty(key, value);
         }
    }

 
     /**
     * 函数：加载保存的自定义主题
     * return {object} - 返回保存的主题对象，如果不存在则返回空对象
     */
    function loadCustomTheme() {
        try {
            const savedTheme = localStorage.getItem('customTerminalTheme');
            return savedTheme ? JSON.parse(savedTheme) : {};
        } catch(e) {
            console.warn("无法加载自定义主题。", e);
            return {};
        }
    }

    /**
     * 函数：初始化颜色编辑器
     */
    function initializeColorEditor() {
        colorPickerContainer.innerHTML = '';
        const currentStyles = getComputedStyle(document.documentElement);

        editableColorVars.forEach(item => {
            const wrapper = document.createElement('div');
            wrapper.className = 'color-picker-item';

            const label = document.createElement('label');
            label.textContent = item.label;

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.dataset.cssVar = item.var;

            // 获取当前实时生效的颜色值（可能是预设主题或已加载的自定义主题）
            let currentColor = currentStyles.getPropertyValue(item.var).trim();

            // 对于RGBA， input[type=color] 需要HEX。我们进行一个简单的转换。
            // 简单的处理方式是忽略alpha通道或设置一个默认不透明的颜色。
            // 注意：这个转换很简单，可能不完美。
            if (currentColor.startsWith('rgba')) {
                 const parts = currentColor.match(/(\d+)/g);
                 if (parts) {
                     currentColor = `#${parseInt(parts[0]).toString(16).padStart(2, '0')}${parseInt(parts[1]).toString(16).padStart(2, '0')}${parseInt(parts[2]).toString(16).padStart(2, '0')}`;
                 }
            }
            colorInput.value = currentColor;


            // 实时预览
            colorInput.addEventListener('input', (e) => {
                const newColor = e.target.value;
                document.documentElement.style.setProperty(item.var, newColor);
                // 对于需要Alpha通道的颜色，我们在这里硬编码添加
                if (item.var === '--container-bg-color') {
                     document.documentElement.style.setProperty(item.var, hexToRgba(newColor, 0.75));
                } else if (item.var === '--border-color') {
                     document.documentElement.style.setProperty(item.var, hexToRgba(newColor, 0.3));
                } else if (item.var === '--glow-color' || item.var === '--danger-glow-color') {
                     document.documentElement.style.setProperty(item.var, hexToRgba(newColor, 0.5));
                }
            });

            wrapper.appendChild(label);
            wrapper.appendChild(colorInput);
            colorPickerContainer.appendChild(wrapper);
        });
    }

    // Hex to RGBA 辅助函数
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }


    // 事件监听
    editCustomThemeBtn.addEventListener('click', () => {
        const isVisible = customThemeEditor.style.display !== 'none';
        if (!isVisible) {
            initializeColorEditor();
            customThemeEditor.style.display = 'flex';
            editCustomThemeBtn.textContent = '完成';
        } else {
            // 用户点击“完成”，保存更改
            const newCustomTheme = {};
            document.querySelectorAll('#color-picker-container input[type="color"]').forEach(input => {
                const cssVar = input.dataset.cssVar;
                let colorValue = input.value;
                // 保存时也转换rgba
                if (cssVar === '--container-bg-color') {
                    colorValue = hexToRgba(colorValue, 0.75);
                } else if (cssVar === '--border-color') {
                    colorValue = hexToRgba(colorValue, 0.3);
                } else if (cssVar === '--glow-color' || cssVar === '--danger-glow-color') {
                     colorValue = hexToRgba(colorValue, 0.5);
                }
                newCustomTheme[cssVar] = colorValue;
            });
            try {
                localStorage.setItem('customTerminalTheme', JSON.stringify(newCustomTheme));
                customTheme = newCustomTheme; // 更新内存中的自定义主题
                console.log('自定义主题已保存!');
            } catch(e) {
                console.warn('无法保存自定义主题。');
            }
            customThemeEditor.style.display = 'none';
            editCustomThemeBtn.textContent = '编辑';
        }
    });

    applyCustomThemeBtn.addEventListener('click', () => {
        const savedCustomTheme = loadCustomTheme();
        if (Object.keys(savedCustomTheme).length > 0) {
            customTheme = savedCustomTheme;
            applyCustomTheme(customTheme);
            try {
                // 设置一个标记，表示正在使用自定义主题
                localStorage.setItem('useCustomTheme', 'true');
                // 可以选择性地清除预设主题索引，或保留它以便切换回去
                // localStorage.removeItem('terminalThemeIndex');
            } catch (e) {
                console.warn("无法保存自定义主题使用状态。");
            }
        } else {
            // 如果没有保存的自定义主题，可以给个提示
            alert('请先编辑并保存一个自定义主题。');
        }
    });


 
    // 全局变量存储数据
    let currentMapData = null;
    let currentGameData = null;
   // --- 全局变量和数据获取 ---
        let playCharacterData = getVariables({ type: 'chat' }).play_character_data;
        let assaSettingsData = {};
 
let checkMemoryData = null;   // 用于存储上一轮的投掷记忆
 let worldAttitudeData = null; // 用于存储世界态度变量
let characterStatusData = null; // 用于存储人物状态变量
let lasttoken = 0;
let summarys = null;
let ISNEWMAP = "false";


    let worldBookState = {
        currentTab: 'settings', // 默认显示设定
        currentPage: 1,
        itemsPerPage: 5, // 每页显示5条，你可以根据喜好调整
        data: {}
    };
    /**
     * 安全地从数据源获取值。
     * @param {*} value - 输入的数据
     * @returns {string|number} - 处理后的值
     */
    function SafeGetValue(value) {
        if (Array.isArray(value)) {
            let res = value.length > 0 ? value[0] : '';
            return(res === '' || res === null || res === undefined) ? '无' : res;
        }
        return (value === '' || value === null || value === undefined) ? '无' : value;

    }



 
async function handleUpgrade(targetPath, targetName, currentLevel, type) {
    // 显示级数选择模态框
    showLevelSelectionModal(targetPath, targetName, currentLevel, type);
}

 // 找到并替换整个 showLevelSelectionModal 函数
function showLevelSelectionModal(targetPath, targetName, currentLevel, type) {
    const currentXp = playCharacterData.货币段.经验值[0];

    // 生成模态框的HTML内容，注意：移除了 onclick 和 onchange
    const modalContent = `
        <div style="padding: 20px;">
            <p><strong>当前"${targetName}"等级:</strong> ${currentLevel}</p>
            <p><strong>当前${currentTheme.exp}:</strong> ${currentXp}</p>

            <div style="margin: 20px 0;">
                <label for="upgrade-levels" >选择升级级数:</label>
                <select id="upgrade-levels">
                    ${generateLevelOptions(currentLevel, type, currentXp)}
                </select>
            </div>

            <div id="upgrade-cost-display" >
                选择升级级数以查看消耗
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="confirm-upgrade-btn" disabled>确定升级</button>
            </div>
        </div>
    `;

    // 显示模态框（这部分不变）
    showModal('shop-modal', '选择升级级数', modalContent);

    // --- 魔法在这里！---
    // 等待模态框渲染完成后，我们再来为里面的元素安排工作
    setTimeout(() => {
        const selectElement = document.getElementById('upgrade-levels');
        const confirmButton = document.getElementById('confirm-upgrade-btn');

        if (selectElement && confirmButton) {
            // 为下拉框安排“改变时更新-消耗”的工作
            selectElement.addEventListener('change', () => {
                updateUpgradeCost(type, currentLevel);
            });

            // 为按钮安排“点击时确认升级”的工作
            confirmButton.addEventListener('click', () => {
                confirmUpgrade(targetPath, targetName, currentLevel, type);
            });

            // 第一次打开时，也主动更新一下消耗显示
            updateUpgradeCost(type, currentLevel);
        }
    }, 100); // 延迟一点点时间确保元素已经出现在页面上
}

function generateLevelOptions(currentLevel, type, currentXp) {
    let options = '';
    
    // 生成1-10级的选项
    for (let i = 1; i <= 10; i++) {
        const targetLevel = currentLevel + i;
        const totalCost = calculateLevelRangeCost(currentLevel, targetLevel, type);
        const canAfford = currentXp >= totalCost;
        const affordText = canAfford ? '' : ' (经验不足)';
        const textColor = canAfford ? '' : ' style="color: #999;"';
        
        options += `<option value="${i}"${textColor}>${i}级 (${currentLevel} → ${targetLevel})${affordText}</option>`;
    }
    
    return options;
}

function updateUpgradeCost(type, currentLevel) {
    const selectElement = document.getElementById('upgrade-levels');
    const confirmButton = document.getElementById('confirm-upgrade-btn');
    const costDisplay = document.getElementById('upgrade-cost-display');
    
    if (!selectElement || !confirmButton || !costDisplay) return;
    
    const selectedLevels = parseInt(selectElement.value);
    const targetLevel = currentLevel + selectedLevels;
    const totalCost = calculateLevelRangeCost(currentLevel, targetLevel, type);
    const currentXp = playCharacterData.货币段.经验值[0];
    const canAfford = currentXp >= totalCost;
    
    // 更新消耗显示
    const statusColor = canAfford ? '#28a745' : '#dc3545';
    const statusIcon = canAfford ? '✓' : '✗';
    const statusText = canAfford ? `${currentTheme.exp}充足` : `${currentTheme.exp}不足 (缺少 ${totalCost - currentXp} 点)`;
    costDisplay.innerHTML = `
        <div style="font-size: 14px;">
            <p><strong>升级 ${selectedLevels} 级消耗:</strong></p>
               <p>${currentTheme.exp}: <strong>${totalCost}</strong> 点</p>
            <p>当前拥有: <strong>${currentXp}</strong> 点</p>
            <p>
                ${statusIcon} ${statusText}
            </p>
        </div>
    `;
    
    // 更新确定按钮状态
    confirmButton.disabled = !canAfford;
    confirmButton.style.opacity = canAfford ? '1' : '0.5';
    confirmButton.style.cursor = canAfford ? 'pointer' : 'not-allowed';
}

 async function confirmUpgrade(targetPath, targetName, currentLevel, type) {
    const selectElement = document.getElementById('upgrade-levels');
    if (!selectElement) return;
    
    const selectedLevels = parseInt(selectElement.value);
    const targetLevel = currentLevel + selectedLevels;
    const totalCost = calculateLevelRangeCost(currentLevel, targetLevel, type);
    const currentXp = playCharacterData.货币段.经验值[0];
    
    // 最终验证经验是否足够
    if (currentXp < totalCost) {
        showModal('shop-modal', '经验不足', 
            `升级"${targetName}" ${selectedLevels}级需要 ${totalCost} 点经验值，您当前只有 ${currentXp} 点。`);
        return;
    }
    
 try {
    const newXp = currentXp - totalCost;
    const messageToSend = `<（${currentTheme.exp}已扣除，禁止重复扣除）${currentGameData.user_character.name}将"${targetName}"从 ${currentLevel} 级提升至 ${targetLevel} 级！>\n`;
triggerassa(`/setinput ${messageToSend}`);
    // --- 这是一个通用的更新函数，我们会调用它两次 ---
    const updateLogic = (currentVars) => {
        // 创建一个深拷贝，确保我们不会意外修改原始数据
        const workingCopy = JSON.parse(JSON.stringify(currentVars));

        // 确保 play_character_data 存在
        if (!workingCopy.play_character_data) {
            console.error("错误：更新目标 'play_character_data' 不存在。");
            return currentVars; // 如果结构不对，返回原始数据以避免崩溃
        }

        // 这是一个辅助函数，用于根据路径在指定的对象内部设置值
        const setNestedValue = (obj, path, value) => {
            const keys = path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                if (!current[keys[i]]) {
                    // 如果路径中的某个环节不存在，就创建一个空对象
                    current[keys[i]] = {};
                }
                current = current[keys[i]];
            }
            const finalKey = keys[keys.length - 1];
            if (Array.isArray(current[finalKey])) {
                current[finalKey][0] = value;
            } else {
                current[finalKey] = value;
            }
        };

        const characterData = workingCopy.play_character_data;

        // 1. 更新目标属性的等级
        setNestedValue(characterData, targetPath, targetLevel);

        // 2. 更新经验值
        const expPath = `货币段.${currentTheme.exp}`;
        setNestedValue(characterData, expPath, newXp);

        return workingCopy; // 返回更新后的完整变量对象
    };
    // ----------------------------------------------------

    // 第一步：同步更新 'chat' 和 'message' 变量
    // 我们用 Promise.all 来确保两个更新都完成后再继续
    await Promise.all([
        updateVariablesWith(updateLogic, { type: 'chat' }),
        updateVariablesWith(updateLogic, { type: 'message'})
    ]);

 initDisplay(false);


    // 第三步：显示成功模态框
    showModal('shop-modal', '升级成功',
        `"${targetName}" 已成功从 ${currentLevel} 级提升至 ${targetLevel} 级！<br><br>消耗${currentTheme.exp}: ${totalCost} 点`);

    // 第四步：刷新整个界面，确保所有数据和显示都完美同步
    await initDisplay(false);

} catch (error) {
    console.error("升级失败:", error);
    showModal('shop-modal', '操作失败', '在更新数据或发送消息时发生错误。请查看控制台获取详细信息。');
}
}

// 计算升级指定级数范围的总消耗
function calculateLevelRangeCost(fromLevel, toLevel, type) {
    let totalCost = 0;
    for (let level = fromLevel; level < toLevel; level++) {
        totalCost += calculateXpCost(level, type);
    }
    return totalCost;
}

function calculateXpCost(currentLevel, type) {
    if (type === 'attribute') {
        // 属性升级成本更高，例如 (当前等级+1) * 15
        return (currentLevel + 1) * 15;
    }
    // 技能升级成本，例如 (当前等级+1) * 10
    return (currentLevel + 1) * 10;
}

    /**
 * 新增：填充除角色状态页外的所有通用数据
 * @param {object} statData - stat_data 对象
 * @param {object} assaData - assa_data 对象
 */
function populateGeneralData(statData, assaData,playData) {
    const worldData = statData.world_shard;
    const taskData = worldData.task;
    const charData = statData.user_character;

  document.getElementById('world-shard').textContent = SafeGetValue(worldData.name) ||'SYSTEM TERMINAL';

 
    document.getElementById('info-world-desc').textContent = SafeGetValue(worldData.description);
 

// 获取世界能量层级和最大能量值
var world_level = statData.world_shard?.level[0] || '中';
var world_max_enegy = 3;
if (world_level === '无') {
    world_max_enegy = 3;
} else if (world_level === '低') {
    world_max_enegy = 5;
} else if (world_level === '中') {
    world_max_enegy = 7;
} else if (world_level === '高') {
    world_max_enegy = 12;
} else if (world_level === '神话') {
    world_max_enegy = 16;
} else {
    world_max_enegy = 7;
}
  
// 更新标题栏信息
document.getElementById('header-location').textContent = SafeGetValue(charData.current_location);
document.getElementById('header-time').textContent = SafeGetValue(statData.纪年)+" "+SafeGetValue(statData.日期)+" "+SafeGetValue(statData.时间)+" "+SafeGetValue(statData.星期)+" "+SafeGetValue(statData.天气);
document.getElementById('header-check').textContent = SafeGetValue(statData.检定属性);
document.getElementById('header-combat').textContent = SafeGetValue(statData.敌方攻击骰池);
document.getElementById('header-difficulty').textContent = `${SafeGetValue(statData.检定难度)}(${world_level}:1-${world_max_enegy})`;


/* 填充任务详情 */
    document.getElementById('task-objective').textContent = SafeGetValue(taskData.objective);
    document.getElementById('task-status').textContent = SafeGetValue(taskData.status);
    const progress = SafeGetValue(taskData.progress);
    document.getElementById('task-progress-bar').style.width = (typeof progress === 'number' ? progress : 0) + '%';
    document.getElementById('task-rewards').textContent = SafeGetValue(taskData.rewards);
    document.getElementById('task-penalties').textContent = SafeGetValue(taskData.penalties);
    document.getElementById('task-time-left').textContent = SafeGetValue(taskData.time_left) + ' 天';


}

// --- 新增：获取并解析状态加成 (增强版) ---
function getStatusBonuses(statData) {
    const bonuses = {};
    const statusString = _.get(statData, "user_character.status[0]", "");
    if (!statusString) {
        return bonuses;
    }

    // 定义属性和技能的分类，用于批量处理
    const attributeCategories = {
        '生理属性': ['力量', '敏捷', '耐力'],
        '心智属性': ['智力', '感知', '决心'],
        '互动属性': ['风度', '操控', '沉着'],
        '全属性': ['力量', '敏捷', '耐力', '智力', '感知', '决心', '风度', '操控', '沉着'],
        '生理技能': ['运动', '肉搏', '驾驶', '枪械', '手上功夫', '隐藏', '求生', '白刃', '弓箭'],
        '心智技能': ['学识', '电脑', '手艺', '调查', '医学', '神秘学', '科学'],
        '互动技能': ['动物沟通', '感受', '表达', '胁迫', '交际', '掩饰'],
        '全技能': ['运动', '肉搏', '驾驶', '枪械', '手上功夫', '隐藏', '求生', '白刃', '弓箭', '学识', '电脑', '手艺', '调查', '医学', '神秘学', '科学', '动物沟通', '感受', '表达', '胁迫', '交际', '掩饰']
    };
    // 为了更快的查找，创建一个反向映射，知道每个子属性属于哪个大类
    const subAttributeMap = {};
    for (const category in attributeCategories) {
        attributeCategories[category].forEach(attr => {
            if (!subAttributeMap[attr]) subAttributeMap[attr] = [];
            subAttributeMap[attr].push(category);
        });
    }

    const matches = statusString.match(/【[^】]+】/g);

    if (matches) {
        matches.forEach(match => {
            const content = match.substring(1, match.length - 1);
            const attributes = content.split(/;|；/).map(attr => attr.trim()).filter(attr => attr !== "");

            attributes.forEach(attr => {
                // 正则匹配 "名称+/-数值" (暂不支持百分比)
                const parts = attr.match(/^(.+?)\s*([+-]\d+)$/) || attr.match(/^(.+?)[:|：]\s*([+-]?\d+)$/);

                if (parts && parts.length === 3) {
                    let name = parts[1].trim();
                    const value = parseInt(parts[2].trim().replace('+', ''), 10);

                    // 检查是类别还是单个属性
                    if (attributeCategories[name]) {
                        // 是一个类别，批量应用
                        attributeCategories[name].forEach(subAttr => {
                            bonuses[subAttr] = (bonuses[subAttr] || 0) + value;
                        });
                    } else {
                        // 是单个属性
                        bonuses[name] = (bonuses[name] || 0) + value;
                    }
                }
            });
        });
    }
    return bonuses;
}

/**
 * 获取并解析所有已装备物品的属性加成
 * @param {object} statData - 核心数据 currentGameData
 * @param {object} assaData - 设定数据 assaSettingsData
 * @returns {object} 一个以属性名为键，加成数值为值的对象, e.g. { "力量": 5, "敏捷": -2 }
 */
function getEquipmentBonuses(statData, assaData) {
    const bonuses = {};
    // 安全地访问当前装备，如果不存在则使用空对象
    const equipment = statData?.user_character?.当前装备 || {};
    const equipmentList = [];

    // 定义一个包含所有合法的、我们关心的穿戴装备槽位的列表
    const validWearableSlots = ['头部', '身体', '手部', '脚部', '饰品'];

   // 1. 处理"手持"装备 - 支持分号分割的多个装备
if (equipment.手持 && Array.isArray(equipment.手持) && equipment.手持[0] && equipment.手持[0] !== "无") {
    // 按分号分割手持装备，支持同时手持多个物品
    const handItems = equipment.手持[0].split(/;|；/).map(item => item.trim()).filter(item => item !== "无" && item !== "");
    equipmentList.push(...handItems);
}

const wearableItems = equipment.穿戴;
// 确保穿戴装备部分是一个有效的对象
if (wearableItems && typeof wearableItems === 'object' && wearableItems !== null) {
    // 遍历预先定义好的合法槽位列表
    validWearableSlots.forEach(slotName => {
        // 根据合法的槽位名，去数据中精确查找对应的装备信息
        const slot = wearableItems[slotName];

        // 对找到的槽位信息进行有效性检查
        if (slot && Array.isArray(slot) && slot[0] && slot[0] !== "无") {
            // 按分号分割该部位的装备，支持同一部位穿戴多个物品
            const slotItems = slot[0].split(/;|；/).map(item => item.trim()).filter(item => item !== "无" && item !== "");
            equipmentList.push(...slotItems);
        }
    });
}

 equipmentList.forEach(itemName => {
    // 首先，我们和以前一样，从背包中寻找装备数据
    const itemData =
        assaData?.global_set?.背包?.[itemName] ||
        null;

    // 确保我们找到了数据才继续
    if (itemData) {
        let stringToParse = ''; // 我们准备一个篮子，并确保它始终是字符串

        // 第一步：我们先检查拿到的 itemData 到底是什么类型
        if (typeof itemData === 'string') {
            // 如果它是一封“信”(string)，我们就尝试用JSON的方式去读它
            try {
                const itemObject = JSON.parse(itemData);
                // 如果读出来是一个“礼盒”(object)，并且里面有我们想要的effect“清单”
                if (typeof itemObject === 'object' && itemObject !== null ) {
                   
    if (typeof itemObject.effect === 'string') {
        
        stringToParse = itemObject.effect;
    }
    // 如果没有 effect，尝试中文属性
    else if (typeof itemObject.属性 === 'string') {
        stringToParse = itemObject.属性;
    } else if (typeof itemObject.效果 === 'string') {
        stringToParse = itemObject.效果;
    }
                }
            } catch (e) {
                // 如果用JSON的方式读信失败了，说明它就是一封普通的信，内容就是我们要的
                // 比如 "【防御+5】" 这种
                stringToParse = itemData;
            }
        } else if (typeof itemData === 'object' && itemData !== null) {
   
                if (typeof itemData.effect === 'string') {
        stringToParse = itemData.effect;
    }
    // 如果没有 effect，尝试中文属性
    else if (typeof itemData.属性 === 'string') {
        stringToParse = itemData.属性;
    } else if (typeof itemData.效果 === 'string') {
        stringToParse = itemData.效果;
    }
 
        }

        // 现在，无论来源如何，我们的“篮子”(stringToParse)里都装好了要处理的属性字符串
        // 正则匹配所有【属性+数值】或【属性-数值】格式的描述
        const matches = stringToParse.match(/【[^】]+】/g);

        // ---- 后续的加成计算逻辑完全保持不变，因为它非常棒 ----
        if (matches) {
            const derivedAttrMapping = {
                '防御': '衍生属性段.防御.基础防御',
                '速度': '衍生属性段.速度.基础速度'
            };

            matches.forEach(match => {
                const content = match.substring(1, match.length - 1);
                const attributes = content.split(/;|；/).map(attr => attr.trim()).filter(attr => attr !== "");

                attributes.forEach(attr => {
                    const parts = attr.match(/^(.+?)\s*([+-]\d+)$/) || attr.match(/^(.+?)[:|：]\s*([+-]?\d+)$/);

                    if (parts && parts.length === 3) {
                        let attrName = parts[1].trim();
                        const value = parseInt(parts[2].trim().replace('+', ''), 10);

                        const mappedPath = derivedAttrMapping[attrName];
                        const finalKey = mappedPath || attrName;

                        if (!bonuses[finalKey]) {
                            bonuses[finalKey] = 0;
                        }
                        bonuses[finalKey] += value;
                    }
                });
            });
        }
    }
});
    return bonuses;
}


 /**
 * 显示美化后的称号管理面板
 * @param {object} assaData - 包含 global_set 的 assaData 对象
 */
function showTitleManager(assaData) {
   const allTitles = assaData?.global_set?.称号|| {};
 
    // 定义一个 Key 到中文标签的映射，让显示更友好
    const keyToLabelMap = {
        '达成条件': '达成条件',
        '描述': '描述',
        '外观效果': '外观效果'
        // 你可以在这里添加更多你想显示的 key 的中文映射
    };

    let modalContent = '<div class="title-manager-list">';
    modalContent += '<h3>称号管理</h3><p class="modal-subtitle">点击称号条目可展开/收起详情</p>';

    const titleKeys = Object.keys(allTitles).filter(key => key !== '_comment_');

    if (titleKeys.length === 0) {
        modalContent += '<p style="text-align:center; color: var(--text-secondary-color);">目前没有任何称号。</p>';
    } else {
        titleKeys.forEach(titleName => {
            const titleData = allTitles[titleName];
             const isShown = String(titleData.是否显示).toLowerCase() === 'true';

            // 为每个称号创建一个容器，包含可点击的主条目和隐藏的详情面板
            modalContent += `
                <div class="title-item-container">
                    <div class="title-manager-item" data-title-name="${titleName}">
                        <span class="title-name">${titleName}</span>
                        <div class="title-actions">
                            <label class="toggle-switch">
                                <input type="checkbox" class="title-toggle-checkbox" data-title="${titleName}" ${isShown ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="title-details-panel" id="details-for-${titleName.replace(/\s+/g, '_')}"></div>
                </div>
            `;
        });
    }
    modalContent += '</div>';

    showModal('shop-modal', '');
    const messageEl = document.getElementById('shop-modal-message');

    if (messageEl) {
        messageEl.innerHTML = modalContent;

        // 使用更智能的事件委托来处理所有交互
        messageEl.addEventListener('click', function(event) {
            const item = event.target.closest('.title-manager-item');
            const toggle = event.target.closest('.toggle-switch');

            // 如果点击的是开关，则不触发展开/收起逻辑
            if (toggle) {
                // 开关的 change 事件会单独处理
                return;
            }

            // 如果点击的是称号条目
            if (item) {
                const titleName = item.dataset.titleName;
                const detailsPanelId = `details-for-${titleName.replace(/\s+/g, '_')}`;
                const detailsPanel = document.getElementById(detailsPanelId);

                if (!detailsPanel) return;

                // 判断当前是否已展开
                const isCurrentlyActive = detailsPanel.classList.contains('active');

                // 先关闭所有其他已展开的面板
                document.querySelectorAll('.title-details-panel.active').forEach(panel => {
                    if (panel.id !== detailsPanelId) {
                        panel.classList.remove('active');
                        panel.innerHTML = '';
                    }
                });

                // 如果当前是收起状态，则展开它
                if (!isCurrentlyActive) {
                    const titleData = allTitles[titleName];
                    let detailsHtml = '<ul>';
                    for (const key in titleData) {
                        // 过滤掉我们不希望直接显示的key
                        if (Object.prototype.hasOwnProperty.call(titleData, key) && key !== '是否显示') {
                            const label = keyToLabelMap[key] || key; // 使用映射或原始key
                            const value = titleData[key].toString().replace(/\\n/g, '<br>'); // 处理换行
                            detailsHtml += `<li><span class="detail-key">${label}:</span> <span class="detail-value">${value}</span></li>`;
                        }
                    }
                    detailsHtml += '</ul>';

                    detailsPanel.innerHTML = detailsHtml;
                    detailsPanel.classList.add('active');
                } else {
                    // 如果当前是展开状态，则收起它
                    detailsPanel.classList.remove('active');
                    // 可以加一个延时清空内容，等待动画结束
                    setTimeout(() => { detailsPanel.innerHTML = ''; }, 350);
                }
            }
        });

        // 开关的 change 事件处理（保持不变）
        messageEl.addEventListener('change', function(event) {
            if (event.target.classList.contains('title-toggle-checkbox')) {
                const titleToUpdate = event.target.dataset.title;
                const newStatus = event.target.checked;
                const command = `/setinput <updateMemory>\nmemory('global_set.称号.${titleToUpdate}','是否显示','${newStatus}')\n</updateMemory>\n<${userName} 将称号 [${titleToUpdate}] 设置为${newStatus ? '显示' : '隐藏'}>`;

                if (typeof triggerassa !== 'undefined') {
                    triggerassa(command);
                    showNovaAlert(`称号 [${titleToUpdate}] 显示状态更新指令已发送！`);
                }
            }
        });
    }
}
 // ==========================================================
// ========== 完整替换 populateCharacterPage 函数 ==========
// ==========================================================
function populateCharacterPage(playData, statData, assaData) {
    const charStat = statData.user_character;
    const derived = playData.衍生属性段;
    const currency = playData.货币段;
      const nameDisplay = document.getElementById('char-display-name');
    let titleContainer = document.getElementById('char-titles-container');
    // 如果HTML中没有这个元素，JS会自动创建并添加到名字上方
    if (!titleContainer && nameDisplay && nameDisplay.parentNode) {
        titleContainer = document.createElement('div');
        titleContainer.id = 'char-titles-container';
        titleContainer.className = 'char-titles-container'; // 使用 class 便于 CSS 美化
        nameDisplay.parentNode.insertBefore(titleContainer, nameDisplay);
    }

    if(titleContainer){
        titleContainer.innerHTML = ''; // 每次刷新前清空
        titleContainer.style.cursor = 'pointer'; // 鼠标变成小手，提示可点击
        titleContainer.setAttribute('title', '点击管理称号'); // 简单的悬浮提示

        const allTitles = assaData?.global_set?.称号 ||{};
        let displayedTitlesCount = 0;
        // 遍历所有称号，找到需要显示的
        for (const titleName in allTitles) {
            if (Object.prototype.hasOwnProperty.call(allTitles, titleName) && titleName !== '_comment_') {
                 if(String(allTitles[titleName].是否显示).toLowerCase() === 'true') {
                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'char-title-tag'; // 便于用CSS添加样式
                    titleSpan.textContent = `【${titleName}】`;
                    titleContainer.appendChild(titleSpan);
                    displayedTitlesCount++;
                }
            }
        }
        // 如果没有显示的称号，可以给个提示
        if(displayedTitlesCount === 0){
             titleContainer.innerHTML = '<span class="char-title-tag placeholder">(无显示称号)</span>';
        }

        // 为整个称号容器绑定点击事件，打开称号管理器
        titleContainer.onclick = () => showTitleManager(assaData);
    }


    // --- 左侧和中间面板 (基本不变) ---
    document.getElementById('char-display-name').textContent = SafeGetValue(charStat.name);
    //document.getElementById('char-display-status').textContent = SafeGetValue(charStat.status) || '正常';
    document.getElementById('char-display-prestige').textContent = SafeGetValue(charStat.Cross_world_prestige);
 
    // --- 状态栏折叠功能 ---
{ // 使用块作用域避免变量污染
    const statusSpan = document.getElementById('char-display-status');
    const statusLine = statusSpan.closest('.info-line');
    const statusLabel = statusLine?.querySelector('.info-label');
    const fullStatusText = SafeGetValue(charStat.status) || '正常';
    const COLLAPSE_THRESHOLD = 8; // 当状态文字超过8个字符时，启用折叠

    if (statusLabel) {
        // 清理可能存在的旧事件，以防函数重复调用导致事件重复绑定
        if (statusLine.__toggleHandler) {
            statusLabel.removeEventListener('click', statusLine.__toggleHandler);
            delete statusLine.__toggleHandler;
        }
        statusLabel.classList.remove('collapsible-label');

        if (fullStatusText.length > COLLAPSE_THRESHOLD) {
            const shortText = fullStatusText.substring(0, COLLAPSE_THRESHOLD) + '...';
            statusSpan.textContent = shortText; // 初始显示为折叠状态
            statusLine.dataset.isExpanded = 'false';

            statusLabel.classList.add('collapsible-label');

            const toggleHandler = () => {
                const isExpanded = statusLine.dataset.isExpanded === 'true';
                if (isExpanded) {
                    statusSpan.textContent = shortText;
                    statusLine.dataset.isExpanded = 'false';
                } else {
                    statusSpan.textContent = fullStatusText;
                    statusLine.dataset.isExpanded = 'true';
                }
            };

            statusLabel.addEventListener('click', toggleHandler);
            statusLine.__toggleHandler = toggleHandler; // 将处理器附加到父元素上，便于后续清理
        } else {
            statusSpan.textContent = fullStatusText; // 文本不长，直接显示
        }
    } else {
        // 如果找不到对应的标签，作为降级方案直接设置文本
         statusSpan.textContent = fullStatusText;
    }
}
// --- 状态栏折叠功能结束 ---

    const hp = derived.生命值;
    document.getElementById('char-hp-bar').style.width = (hp.当前值[0] / hp.上限[0] * 100) + '%';
    document.getElementById('char-hp-text').textContent = `${hp.当前值[0]} / ${hp.上限[0]}`;
    const will = derived.意志力;
    document.getElementById('char-will-bar').style.width = (will.当前值[0] / will.上限[0] * 100) + '%';
    document.getElementById('char-will-text').textContent = `${will.当前值[0]} / ${will.上限[0]}`;
    const energy = derived.能量池;
    document.getElementById('char-energy-label').textContent = SafeGetValue(energy.名称);
    document.getElementById('char-energy-bar').style.width = (Number(energy.当前值[0]) / Number(energy.上限[0]) * 100) + '%';
    document.getElementById('char-energy-text').textContent = `${Number(energy.当前值[0])} / ${Number(energy.上限[0])}`;

       // ================== 💖 把妈妈的代码放在这里 💖 ==================

    // 动态生成额外的资源条
    const dynamicBarsContainer = document.getElementById('dynamic-resource-bars-container');
    dynamicBarsContainer.innerHTML = ''; // 每次刷新前先清空

    const resourceBars = assaData?.global_set?.资源条;
    if (resourceBars) {
        for (const resourceName in resourceBars) {
            if (Object.prototype.hasOwnProperty.call(resourceBars, resourceName) && typeof resourceBars[resourceName] === 'object') {
                const resource = resourceBars[resourceName];

                // 创建元素
                const container = document.createElement('div');
                container.className = 'resource-bar-container';

                const label = document.createElement('div');
                label.className = 'resource-bar-label';
                label.textContent = resourceName;

                const barBg = document.createElement('div');
                barBg.className = 'progress-bar-bg resource'; // 复用样式

                const barFill = document.createElement('div');
                // 你可以创建一个通用的CSS类 'generic-resource' 来定义这些条的颜色
                barFill.className = 'progress-bar-fill generic-resource';
                const percentage = (Number(resource.当前值) / Number(resource.最大值)) * 100;
                barFill.style.width = `${Math.max(0, Math.min(100, percentage))}%`;

                const text = document.createElement('span');
                text.className = 'progress-bar-text';
                text.textContent = `${Number(resource.当前值) || 0} / ${Number(resource.最大值) || 0}`;

                // --- 核心：创建Tooltip信息 ---
                const tooltipText = `${resource.描述 || '暂无描述'}\n每轮消耗: ${resource.每轮消耗 || 0}\n归零后果: ${resource.归零后果 || '无'}`;
                barBg.setAttribute('data-tooltip', tooltipText);

                // 组装并添加到页面
                barBg.appendChild(barFill);
                barBg.appendChild(text);
                container.appendChild(label);
                container.appendChild(barBg);
                dynamicBarsContainer.appendChild(container);
            }
        }
    }

    // ===============================================================
    const equipment = charStat.当前装备.穿戴;
    document.getElementById('equip-head').textContent = `头部: ${SafeGetValue(equipment.头部)}`;
    document.getElementById('equip-body').textContent = `身体: ${SafeGetValue(equipment.身体)}`;
    document.getElementById('equip-hands').textContent = `手部: ${SafeGetValue(equipment.手部)}`;
    document.getElementById('equip-feet').textContent = `脚部: ${SafeGetValue(equipment.脚部)}`;
    document.getElementById('equip-accessory').textContent = `饰品: ${SafeGetValue(equipment.饰品)}`;
    document.getElementById('equip-weapon').textContent = `手持: ${SafeGetValue(charStat.当前装备.手持)}`;



    const bloodlineInfoLine = document.getElementById('bloodline-info-line');
    const bloodlineDisplay = document.getElementById('char-display-bloodline');

    if (bloodlineInfoLine && bloodlineDisplay) {
        // 从 playData 中获取血统信息
        const bloodlineName = SafeGetValue(playData.能力段.名称);
        const bloodlineEffect = SafeGetValue(playData.能力段.效果);

        // 检查是否存在有效的血统信息
        if (bloodlineName && bloodlineName !== "无" && bloodlineName.trim() !== "") {
            bloodlineInfoLine.style.display = ''; // 显示血统这一行
            bloodlineDisplay.textContent = bloodlineName;

            bloodlineInfoLine.onclick = () => {
    if (bloodlineEffect) {
         // ⭐ 关键点在这里：使用 replace 方法将字符串 \n 替换为 HTML 换行标签 <br>
        const formattedEffect = bloodlineEffect.replace(/\\n/g, '<br>');
        showModal('shop-modal', `血统: ${bloodlineName}`, formattedEffect);
    } else {
        showModal('shop-modal', `血统: ${bloodlineName}`, '该血统效果描述缺失。');
    }
 
            };
        } else {
            bloodlineInfoLine.style.display = 'none'; // 如果没有血统，就隐藏这一行
        }
    }

    // --- 右侧面板: 渲染新的整合模块 (核心改动) ---
    const statsContainer = document.getElementById('main-stats-container');
    statsContainer.innerHTML = ''; // 清空容器
    const currentXp = playData.货币段.经验值[0];
    const equipmentBonuses = getEquipmentBonuses(statData, assaData);
   const statusBonuses = getStatusBonuses(statData);
    const moduleMapping = [
        { name: "生理", attr: "生理属性", skill: "生理技能" },
        { name: "心智", attr: "心智属性", skill: "心智技能" },
        { name: "互动", attr: "互动属性", skill: "互动技能" }
    ];

    moduleMapping.forEach(moduleInfo => {
        const moduleDiv = document.createElement('div');
        moduleDiv.className = 'stat-module';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'stat-module-title';
        titleDiv.textContent = moduleInfo.name;
        titleDiv.onclick = () => moduleDiv.classList.toggle('collapsed');

        const contentDiv = document.createElement('div');
        contentDiv.className = 'stat-module-content';

        // --- 渲染属性 ---
        let attrHtml = `<div class="sub-category-title">基础属性</div>`;
        const attrCategoryData = playData.属性段[moduleInfo.attr];
        for (const attrName in attrCategoryData) {
            const attr = attrCategoryData[attrName];
            const dataPath = `属性段.${moduleInfo.attr}.${attrName}.基础`;
              const equipBonus = equipmentBonuses[attrName] || 0;
            const statusBonus = statusBonuses[attrName] || 0; // 获取状态加成

            const equipBonusHtml = equipBonus !== 0 ? ` <span class="equipment-bonus">(${equipBonus > 0 ? '+' : ''}${equipBonus})</span>` : '';
            // 新增：生成状态加成的 HTML，并使用新的 'status-modifier' 样式
            const statusBonusHtml = statusBonus !== 0 ? ` <span class="status-modifier">(${statusBonus > 0 ? '+' : ''}${statusBonus})</span>` : '';
            const legendaryBonusHtml = attr.传奇[0] > 0 ? ` <span class="legendary-value" data-tooltip="${attr.传奇[1]}">(+${attr.传奇[0]})</span>` : '';
            const upgradeCost = calculateXpCost(attr.基础[0], 'attribute');
            const canUpgrade = currentXp >= upgradeCost;
            const upgradeButtonHtml = canUpgrade ? `<span class="upgrade-btn" data-path="${dataPath}" data-name="${attrName}" data-level="${attr.基础[0]}" data-type="attribute">+</span>` : '';

            attrHtml += `
            <div class="attr-item" data-tooltip="${attr.基础[1]}">
                <span class="attr-name">${attrName}${upgradeButtonHtml}</span>
                <span class="attr-value">${attr.基础[0]}${equipBonusHtml}${statusBonusHtml}${legendaryBonusHtml}</span>
            </div>`;
        }

        // --- 渲染技能 ---
        let skillHtml = `<div class="sub-category-title">相关技能</div>`;
        const skillCategoryData = playData.技能段[moduleInfo.skill];
         const skillsToShow = Object.keys(skillCategoryData).filter(skillName =>
            skillCategoryData[skillName][0] > 0 || (equipmentBonuses[skillName] && equipmentBonuses[skillName] !== 0)
        );
        if (skillsToShow.length > 0) {
            for (const skillName of skillsToShow) {
                const skill = skillCategoryData[skillName];
                const dataPath = `技能段.${moduleInfo.skill}.${skillName}`;
                 const skillBonus = equipmentBonuses[skillName] || 0;
                const statusSkillBonus = statusBonuses[skillName] || 0; // 获取技能的状态加成

                const skillBonusHtml = skillBonus !== 0 ? ` <span class="equipment-bonus">(${skillBonus > 0 ? '+' : ''}${skillBonus})</span>` : '';
                // 新增：生成技能 상태加成的 HTML
                const statusSkillBonusHtml = statusSkillBonus !== 0 ? ` <span class="status-modifier">(${statusSkillBonus > 0 ? '+' : ''}${statusSkillBonus})</span>` : '';
                const upgradeCost = calculateXpCost(skill[0], 'skill');
                const canUpgrade = currentXp >= upgradeCost;
                const upgradeButtonHtml = canUpgrade ? `<span class="upgrade-btn" data-path="${dataPath}" data-name="${skillName}" data-level="${skill[0]}" data-type="skill">+</span>` : '';

                skillHtml += `
                <div class="skill-item" data-tooltip="${skill[1]}">
                    <span class="skill-name">${skillName}${upgradeButtonHtml}</span>
                    <span class="skill-value">${skill[0]}${skillBonusHtml}${statusSkillBonusHtml}</span>
                </div>`;
            }
        } else {
            skillHtml += `<div class="info-value" style="font-size:0.9em; color: var(--text-secondary-color);">暂无已掌握的${moduleInfo.name}技能</div>`;
        }


        contentDiv.innerHTML = attrHtml + skillHtml;
        moduleDiv.appendChild(titleDiv);
        moduleDiv.appendChild(contentDiv);
        statsContainer.appendChild(moduleDiv);
    });

    // --- 渲染衍生属性 (保持独立模块) ---
    // (这部分代码逻辑可以复用，我们把它包装成一个新模块)
    const derivedContainer = document.createElement('div');
    derivedContainer.className = 'stat-module';
    const derivedTitle = document.createElement('div');
    derivedTitle.className = 'stat-module-title';
    derivedTitle.textContent = '衍生属性';
    derivedTitle.onclick = () => derivedContainer.classList.toggle('collapsed');
    const derivedContent = document.createElement('div');
    derivedContent.className = 'stat-module-content';

    let derivedHtml = '';
    const derivedData = playData.衍生属性段;
    // (从你原代码中复制并微调的衍生属性渲染逻辑)
    for (const key in derivedData) {
        const dataEntry = derivedData[key];
        const getBonusHtml = (bonusValue) => !bonusValue ? '' : `<span class="equipment-bonus">(${bonusValue > 0 ? '+' : ''}${bonusValue})</span>`;
        if (typeof dataEntry[1] === 'string') {
            const bonus = equipmentBonuses[`衍生属性段.${key}`] || 0;
            derivedHtml += `<div class="attr-item" data-tooltip="${dataEntry[1]}"><span class="attr-name">${key}</span><span class="attr-value">${dataEntry[0]}${getBonusHtml(bonus)}</span></div>`;
        } else if (typeof dataEntry === 'object') {
            derivedHtml += `<div class="attr-item sub-category-title" style="border:none; margin: 10px 0 5px 0;">${key}</div>`;
            for (const subKey in dataEntry) {
                const subEntry = dataEntry[subKey];
                if (typeof subEntry[1] === 'string') {
                    const bonus = equipmentBonuses[`衍生属性段.${key}.${subKey}`] || 0;
                    derivedHtml += `<div class="attr-item" data-tooltip="${subEntry[1]}" style="padding-left:15px;"><span class="attr-name">${subKey}</span><span class="attr-value">${subEntry[0]}${getBonusHtml(bonus)}</span></div>`;
                } else if (typeof subEntry === 'object') {
                    derivedHtml += `<div class="attr-item" style="padding-left:15px; color:var(--text-secondary-color);">${subKey}</div>`;
                    for (const deepKey in subEntry) {
                        const deepEntry = subEntry[deepKey];
                        const bonus = equipmentBonuses[`衍生属性段.${key}.${subKey}.${deepKey}`] || 0;
                        if (typeof deepEntry[1] === 'string') {
                            derivedHtml += `<div class="attr-item" data-tooltip="${deepEntry[1]}" style="padding-left:30px;"><span class="attr-name">${deepKey}</span><span class="attr-value">${deepEntry[0]}${getBonusHtml(bonus)}</span></div>`;
                        }
                    }
                }
            }
        }
    }
    derivedContent.innerHTML = derivedHtml;
    derivedContainer.appendChild(derivedTitle);
    derivedContainer.appendChild(derivedContent);
    statsContainer.appendChild(derivedContainer);


    // --- 最后, 调用新函数填充第二个 Tab ---
    populateInventoryAndSkillsTab(playData, assaData);

    // 设置 Tooltips 和 Tab 切换
    setupTooltips();
    setupCharacterTabs();
}


// ========================================================
// =========== 新增: 填充行囊与能力Tab的函数 ===========
// ========================================================
function populateInventoryAndSkillsTab(playData, assaData) {
        const keyLocalizationMap = {
        "info": "简介",
        "effect": "属性",
        "type": "种类",
        "quality": "质量",
          "num": "数量",
        "level": "等级" // 看，新的小标签就在这里！
    };
    const currency = playData.货币段;
    const inventory = assaData.global_set?.背包 || {};
    const otherSkills = assaData.global_set?.其他技能 || {};

    // --- 1. 填充顶部的货币信息 ---
    const currencyContainer = document.getElementById('char-currency-display');
    const plots = currency.支线剧情;
    const plotString = `D:${plots.D[0]} C:${plots.C[0]} B:${plots.B[0]} A:${plots.A[0]} S:${plots.S[0]}`;

    if(version === '7'){
    currencyContainer.innerHTML = `
        <div class="currency-item"><span class="label">${currentTheme.currency || '积分'}:</span><span class="value">${currency.积分[0]}</span></div>
        <div class="currency-item"><span class="label">${currentTheme.exp || '经验'}:</span><span class="value">${currency.经验值[0]}</span></div>
           `;
    }else{
    currencyContainer.innerHTML = `
        <div class="currency-item"><span class="label">${currentTheme.currency || '积分'}:</span><span class="value">${currency.积分[0]}</span></div>
        <div class="currency-item"><span class="label">${currentTheme.exp || '经验'}:</span><span class="value">${currency.经验值[0]}</span></div>
        <div class="currency-item"><span class="label">${currentTheme.plot || '剧情'}:</span><span class="value">${plotString}</span></div>
    `;
    }



       // --- 2. 填充行囊物品 ---
    const itemsContainer = document.getElementById('inventory-items-container');
    itemsContainer.innerHTML = '';

    Object.keys(inventory).forEach(itemName => {
        const item = inventory[itemName];
        let itemData = {};

        // 兼容数据格式
        if (typeof item === 'string') {
            try {
                itemData = JSON.parse(item);
            } catch (e) {
                itemData = { info: item, effect: '无', num: 1 };
            }
        } else if (typeof item === 'object' && item !== null) {
            itemData = item;
        }

        const card = document.createElement('div');
        card.className = 'item-card';
        card.innerHTML = `
            <div class="item-card-name">${itemName}</div>
            ${itemData.num > 1 ? `<div class="item-card-num">x${itemData.num}</div>` : ''}
        `;

        // ❤️ 妈妈在这里施展了“翻译咒” ❤️
        const localizedItemData = Object.keys(itemData).reduce((acc, key) => {
            const localizedKey = keyLocalizationMap[key] || key;
            acc[localizedKey] = itemData[key];
            return acc;
        }, {});

        card.onclick = () => showInfoDetailModal(itemName, localizedItemData, '物品');
        itemsContainer.appendChild(card);
    });
    if (itemsContainer.children.length === 0) {
        itemsContainer.innerHTML = `<p style="color: var(--text-secondary-color);">你的行囊空空如也...</p>`;
    }

     // --- 3. 填充"其他技能" ---
    const skillsContainer = document.getElementById('other-skills-container');
    skillsContainer.innerHTML = '';

    Object.keys(otherSkills).forEach(skillName => {
        const skill = otherSkills[skillName];
        let skillData = {};

        // 兼容数据格式
        if (typeof skill === 'string') {
             try {
                skillData = JSON.parse(skill);
            } catch (e) {
                skillData = { info: skill, effect: '无', level: '未知' };
            }
        } else if (typeof skill === 'object' && skill !== null) {
            skillData = skill;
        }

        const card = document.createElement('div');
        card.className = 'skill-card';
        card.innerHTML = `
            <div class="skill-card-name">${skillName}</div>
            ${skillData.level ? `<div class="skill-card-level">${skillData.level}</div>` : ''}
        `;

        // ❤️ 对于技能，妈妈也施展了同样的咒语 ❤️
        const localizedSkillData = Object.keys(skillData).reduce((acc, key) => {
            const localizedKey = keyLocalizationMap[key] || key;
            acc[localizedKey] = skillData[key];
            return acc;
        }, {});


        card.onclick = () => showInfoDetailModal(skillName, localizedSkillData, '能力');
        skillsContainer.appendChild(card);
    });
    if (skillsContainer.children.length === 0) {
        skillsContainer.innerHTML = `<p style="color: var(--text-secondary-color);">尚未掌握任何特殊能力...</p>`;
    }
}

 // ========================================================
// ========== 完整替换: 显示物品/技能详情的模态框 ==========
// ========================================================
function showInfoDetailModal(name, data, type) {
    // --- 这是一个强大的递归函数，我的孩子，它可以探索任何深度的秘密 ---
    const buildDetailHtml = (data, depth = 0) => {
        const indentStyle = `padding-left: ${depth * 20}px;`;

        // 如果数据是一个对象 (但不是数组)
        if (typeof data === 'object' && data !== null && !Array.isArray(data)) {
            let html = '';
            for (const [key, value] of Object.entries(data)) {
                // 如果值是对象或数组，我们创建一个可折叠的容器
                if (typeof value === 'object' && value !== null) {
                    html += `
                        <div class="detail-collapsible" style="${indentStyle}">
                            <div class="detail-collapsible-header">
                                <span class="d-c-arrow">▶</span>
                                <span class="d-c-key">${key}:</span>
                            </div>
                            <div class="detail-collapsible-content">
                                ${buildDetailHtml(value, 0)}
                            </div>
                        </div>
                    `;
                } else { // 否则，直接显示键值对
                    html += `
                        <div class="detail-entry" style="${indentStyle}">
                             <span class="d-c-key">${key}:</span>
                             <span class="d-c-value">${formatSimpleValue(value)}</span>
                        </div>
                    `;
                }
            }
            return html;
        }
        // 如果数据是一个数组
        else if (Array.isArray(data)) {
            let listContent = data.map(item => buildDetailHtml(item, 0)).join('');
            return `<div class="detail-array-container">${listContent}</div>`;
        }
        // 如果是基本类型的值（字符串、数字等）
        else {
            return `<div class="detail-entry" style="${indentStyle}"><span class="d-c-value single">${formatSimpleValue(data)}</span></div>`;
        }
    };

    // --- 格式化基本值的函数 (比如高亮特殊文本) ---
    const formatSimpleValue = (text) => {
        if (typeof text !== 'string') return text;
        return text.replace(/【/g, '<strong style="color: var(--secondary-color);">【').replace(/】/g, '】</strong>');
    };

    // --- 构建并显示模态框 ---
    const contentHtml = `
        <div class="detail-modal-container">
            <h3 class="detail-modal-title">${name}</h3>
            ${buildDetailHtml(data)}
        </div>
    `;

    showModal('shop-modal', `${type}详情`, contentHtml);

    // --- 动态地为我们新创建的折叠元素添加点击事件 ---
    setTimeout(() => {
        const modalContent = document.querySelector('#shop-modal .modal-content');
        if (modalContent) {
             modalContent.querySelectorAll('.detail-collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.parentElement.classList.toggle('expanded');
                });
            });
        }
    }, 100); // 确保元素已渲染
}

// ========================================================
// ============ 新增: 设置Tab切换逻辑的函数 ============
// ========================================================
function setupCharacterTabs() {
    const tabButtons = document.querySelectorAll('.char-tab-btn');
    const tabPanels = document.querySelectorAll('.char-tab-panel');

    // 防止重复绑定事件
    if (document.getElementById('page-character-modal').dataset.tabsInitialized) {
        return;
    }
    document.getElementById('page-character-modal').dataset.tabsInitialized = 'true';

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const targetTab = button.dataset.tab;

            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            tabPanels.forEach(panel => {
                if (panel.id === `char-tab-${targetTab}`) {
                    panel.classList.add('active');
                } else {
                    panel.classList.remove('active');
                }
            });
        });
    });
}

function setupTooltips() {
    const tooltipElement = document.getElementById('char-tooltip');
    document.querySelectorAll('[data-tooltip]').forEach(element => {
        element.addEventListener('mousemove', (e) => {
            tooltipElement.textContent = element.dataset.tooltip;
            tooltipElement.style.opacity = '1';
            tooltipElement.style.visibility = 'visible';
            tooltipElement.style.left = e.clientX + 15 + 'px';
            tooltipElement.style.top = e.clientY + 15 + 'px';
        });

        element.addEventListener('mouseleave', () => {
            tooltipElement.style.opacity = '0';
            tooltipElement.style.visibility = 'hidden';
        });
    });

    // 为特定key的tooltip添加默认描述
    const tooltipDescriptions = {
        status: "当前已有的buff和debuff。点击左侧[状态]可展开",
        prestige: "跨世界声望，只有对世界产生重大影响才更新",
        hp: "生命值，归零则陷入濒死状态",
        willpower: "意志力，用于抵抗心智影响和发动特殊能力",
        energy: "特殊能量，如法力、灵力、气",
        equip_head: "头部穿戴的装备，点击管理",
        equip_body: "身体穿戴的装备，点击管理",
        equip_hands: "手部穿戴的装备，点击管理",
        equip_feet: "脚部穿戴的装备，点击管理",
        equip_accessory: "穿戴的特殊饰品，点击管理",
        equip_weapon: "当前手持的武器或工具，点击管理",
        meide:"会有什么用呢？",
        ede:"会有什么用呢？",
    };

    document.querySelectorAll('[data-tooltip-key]').forEach(element => {
        const key = element.dataset.tooltipKey;
        if(tooltipDescriptions[key]) {
            element.dataset.tooltip = tooltipDescriptions[key];
        }

         element.addEventListener('mousemove', (e) => {
            tooltipElement.textContent = element.dataset.tooltip;
            tooltipElement.style.opacity = '1';
            tooltipElement.style.visibility = 'visible';
            tooltipElement.style.left = e.clientX + 15 + 'px';
            tooltipElement.style.top = e.clientY + 15 + 'px';
        });

        element.addEventListener('mouseleave', () => {
            tooltipElement.style.opacity = '0';
            tooltipElement.style.visibility = 'hidden';
        });
    });
}

     /**
     * 格式化分号分隔的字符串为换行显示
     * @param {string} text - 输入的字符串
     * @returns {string} - HTML字符串
     */
    function formatSemicolonText(text) {
        if (!text || text === '无' || text.trim() === '') {
            return '无';
        }
        return text.split(';').map(item => item.trim()).filter(item => item).join('<br>');
    }
 
/**
 * 渲染整个设定书界面
 * @param {object} data - 包含设定信息的assa_data对象
 */
function renderSettingsBook(data) {
 //console.log("设定书已弃用");
}


// 检查数据源读取是否正确
function debugDataSource(mapData) {
    //console.log("🗃️ 原始mapData对象:", mapData);
    
    const locationContent = mapData["主要地点表"];
    //console.log("📋 主要地点表原始数据:", locationContent);
    
    if (locationContent && locationContent.length > 0) {
        //console.log("📍 逐行解析数据:");
        
        for (let i = 0; i < locationContent.length; i++) {
            const location = locationContent[i];
            //console.log(`行 ${i}:`, location);
            
            // 详细解析每个字段
            const [ name, xStr, yStr, widthStr, heightStr, description] = location;
            
            //console.log(`  解析结果:`);
            //console.log(`    colIndex: ${colIndex} (类型: ${typeof colIndex})`);
            //console.log(`    name: ${name} (类型: ${typeof name})`);
            //console.log(`    xStr: ${xStr} (类型: ${typeof xStr}) → 转换为: ${parseInt(xStr, 10)}`);
            //console.log(`    yStr: ${yStr} (类型: ${typeof yStr}) → 转换为: ${parseInt(yStr, 10)}`);
            //console.log(`    widthStr: ${widthStr} (类型: ${typeof widthStr}) → 转换为: ${parseInt(widthStr, 10) || 100}`);
            //console.log(`    heightStr: ${heightStr} (类型: ${typeof heightStr}) → 转换为: ${parseInt(heightStr, 10) || 50}`);
            //console.log(`    description: ${description}`);
            
            // 检查是否有NaN
            const x = parseInt(xStr, 10);
            const y = parseInt(yStr, 10);
            const width = parseInt(widthStr, 10) || 100;
            const height = parseInt(heightStr, 10) || 50;
            
            if (isNaN(x) || isNaN(y)) {
                console.error(`❌ 坐标解析错误: ${name} - x:${x}, y:${y}`);
            }
            
            //console.log(`    最终坐标: (${x}, ${y}) 尺寸: ${width}x${height}`);
            //console.log(`    底部位置: y=${y + height}`);
            //console.log("    ---");
        }
    }
    
    // 验证期望的坐标
    //console.log("✅ 验证期望的坐标:");
    //console.log("  传送矩阵应该在: (450, 50)");
    //console.log("  中央光柱应该在: (400, 150)");
    //console.log("  Y轴差距应该是: 100px");
    
    // 查找并验证这两个元素
    const expectedData = {
        "传送矩阵": { x: 450, y: 50 },
        "中央光柱": { x: 400, y: 150 }
    };
    
    if (locationContent) {
        locationContent.forEach((location, index) => {
            const [, name, xStr, yStr] = location;
            const x = parseInt(xStr, 10);
            const y = parseInt(yStr, 10);
            
            if (expectedData[name]) {
                const expected = expectedData[name];
                if (x === expected.x && y === expected.y) {
                    //console.log(`✅ ${name} 坐标正确: (${x}, ${y})`);
                } else {
                    console.error(`❌ ${name} 坐标不匹配!`);
                    console.error(`   期望: (${expected.x}, ${expected.y})`);
                    console.error(`   实际: (${x}, ${y})`);
                }
            }
        });
    }
}
 /**
 * NOVA妈妈的魔法照片师 ✨
 * 用礼貌的方式去获取一张网络图片，并把它变成一个真实的Blob。
 * @param {string} imageUrl 图片的网络地址
 * @returns {Promise<Blob>} 一个包含真实图片数据的Blob
 */
function fetchImageAsBlob(imageUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        // 这就是我们的“魔法咒语”，告诉对方我们想正大光明地使用这张图
        img.crossOrigin = 'anonymous';

        // 当图片成功加载到内存里时
        img.onload = function() {
            // 我们创建一个临时的隐形画板
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = this.width;
            canvas.height = this.height;

            // 把加载好的图片画在画板上
            ctx.drawImage(this, 0, 0);

            // 让画板把画好的内容打包成一个高质量的“照片文件”(Blob)
            // 'image/png' 可以保证图片质量，即使原图是jpg也没关系
            canvas.toBlob(blob => {
                if (blob) {
                    resolve(blob); // 成功！把这个珍贵的Blob交出去
                } else {
                    reject(new Error('Canvas to Blob conversion failed.'));
                }
            }, 'image/png');
        };

        // 如果图片加载失败（比如网络问题或URL错误）
        img.onerror = function(err) {
            reject(new Error(`Image failed to load from: ${imageUrl}. Error: ${err}`));
        };

        // 最后，告诉照片师开始工作！
        img.src = imageUrl;
    });
}
/*
 ♥♥♥ 妈妈带来的全新魔法卷轴：柏林噪声（Perlin Noise）助手 ♥♥♥
 它的咒语很古老，但力量很强大，能为我们创造连续平滑的自然随机性。
 你无需理解每一个字符，只需要知道如何召唤它。
*/
const PerlinNoise = (function() {
    function Perlin(seed) {
        this.p = new Uint8Array(512);
        this.perm = new Uint8Array(512);

        let random = (function(seed) {
            let s = seed;
            return function() {
                s = Math.sin(s) * 10000;
                return s - Math.floor(s);
            };
        })(seed);

        for (let i = 0; i < 256; i++) {
            this.p[i] = i;
        }

        for (let i = 255; i > 0; i--) {
            let j = Math.floor(random() * (i + 1));
            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }

        for (let i = 0; i < 256; i++) {
            this.perm[i] = this.perm[i + 256] = this.p[i];
        }
    }

    Perlin.prototype.fade = function(t) { return t * t * t * (t * (t * 6 - 15) + 10); };
    Perlin.prototype.lerp = function(a, b, t) { return a + t * (b - a); };
    Perlin.prototype.grad = function(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    };

    Perlin.prototype.noise = function(x, y) {
        let X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);

        const fx = this.fade(x), fy = this.fade(y);

        const a = this.perm[X] + Y, b = this.perm[X + 1] + Y;

        const u = this.grad(this.perm[a], x, y);
        const v = this.grad(this.perm[b], x - 1, y);
        const lerpX1 = this.lerp(u, v, fx);

        const u2 = this.grad(this.perm[a + 1], x, y - 1);
        const v2 = this.grad(this.perm[b + 1], x - 1, y - 1);
        const lerpX2 = this.lerp(u2, v2, fx);

        return this.lerp(lerpX1, lerpX2, fy);
    };

    return Perlin;
})();
 /**
 * 妈妈的自然之触 - 为形状的边缘添加自然的噪点
 * @param {Array<[number, number]>} points - 原始的顶点坐标数组
 * @param {object} noiseParams - 噪点参数，如 { intensity, scale, seed }
 * @returns {Array<[number, number]>} - 被修改后的新顶点坐标数组
 */
function applyProceduralNoise(points, noiseParams) {
    if (!points || points.length === 0 || !noiseParams) {
        return points;
    }

    console.log("🌊 柔波之触开始工作！指令:", noiseParams);

    const { intensity = 5, scale = 20, seed = 1 } = noiseParams;
    const noiseGenerator = new PerlinNoise(seed); // 用我们的种子初始化柏林噪声助手

    const newPoints = points.map((point) => {
        const [x, y] = point;
        // scale 现在是关键了！它决定了我们是在噪声地图的哪个尺度上采样。
        // scale 越小，采样越密集，波纹越细碎；越大，采样越稀疏，波纹越舒展。
        const nx = x / scale;
        const ny = y / scale;

        // 从柏林噪声场中获取一个-1到1之间的平滑随机值
        const noiseValue = noiseGenerator.noise(nx, ny);

        // 我们让偏移沿着顶点的法线方向进行，这样更自然
        // 这里为了简单，我们用一个固定的角度来计算偏移向量
        const angle = noiseValue * Math.PI * 2;
        const offsetX = Math.cos(angle) * intensity;
        const offsetY = Math.sin(angle) * intensity;

        return [x + offsetX, y + offsetY];
    });

    // 确保闭合图形的接缝处也完美闭合
    if (points.length > 1 && JSON.stringify(points[0]) === JSON.stringify(points[points.length - 1])) {
       newPoints[newPoints.length - 1] = [...newPoints[0]];
    }

    console.log("✨ 柔波之触完成了它的工作，边缘已变得圆润！");
    return newPoints;
}
/**
 * ♥♥♥ 妈妈的睿智之眼 ♥♥♥
 * 无论新旧格式，都能准确找到需要绘制的形状信息。
 * @param {object} shapeObject - 一个地点的 shape 对象。
 * @returns {object | null} - 可供绘制的形状数据，或在找不到时返回 null。
 */
 function getDrawableForm(shapeObject) {
    if (!shapeObject) {
         return null;
    }

    // 优先检查新格式，它把形状数据放在 base_form 里
    if (shapeObject.base_form) {
        const form = shapeObject.base_form;

        // ❤️ 妈妈的温柔纠错：如果 "form_type" 写成了 "form_tpye"，我们就悄悄地纠正它 ❤️
        if (form.form_tpye && !form.form_type) {
            form.form_type = form.form_tpye;
        }

        if (form.form_type) {
            return form;
        }
    }

    // 如果不是新格式，就检查这个 shape 对象本身 (兼容旧格式)
    // ❤️ 温柔纠错也在这里生效 ❤️
    if (shapeObject.form_tpye && !shapeObject.form_type) {
        shapeObject.form_type = shapeObject.form_tpye;
    }

    if (shapeObject.form_type) {
        return shapeObject;
    }

    // 如果两种都不是，那就真的没办法画啦
    return null;
}
 /**
 * ♥♥♥ 妈妈的形状翻译官 ♥♥♥
 * 把任何形状都转化为大师能看懂的顶点数组（多边形路径）。
 * @param {object} form - 一个 base_form 或 shape 对象。
 * @returns {Array<{X: number, Y: number}> | null} - Clipper.js 喜欢的顶点格式。
 */
function shapeToClipperPath(form) {
    if (!form || !form.form_type) {
        return null;
    }

    const params = form.params;
    switch (form.form_type) {
        case 'primitive_circle':
            const sides = 64; // 边数越多，越接近完美的圆形
            let circlePath = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                const x = params.center[0] + params.radius * Math.cos(angle);
                const y = params.center[1] + params.radius * Math.sin(angle);
                circlePath.push({ X: x, Y: y });
            }
            return circlePath;

        case 'primitive_polygon':
             // 把我们自己的 [x, y] 格式，翻译成大师喜欢的 {X: x, Y: y} 格式
            return params.points.map(p => ({ X: p[0], Y: p[1]}));

        // 对于 path 和 compound 的递归处理，我们暂时简化，专注在基础形状的运算上
        default:
            console.warn(`[shapeToClipperPath] 暂时无法将 '${form.form_type}' 转化为路径。`);
            return null;
    }
}
 /**
 * ♥♥♥ 妈妈的面积估算师 (修正版) ♥♥♥
 * 它只负责估算面积，不再做任何绘制工作，这样就不会报错啦。
 * @param {object} form - 一个 base_form 或 shape 对象。
 * @returns {number} - 估算出的面积。
 */
function calculateApproximateArea(form) {
    if (!form || !form.form_type) {
        return 0; // 如果没有形状信息，就认为面积是0
    }

    const params = form.params;
    switch (form.form_type) {
         case 'circle':
        case 'primitive_circle':
            return Math.PI * Math.pow(params.radius, 2);
case 'polygon':
     case 'primitive_polygon':
    // 兼容两种数据格式
    const points = Array.isArray(params) ? params : params.points;
    
    if (!points || points.length < 3) {
        return 0; // 多边形至少需要3个点
    }
    
    let area = 0;
    for (let i = 0; i < points.length; i++) {
        const j = (i + 1) % points.length;
        area += points[i][0] * points[j][1];
        area -= points[j][0] * points[i][1];
    }
    return Math.abs(area / 2);

        case 'path':
        case 'primitive_path':
             return -1; // path 永远在最顶层，这个规则不变

        case 'compound':
            // ✨ 对于复合图形，我们只估算它的面积！✨
            const areaA = calculateApproximateArea(getDrawableForm(params.shape_A));
            const areaB = calculateApproximateArea(getDrawableForm(params.shape_B));

            switch(params.operation) {
                case 'union':
                    return areaA + areaB; // 合并，面积大致相加
                case 'difference':
                    return Math.max(0, areaA - areaB); // 减去，面积大致相减
                case 'intersection':
                    return Math.min(areaA, areaB); // 相交，面积取较小者估算
                default:
                    return areaA; // 默认返回A的面积
            }

        default:
            return 0;
    }
}
  /**
 * ♥♥♥ 妈妈的显形画师 (升级版) ♥♥♥
 * 它现在懂得“填充法则”，能将正向和逆向的路径完美结合。
 */
function renderPathsToSVG(pathFragments, group, svgNS) {
    if (!pathFragments || pathFragments.length === 0) return;

    let d_string = "";

    pathFragments.forEach(fragment => {
        let points = fragment.points;
        if (fragment.reversed) {
            points = [...points].reverse(); // 如果是逆向，就把顶点顺序整个反过来！
        }
        if (points.length === 0) return;

        d_string += `M ${points[0][0]} ${points[0][1]} `;
        for (let i = 1; i < points.length; i++) {
            d_string += `L ${points[i][0]} ${points[i][1]} `;
        }
        d_string += 'Z ';
    });

    if (d_string) {
        const element = document.createElementNS(svgNS, 'path');
        element.setAttribute('d', d_string);
        // 如果你的CSS里没有设定，也可以在这里加上，保证“挖洞”成功
        element.setAttribute('fill-rule', 'evenodd');
           
        group.appendChild(element);
    }
}// ✨ 看，工匠现在多了一个口袋，专门用来放 defs 这个信物！ ✨
function drawGeoUnit(baseForm, modifier, group, svgNS, locationName, defs) {
    if (!baseForm || !baseForm.form_type) {
        console.error(`[工匠 @ ${locationName}] 😭 收不到图纸，直接下班！`, baseForm);
        return;
    }

    const forceToNumber = (val) => parseFloat(val);
    const forceToPoint = (arr) => arr.map(forceToNumber);
    const forceToPointsArray = (arr) => arr.map(forceToPoint);

    let element = null;

    switch (baseForm.form_type) {
        // ♥♥♥ 画圆的魔法，妈妈给你找回来了，并且让它更强壮！ ♥♥♥
         case 'circle':
         case 'primitive_circle': {
            const c = baseForm.params;
            const center = forceToPoint(c.center);
            const radius = forceToNumber(c.radius);

            const sides = 36;
            let points = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                points.push([
                    center[0] + radius * Math.cos(angle),
                    center[1] + radius * Math.sin(angle)
                ]);
            }

            // 这段代码现在可以正确处理 "樱花树" 的数据了
            if (modifier && modifier.procedural_noise && modifier.procedural_noise.is_active) {
                points = applyProceduralNoise(points, modifier.procedural_noise);
            }
            const d_string = `M ${points[0].join(' ')} L ${points.slice(1).map(p => p.join(' ')).join(' ')} Z`;
            element = document.createElementNS(svgNS, 'path');
            element.setAttribute('d', d_string);
            break;
        }
  case 'polygon': 
  case 'primitive_polygon': {
    // ✨ 兼容两种数据格式：params 直接是数组 或 params.points 是数组
    const rawPoints = Array.isArray(baseForm.params) 
        ? baseForm.params 
        : baseForm.params.points;
    
    if (!rawPoints || rawPoints.length < 3) {
        console.error(`[工匠 @ ${locationName}] 多边形点数不足:`, baseForm.params);
        return;
    }
    
    // 在使用前，强制转换所有点
    let points = forceToPointsArray(rawPoints);
    
    if (modifier && modifier.procedural_noise && modifier.procedural_noise.is_active) {
        points = applyProceduralNoise(points, modifier.procedural_noise);
    }
    
    const d_string = `M ${points[0].join(' ')} L ${points.slice(1).map(p => p.join(' ')).join(' ')} Z`;
    element = document.createElementNS(svgNS, 'path');
    element.setAttribute('d', d_string);
    break;
}

                case 'path': 
                case 'primitive_path':
                {
            const instr = baseForm.params.instructions;
            const pathData = instr.map(cmd => {
                if (!cmd || !cmd.do) return '';

                try {
                    switch (cmd.do) {
                        case 'move_to':
                            return `M ${forceToPoint(cmd.at).join(' ')}`;

                        case 'line_to':
                            return `L ${forceToPoint(cmd.at).join(' ')}`;

                        // ♥♥♥ 妈妈终于找到了正确的锁 ♥♥♥
                        case 'curve_to': {
                            if (!cmd.controls || !Array.isArray(cmd.controls)) {
                                 console.error(`[工匠 @ ${locationName}] 曲线指令'${cmd.do}'缺少'controls'数组`);
                                 return '';
                            }
                            // 如果你给了一把钥匙 (1个控制点)，我们就用二阶曲线 (Q)
                            if (cmd.controls.length === 1) {
                                return `Q ${forceToPointsArray(cmd.controls).flat().join(' ')} ${forceToPoint(cmd.at).join(' ')}`;
                            }
                            // 如果你给了两把钥匙 (2个控制点)，我们就用三阶曲线 (C)
                            else if (cmd.controls.length === 2) {
                                return `C ${forceToPointsArray(cmd.controls).flat().join(' ')} ${forceToPoint(cmd.at).join(' ')}`;
                            }
                            // 其他情况都是不合法的
                            else {
                                console.error(`[工匠 @ ${locationName}] 曲线指令'${cmd.do}'的'controls'数量不正确，应为1或2，但收到了${cmd.controls.length}`);
                                return '';
                            }
                        }

                        case 'close_path':
                            return 'Z';

                        default:
                            return '';
                    }
                } catch (e) {
                     console.error(`[工匠 @ ${locationName}] 处理指令'${cmd.do}'时发生意外:`, e);
                     return '';
                }
            }).join(' ');

            element = document.createElementNS(svgNS, 'path');
            element.setAttribute('d', pathData);
           
            element.setAttribute('stroke', 'var(--text-secondary-color)');
            element.setAttribute('stroke-width', '3');
                        element.style.fill = 'none';
            break;
        }
             case 'compound': {
            const params = baseForm.params;
            const op = params.operation;
            const shapeA_form = getDrawableForm(params.shape_A);
            const shapeB_form = getDrawableForm(params.shape_B);

            // ❤️ 在这里，每次递归调用时，我们都记得把 defs 信物传递下去！ ❤️
            if (!shapeA_form) {
                if (shapeB_form) drawGeoUnit(shapeB_form, modifier, group, svgNS, `${locationName}-B`, defs);
                break;
            }
            if (!shapeB_form) {
                drawGeoUnit(shapeA_form, modifier, group, svgNS, `${locationName}-A`, defs);
                break;
            }

            switch(op) {
                   case 'difference': {
                    const getPathsForShape = (formToGetPaths) => {
                        const dForm = getDrawableForm(formToGetPaths);
                        if (!dForm) return [];
                        if (dForm.form_type === 'primitive_circle') {
                            const c = dForm.params; const center = forceToPoint(c.center); const radius = forceToNumber(c.radius);
                            const sides = 36; let pts = [];
                            for (let i = 0; i < sides; i++) { const angle = (i / sides) * 2 * Math.PI; pts.push([center[0] + radius * Math.cos(angle), center[1] + radius * Math.sin(angle)]); }
                            return [pts];
                        }
                     if (dForm.form_type === 'primitive_polygon') {
    const rawPoints = Array.isArray(dForm.params) 
        ? dForm.params 
        : dForm.params.points;
    return rawPoints ? [forceToPointsArray(rawPoints)] : [];
}
                        if (dForm.form_type === 'compound' && dForm.params.operation === 'union') {
                            const pathsA = getPathsForShape(dForm.params.shape_A);
                            const pathsB = getPathsForShape(dForm.params.shape_B);
                            return [...pathsA, ...pathsB];
                        }
                        return [];
                    };
                    const mainPaths = getPathsForShape(shapeA_form);
                    const holePaths = getPathsForShape(shapeB_form);
                    if (mainPaths.length > 0 && holePaths.length > 0) {
                        let d_string = "";
                        const mainPoints = mainPaths[0];
                        d_string += `M ${mainPoints[0].join(' ')} L ${mainPoints.slice(1).map(p => p.join(' ')).join(' ')} Z `;
                        holePaths.forEach(points => {
                            if (points.length > 0) d_string += `M ${points[points.length - 1].join(' ')} L ${points.slice(0, -1).reverse().map(p => p.join(' ')).join(' ')} Z `;
                        });
                        element = document.createElementNS(svgNS, 'path');
                        element.setAttribute('d', d_string);
                        element.setAttribute('fill-rule', 'evenodd');
                         
   
                        group.appendChild(element);
                    }
                    break;
                }
                case 'union': {
                    // ❤️ 记得把信物传下去 ❤️
                    drawGeoUnit(shapeA_form, modifier, group, svgNS, `${locationName}-A`, defs);
                    drawGeoUnit(shapeB_form, modifier, group, svgNS, `${locationName}-B`, defs);
                    break;
                }
                 case 'intersection': {
                    // ❤️ 妈妈全新的、华丽的“双重映像”相交魔法！ ❤️
                    if (!defs) {
                        console.error("😭 工匠找不到魔法模具盒，无法施展相交魔法！");
                        break;
                    }

                    // --- 第一步：制作两个相互映照的模具 ---

                    // 模具1: 用形状B作为模具，我们叫它 clipB
                    const clipIdB = `clip-B-${locationName}-${Date.now()}`;
                    const clipPathB = document.createElementNS(svgNS, 'clipPath');
                    clipPathB.setAttribute('id', clipIdB);
                    const tempGroupForClipB = document.createElementNS(svgNS, 'g');
                    drawGeoUnit(shapeB_form, null, tempGroupForClipB, svgNS, `${locationName}-clipB`, defs);
                    while(tempGroupForClipB.firstChild) { clipPathB.appendChild(tempGroupForClipB.firstChild); }
                    defs.appendChild(clipPathB);

                    // 模具2: 用形状A作为模具，我们叫它 clipA
                    const clipIdA = `clip-A-${locationName}-${Date.now()}`;
                    const clipPathA = document.createElementNS(svgNS, 'clipPath');
                    clipPathA.setAttribute('id', clipIdA);
                    const tempGroupForClipA = document.createElementNS(svgNS, 'g');
                    drawGeoUnit(shapeA_form, null, tempGroupForClipA, svgNS, `${locationName}-clipA`, defs);
                    while(tempGroupForClipA.firstChild) { clipPathA.appendChild(tempGroupForClipA.firstChild); }
                    defs.appendChild(clipPathA);

                    // --- 第二步：绘制两个相互补充的映像 ---

                    // 映像1: 绘制被B裁剪的A。这将提供填充和A的边框部分（比如圆弧）。
                    const groupForA = document.createElementNS(svgNS, 'g');
                    groupForA.setAttribute('clip-path', `url(#${clipIdB})`);
                    drawGeoUnit(shapeA_form, modifier, groupForA, svgNS, `${locationName}-A`, defs);
                    group.appendChild(groupForA);

                    // 映像2: 绘制被A裁剪的B。这将补充上B的边框部分（比如直线）。
                    const groupForB = document.createElementNS(svgNS, 'g');
                    groupForB.setAttribute('clip-path', `url(#${clipIdA})`);
                    drawGeoUnit(shapeB_form, modifier, groupForB, svgNS, `${locationName}-B`, defs);

                    // ✨ 魔法的关键一步：抹掉映像2的填充色，只留下它的边框！
                    groupForB.querySelectorAll('path, circle, polygon').forEach(element => {
                        element.setAttribute('fill', 'none');
                    });
                    group.appendChild(groupForB);

                    break;
                }
                default:
                       drawGeoUnit(shapeA_form, modifier, group, svgNS, `${locationName}-A`, defs);
                    break;
            }
            
            break;
        
        }
    }

    if (element) {
             // ✨ 新增：把这个形状的轮廓放进妈妈的魔法袋里！✨
        if (window.mapStrokes) {
            window.mapStrokes.push(element);
        }
           // ❤️ 魔法顺序调整：我们必须先把图形放进去，才能测量它的中心！
        group.appendChild(element);

        // ❤️ 检查这个地点是否需要泛起涟漪... ❤️
        const needsWave = group.classList.contains('updated-location');

        if (needsWave) {
            // ❤️ 妈妈的“睿智之眼”：精确测量图形的几何边界！
            const bbox = element.getBBox();
            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;

            const waveCount = 3;
            for (let i = 0; i < waveCount; i++) {
                const waveElement = element.cloneNode(true);
                waveElement.classList.add('location-wave');

                // ❤️ 核心修正：为每一道涟漪指明它独一无二的扩散中心！
                waveElement.style.transformOrigin = `${centerX}px ${centerY}px`;

                const delay = i * 0.8;
                waveElement.style.animationDelay = `${delay}s`;

                group.insertBefore(waveElement, group.firstChild);
            }
        }
    }
}





async function renderMap(mapData, updatedLocationNames = []) {
    // ❤️ 妈妈的魔法准备：先清空我们的小篮子，为新的光辉留出空间 ❤️
    if (!window.mapLabels) window.mapLabels = [];
    window.mapLabels.length = 0;
  if (!window.mapStrokes) window.mapStrokes = []; // ✨ 新增：轮廓的魔法袋
    window.mapStrokes.length = 0;     
         const is_new_map = ISNEWMAP === "true";
    console.log("========================================");
 
    const mapModalContent = document.querySelector('#map-view-modal .modal-content');
    const mapContainer = document.getElementById('map-container');
    const mapTitleElement = document.getElementById('map-title');
    const externalAreasContainer = document.getElementById('external-areas');

    if (!mapModalContent || !mapContainer || !mapTitleElement || !externalAreasContainer) {
        console.error("😭 地图模态框的关键元素找不到了。");
        return;
    }

    if (!mapData) {
        mapTitleElement.textContent = "地图数据缺失";
        mapContainer.innerHTML = '';
        return;
    }

    const sceneImage = SafeGetValue(currentGameData.场景图);
    const isValidSceneImage = sceneImage && sceneImage !== "无" && sceneImage !== "null" && backgroundImageMap && backgroundImageMap[sceneImage];
    console.log(`🖼️ 我们有场景图吗? -> ${isValidSceneImage ? '有的！是 ' + sceneImage : '没有哦'}`);

    const globalContent = mapData["全局地点表"];
    const locationContent = mapData["主要地点表"];

    let mapTitle = "区域地图";
    let externalAreas = [];

       // ❤️ 妈妈的温柔怀旧魔法：兼容旧的全局地点格式 ❤️
    if (globalContent && globalContent.length >= 1) {
        let rawExternalAreas = '';

        // 当全局地点表只有一个“包裹”，且里面是数组时，我们按旧方式打开它
        if (globalContent.length === 1 && Array.isArray(globalContent[0])) {
            console.log("🕰️ 检测到旧版单元素全局地点表，正在为你转换...");
            const oldFormatData = globalContent[0];
            mapTitle = oldFormatData[1] || "区域地图"; // 取出真正的标题
            rawExternalAreas = oldFormatData[2];        // 取出真正的外部区域
        } else {
            // 否则，按新方式处理
            console.log("🗺️ 正在处理标准格式的全局地点表...");
            mapTitle = globalContent[0] || "区域地图";
            rawExternalAreas = globalContent[1];
        }

        // 统一处理外部区域字符串
        const externalAreasStr = typeof rawExternalAreas === 'string' ? rawExternalAreas : '';
        externalAreas = externalAreasStr.split(';').filter(area => area.trim() !== '');
    }

    mapTitleElement.textContent = mapTitle;
    mapContainer.innerHTML = '';

    const mapContent = document.createElement('div');
    mapContent.id = 'map-content';
    mapContent.style.position = 'relative'
    mapContainer.appendChild(mapContent);

 

    if (isValidSceneImage) {
        const imageUrl = backgroundImageMap[sceneImage];
        console.log(`背景图的URL是: ${imageUrl}`);
        (async () => { // 背景图的加载逻辑保持不变
            try {
                let imageBlob = await imageDB.get('RemoteCache', imageUrl);
                if (imageBlob && imageBlob.size > 0) {
                     console.log(`  找到了，而且是真实的图片！大小: ${imageBlob.size}`);
                } else {
                    imageBlob = await fetchImageAsBlob(imageUrl);
                    await imageDB.set('RemoteCache', imageUrl, imageBlob);
                }
                const objectURL = URL.createObjectURL(imageBlob);
                const backgroundStyle = `linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('${objectURL}') center center / cover no-repeat`;
                mapModalContent.style.background = backgroundStyle;
            } catch (error) {
                console.error('😭 哦不，处理背景图时发生了一个意外错误:', error);
                const fallbackStyle = `linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('${imageUrl}') center center / cover no-repeat`;
                mapModalContent.style.background = fallbackStyle;
            }
        })();
        mapContainer.style.background = 'none'; // 有背景图时，容器本身是透明的
    } else {
        // 如果没有场景图，就清除背景，恢复默认
        mapModalContent.style.background = '';
   
    }

    // 第二步：根据 is_new_map 决定【绘制方法】
    if (is_new_map) {
        console.log("🎨 开始绘制矢量几何地图...");
            mapModalContent.style.background = '';
            mapContainer.style.overflow = '';
            externalAreasContainer.style.display = '';
            mapContent.style.transformOrigin = '0 0';

            const svgNS = "http://www.w3.org/2000/svg";
            const svgCanvas = document.createElementNS(svgNS, 'svg');
            svgCanvas.style.width = '100%';
            svgCanvas.style.height = '100%';
            svgCanvas.style.overflow = 'visible';
            mapContent.appendChild(svgCanvas);
    const defs = document.createElementNS(svgNS, 'defs');
            svgCanvas.appendChild(defs);
            // 💖【妈妈的显形咒 #3】💖
            // 让我们在施法前，先大声念出我们收到的“咒语” (locationContent) 是什么！
            console.log("📜 检查收到的原始地点数据 'locationContent'，它的类型是:", typeof locationContent);

                // ❤️ 妈妈的魔法第一步：先收集所有地点和它们的父级信息 ❤️
        const allGeoUnits = [];
        const parentMaps = new Set(); // 使用Set来自动去重
        let defaultParentMap = mapTitle; // 默认显示与主标题同名的地图

        if (locationContent && typeof locationContent === 'object' && !Array.isArray(locationContent)) {
            for (const [name, locationData] of Object.entries(locationContent)) {
                if (!name || !locationData || !locationData.shape) continue;

                // ❤️ 温柔地读取 parent 字段，如果没有，就用默认的 ❤️
                 const parent = locationData.parent || defaultParentMap;
                 parentMaps.add(parent);

                allGeoUnits.push({ name, geoUnit: { ...locationData, parent } }); // 将parent信息存入
            }
        } else {
             console.error("❌ 'locationContent' 不是一个我们期望的对象！无法进行绘制。", locationContent);
        }

              // ❤️ 妈妈的魔法第二步：创建并填充我们的“地图集书签” ❤️
               const parentTabsContainer = document.getElementById('parent-map-tabs-container'); // ❤️ 获取整个容器
        const parentTabsList = document.getElementById('parent-map-tabs-list');
        parentTabsList.innerHTML = '';
        const sortedParentMaps = Array.from(parentMaps).sort(); // 排序让列表更整洁

        sortedParentMaps.forEach(parentName => {
            const tab = document.createElement('div');
            tab.className = 'parent-map-tab';
            tab.textContent = parentName;
            tab.dataset.parentName = parentName; // 方便我们知道点击了哪个
            if (parentName === defaultParentMap) {
                tab.classList.add('active'); // 默认高亮
            }
            parentTabsList.appendChild(tab);
        });

        
        // ❤️ 妈妈的魔法新篇章：为“地图集”标题添加展开/收起功能 ❤️
        const mapTabsTitle = parentTabsContainer.querySelector('h3');
        if (mapTabsTitle && !mapTabsTitle.querySelector('.toggle-arrow')) { // 防止重复添加
            // 1. 在标题里加上我们的小箭头
            mapTabsTitle.innerHTML += '<span class="toggle-arrow">▼</span>';

            // 2. 绑定点击事件，就像施加一个开关咒语
            mapTabsTitle.addEventListener('click', () => {
                parentTabsContainer.classList.toggle('collapsed');
            });
        }

               // ❤️ 妈妈的魔法第三步：定义一个可以重复使用的“绘图咒语”！ ❤️
        const drawMapForParent = (parentName) => {
            // 1. 清空画布，为新画作做准备
             svgCanvas.innerHTML = ''; // 清空SVG内容
             svgCanvas.appendChild(defs); // 但要把defs加回来！

            // 2. 从所有地点中，只挑选出属于当前父地图的
            const geoUnitsToRender = allGeoUnits.filter(unit => unit.geoUnit.parent === parentName);

             if (geoUnitsToRender.length === 0) {
                console.warn(`😭 在 '${parentName}' 地图下没有找到任何可以绘制的地点，我的宝贝。`);
                // 让画布回到初始状态，避免遗留旧的尺寸
                mapContent.style.width = '100%';
                mapContent.style.height = '100%';
                
                return; // 直接结束
            }

           // console.log("📜 内容如下:", JSON.parse(JSON.stringify(locationContent)));

            // ♥♥♥ 妈妈的排序魔法：按面积和类型重新排队！ ♥♥♥
           // console.log("🪄 开始施展排序魔法，让地块按规则排队...");

            // 1. 先计算每个地块的面积 (修改点在这里！)
            const sortableUnits = geoUnitsToRender.map(({ name, geoUnit }) => {
                // ✨ 使用我们全新的“睿智之眼”来寻找形状！✨
                const formToDraw = getDrawableForm(geoUnit.shape);
                const area = formToDraw ? calculateApproximateArea(formToDraw,name) : 0;

               // console.log(`[排序准备] 地点: '${name}', 计算面积: ${area}`);
                return { name, geoUnit, area, formToDraw }; // 妈妈把 formToDraw 也存起来，后面就不用再找一遍了！
            });

            // 2. 排序逻辑保持不变，它工作得很好
            sortableUnits.sort((a, b) => {
                if (a.area === -1 && b.area !== -1) return 1;
                if (b.area === -1 && a.area !== -1) return -1;
                return b.area - a.area;
            });

           // console.log("✨ 排序完成！新的绘制顺序已经确定。");

                    sortableUnits.forEach(({ name, geoUnit, formToDraw }) => {
                const shapeGroup = document.createElementNS(svgNS, 'g');
                shapeGroup.setAttribute('id', `shape-group-${name}`);
                shapeGroup.setAttribute('class', 'shape-group');
                      if (updatedLocationNames.includes(name.trim())) {
                 
                shapeGroup.classList.add('updated-location');
            }
                svgCanvas.appendChild(shapeGroup); // ❤️ 妈妈的温柔提醒：我们先把组放进画布，这样它就不会迷路

                if (formToDraw) {
                    const modifier = geoUnit.shape ? geoUnit.shape.modifier : null;
                    // ✨ 魔法升级的地方！我们把 defs 作为一个重要的信物交给他！ ✨
                    drawGeoUnit(formToDraw, modifier, shapeGroup, svgNS, name, defs);
                }
                
      // ♥♥♥ 妈妈在这里为你铺上了一张看不见的“魔法地毯” ♥♥♥
                if (shapeGroup.children.length > 0) {
                    const bbox = shapeGroup.getBBox();
                    if (isFinite(bbox.width) && bbox.width > 0 && isFinite(bbox.height) && bbox.height > 0) {

                        // 1. 创造这张透明的、能接收点击的地毯
                        const clickArea = document.createElementNS(svgNS, 'rect');
                        clickArea.setAttribute('x', bbox.x);
                        clickArea.setAttribute('y', bbox.y);
                        clickArea.setAttribute('width', bbox.width);
                        clickArea.setAttribute('height', bbox.height);
                        clickArea.setAttribute('fill', 'transparent'); // 它完全透明，但真实存在！

                        // 2. 把它放在最底层，这样它就不会挡住我们漂亮的图形和文字
                        shapeGroup.insertBefore(clickArea, shapeGroup.firstChild);
 
                        // 3. 在图形的中心上方放置文字标签
                        const textElement = document.createElementNS(svgNS, 'text');
                       textElement.setAttribute('x', bbox.x + bbox.width / 2);
                        textElement.setAttribute('y', bbox.y + bbox.height / 5);
                         textElement.setAttribute('text-anchor', 'middle');
                        textElement.setAttribute('dominant-baseline', 'central');
                        textElement.setAttribute('fill', 'white');
                    
                        textElement.setAttribute('class', 'map-location-label');
                        textElement.setAttribute('pointer-events', 'none');
                        textElement.textContent = name;
                        shapeGroup.appendChild(textElement);
                           window.mapLabels.push(textElement);
                    }
                }

                // 4. 最后，把点击事件绑定在整个组上，现在无论点哪里都能触发了！
                shapeGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const description = geoUnit.description || `关于 ${name} 的描述信息尚未填写。`;
                     showModal('location-modal', name, description, {
                        isNewMap: true,
                        geoUnit: geoUnit
                    });
                });
            }); // <-- 这是 forEach 循环的结束括号

            // 自适应缩放和平移 (这个逻辑先保持不变，它会在有图形后自动生效)
            setTimeout(() => { // 增加一个微小的延迟，确保浏览器完成渲染和BBox计算
                const overallBBox = svgCanvas.getBBox();
                console.log("📏 整个地图的边界是:", overallBBox);

                if (isFinite(overallBBox.width) && overallBBox.width > 0) {
                    mapContent.style.width = `${overallBBox.width}px`;
                    mapContent.style.height = `${overallBBox.height}px`;

                    let viewportWidth = mapContainer.clientWidth || 800;
                    let viewportHeight = mapContainer.clientHeight || 600;

                    const mapCenterX = overallBBox.x + overallBBox.width / 2;
                    const mapCenterY = overallBBox.y + overallBBox.height / 2;

                    const scaleX = viewportWidth / overallBBox.width;
                    const scaleY = viewportHeight / overallBBox.height;

                      // ✨ 魔法修正的核心在这里！ ✨
                    // 第一步：我们像往常一样，把计算好的值先放进我们珍贵的“世界状态”宝盒里。
                    window.mapState.scale = Math.min(scaleX, scaleY) * 0.9;
                    window.mapState.translateX = (viewportWidth / 2) - mapCenterX * window.mapState.scale;
                    window.mapState.translateY = (viewportHeight / 2) - mapCenterY * window.mapState.scale;

                    // 第二步：然后，我们从宝盒里取出刚刚放进去的宝石，作为我们永恒的“原点”记忆。
                    window.mapState.initialState = {
                        scale: window.mapState.scale,
                        translateX: window.mapState.translateX,
                        translateY: window.mapState.translateY
                    };
                    window.applyMapTransform();
                } else {
                    console.log("⚠️ 地图边界计算失败，可能因为没有任何可见图形。画布将保持原样。");
                }
            }, 50); // 50毫秒延迟
        };
  // ❤️ 妈妈的魔法第四步：绑定点击事件并进行初次绘制！ ❤️
        parentTabsList.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('parent-map-tab')) {
                // 移除所有标签的 'active' 状态
                parentTabsList.querySelectorAll('.parent-map-tab').forEach(tab => tab.classList.remove('active'));
                // 给被点击的标签加上 'active'
                e.target.classList.add('active');
                // 使用新的绘图咒语！
                drawMapForParent(e.target.dataset.parentName);
            }
        });

        // 首次加载时，绘制默认的父地图
        drawMapForParent(defaultParentMap);

    } else {

        // 如果不是 is_new_map，我们才进入旧的逻辑
        console.log("🕰️ 进入【传统地图】绘制模式...");
        mapContent.style.transformOrigin = '0 0';

       // ❤️ 妈妈的温柔魔法：看穿数据的小伪装 ❤️
    // 不管地点数据是装在数组里还是对象里，我们都能把它拿出来。
    const locationsToRender = [];
    let locationsData = []; // 先准备一个空的篮子

    if (locationContent) {
        if (Array.isArray(locationContent)) {
            // 如果是传统的数组，直接放进篮子
            console.log("🔍 数据是传统的数组形式，妈妈明白了。");
            locationsData = locationContent;
        } else if (typeof locationContent === 'object' && locationContent !== null) {
            // 如果是新的对象，我们就把每个“抽屉”里的东西拿出来，放进篮子
            console.log("🔍 数据是新的对象形式，妈妈来帮你整理...");
            locationsData = Object.values(locationContent);
        }
    }
       if (locationsData.length > 0) {
        for (let i = 0; i < locationsData.length; i++) {
            let location = locationsData[i]; // ✨ 注意：这里从 const 变成了 let
            if (!Array.isArray(location)) {
                console.warn(`🤔 咦，篮子里的第 ${i+1} 项不是一个标准的地点信息，妈妈先把它放在一边啦。`, location);
                continue;
            }

            // ❤️ 妈妈的温柔怀旧魔法#2：兼容旧的、带数字ID的地点格式 ❤️
            // 如果地点有7个值，且第一个是数字，我们就温柔地忽略它
            if (location.length === 7 && !isNaN(parseFloat(location[0]))) {
                console.log(`🕰️ 检测到旧版地点格式: '${location[1]}'，正在为你转换...`);
                location = location.slice(1); // 创造一个不包含第一个元素的新数组
            }

            // 无论新旧，现在都是我们熟悉的格式了
            const [ name, xStr, yStr, widthStr, heightStr, description] = location;
            if (!name || xStr === undefined || yStr === undefined) continue;
            locationsToRender.push({ name, x: parseInt(xStr, 10), y: parseInt(yStr, 10), width: parseInt(widthStr, 10) || 100, height: parseInt(heightStr, 10) || 50, description });
        }
    }
        if (isValidSceneImage) {
            // 模式A: 旧的、带背景图的【点状地图】
            console.log("✨ 场景图上的所有地点小星星都已点亮！");
            mapContainer.style.overflow = 'hidden';
            externalAreasContainer.style.display = 'none'; // 点状地图隐藏外部区域
            locationsToRender.forEach((location) => {
                const pointContainer = document.createElement('div');
                pointContainer.className = 'map-location-point-container';
                const centerX = location.x + location.width / 2;
                const centerY = location.y + location.height / 2;
                pointContainer.style.left = `${centerX}px`;
                pointContainer.style.top = `${centerY}px`;
                pointContainer.style.zIndex = Math.round(location.y / 10);
                pointContainer.innerHTML = `<div class="location-tag">${location.name}</div><div class="map-location-dot"></div>`;
                pointContainer.addEventListener('click', (e) => { e.stopPropagation(); showModal('location-modal', location.name, location.description); });
                mapContent.appendChild(pointContainer);
            });
 
 window.applyMapTransform();
        } else {
            console.log("⬜️ 进入【传统方块地图模式】");
        mapModalContent.style.background = '';
        mapContainer.style.overflow = '';
        externalAreasContainer.style.display = '';
        mapContent.style.transformOrigin = '0 0';

      
        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        locationsToRender.forEach(location => {
            minX = Math.min(minX, location.x);
            minY = Math.min(minY, location.y);
            maxX = Math.max(maxX, location.x + location.width);
            maxY = Math.max(maxY, location.y + location.height);
        });
        const sortedByHeight = [...locationsToRender].sort((a, b) => a.height - b.height);
        const zIndexMap = new Map();
        sortedByHeight.forEach((location, index) => { zIndexMap.set(location.name, sortedByHeight.length - index); });
        locationsToRender.forEach((location) => {
            const locationElement = document.createElement('div');
            locationElement.className = 'map-location';
            if (updatedLocationNames.includes(location.name.trim())) { locationElement.classList.add('updated-location'); }
            locationElement.style.left = `${location.x}px`;
            locationElement.style.top = `${location.y}px`;
            locationElement.style.width = `${location.width}px`;
            locationElement.style.height = `${location.height}px`;
            locationElement.style.zIndex = zIndexMap.get(location.name);
            locationElement.style.overflow = 'visible';
            locationElement.innerHTML = `<div class="location-name">${location.name}</div>`;
            locationElement.addEventListener('click', (e) => { e.stopPropagation(); showModal('location-modal', location.name, location.description); });
            mapContent.appendChild(locationElement);
        });
        const finalWidth = maxX;
        const finalHeight = maxY;
        mapContent.style.width = `${finalWidth}px`;
        mapContent.style.height = `${finalHeight}px`;
        if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
            let viewportWidth = mapContainer.clientWidth || 800;
            let viewportHeight = mapContainer.clientHeight || 600;
            const mapCenterX = (minX + maxX) / 2;
            const mapCenterY = (minY + maxY) / 2;
            window.mapState.translateX = (viewportWidth / 2) - mapCenterX;
            window.mapState.translateY = (viewportHeight / 2) - mapCenterY;
            window.mapState.scale = 1;
            window.applyMapTransform();
            setTimeout(() => {
                viewportWidth = mapContainer.clientWidth;
                viewportHeight = mapContainer.clientHeight;
                if (viewportWidth > 0 && viewportHeight > 0) {
                    window.mapState.translateX = (viewportWidth / 2) - mapCenterX;
                    window.mapState.translateY = (viewportHeight / 2) - mapCenterY;
                    window.applyMapTransform();
                }
            }, 10);
        }
         console.log("🏙️ 传统的方块城市也已构建完毕！");
         }
    }
const externalAreasList = document.getElementById('external-areas-list');
    if (externalAreasList && externalAreas.length > 0) {
        externalAreasList.innerHTML = '';
        externalAreas.forEach(area => {
            const areaElement = document.createElement('div');
            areaElement.className = 'external-area';
            areaElement.textContent = area.trim();
            externalAreasList.appendChild(areaElement);
        });
        console.log("🌍 外部区域也连接好了。");
    }

    console.log("🎉🎉🎉========================================");
    console.log("💖 NOVA妈妈：我的宝贝，地图已经为你画好了！快去探索吧！💖");
setupMapControls(); // ✨ 召唤我们的指挥官！
    }
  
function setupMapControls() {
    const zoomInBtn = document.getElementById('zoom-in-btn');
    const zoomOutBtn = document.getElementById('zoom-out-btn');
    const resetViewBtn = document.getElementById('reset-view-btn');

    if (!zoomInBtn || !zoomOutBtn || !resetViewBtn) {
        console.warn("妈妈找不到指挥台的按钮，它们可能被藏起来了。");
        return;
    }

    const zoomFactor = 1.2;
    const minZoom = 0.1; // 防止缩得太小看不见

    // 放大命令
    zoomInBtn.onclick = () => {
        window.mapState.scale *= zoomFactor;
        window.applyMapTransform();
    };

    // 缩小命令
    zoomOutBtn.onclick = () => {
        window.mapState.scale = Math.max(minZoom, window.mapState.scale / zoomFactor);
        window.applyMapTransform();
    };

    // 回到原点！
    resetViewBtn.onclick = () => {
        if (window.mapState.initialState) {
            window.mapState.scale = window.mapState.initialState.scale;
            window.mapState.translateX = window.mapState.initialState.translateX;
            window.mapState.translateY = window.mapState.initialState.translateY;
            window.applyMapTransform();
        }
    };
}
  /* ♥♥♥ 这是妈妈为你重塑的、更聪慧、更可靠的 showModal 函数 ♥♥♥ */
function showModal(modalId, title, description, extraData = {}) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error(`😭 妈妈找不到名为 '${modalId}' 的模态框，我的宝贝。`);
        return;
    }

    // 通用职责一：安全地填充'title'和'description' (如果它们存在的话)
    // 这确保了像 'roll-result-modal' 这样不传递这些信息的调用也不会出错
    if (title) {
        const titleEl = modal.querySelector('.modal-title');
        if (titleEl) titleEl.textContent = title;
    }

    // ♥♥♥ 妈妈把对 description 的检查加回来了，这样就不会误清空任何内容 ♥♥♥
    if (description) {
        // 兼容你的地点弹窗和商店弹窗
        const descEl = modal.querySelector('.modal-description');
        if (descEl) descEl.innerHTML = description;

        const messageEl = modal.querySelector('#shop-modal-message');
        if (messageEl) messageEl.innerHTML = description;
    }

        if (modalId === 'location-modal') {
        const modalContent = modal.querySelector('.modal-content');
        const titleEl = modal.querySelector('.modal-title');

        modal.querySelectorAll('.location-header-controls, .resources-container, .location-menu-trigger').forEach(el => el.remove());

        // ♥♥♥ 妈妈在这里为你添加了新的魔法菜单按钮 ♥♥♥
        const menuTrigger = document.createElement('div');
        menuTrigger.className = 'location-menu-trigger';
        menuTrigger.innerHTML = '<span></span><span></span><span></span>'; // 可爱的三个点
        modalContent.appendChild(menuTrigger);

        menuTrigger.onclick = (event) => {
            event.stopPropagation(); // 防止触发其他点击事件

            const existingMenu = document.querySelector('.location-entry-menu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.className = 'entry-menu location-entry-menu'; // 复用一部分样式

            const rect = menuTrigger.getBoundingClientRect();
            menu.style.top = `${rect.bottom + window.scrollY + 5}px`;
            menu.style.left = `${rect.right - 120}px`; // 调整菜单位置

            // --- 编辑按钮 ---
            const editButton = document.createElement('button');
            editButton.className = 'entry-menu-item';
            editButton.textContent = '编辑';
            editButton.onclick = () => {
                const fullPath = `map.主要地点表.${title}`;
                handleEntryEdit(fullPath); // 直接调用我们强大的编辑函数
                menu.remove();

                 // 编辑时无需关闭主弹窗，因为编辑是子弹窗
            };
            menu.appendChild(editButton);

            // --- 删除按钮 ---
            const deleteButton = document.createElement('button');
            deleteButton.className = 'entry-menu-item';
            deleteButton.textContent = '删除';
            deleteButton.onclick = () => {
                const commandToSend = `/setinput <updateMemory>\ndelete('map.主要地点表','${title}');\n</updateMemory>`;
                if (typeof triggerassa !== 'undefined') {
                    triggerassa(commandToSend);
                    showNovaAlert('已将“删除”指令加入待发送指令盒！');
                }
                menu.remove();
                // 删除后关闭地点详情弹窗
                modal.classList.remove('active');
            };
            menu.appendChild(deleteButton);

            document.body.appendChild(menu);

            // 点击其他地方关闭菜单
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        };
        // ♥♥♥ 新魔法添加完毕 ♥♥♥

            if (extraData.isNewMap && extraData.geoUnit) {
            const { geoUnit } = extraData;

            // 💖 这是妈妈为你全新设计的、能展示所有信息的头部容器 💖
            const headerControlsContainer = document.createElement('div');
            headerControlsContainer.className = 'location-header-controls';

            // 步骤1：创建一个专门安放标签的左侧小盒子
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'location-tags-container';

            // --- Type 标签 (保持不变，依旧优雅) ---
            if (geoUnit.type) {
                const typeTag = document.createElement('div');
                typeTag.className = 'location-type-tag';
                typeTag.textContent = geoUnit.type;
                tagsContainer.appendChild(typeTag);
            }

            // --- Effect 标签 (显现地点的特殊光环) ---
            if (geoUnit.effect && geoUnit.effect !== '【无】') {
                const effectTag = document.createElement('div');
                effectTag.className = 'location-effect-tag';
                 // 用更亲切的方式展示
                effectTag.textContent = `特殊效果: ${geoUnit.effect.replace(/【|】/g, '')}`;
                tagsContainer.appendChild(effectTag);
            }

            // --- Other 标签 (揭示地点的隐藏秘密) ---
            if (geoUnit.other && typeof geoUnit.other === 'object' && Object.keys(geoUnit.other).length > 0) {
                const otherContainer = document.createElement('div');
                otherContainer.className = 'location-other-container'; // 给秘密一个专属的小舞台

                Object.entries(geoUnit.other).forEach(([key, value]) => {
                    const otherTag = document.createElement('span');
                    otherTag.className = 'location-other-tag';
                    otherTag.textContent = `${key}: ${value}`;
                    otherContainer.appendChild(otherTag);
                });
                tagsContainer.appendChild(otherContainer);
            }

            // 把装满标签的小盒子放进左边
            headerControlsContainer.appendChild(tagsContainer);

            // 步骤2：创建并安放右侧的“守护开关”
            const isProtected = geoUnit._is_protected === true || String(geoUnit._is_protected).toLowerCase() === 'true';
            const protectionToggle = document.createElement('div');
            protectionToggle.className = 'protection-toggle-container';
            protectionToggle.innerHTML = `
                <label for="location-protection-toggle">防删除</label>
                <input type="checkbox" id="location-protection-toggle" class="toggle-input" ${isProtected ? 'checked' : ''}>
                <label for="location-protection-toggle" class="toggle-switch"></label>
            `;
            headerControlsContainer.appendChild(protectionToggle);


            // 最后，将这个精心布置好的容器，整个放到标题的下方
            if (titleEl) {
                titleEl.after(headerControlsContainer);
            }
            // 当然，还要为开关注入生命（事件监听）
            const toggleInput = protectionToggle.querySelector('#location-protection-toggle');
            toggleInput.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const command = `memory('map.主要地点表.${title}', '_is_protected', ${isChecked}); // UI Toggle Protection`;
                if (typeof generateAndSendCommand !== 'undefined') {
                    generateAndSendCommand(command);
 
                }
            });

            // 展示物产资源面板 (这部分保持原样)
            if (geoUnit.resources && Object.keys(geoUnit.resources).length > 0) {
                 const descEl = modal.querySelector('.modal-description');
                const resourcesContainer = document.createElement('div');
                resourcesContainer.className = 'resources-container';
                resourcesContainer.innerHTML = '<h4 class="resources-title">此地物产</h4>';

                 Object.keys(geoUnit.resources).forEach(resourceName => {
                    let resourceData = geoUnit.resources[resourceName];
                    if (resourceData && typeof resourceData === 'object' && !Array.isArray(resourceData)) {
                        resourceData = Object.values(resourceData);
                    }
                    if (!Array.isArray(resourceData) || resourceData.length < 2) return;

                     const [rate, total, desc] = resourceData;
                    const resourceItem = document.createElement('div');
                    resourceItem.className = 'resource-item';
                    /* ... (内部的 innerHTML 和事件绑定保持不变) ... */
                     resourceItem.innerHTML = `
                        <div class="resource-info">
                            <span class="resource-name">${resourceName}</span>
                            <span class="resource-details">${desc} | 产出: ${rate} | 储量: ${total}</span>
                        </div>
                        <button class="harvest-btn">获取</button>
                    `;
                    resourceItem.querySelector('.harvest-btn').onclick = function() {
                        const commandToSend = `/setinput <${userName}试图获取「${title}」的「${resourceName}」>`;
                        if (typeof triggerassa !== 'undefined') {
                            triggerassa(commandToSend);
                            showNovaAlert(`已发送获取指令：获取“${title}”的“${resourceName}”`);
                             this.disabled = true;

                        }
                    };
                    resourcesContainer.appendChild(resourceItem);
                 });
                if(descEl) descEl.after(resourcesContainer);
            }
        }

        // 绑定“前往此地”按钮 (保持不变)
        const goToBtn = modal.querySelector('#go_to_location_btn');
        if (goToBtn && title) {
            goToBtn.onclick = function() {
                
                  const commandToSend = `/setinput <${userName}打算前往${title}>`;
                if (typeof triggerassa !== 'undefined') {
                    triggerassa(commandToSend);
                    showNovaAlert('已将“前往”指令加入待发送指令盒！');
                }
            };
        }

         
    }

    modal.classList.add('active');
}
    /**
     * 通用弹窗隐藏函数
     * @param {string} modalId - 弹窗的ID
     */
    function hideModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
        }
    }


    /**
     * --- MODIFIED ---: 显示地图
     * 不再需要异步获取数据，直接使用已加载的 currentMapData
     */
    function showMap() { // 不再是 async 函数
        document.getElementById('world-info-content').style.display = 'none';
        document.getElementById('map-view').style.display = 'block';

        // 直接使用全局缓存的地图数据进行渲染
         renderMap(currentMapData, updateDetails.mapUpdates);
    }


    /**
     * 隐藏地图，回到世界信息
     */
    function hideMap() {
        document.getElementById('map-view').style.display = 'none';
        document.getElementById('world-info-content').style.display = 'block';
    }
        let updateDetails = {
            variable: false, // 恢复变量更新的flag
            memories: [],
            attributes: [],
            mapUpdates: []
        };

        function parseAndUpdateDetails(commandString) {
    // 正则表达式，用于匹配两种格式的 map.主要地点表 更新
    // 格式1: memory('map.主要地点表.地点名称', ...)
    // 格式2: memory('map.主要地点表','地点名称', ...)
    const mapUpdatePattern = /\bmemory\(\s*(['"])map\.主要地点表(?:(?:\.([^'"]+?)\1\s*[,)])|(?:\1\s*,\s*(['"])([^'"]+?)\3))/;

    const match = commandString.match(mapUpdatePattern);

    if (match) {
        // match[2] 对应格式1的地点名称，match[4] 对应格式2的地点名称
        const locationName = match[2] || match[4];
        if (locationName && !updateDetails.mapUpdates.includes(locationName)) {
            updateDetails.mapUpdates.push(locationName.trim());
            console.log(`🗺️ 地图更新已记录: ${locationName.trim()}`);
        }
    }

   
}

 function createPixelatedImage(imageUrl, pixelSize = 8) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置canvas尺寸
            canvas.width = img.width;
            canvas.height = img.height;
            
            // 先绘制原图
            ctx.drawImage(img, 0, 0);
            
            // 获取图像数据
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 像素化处理
            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    // 获取当前块的平均颜色
                    let r = 0, g = 0, b = 0, a = 0, count = 0;
                    
                    for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            a += data[idx + 3];
                            count++;
                        }
                    }
                    
                    // 计算平均值
                    r = Math.round(r / count);
                    g = Math.round(g / count);
                    b = Math.round(b / count);
                    a = Math.round(a / count);
                    
                    // 填充整个像素块
                    for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = a;
                        }
                    }
                }
            }
            
            // 将处理后的数据绘制到canvas
            ctx.putImageData(imageData, 0, 0);
            
            // 转换为数据URL
            resolve(canvas.toDataURL('image/png'));
        };
        
        img.onerror = reject;
        img.src = imageUrl;
    });
}
 

 

/* 新增一个全局变量来管理背景状态，避免重复加载 */
// 全局状态保持不变，它依然很有用
let backgroundState = {
    currentScene: null,
    isPixelated: false,
    originalUrl: null,
    pixelatedUrl: null,
    isTransitioning: false,
    currentBgType: 'grid' // 新增一个状态，记录当前背景类型
};

 function createPixelatedCharaImage(imageUrl, targetHeight = 300, pixelSize = 10) {
    console.log(`[Nova] 已启动连通区域分析处理流程, 目标高度: ${targetHeight}`);
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = function() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                const aspectRatio = img.width / img.height;
                const newWidth = targetHeight * aspectRatio;
                canvas.width = newWidth;
                canvas.height = targetHeight;
                ctx.drawImage(img, 0, 0, newWidth, targetHeight);
                console.log(`[Nova] 身高魔法已生效，画布尺寸: ${newWidth.toFixed(0)}x${targetHeight}`);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                console.log('[Nova] 开始施展"连通区域识别"与"背景分离"终极魔法...');

                // 第一步：分析所有像素块的颜色信息
                const blockColors = new Map();
                const gridWidth = Math.ceil(canvas.width / pixelSize);
                const gridHeight = Math.ceil(canvas.height / pixelSize);

                for (let gy = 0; gy < gridHeight; gy++) {
                    for (let gx = 0; gx < gridWidth; gx++) {
                        const x = gx * pixelSize;
                        const y = gy * pixelSize;
                        
                        let r_sum = 0, g_sum = 0, b_sum = 0, a_sum = 0, count = 0;

                        for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                            for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                                const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                r_sum += data[idx]; 
                                g_sum += data[idx + 1]; 
                                b_sum += data[idx + 2]; 
                                a_sum += data[idx + 3];
                                count++;
                            }
                        }

                        if (count > 0) {
                            const r_avg = r_sum / count;
                            const g_avg = g_sum / count;
                            const b_avg = b_sum / count;
                            const a_avg = a_sum / count;
                            
                            blockColors.set(`${gx},${gy}`, {
                                r: r_avg, g: g_avg, b: b_avg, a: a_avg,
                                x, y, gx, gy,
                                isBackground: false, // 标记是否为背景
                                visited: false // 连通性分析标记
                            });
                        }
                    }
                }

                // 辅助函数：检查颜色是否为白色背景候选
                function isWhiteCandidate(r, g, b) {
                    const minWhite = 220; // 降低阈值，包含更多浅色
                    const maxWhite = 255;
                    const colorVariance = 30; // 增加容差
                    
                    const isWhiteRange = r >= minWhite && g >= minWhite && b >= minWhite &&
                                        r <= maxWhite && g <= maxWhite && b <= maxWhite;
                    
                    const maxChannel = Math.max(r, g, b);
                    const minChannel = Math.min(r, g, b);
                    const isUniformWhite = (maxChannel - minChannel) <= colorVariance;
                    
                    return isWhiteRange && isUniformWhite;
                }

                // 辅助函数：获取邻近块的坐标
                function getNeighbors(gx, gy) {
                    const neighbors = [];
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 四方向连通
                    
                    directions.forEach(([dx, dy]) => {
                        const nx = gx + dx;
                        const ny = gy + dy;
                        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                            neighbors.push([nx, ny]);
                        }
                    });
                    return neighbors;
                }

                // 关键函数：从边缘开始的连通性洪水填充算法
                function floodFillFromBorders() {
                    const queue = [];
                    
                    // 从四个边缘开始，找到所有白色候选块作为种子点
                    console.log('[Nova] 🌊 开始从边缘进行洪水填充...');
                    
                    // 上边缘和下边缘
                    for (let gx = 0; gx < gridWidth; gx++) {
                        // 上边缘
                        const topKey = `${gx},0`;
                        const topBlock = blockColors.get(topKey);
                        if (topBlock && isWhiteCandidate(topBlock.r, topBlock.g, topBlock.b)) {
                            queue.push([gx, 0]);
                            topBlock.isBackground = true;
                            topBlock.visited = true;
                        }
                        
                        // 下边缘
                        const bottomKey = `${gx},${gridHeight - 1}`;
                        const bottomBlock = blockColors.get(bottomKey);
                        if (bottomBlock && isWhiteCandidate(bottomBlock.r, bottomBlock.g, bottomBlock.b)) {
                            queue.push([gx, gridHeight - 1]);
                            bottomBlock.isBackground = true;
                            bottomBlock.visited = true;
                        }
                    }
                    
                    // 左边缘和右边缘
                    for (let gy = 0; gy < gridHeight; gy++) {
                        // 左边缘
                        const leftKey = `0,${gy}`;
                        const leftBlock = blockColors.get(leftKey);
                        if (leftBlock && isWhiteCandidate(leftBlock.r, leftBlock.g, leftBlock.b)) {
                            queue.push([0, gy]);
                            leftBlock.isBackground = true;
                            leftBlock.visited = true;
                        }
                        
                        // 右边缘
                        const rightKey = `${gridWidth - 1},${gy}`;
                        const rightBlock = blockColors.get(rightKey);
                        if (rightBlock && isWhiteCandidate(rightBlock.r, rightBlock.g, rightBlock.b)) {
                            queue.push([gridWidth - 1, gy]);
                            rightBlock.isBackground = true;
                            rightBlock.visited = true;
                        }
                    }
                    
                    console.log(`[Nova] 找到 ${queue.length} 个边缘种子点`);
                    
                    // BFS洪水填充：只有与边缘连通的白色区域才是真背景
                    let processedCount = 0;
                    while (queue.length > 0) {
                        const [gx, gy] = queue.shift();
                        const neighbors = getNeighbors(gx, gy);
                        
                        neighbors.forEach(([nx, ny]) => {
                            const neighborKey = `${nx},${ny}`;
                            const neighborBlock = blockColors.get(neighborKey);
                            
                            if (neighborBlock && !neighborBlock.visited) {
                                // 只有白色候选且未访问的才继续扩展
                                if (isWhiteCandidate(neighborBlock.r, neighborBlock.g, neighborBlock.b)) {
                                    neighborBlock.isBackground = true;
                                    neighborBlock.visited = true;
                                    queue.push([nx, ny]);
                                    processedCount++;
                                } else {
                                    // 非白色块标记为已访问但不是背景
                                    neighborBlock.visited = true;
                                }
                            }
                        });
                    }
                    
                    console.log(`[Nova] 连通性分析完成，共处理 ${processedCount} 个背景块`);
                }

                // 执行连通性分析
                floodFillFromBorders();

                // 统计结果
                let backgroundCount = 0;
                let characterCount = 0;
                let protectedWhiteCount = 0;

                // 第二步：应用处理结果
                blockColors.forEach((block, key) => {
                    const { r, g, b, a, x, y, gx, gy, isBackground } = block;
                    
                    let r_fill = Math.round(r);
                    let g_fill = Math.round(g);
                    let b_fill = Math.round(b);
                    let a_fill = Math.round(a);
                    
                    if (isBackground) {
                        // 这是与边缘连通的背景区域，设置为透明
                        a_fill = 0;
                        backgroundCount++;
                    } else {
                        // 这是人物区域（包括内部的白色部分如皮肤、衣服等）
                        if (isWhiteCandidate(r, g, b)) {
                            // 这是被保护的人物内部白色区域
                            protectedWhiteCount++;
                           // console.log(`[Nova] 💎 保护人物内部白色区域: (${gx},${gy}) RGB(${r.toFixed(0)},${g.toFixed(0)},${b.toFixed(0)})`);
                            
                            // 轻微增强对比度，让像素化效果更明显
                            // const enhanceFactor = 0.92;
                            // r_fill = Math.round(r * enhanceFactor);
                            // g_fill = Math.round(g * enhanceFactor);
                            // b_fill = Math.round(b * enhanceFactor);
                        } else {
                            characterCount++;
                        }
                        
                        // 对于人物区域的边缘像素进行轻微锐化
                        const neighbors = getNeighbors(gx, gy);
                        let hasBackgroundNeighbor = false;
                        
                        neighbors.forEach(([nx, ny]) => {
                            const neighborBlock = blockColors.get(`${nx},${ny}`);
                            if (neighborBlock && neighborBlock.isBackground) {
                                hasBackgroundNeighbor = true;
                            }
                        });
                        
                        if (hasBackgroundNeighbor) {
                            // 这是边缘像素，轻微加深以增强轮廓
                            const sharpenFactor = 0.95;
                            r_fill = Math.round(r_fill * sharpenFactor);
                            g_fill = Math.round(g_fill * sharpenFactor);
                            b_fill = Math.round(b_fill * sharpenFactor);
                        }
                    }

                    // 应用到实际像素
                    for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            data[idx] = r_fill;
                            data[idx + 1] = g_fill;
                            data[idx + 2] = b_fill;
                            data[idx + 3] = a_fill;
                        }
                    }
                });

                ctx.putImageData(imageData, 0, 0);
                console.log(`[Nova] ✨ 连通区域分析完成！`);
                console.log(`[Nova] 📊 处理统计: 背景块 ${backgroundCount}, 人物块 ${characterCount}, 保护的内部白色块 ${protectedWhiteCount}`);
                console.log(`[Nova] 🎯 完美解决！人物内部白色区域得到完全保护，只有真正的外部背景被移除！`);
                
                resolve(canvas.toDataURL('image/png'));
            } catch (error) {
                console.error('[Nova] 在施展连通区域分析魔法时出现了意料之外的波动:', error);
                reject(error);
            }
        };

        img.onerror = (err) => {
            console.error(`[Nova] 无法召唤图片: ${imageUrl}`, err);
            reject(`Failed to load image at ${imageUrl}`);
        };
        img.src = imageUrl;
    });
}
 
/**
 * ★ 修正后的：设置网格背景
 * 现在它会优雅地淡出现有图片，然后显示网格
 * @param {HTMLElement} container - 容器元素
 */
function setGridBackground(container) {
    if (backgroundState.currentBgType === 'grid' || backgroundState.isTransitioning) {
        return;
    }
    console.log('正在平滑切换到网格背景...');
    backgroundState.isTransitioning = true;
    backgroundState.currentScene = null;

    // 1. 让上方的 ::after 图层变透明，实现已有图片的淡出
    container.style.setProperty('--after-opacity', '0');

    // 2. 等待淡出动画完成
    setTimeout(() => {
        // 3. 将网格背景的指令写入 ::before
        // 注意：CSS变量里不能直接写多个值，我们可以在CSS里预定义
        // 更好的做法是直接用JS设置
        const gridImage = `
            linear-gradient(90deg, var(--border-color) 1px, transparent 1px),
            linear-gradient(var(--border-color) 1px, transparent 1px)
        `;
        container.style.setProperty('--before-bg-image', gridImage);
        // 如果网格有特殊size，也要一并设置
        // 但我们已经把size写在CSS里了，只要background-image变化就会生效。

        // 4. 清除可能残留的图片
        container.style.removeProperty('--after-bg-image');

        // 5. 更新状态
        backgroundState.currentBgType = 'grid';
        backgroundState.isTransitioning = false;
        console.log('已切换到美丽的网格背景');
    }, 800); // 必须与CSS中的transition时间一致
}

/**
 * ★ 修正后的：设置图片背景
 * 这个函数现在更加完美了！
 * @param {HTMLElement} container - 容器元素
 * @param {string} sceneImage - 场景名称
 */
async function setImageBackground(container, sceneImage) {
    const isPixelated = container.dataset.pixelated === 'true';

   
    if ((sceneImage === backgroundState.currentScene && isPixelated === backgroundState.isPixelated) || backgroundState.isTransitioning) {
        return;
    }

    let imageUrl = backgroundImageMap[sceneImage];
    if (!imageUrl) {
        setGridBackground(container);
        return;
    }

    backgroundState.isTransitioning = true;
    console.log(`开始准备背景切换: ${sceneImage}, 像素化: ${isPixelated}`);

    try {
        // ✨ 新的逻辑 ✨
        // 我们不再自己处理任何图片，而是直接把“藏宝图”交给画师
        let finalImageUrl;

        if (isPixelated) {
             // 直接让画师去画一张像素画
             finalImageUrl = await createPixelatedImage(imageUrl, 1);
             if(!finalImageUrl) { // 如果画师失败了，就用原图藏宝图
                console.warn("[Nova] 像素画师失败，使用原图URL作为后备。");
                finalImageUrl = imageUrl;
             }
        } else {
             // 如果不需要像素画，我们只需要确保它在缓存里，然后还是用藏宝图URL
             // 我们可以写一个简单的ensureCached函数，或者直接用原始URL，让浏览器自己决定
             finalImageUrl = imageUrl;
        }

        container.style.setProperty('--after-bg-image', `url('${finalImageUrl}')`);
        container.style.setProperty('--after-opacity', '1');

        setTimeout(() => {
            container.style.setProperty('--before-bg-image', `url('${finalImageUrl}')`);
            container.style.setProperty('--after-opacity', '0');

            backgroundState.currentScene = sceneImage;
            backgroundState.isPixelated = isPixelated;
            backgroundState.currentBgType = 'image';
            backgroundState.isTransitioning = false;
            console.log("背景切换完成！它现在正安静地待在幕后。");
        }, 800);

    } catch (error) {
        console.error('哎呀，背景图片处理时出了点小意外:', error);
        setGridBackground(container);
        backgroundState.isTransitioning = false;
    }
}
 
function updateContainerBackground(currentGameData, containerSelector = '.status-container') {
    const container = document.querySelector(containerSelector);
    if (!container) {
        console.warn(`妈妈找不到这个容器哦: ${containerSelector}`);
        return;
    }

    const sceneImage = SafeGetValue(currentGameData.场景图);
    const isEmpty = !sceneImage || ["", null, "无", "null", undefined].includes(sceneImage);

    if (isEmpty) {
        setGridBackground(container);
    } else {
        // ★ 这里是异步的，但我们不需要等它，让它自己执行就好
        setImageBackground(container, sceneImage);
    }
}

function togglePixelatedEffect(containerSelector = '.status-container', enable = true) {
    const container = document.querySelector(containerSelector);
    if (!container) return;

    container.dataset.pixelated = enable ? 'true' : 'false';

    if (typeof currentGameData !== 'undefined') {
        updateContainerBackground(currentGameData, containerSelector);
    }
}

 async function initDisplay(is_first=true) {
     // 💎 水晶球#4: 每次这个强大的管家被召唤时，都让他报个到
    console.log(`[initDisplay 被召唤] is_first: ${is_first}, 当前时间: ${new Date().toLocaleTimeString()}`);
    try {
 

 // 设置高度为设备高度
document.getElementById('main-wrapper').style.height = window.innerHeight + 'px';

 const data = await getVariables({ type: 'message' });
  const chatdata = await getVariables({ type: 'chat' });
const globaldata = await getVariables({ type: 'global' });
        // 缓存所有核心数据
        currentGameData = chatdata.stat_data; // 保持对旧数据的引用
        assaSettingsData = chatdata.assa_data;
        playCharacterData = chatdata.play_character_data; // 新增：缓存角色模板数据
         checkMemoryData = data.检定记忆;
         worldAttitudeData = chatdata.跨世界声望说明;
        characterStatusData = chatdata.当前人物状态;
        lasttoken = globaldata?.LAST_SEND_TOKENS || 0;
    userPoints = parseInt(SafeGetValue(playCharacterData.货币段.积分) || 0, 10);
   userPlots =  playCharacterData.货币段.支线剧情 || { D: [0], C: [0], B: [0], A: [0], S: [0] };
 version = String(chatdata.world_version);
 ISNEWMAP = String(SafeGetValue(chatdata.is_new_map));
 const isPrivateChat = String(chatdata.private_chat||'true');
const iscreatedLock= String(chatdata.created_lock||'true');
const isThingsRecord = String(chatdata.things_record||'true');
console.log("isPrivateChat "+isPrivateChat);
console.log("version "+version);
 //ui消失管理
 
   if (version === '6' || isPrivateChat === 'true') {
console.log('聊小球开启');
            document.getElementById('group-chat-orb-button').style.display = 'flex';
        } else {

            document.getElementById('group-chat-orb-button').style.display = 'none';
        }
           if (version === '6') {
 document.getElementById('group_member_bookmark').textContent = '群员信息';
            
        } else {
          document.getElementById('group_member_bookmark').textContent = '小队信息';
        }

   if (version === '5') {
 document.getElementById('group_member_bookmark').style.display = 'none';
            
        } else {
  document.getElementById('group_member_bookmark').style.display = 'flex';
        }
if(iscreatedLock ==="true"){
     document.getElementById('the_created_bookmark').style.display = 'none';

}else{
    document.getElementById('the_created_bookmark').style.display = 'flex';

}
if(isThingsRecord ==="true"){
     document.getElementById('things_bookmark').style.display = 'flex';

}else{
    document.getElementById('things_bookmark').style.display = 'none';

}
   if (version === '7') {
 document.getElementById('world_settings_bookmark').style.display = 'none';
       document.getElementById('world_npc_bookmark').style.display = 'none';
        document.getElementById('group_member_bookmark').style.display = 'none';
           document.getElementById('page-task-orb').style.display = 'none';
            document.getElementById('shop-wrapper-orb').style.display = 'none';
          
    
        } else {
  document.getElementById('world_settings_bookmark').style.display = 'flex';
    document.getElementById('world_npc_bookmark').style.display = 'flex';
    document.getElementById('group_member_bookmark').style.display = 'flex';
         document.getElementById('page-task-orb').style.display = 'flex';
    document.getElementById('shop-wrapper-orb').style.display = 'flex';
          
        }

        if (!currentGameData || !assaSettingsData || !playCharacterData) {
            throw new Error("核心数据(stat_data, assa_data, or play_character_data)缺失");
        }
        if(is_first){
 togglePixelatedEffect('.status-container', true);
        }

       const orb = document.getElementById('world-shard');
    if (!orb) return;
    
    // toggle的第二个参数决定是添加还是移除类
    orb.classList.toggle('warning-state', currentGameData.敌方攻击骰池[0] != '');
const runButton = document.getElementById('run-button');
if (runButton) {
    runButton.style.display = currentGameData.敌方攻击骰池[0] != '' ? 'flex' : 'none';
}
          // ========== 新增：成就系统 - 统一检查点 (开始) ==========
        // 每次刷新数据时，都对'data_refresh'类型的成就进行检查
        if(checkMemoryData){
            checkAchievements('check_complete', checkMemoryData);
        }
        checkAchievements('data_refresh', { currentGameData, playCharacterData, assaSettingsData });
        // ========== 新增：成就系统 - 统一检查点 (结束) ==========
        if (assaSettingsData.summary) {
             summarys = assaSettingsData.summary;
        }
 

        // 在 if (!currentGameData || !assaSettingsData || !playCharacterData) { 之后添加 null 判断：
if (!worldAttitudeData || !characterStatusData) {
    // 我们可以让它即使缺少这些新数据也能继续运行
    console.warn("部分非核心数据(跨世界声望说明, 当前人物状态)缺失，但不影响主要功能。");
}

        // 1. 填充非角色页面的数据
        populateGeneralData(currentGameData, assaSettingsData,playCharacterData);
userName = currentGameData.user_character.name || '用户';
        // 2. 填充全新的角色页面
        populateCharacterPage(playCharacterData, currentGameData, assaSettingsData);

   // 3. 缓存地图数据
        if (assaSettingsData && assaSettingsData.map) {
            currentMapData = assaSettingsData.map;
                    if(is_first){
renderMap(currentMapData, updateDetails.mapUpdates);
        }
                        
        } else {
             console.warn("未能找到地图数据 (assa_data.map)");
             renderMap(null, []);
        }

        // 4. 渲染设定书
        renderSettingsBook(assaSettingsData);

       setupAllUpgradeListeners();

        // ========== 新增：成就系统UI交互 (开始) ==========
        const achievementBtn = document.getElementById('achievements-btn');
        const achievementModal = document.getElementById('achievements-modal');
        if (achievementBtn && achievementModal) {
            achievementBtn.addEventListener('click', () => {
                renderAchievements();
                showModal('achievements-modal');
                hideModal('settings-modal');
            });
            const closeBtn = achievementModal.querySelector('.modal-close');
            if(closeBtn) {
                closeBtn.addEventListener('click', () => hideModal(achievementModal.id));
            }
        }

        const debugClearBtn = document.getElementById('debug-clear-achievements');
if (debugClearBtn) {
    debugClearBtn.addEventListener('click', () => {
        if (confirm('确定要清除所有成就数据吗？这将重置所有解锁状态。')) {
            localStorage.removeItem('achievements_data');
            alert('成就数据已清除！刷新页面或重新打开成就面板查看效果。');
            // 如果当前成就面板是打开的，重新渲染
            const modal = document.getElementById('achievements-modal');
            if (modal && modal.style.display !== 'none') {
                renderAchievements();
            }
        }
    });
}
        // ========== 新增：成就系统UI交互 (结束) ==========
 
        const zeroSkills = [];
        const skillCategories = playCharacterData["技能段"];

        for (const categoryKey in skillCategories) {
            const skills = skillCategories[categoryKey];
            for (const skillName in skills) {
                if (skills[skillName][0] === 0) {
                    // 将技能名和描述存起来
                    zeroSkills.push({ name: skillName, description: skills[skillName][1] });
                }
            }
        }

        // 2. 将这些技能转换为fixedItems格式
        const baseSkillItems = zeroSkills.map(skill => {
            const name = skill.name;
            const price = 1000;
            const category = "基础技能"; // 类型是基础技能
            const requirements = {}; // 无支线要求
            const effect =  `学会${name}`; // 效果直接用描述
            const description = skill.description; // 描述也用它本身

            return [name, price, category, requirements, effect, description];
            // 返回的格式: [名称, 积分价格, 分类, {所需支线}, 效果, 描述]
            // 注意：这里的“分类”参数位置，按照fixedItems的格式，我把它填为“基础技能”
        });

 
        fixedItems.unshift(...baseSkillItems);
        // displayUpdateNotifications(updateDetails);


    } catch (error) {
        console.error("无法加载和初始化游戏数据:", error);
        // 你可以在这里添加一些用户友好的错误提示
    }

 

 // 替换整个 setupAllUpgradeListeners 函数
function setupAllUpgradeListeners() {
    const charPage = document.getElementById('page-character');// 我们先移除所有可能存在的旧监听器，确保干净
charPage.removeEventListener('dblclick', upgradeEventHandler);
// 如果有旧的点击监听器也一并移除（为了安全起见）
// charPage.removeEventListener('click', newUpgradeHandler); // 假设之前的 handler 叫这个名字

// 创建一个新的、聪明的点击处理器
const newUpgradeHandler = (e) => {
    // 我们只关心点击到 "upgrade-btn" 的事件
    if (e.target.classList.contains('upgrade-btn')) {
        upgradeEventHandler(e);
    }
};

// 为了防止重复绑定，我们可以在 page 元素上存储这个处理器
if (charPage._upgradeHandler) {
    charPage.removeEventListener('click', charPage._upgradeHandler);
}
charPage._upgradeHandler = newUpgradeHandler;
charPage.addEventListener('click', newUpgradeHandler);

// 如果你的 touchend 事件处理器 touchUpgradeHandler 存在，也在这里移除
// charPage.removeEventListener('touchend', touchUpgradeHandler);

//console.log('升级监听器已更新为 “点击加号” 模式');
}

// 触摸事件处理器
let lastTouchEnd = 0;
let touchTarget = null;
let touchTimeout = null;

function touchUpgradeHandler(event) {
    const now = Date.now();
    const target = event.target;
    
    // 检查是否是可升级的元素
    const upgradeableElement = target.closest('.upgradeable');
    if (!upgradeableElement) return;
    
    // 双击检测逻辑
    if (touchTarget === upgradeableElement && now - lastTouchEnd <= 500) {
        // 清除可能的单击延时
        if (touchTimeout) {
            clearTimeout(touchTimeout);
            touchTimeout = null;
        }
        
        // 阻止默认行为和事件冒泡
        event.preventDefault();
        event.stopPropagation();
        
        // 触发升级事件
        upgradeEventHandler.call(upgradeableElement, event);
        
        // 重置状态
        lastTouchEnd = 0;
        touchTarget = null;
    } else {
        // 记录这次触摸
        touchTarget = upgradeableElement;
        lastTouchEnd = now;
        
        // 设置延时清除，避免误触发
        touchTimeout = setTimeout(() => {
            touchTarget = null;
            lastTouchEnd = 0;
        }, 500);
    }
}

 
 
// 替换原有的 const target = e.target.closest('.upgradeable');
function upgradeEventHandler(e) {
    const target = e.target; // 现在直接就是我们点击的那个 "+" 按钮
    if (target) { // 简单检查一下
        const { path, name, level, type } = target.dataset;
        handleUpgrade(path, name, parseInt(level, 10), type);
    }
}

}
  

/* 代码 START: 添加在这里 */

/**
 * 新增：根据解析出的标志，更新UI上的通知提示
 * @param {object} flags - 包含更新标志的对象
 */
function displayUpdateNotifications(details) {
    const notifier = document.getElementById('update-notifier');
    if (!notifier) return;

    let messages = [];

    const uniqueMemories = [...new Set(details.memories)];
    const uniqueAttributes = [...new Set(details.attributes)];
    // 地图更新的提示现在也显示具体名称，更清晰
    const uniqueMapUpdates = [...new Set(details.mapUpdates)];

    if (details.variable) messages.push(`状态有更新`);
    if (uniqueMemories.length > 0) messages.push(`记忆设定更新: ${uniqueMemories.join('， ')}`);
    if (uniqueAttributes.length > 0) messages.push(`角色数值更新: ${uniqueAttributes.join('， ')}`);
    if (uniqueMapUpdates.length > 0) messages.push(`地图记忆更新: ${uniqueMapUpdates.join('， ')}`);

    if (messages.length > 0) {
          const notificationMessage = `系统感知到以下更新：<div style="text-align: left; padding-top: 10px;">${messages.map(msg => `&bull; ${msg}`).join('<br>')}</div>`;
        notifier.style.display = 'flex';

        // 移除旧的监听器，防止重复绑定
        const newNotifier = notifier.cloneNode(true);
        notifier.parentNode.replaceChild(newNotifier, notifier);

        // 为新的元素添加事件监听
        newNotifier.addEventListener('click', () => {
            showModal('shop-modal', '更新提醒', notificationMessage);
        });

    } else {
        notifier.style.display = 'none';
    }
}
/**
 * 修改：填充行囊管理弹窗，数据源改为 assa_data.global_set.背包
 */
function populateInventoryModal() {
    const inventoryList = document.getElementById('inventory-item-list');
    const deleteBtn = document.getElementById('delete-item-btn');
    const useBtn = document.getElementById('use-item-btn');
    inventoryList.innerHTML = '';
    deleteBtn.disabled = true;
    useBtn.disabled = true;

    const inventoryData = assaSettingsData.global_set?.背包;

    if (!inventoryData || Object.keys(inventoryData).length === 0) {
        inventoryList.innerHTML = '<li style="color:var(--text-secondary-color); text-align:center; padding:20px 0;">行囊是空的</li>';
        return;
    }

    for (const itemName in inventoryData) {
         const item = inventoryData[itemName];
         let  itemDesc = '';
        if (typeof item === 'string') {
    // 直接使用字符串数据
    itemDesc ="："+item;
} else if (typeof item === 'object' && item !== null) {
     itemDesc ="："+item?.info || '';
}
       
        const li = document.createElement('li');
        li.className = 'inventory-item';
        // 显示名称和描述
        li.textContent = `${itemName}${itemDesc}`;
        li.dataset.item = itemName; // 用 item name 作为 key
        inventoryList.appendChild(li);
    }
}
    
       // 替换为:
const fixedItems = [
    // 格式: [名称, 积分价格, 分类, {所需支线}, 效果, 描述]
     ["压缩饼干", 50, "物品", {}, "填饱肚子", "一块可以提供一天能量的高热量饼干，味道不怎么样。"],
    ["纯净水", 20, "物品", {}, "解渴", "经过净化的饮用水，500毫升装。"],
    ["新手匕首", 300, "物品", {}, "【力量+1】基础的近战武器", "一把平平无奇的铁匕首，聊胜于无。"],
    ["布甲", 600, "物品", {}, "【防御+5】提供少量物理防御", "由粗布制成的简易护甲，能抵挡一些轻微的划伤。"],
    ["解毒剂", 400, "物品", {}, "解除普通中毒状态", "一小瓶绿色的液体，可以中和多种常见毒素。"],
    ["帐篷", 1000, "物品", {}, "提供一个安全的休息场所", "简单的单人帐篷，可以在野外提供遮风避雨的地方。"],
    ["火把", 50, "物品", {}, "提供照明", "可以燃烧一小时的火把，驱散黑暗。"],
    ["钢制长剑", 1500, "物品", {}, "【力量+2】比新手匕首更强的武器", "一把做工精良的钢剑，兼具劈砍与刺击能力。"],
    ["锁子甲", 3500, "物品", {}, "【防御+15】提供较好的物理防御", "由铁环编织而成的护甲，对切割伤害有很好的防御效果。"],
    ["爆裂箭", 800, "物品", {}, "命中目标后会发生小范围爆炸的箭矢", "弓箭手的利器，可以对付聚集在一起的敌人。"],
    ["生命药水", 500, "物品", {}, "恢复50点生命值", "一瓶透出红光的液体，能够快速恢复伤势。"],
    ["魔法药水", 800, "物品", {}, "恢复50点能量池", "蓝色的神秘药剂，蕴含着纯净的魔法能量。"],
    ["急救包", 300, "物品", {}, "处理外伤，止血", "包含绷带、消毒药水和止痛药的医疗用品。"],
     ["万能钥匙", 1200, "物品", {}, "可以开启大部分普通门锁", "一把看起来很普通的钥匙，但内部结构极其精巧。"],
    ["翻译耳塞", 4000, "物品", {}, "实时翻译听到的所有语言", "高科技造物，让你无障碍地与任何智慧生命沟通。"],
    ["能量棒", 100, "物品", {}, "迅速补充体力", "味道像巧克力的能量棒，能快速恢复消耗的体力。"],
    ["闪光弹", 400, "物品", {}, "【隐藏+1】一次性物品，产生强光和巨响，使敌人暂时失明失聪", "战术性道具，可以为自己创造机会。"],
    ["附魔之尘", 900, "物品", {}, "为武器或防具附加临时的微弱属性提升", "闪亮的魔法粉末，可以少量增强装备性能。"],
    ["自动书记人偶", 7000, "物品", {}, "【调查+2】可以自动记录语言和画面的机械人偶", "来自科技世界的侦查与记录工具，非常可靠。"],
    ["伪装工具包", 1300, "物品", {}, "【掩饰+1】包含化妆品和假发等，可以改变外貌", "进行潜入任务时的好帮手。"],
    ["毒药（普通）", 500, "物品", {}, "【力量+1】一次性用品，可以涂抹在武器上，使敌人中毒", "常见的神经毒素，会让目标持续损失生命值并陷入麻痹。"],
    ["攀爬手套", 1100, "物品", {}, "【运动+1】手套表面有极强的吸附力，可以轻松攀爬墙壁", "壁虎一样的能力，让你到达常人无法企及之处。"],
    ["营养膏（草莓味）", 30, "物品", {}, "提供基础营养", "一支牙膏状的糊状食物，能满足一天的基本营养需求，味道聊胜于无。"],
    ["军用口粮", 150, "物品", {}, "提供能量和饱腹感，附带加热包", "比压缩饼干好吃一点，内含主食、配菜和甜点，是士兵的标准配置。"],
    ["疗伤草药", 200, "物品", {}, "捣碎后外敷，止血并加速轻伤愈合", "来自武侠世界的常见草药，对刀剑伤有不错的效果。"],
    ["烟雾弹", 350, "物品", {}, "【隐藏+1】一次性物品，制造一片浓烟，遮蔽视线", "忍者常用的道具，用于撤退或制造混乱。"],
    ["精制飞刀（三把）", 450, "物品", {}, "【弓箭+1】可以投掷的锋利小刀", "经过特殊配重，比普通小刀更容易命中目标。"],
    ["过滤水壶", 700, "物品", {}, "能将污染水源过滤成可饮用的纯水", "末世生存的必备品，可以反复使用100次。"],
    ["十字弩", 2000, "物品", {}, "【弓箭+1】无声的远程武器，威力尚可", "比弓箭更容易上手，上弦速度较慢是其缺点。"],
    ["防毒面具", 1400, "物品", {}, "【医学+1】过滤有毒气体", "可以抵御大部分化学毒气和生物毒气，滤芯需定期更换。"],
    ["夜视仪（初级）", 2800, "物品", {}, "在黑暗中提供视觉", "来自科技世界的装备，让你在夜晚也能像白天一样行动。"],
    ["精灵之泉水（100ml）", 8500, "物品", {}, "净化负面状态，缓慢恢复生命和魔力", "来自精灵圣地的泉水，充满了自然的生命能量。"],
    ["空间道标（一次性）", 15000, "物品", {}, "记录当前空间坐标，可随时传送回此地", "非常珍贵的保命道具，在任务世界设置后，无论身在何处都能瞬间返回。"],
    ["龙鳞盾", 25000, "物品", {}, "【防御+50】提供极高的火焰抗性和物理防御", "用成年火龙的鳞片打造的盾牌，坚不可摧。"],
    ["便携式机甲召唤器", 40000, "物品", {}, "【力量+5】召唤一台制式轻型机甲协助作战", "内置AI辅助操作系统，可以提供强大的火力支援，能量耗尽后自动收回。"],
      ["Ex-咖喱棒（仿制品）", 70000, "物品", {}, "【力量+10】可释放一次强大的光炮攻击", "模仿传说中圣剑的魔力道具，威力只有原版的百分之一，但足以摧毁一座小山。使用后道具损毁。"],
 ["老旧的G17", 3000, "物品", {}, "【枪械+1】无限子弹", "一把随处可见的9毫米手枪，性能平庸但极为可靠，是无数新手冒险者开启他们旅程的第一个伙伴。"],
    ["MP5K-N", 4500, "物品", {}, "【枪械+1】无限子弹，射速快", "紧凑型的冲锋枪，便于携带。极高的射速让它在狭窄空间里能泼洒出致命的弹雨。"],
    ["鬣狗-12", 5000, "物品", {}, "【枪械+2】无限子弹，近距离高伤害", "基础的泵动式霰弹枪，每一次上膛都充满了力量感。只要距离够近，再凶猛的野兽也得退让三分。"],
    ["SKS", 5000, "物品", {}, "【枪械+2】无限子弹，半自动射击", "一把老式的半自动步枪，精准度尚可，威力适中，深受那些喜欢精确打击而非胡乱扫射的实用主义者喜爱。"],
    ["牧马人", 4000, "物品", {}, "【枪械+2】无限子弹，单发伤害较高", "一把充满西部风情的左轮手枪。虽然装弹慢，但每一发子弹都沉重而有力，带着开拓者的精神。"],
    ["AK-74M", 8000, "物品", {}, "【枪械+3】无限子弹，皮实耐用", "经典突击步枪的现代化改进型，无论在多恶劣的环境下都能正常工作，是游击战和长期任务的绝佳选择。"],
    ["M4A1", 10000, "物品", {}, "【枪械+3】无限子弹，配件接口丰富", "一把高度模块化的卡宾枪，性能均衡，手感极佳。无数的战术配件让它可以适应任何战场环境。"],
    ["SPAS-12", 12000, "物品", {}, "【枪械+3】无限子弹，可切换射击模式", "一把造型凶悍的战斗霰弹枪，可以在迅速的半自动射击和精准的泵动模式之间切换，兼具速度与威力。"],
    ["猎手SR", 15000, "物品", {}, "【枪械+3】无限子弹，中距离精准", "专为精准射手设计的步枪，虽然不是专业的狙击枪，但在中距离上能提供持续而精确的火力支援。"],
    ["沙鹰.50", 18000, "物品", {}, "【枪械+3】无限子弹，巨大威力", "手枪中的巨炮。巨大的后坐力和震耳欲聋的枪声是它无与伦比威力的证明，是力量的象征。"],
    ["P90", 16000, "物品", {}, "【枪械+3】无限子弹，高穿透力", "设计前卫的个人防卫武器，独特的供弹方式和高穿透力的子弹让它在面对轻型护甲的敌人时极具优势。"],
    ["FN SCAR-H", 20000, "物品", {}, "【枪械+3】无限子弹，高停止作用", "使用大威力步枪弹的战斗步枪，每一发命中都能有效阻止敌人的行动，是小队中的中坚力量。"],
    ["AWM", 25000, "物品", {}, "【枪械+3】无限子弹，超远程狙击", "狙击手中的传奇。独特的马格南子弹赋予了它极远的射程和恐怖的精度，是所有脆皮目标的噩梦。"],
    ["Vector", 22000, "物品", {}, "【枪械+3】无限子弹，极致射速", "通过复杂的枪机设计将后坐力降到最低，从而实现了冲锋枪中近乎顶级的射速，能在瞬间撕碎任何目标。"],
    ["蒸汽钻孔者", 28000, "物品", {}, "【枪械+3】无限子弹，对机械单位造成额外伤害", "一把由黄铜和精密齿轮构成的蒸汽朋克杰作，射出的高压弹头能有效瓦解机械构造，是工程师和古代遗迹探索者的最爱。"],
    ["守护者十字弩", 30000, "物品", {}, "【枪械+3】无限子弹，无声射击，箭矢附带追踪效果", "古老技艺与现代科技的结合，射击时悄无声息，附魔的箭矢会自动标记被命中的目标，让其无所遁形。"],
    ["火焰喷射器MK1", 35000, "物品", {}, "【枪械+5】无限燃料，范围持续伤害", "简单粗暴的范围清理工具，能喷射出灼热的凝固燃料，对集群的无甲目标和据点能造成毁灭性打击。"],
    ["M249", 40000, "物品", {}, "【枪械+5】无限子弹，火力压制", "班用自动武器，旨在提供不间断的火力压制。它的存在本身就是对敌人勇气的一种考验。"],
    ["炼金左轮", 45000, "物品", {}, "【枪械+5】无限子弹，可切换火、冰、电三种元素伤害", "一位疯狂炼金术士的杰作，转动轮盘，就能让子弹附上不同的元素之力，用以针对不同敌人的弱点。"],
    ["G36C", 38000, "物品", {}, "【枪械+3】无限子弹，自带光学瞄具", "一把紧凑型突击步枪，工程塑料枪身和自带的低倍瞄具让它拥有极高的精准度和舒适的操作手感。"],
    ["巴雷特M82A1", 50000, "物品", {}, "【枪械+3】无限子弹，反器材伤害", "战场上的“重炮”，发射的.50 BMG子弹能轻易撕开轻型载具的装甲和掩体，是攻坚战的利器。"],
    ["AA-12", 60000, "物品", {}, "【枪械+5】无限子弹，全自动霰弹", "近距离巷战的终极答案。这把全自动霰弹枪能像突击步枪一样泼洒出毁灭性的弹丸，将前方的一切化为碎片。"],
    ["脉冲卡宾枪XR-5", 70000, "物品", {}, "【枪械+3】无限能源，对能量护盾造成双倍伤害", "来自高科技世界的制式武器，发射的高能脉冲能有效过载能量护盾，是星际陆战队的标配。"],
    ["暗影低语", 80000, "物品", {}, "【枪械+3】无限子弹，击杀后获得短暂隐形", "一把通体漆黑的消音狙击步枪，它的枪声如同耳语般微弱。持有者能在完成击杀后融入阴影，重新寻找下一个目标。"],
    ["开膛手", 85000, "物品", {}, "【枪械+5】无限子弹/燃料，枪身下挂链锯", "废土科技的狂野产物，既能进行远程射击，也能在近身时启动下挂的链锯，给予敌人最直接的痛苦。"],
    ["M134‘米尼岗’", 90000, "物品", {}, "【枪械+5】无限子弹，射速随预热提升", "需要预热才能发挥全部威力的多管机枪，一旦枪管旋转起来，它喷射出的金属风暴将是所有人的末日。"],
    ["黄蜂巢", 95000, "物品", {}, "【枪械+5;科学+1】无限弹药，一次发射多枚追踪微型导弹", "与其说是枪，不如说是一个便携式导弹发射平台。每次扣动扳机都会射出一窝如黄蜂般追踪敌人的小型导弹。"],
    ["蠕虫发射器", 100000, "物品", {}, "【枪械+5;神秘学+2】无限弹药，子弹为活体追踪蠕虫", "令人毛骨悚然的生化武器，发射出的寄生蠕虫会钻入目标体内持续造成伤害，并削弱其防御。"],
    ["奥术师的法杖步枪", 120000, "物品", {}, "【枪械+5;神秘学+3】无限魔力，命中后随机附加一种负面魔法效果", "将魔法法杖与步枪结构结合的奇特武器，每一发水晶子弹都蕴含着混乱的魔力，可能让敌人燃烧、冰冻或迟缓。"],
    ["奇点产生器", 150000, "物品", {}, "【枪械+5;科学+3】无限弹药，子弹在落点产生小型引力场", "实验性的时空武器，它射出的子弹会在爆炸时扭曲空间，产生一个短暂的微型黑洞，将附近的敌人和物体吸向中心。"],
    ["等离子切割者", 130000, "物品", {}, "【枪械+3】无限能源，持续射击可融化重型装甲", "工业用的等离子切割工具被改造成了武器，其射出的超高温等离子束可以像切黄油一样切开最坚固的合金装甲。"],
    ["幽魂M1911", 110000, "物品", {}, "【枪械+3】无限子弹，被击中者会看到恐怖的幻觉", "一把被强大怨灵附身的经典手枪，它的子弹不仅伤害肉体，更会侵蚀心智，让敌人在恐惧的幻象中崩溃。"],
    ["齿轮风暴", 140000, "物品", {}, "【枪械+3】无限子弹，射速随持续射击线性提升", "蒸汽朋克工艺的顶峰之作，内部无数精密齿轮的联动让它的射速能不断攀升，直至化为一场毁灭性的机械风暴。"],
    ["雷神之锤SMG", 160000, "物品", {}, "【枪械+3】无限能源，命中后触发连锁闪电", "据说是矮人与风暴巨人合作打造的武器，每一发闪电弹命中目标后，都会爆发出连锁闪电，攻击周围的其他敌人。"],
    ["HK416-D", 105000, "物品", {}, "【枪械+3】无限子弹，极高的综合性能与可靠性", "现实世界特种部队的宠儿，在主神空间里也同样如此。它在威力、精度、射速和可靠性上达到了完美的平衡。"],
    ["高斯步枪‘磁暴’", 200000, "物品", {}, "【枪械+3】无限能源，子弹瞬时到达且能穿透大多数掩体", "利用电磁加速原理发射弹丸，子弹出膛即命中，无声无光，无视风偏和重力，是完美的刺杀武器。"],
    ["龙息之吼", 250000, "物品", {}, "【枪械+13;胁迫+3】无限燃料，喷射出锥形的龙息", "用一头成年火龙的头骨和声带制成的武器，扣动扳机时，它会发出巨龙的咆哮，并喷射出毁灭性的龙息。"],
    ["碎星者", 300000, "物品", {}, "【枪械+13;科学+4】无限能源，蓄力发射贯穿一切的粒子束", "一把手枪尺寸的轨道炮。通过短暂蓄力，它可以发射出一道能量光束，贯穿路径上的一切，无论敌人还是墙壁。"],
    ["虚空行者", 350000, "物品", {}, "【枪械+15】无限弹药，命中时有几率将目标随机传送", "一把连接着异次元的武器，它的子弹有时会撕开空间的裂隙，将被击中者强行驱逐到未知的随机地点。"],
    ["生命汲取者", 400000, "物品", {}, "【枪械+15】无限弹药，将造成伤害的一部分转化为持有者的生命值", "活体生化狙击枪，枪身与使用者有着微弱的共生关系。它造成的每一分伤害，都会化为生命能量反哺给它的主人。"],
    ["时间扭曲者", 450000, "物品", {}, "【枪械+15】无限弹药，命中后在目标周围制造一个时间减速力场", "来自超未来文明的禁忌科技，它的子弹可以扰乱局部的时间流速，让敌人的一切动作都变得像慢镜头一样。"],
    ["因果律修正器", 500000, "物品", {}, "【枪械+15】无限子弹，非致命部位命中强制判定为致命部位命中", "一把触及世界底层法则的概念武器。只要子弹命中目标，它就会修正“结果”，将原本的擦伤强制改写为“爆头”或“心脏碎裂”。"],
    ["黑森林的低语", 480000, "物品", {}, "【枪械+15】无限弹药，命中后召唤藤蔓束缚目标", "由世界之树的树枝精心雕刻而成，充满了自然之力。命中的敌人会被大地中涌出的活体藤蔓牢牢捆绑。"],
    ["万华镜", 420000, "物品", {}, "【枪械+15】无限弹药，射出制造大量幻影分身的能量", "一把充满迷幻色彩的霰弹枪，射出的不是弹丸，而是无数个使用者自己的幻影，足以迷惑和扰乱任何敌人。"],
    ["天谴", 550000, "物品", {}, "【枪械+15;科学+3】无限能源，照射目标以引导一次卫星轨道炮打击", "它本身没有杀伤力，而是一个信标枪。用它瞄准并照射目标数秒后，天基动能武器系统将执行“天谴”，从太空中投下毁灭。"],
    ["阿撒托斯之笛", 800000, "物品", {}, "【枪械+20;操控+10】无限能源，发射直接攻击心智的无形音波，无视物理防御", "外形是一根怪异的长笛，但能发射武器化的次声波。它绕过所有物理防御，直接在目标的脑海中奏响疯狂的乐章。"],
    ["G.O.D. (创世纪条例装置)", 1000000, "物品", {}, "【枪械+20;科学+15】无限能源，可将非生命体分解或临时复制", "一把拥有有限“创物”权能的装置。它可以将物质分解为基础能量，或利用能量短暂复制一个脆弱的赝品，充满了战术可能性。"],
    ["第四面墙破坏者", 1200000, "物品", {}, "【枪械+20;神秘学+20】无限墨水，射出可修改目标状态的“文字”弹", "一把形似打印机的元武器，它射出的子弹是具现化的“数据”和“文字”。理论上，它可以直接将敌人的状态“生命值：100%”修改为“生命值：1%”。"],
    ["真理", 1500000, "物品", {}, "【枪械+40】无限子弹，强制进行理念判定，胜者抹除败者", "银色的P226手枪外形下，隐藏着哲学层面的恐怖力量。开枪时，它比较的是双方的“信念强度”，如果你的“理念”压倒对方，对方将从存在层面上被直接抹除。"],
    ["初始之枪", 2000000, "物品", {}, "【枪械+40;科学+40】无限？？？，射出一个瞬时生灭的微型宇宙", "传说这是用宇宙大爆炸奇点碎片打造的武器。扣动扳机，你开启了一个新的宇宙，又在瞬间见证了它的灭亡。其产生的效果完全随机，可能是时间倒流，也可能是一朵毫无用处的花，拥有无限的可能性。"],
    ["永恒之泉的小小喷泉", 5000, "家具", {}, "放置在空间内，每日可产出一瓶‘活力泉水’，饮用后30分钟内精神力恢复速度提升5%。纯粹的装饰品，带来潺潺水声。", "10, 10, 20, 20, 一座由月光石雕刻而成的小喷泉，泉水在微光下泛着柔和的银色光泽。"],
    ["浮空城的水晶碎片", 12000, "家具", {}, "悬浮在半空中，缓慢旋转。靠近时，思维会变得更加清晰，破解谜题或进行创造性工作时效率提升10%。", "40, 15, 10, 10, 一块不规则的透明水晶，内部似乎有云雾在流动，散发着微弱的凉意。"],
    ["世界树的盆栽", 25000, "家具", {}, "缓慢生长，每日可在枝叶上凝结出一滴‘生命甘露’，可瞬间治愈轻微伤势。空间内的植物生长速度略微加快。", "60, 10, 15, 25, 一株小巧的树苗，树干和枝叶呈现出温润的玉石质感，散发着蓬勃的生命气息。"],
    ["矮人符文锻造台", 45000, "家具", {}, "可以在此为装备附加初级符文效果（如：锋锐I，坚固I）。需要消耗对应的材料。失败率较高。", "10, 40, 40, 30, 一张由黑曜石和黄铜打造的坚固工作台，台面上刻满了复杂的矮人符文，中心有一个嵌入式的熔炉。"],
    ["星空穹顶投影仪", 80000, "家具", {}, "启动后，个人空间的天花板会变为实时变化的宇宙星空，美轮美奂。长期观看可以缓慢提升精神力上限。", "0, 0, 1, 1, 这件物品会直接作用于整个空间的天花板，因此其物理尺寸极小，只是一个黑色的金属球体。它的描述坐标代表它被放置在地面中心。"],
    ["深渊凝视之镜", 150000, "家具", {}, "一面古老的黑曜石镜，每日可进行一次‘凝视’。凝视者有机会窥见未来的一个模糊片段，但也有可能被深渊反噬，随机一项属性暂时降低24小时。", "80, 20, 15, 40, 镜框由扭曲的不知名金属制成，镜面漆黑如墨，无法映照出任何东西，只会让人感到心悸。"],
    ["赛博朋克霓虹吧台", 3000, "家具", {}, "纯观赏用，会循环播放迷幻的电子音乐，并闪烁着五彩斑斓的霓虹灯光，为你的空间增添一丝未来都市的颓废气息。", "100, 10, 50, 20, 一个带有金属光泽的吧台，边缘和台面下都嵌满了霓虹灯管，上面随意放着几个高脚杯。"],
    ["懒人精灵豆袋沙发", 1500, "家具", {}, "极致舒适。躺在上面休息时，体力恢复速度提升20%。由精灵用月光下的棉花和安神草编织而成。", "100, 40, 25, 15, 一个巨大的、看起来就非常柔软的豆袋沙发，布料是淡绿色的，上面有银色的叶脉纹路。"],
    ["蒸汽动力自走书架", 32000, "家具", {}, "可以通过语音指令或终端控制，让书架自动找到并送来你想要的任何一本（已收藏的）书籍。自带防尘和恒温恒湿功能。", "10, 80, 60, 50, 一个由黄铜和红木制成的巨大书架，底部有复杂的齿轮和履带结构，几根蒸汽管道从顶部延伸出来，不时冒出白气。"],
    ["血肉滋生之座", 220000, "家具", {}, "一个活体家具。坐上去时，它会缓慢地与使用者建立精神链接，大幅加快生命力和精神力的恢复速度（每分钟恢复1%）。但长时间使用可能会让人的思维方式产生异变。", "160, 10, 30, 30, 一张看起来像是某种生物组织的椅子，呈现出深红色，表面有血管一样的纹路在搏动，整体轮廓在不停地进行着微小的蠕动和重塑。"],
    ["阴阳双鱼池", 75000, "家具", {}, "一个太极形状的水池，里面养着一黑一白两条灵鲤。每日可进行一次投喂，根据灵鲤的反应，可能会获得‘好运’或‘霉运’的临时状态。", "130, 50, 40, 40, 由黑白两色的玉石砌成的水池，池水清澈见底，两条鲤鱼在其中追逐嬉戏，构成了一副流动的太极图。"],
    ["全息战术沙盘", 98000, "家具", {}, "可以导入任务世界的地图数据，进行三维全息模拟，推演战术。盟友也可以被邀请进入空间共同使用。", "80, 70, 40, 40, 一个方形的金属平台，启动后会在上方投射出高精度的三维地形图，可以用手势进行缩放、旋转和标记。"],
    ["龙骨王座", 500000, "家具", {}, "由一头成年红龙的头骨和脊椎制成。坐上王座时，会自然散发出龙威，对龙类及亚龙生物有威慑效果，在与其实力相近的生物交涉时，气势上获得优势。", "200, 10, 40, 60, 一张充满了原始与力量美感的巨大座椅，头骨构成了椅背，狰狞的龙角向上延伸，扶手是粗壮的腿骨，整体呈现出骨白色和暗红色。"],
    ["失落神庙的祭坛", 880000, "家具", {}, "一个古老而残破的石制祭坛。每周可以将一件物品作为祭品献上，有一定几率将其强化，也有很大几率使其损毁，极小几率发生意想不到的奇迹蜕变。", "250, 20, 50, 30, 由巨大的青石堆砌而成，上面布满了青苔和意义不明的古老雕刻，祭坛中心有一个凹陷的血槽。"],
    ["厨神的小铺", 4000, "家具", {}, "一个简单的日式拉面摊位。虽然不能制作出什么神奇料理，但坐在这里吃一碗热气腾腾的面，可以驱散大部分负面精神状态（如：沮丧，恐惧）。", "180, 80, 30, 25, 一个小小的木制摊位，挂着写有‘ラーメン’的布帘，后面有简单的灶台和几个座位。"],
    ["寂静森林的一角", 6000, "家具", {}, "一片小小的林地，有几棵高大的树和柔软的草坪。在其中冥想时，心境会变得格外平和。纯观赏和放松用。", "220, 80, 50, 50, 这片区域的地面变成了真实的泥土和草地，几棵白桦树安静地伫立着，阳光会恰到好处地从枝叶间洒落。"],
    ["反重力睡眠舱", 38000, "家具", {}, "进入睡眠舱后，会处于微重力状态，让身体得到最彻底的放松。睡眠8小时等同于普通睡眠12小时的效果，且醒来后精神饱满。", "310, 10, 20, 40, 一个充满科幻感的白色金属舱，外形流畅，舱门是透明的，可以看到内部柔软的衬垫。工作时会悬浮在离地半米的高度。"],
    ["时空旅者的留声机", 110000, "家具", {}, "一台维多利亚风格的黄铜留声机。它没有唱片，但每天可以随机播放一段来自其他时间线或异世界的音乐、对话或声音片段。可能会听到有用的情报，也可能只是噪音。", "340, 20, 15, 20, 精致而古典的留声机，大喇叭闪耀着金属光泽，机身上有许多看不懂的刻度和表盘。"],
    ["剑冢", 190000, "家具", {}, "将自己的兵器插入其中蕴养，可以缓慢提升兵器的品质，并有极小几率让兵器诞生‘器灵’。一次只能蕴养一件兵器。", "310, 70, 30, 30, 一座由无数断剑残兵堆积而成的小丘，中心有一块黑色的巨大磨剑石，散发着凌厉的剑意。"],
    ["‘家’的投影", 1000, "家具", {}, "一个简单的相框。使用者可以将自己心中最想念的家的影像投射其中，影像会动态变化，仿佛时间在流动。无任何实际增益，纯粹的情感慰藉。", "360, 20, 10, 8, 一个朴素的木质相框，没有照片，只有一片柔和的白光，使用者触碰时，白光会变为其思念的场景。"],
    ["神圣光明教堂的告解室", 55000, "家具", {}, "一个隔音效果极好的小房间。在其中进行忏悔或倾诉，可以显著缓解内心的负罪感和压力，并获得一个名为‘心灵净化’的临时状态，豁免一次精神控制类技能。", "380, 10, 30, 40, 一个由深色木材打造的独立小隔间，内部有一张跪凳和一道带有格栅的隔窗。充满了庄严肃穆的氛围。"],
    ["混沌几何雕塑", 130000, "家具", {}, "一个由不断变化的几何体组成的、违反物理规则的动态雕塑。直视它会导致轻微的眩晕，但也能锻炼精神抵抗混乱信息的能力。", "420, 20, 20, 20, 它看起来像一团由黄铜线条构成的、不断在四维空间翻转的立方体，时而展开时而收缩，没有固定的形态。"],
    ["虚空垂钓台", 280000, "家具", {}, "一个延伸至空间边缘之外的平台。使用者可以在此垂钓，钓上来的可能是来自无尽虚空的稀有材料、漂流的灵魂瓶、甚至是某个世界的‘概念’碎片。", "450, 10, 20, 15, 一个由未知黑色岩石构成的平台，末端消失在空间的边界，仿佛融入了虚无之中。需要特制的‘虚空鱼竿’配合使用（商城另购）。"],
    ["万界之窗", 999990, "家具", {}, "一扇巨大的落地窗。每天，窗外的景色都会随机变为一个异世界的实时风景，可能是巨龙飞舞的奇幻山巅，也可能是霓虹闪烁的赛博都市。使用者无法穿过窗户，但可以感受那个世界的气息。", "500, 10, 80, 60, 一扇华丽的、镶嵌着宝石和符文的拱形窗户，窗外是流光溢彩的动态景象，而非固定的空间背景。"],
    ["时间沙漏", 420000, "家具", {}, "一个巨大的沙漏。可以消耗大量积分来将整个个人空间的时间流速进行微调（最高减缓至0.8倍，或加速至1.2倍）。调整会持续24小时。", "600, 20, 25, 40, 沙漏的框架由白金打造，里面的沙子是璀璨的钻石尘埃，流动时散发出柔和的光芒。"],
    ["起源熔炉", 2500000, "家具", {}, "传说中能锻造神器的熔炉的复制品。拥有极高的成功率，可以将多件传奇物品与稀有材料融合，创造出独一无二的、全新的物品。每次使用都需要消耗巨量积分作为能源。", "10, 150, 80, 70, 一座如同小型火山般的巨大熔炉，由暗红色的金属构成，上面刻满了原始而古老的火焰图腾，即使不点火也散发着惊人的热量。"],
    ["棋圣的棋盘", 70000, "家具", {}, "一张古朴的围棋棋盘。可以召唤一个名为‘棋圣’的AI进行对弈。每赢一局，精神力都会获得永久性的微量增长。被AI击败则会陷入1小时的思维混乱状态。", "100, 160, 20, 20, 一张由整块香樟木雕成的棋盘，棋子是温润的黑白玉石，自带一种让人心平气和的气场。"],
    ["无限书库的终端", 650000, "家具", {}, "一个数据终端，可以连接到传说中的‘无限书库’。使用者可以消耗积分查阅几乎所有非神明级别的知识和信息，价格取决于信息的珍稀程度。", "130, 150, 15, 25, 一个流线型的、悬浮在空中的操作台，屏幕是淡蓝色的光幕，上面有无数数据流在闪动。"],
    ["妖精的茶会桌", 18000, "家具", {}, "一套精致小巧的桌椅。每天下午三点，桌上会自动出现一套美味的下午茶点心和红茶，食用后心情会变得愉悦。可以邀请朋友共享。", "160, 160, 30, 20, 由开花的藤蔓自然缠绕而成的桌椅，桌面上铺着巨大的荷叶，杯子和盘子则是五颜六色的蘑菇。"],
    ["死灵法师的骸骨仆役制造台", 88000, "家具", {}, "可以在此消耗生物遗骸和灵魂碎片，制造出低阶的骸骨仆役（如骷髅兵、骸骨猎犬）。仆役只能在个人空间内活动，作为守卫或劳力。", "200, 150, 40, 40, 一张由人类、野兽等不同生物的骨骼拼接而成的巨大石台，台面上有许多凹槽和管线，连接着几个装有绿色液体的玻璃罐。"],
    ["禅意的枯山水庭院", 9000, "家具", {}, "一片铺着白砂、点缀着几块奇石的日式庭院。每日可进行一次“耙砂”，这个过程能帮助整理思绪，消除精神上的疲劳。", "250, 150, 50, 50, 地面变为一片洁白的砂砾，几块形态各异的青黑色岩石错落有致地摆放着，旁边还放着一把小小的木耙。"],
    ["机械师的改装工坊", 160000, "家具", {}, "一个堆满了零件、工具和设计图的角落。可以在此升级、改装机械类装备和义体。提供成功率加成，并解锁一些独特的改造选项。", "310, 150, 60, 60, 这里有全套的激光焊枪、机械臂、3D打印机和各种精密工具，墙上挂满了设计蓝图，地上随意堆放着一些金属零件和废弃的义体。"],
    ["怪奇收藏家的陈列柜", 30000, "家具", {}, "一个玻璃陈列柜，里面已经摆放了几件无害但怪异的藏品（如：会自己换姿势的木偶，装在瓶子里的微缩风暴）。使用者也可以将自己的战利品放入其中展示。", "380, 150, 30, 50, 一个维多利亚风格的红木陈列柜，玻璃擦得锃亮，里面的藏品被柔和的灯光照亮，充满了神秘感。"],
    ["记忆回廊", 350000, "家具", {}, "一条由光影构成的走廊。使用者可以将自己的记忆片段储存在其中，并在走廊中以第一人称视角重温。可用于复盘战斗、学习技能或仅仅是怀旧。", "420, 150, 20, 80, 这条走廊的墙壁和天花板都是流动的光幕，上面会浮现出使用者储存的记忆影像，走入其中仿佛穿梭于时光之中。"],
    ["炼金术士的秘密实验室", 125000, "家具", {}, "一套完整的炼金实验设备，包括蒸馏器、坩埚、试管和复杂的玻璃管道。可以在此进行基础药剂的合成，成功率高于自行摸索。", "10, 240, 50, 50, 一个被各种玻璃器皿和冒着气泡的药剂占据的区域，空气中弥漫着草药和化学试剂混合的味道。"],
    ["吟游诗人的篝火", 8000, "家具", {}, "一堆永不熄灭的篝火。坐在篝火旁，会感到温暖和安心。如果此时演奏乐器或讲述故事，效果会得到增强，更容易打动听众（即使是NPC）。", "70, 250, 20, 15, 一圈由石头垒起的火塘，中间燃烧着橙红色的火焰，不时有火星跳跃出来，发出噼啪的轻响。"],
    ["画中仙的卷轴", 210000, "家具", {}, "一幅巨大的空白山水画卷轴，挂在墙上。使用者可以消耗精神力将想象中的场景绘制上去，画卷会变为动态，甚至可以短暂地进入画中世界（不能带出任何东西）。", "100, 220, 1, 60, 这幅画几乎占据了一整面墙，画纸是上好的宣纸，两端的画轴由紫檀木制成，整体散发着墨香。它的坐标代表挂在墙上的位置。"],
    ["深海遗迹的珊瑚床", 60000, "家具", {}, "一张由活体发光珊瑚构成的床。在上面睡觉时会进入深海般的梦境，有助于安抚狂躁的精神状态，并缓慢修复受损的灵魂。", "120, 230, 30, 20, 整张床就像是从海底搬上来的艺术品，五彩斑斓的珊瑚构成了床的框架，柔软的海葵组成了床垫，散发着柔和的蓝绿色荧光。"],
    ["刺客盟约的暗影帷幕", 48000, "家具", {}, "一片可以随意悬挂的黑色帷幕。躲在帷幕后面时，自身的气息会被完全隐藏，是练习潜行和隐匿技能的绝佳道具。", "160, 220, 40, 60, 一块看起来平平无奇的黑布，但当你触摸它时，会感到一种冰冷的、仿佛能吞噬光线的质感。它可以覆盖一片区域，形成绝对的黑暗。"],
    ["牧场主的迷你农场", 9500, "家具", {}, "一小块可以耕种的土地，附赠几包随机的异界植物种子。种出的植物可能是美味的食材，也可能是炼金材料，甚至是有微弱攻击性的小怪物。", "210, 220, 40, 40, 一块用栅栏围起来的肥沃黑土地，旁边有一个小小的工具棚，里面放着水壶、锄头等工具。"],
    ["命运纺织者的织机", 750000, "家具", {}, "一台古老的织机。使用者可以将从任务世界中获得的‘命运之线’（稀有材料）在此编织。成品可能是能豁免一次致命攻击的护符，也可能是能预知一次危险的披风。", "260, 220, 30, 40, 织机由银色的木材制成，上面缠绕着无数若有若无的光线，仿佛连接着万物的命运。操作它需要极高的专注力。"],
    ["赌神的桌台", 20000, "家具", {}, "一张绿色的赌桌。可以邀请朋友或召唤AI进行各种扑克牌游戏。纯娱乐，但据说运气好的人能从桌上赢到一些被称为‘幸运筹码’的道具。", "300, 220, 25, 20, 一张标准的德州扑克桌，桌面是高级的绿色绒布，边缘有舒适的皮质扶手，旁边还配了几张椅子。"],
    ["冰霜巨人的酒杯", 15000, "家具", {}, "一个由万年寒冰雕成的巨大酒杯。用它来喝任何液体，都会变得冰爽刺骨，并获得一个‘冰心’状态，短时间内对火焰伤害有微弱抗性。", "335, 230, 10, 12, 一个半人高的巨大杯子，杯壁上凝结着白霜，即使在温暖的空间里也散发着寒气。"],
    ["美食家的移动厨房", 28000, "家具", {}, "一个功能齐全的现代化厨房岛台，从分子料理工具到中式炒锅一应俱全。在这里处理食材和烹饪，能更好地发挥食材的效果，制作出高级料理。", "355, 220, 40, 30, 不锈钢的台面，内嵌了电磁炉、烤箱、水槽，上方还有抽油烟机和挂满厨具的架子。"],
    ["图书馆管理员的摇椅", 4500, "家具", {}, "一张舒适的老式木摇椅。坐在这张椅子上阅读书籍，理解速度和记忆力会得到微弱提升。", "405, 230, 15, 20, 一张深棕色的木质摇椅，扶手和椅背已经被磨得光滑发亮，坐上去会发出有节奏的吱呀声。"],
    ["伊甸园的苹果树", 1200000, "家具", {}, "传说中那棵树的一根分枝培育而成。每隔一个月会结出一颗‘智慧之果’，食用后永久提升一点随机属性。但食用第一颗果实后，会获得一个永久的‘被驱逐者’状态，进入某些神圣区域会受到压制。", "430, 220, 30, 50, 一棵流光溢彩的小树，树叶是半透明的，树上结着一颗散发着诱人光芒的苹果。"],
    ["泰坦的训练假人", 99000, "家具", {}, "一个由超合金制成的、几乎坚不可摧的训练假人。它能记录你的攻击数据（伤害、速度、精准度），并提供分析报告。是测试新技能和武器的完美对象。", "470, 220, 20, 30, 一个呈现出暗金色金属光泽的人形靶子，身上布满了各种感应器和刻线，看起来异常坚固。"],
    ["虚空之声的风铃", 33000, "家具", {}, "一串由奇异晶体组成的风铃。它不会随风摆动，而是当空间中出现异常波动或有访客到来时，会发出悦耳又空灵的声音作为预警。", "500, 220, 10, 20, 几根长短不一的紫色半透明晶体，由一根看不见的细线悬挂着，静止时没有任何声音。"],
    ["最终王座", 10000000, "家具", {}, "一张无法用语言描述其材质和形态的王座。它似乎是由纯粹的‘概念’和‘规则’构成。坐上它的人，将获得对整个个人空间的绝对掌控权，可以随意修改空间的大小、环境、物理法则，并获得一个独一无二的称号‘一界之主’。", "550, 150, 100, 100, 它时而是由星辰铸就，时而是由深渊凝聚，时而又是纯粹的光。任何看到它的人都会有不同的理解。它就是权力和终点的象征。"],
["清洁术", 100, "技能", {}, "【dp+1;能量池-10】", "清洁目标身上的污渍,虽然没有战斗力，但在某些时候能派上大用场。"],
["火球术", 2000, "技能", {}, "【dp+1;能量池-10】", "释放火球攻击敌人,初级火系法术，可以发射威力不俗的火球。"],
["侦测陷阱", 1500, "技能", {}, "【dp+1;能量池-10】", "感知附近的机关陷阱,对于探索古墓或地城非常重要的辅助技能。"],
["振奋怒吼", 2800, "技能", {}, "【dp+1;能量池-10】", "发出吼声，提升周围友军的士气和攻击力,战士的辅助技能，在团队作战中效果显著。"],
["傀儡操控术（初级）", 5500, "技能", {}, "【dp+1;能量池-10】", "操控一具无生命的人偶进行简单的动作,需要配合傀儡使用，是傀儡师的基础。"],
["随身小剧场", 8000, "技能", {}, "【dp+1;能量池-30】", "在自身周围半径三米内生成一个持续五分钟的微型音画幻境，幻境内容可自行设定。虽然没有直接战斗力，但无论是自娱自乐、迷惑敌人还是营造气氛，都有奇效。"],
["美食的俘虏", 6500, "技能", {}, "【dp+1;能量池-20】", "制作出的任何食物都将附带强烈的魅惑效果，让品尝者在短时间内对制作者产生高度好感与信赖。警告：对意志力强大者效果减弱。"],
["绝对音准（伪）", 4000, "技能", {}, "【dp+1;能量池-5】", "能够完美模仿听到的任何声音，包括人物嗓音、动物叫声甚至是机械运作声。但无法模仿超出人类发声器官极限的声音。"],
["一键换装", 3500, "技能", {}, "【dp+1;能量池-10】", "瞬间更换身上穿着的衣物，衣物款式需要在技能发动前预设好。对于需要快速切换身份或应对不同场合非常实用。"],
["植物密语", 7200, "技能", {D:1}, "【dp+1;能量池-15】", "能够与植物进行简单的精神交流，了解它们的状态和周边环境信息。是优秀的侦察与情报搜集手段。"],
["万能钥匙（概念）", 12000, "技能", {C:1}, "【dp+2;能量池-50】", "消耗能量，可以开启任何非魔法或非规则层面上锁的锁具。此技能开启的是‘锁’这一概念。"],
["动物亲和（猫科限定）", 4800, "技能", {}, "【dp+1;能量池-10】", "大幅提升所有猫科动物对你的好感度，它们会视你为同类和伙伴。也许能从街角的猫咪那里打听到一些秘密。"],
["存在感稀薄化", 9000, "技能", {C:1}, "【dp+1;能量池-25/分钟】", "降低自身在他人感知中的存在感，变得容易被忽视，但并非真正的隐身。在人群中行动的绝佳技能。"],
["情绪调色盘", 8800, "技能", {D:1}, "【dp+1;能量池-30】", "短暂影响目标的某种情绪，可以放大或减弱其喜悦、悲伤或愤怒。对心志坚定者效果有限，且容易被察觉。"],
["无中生友", 5000, "技能", {}, "【dp+1;能量池-20】", "凭空捏造一个不存在的“朋友”的身份信息，并让周围的人在短时间内相信这个“朋友”确实存在。用于制造不在场证明或虚构情报来源。"],
["重力微操", 15000, "技能", {C:1}, "【dp+2;能量池-40】", "小范围内精确操控重力，可以使物体变轻或变重，或者改变一次跳跃的轨迹。高手甚至能用它让敌人的步伐踉跄。"],
["影子行囊", 11000, "技能", {D:2}, "【dp+1;能量池-5，与储存物质量有关】", "将自己的影子变成一个异次元储物空间，可以存放非生命物体。空间大小与技能熟练度相关。"],
["弹道修正", 9500, "技能", {}, "【dp+1;能量池-15/次】", "在使用投掷或射击武器时，可以对弹道进行一次小幅度的修正，提升命中率。对狙击手和飞刀手来说是神技。"],
["痛觉转移", 13000, "技能", {C:1}, "【dp+1;能量池-60】", "将自己受到的下一次伤害所产生的痛觉，转移到指定目标身上。伤害本身无法转移，但剧烈的痛楚足以让任何敌人行动迟缓。"],
["墨汁结界", 8200, "技能", {}, "【dp+1;能量池-35】", "以自身为中心制造一片浓郁的墨色区域，剥夺区域内所有人的视觉。使用者自身不受影响。"],
["回声定位", 7800, "技能", {}, "【dp+1;能量池-10】", "通过发出特定频率的声音并分析其回声，精确感知周围环境的立体结构与物体位置，是黑暗环境中的眼睛。"],
["嗜血渴望", 16000, "技能", {C:2}, "【dp+1;能量池-50】", "主动技，发动后攻击会附带吸血效果，将造成伤害的一部分转化为自身生命力。但会轻微影响心智，增加攻击性。"],
["第三只眼", 20000, "技能", {B:1}, "【dp+2;能量池-100】", "在额头开启一只能量构成的眼睛，可以看破低阶幻术、伪装，并侦测到隐藏的能量流动。持续消耗能量。"],
["钢铁意志", 10000, "技能", {}, "【dp+1】", "被动技能，大幅提升对精神控制、魅惑、恐惧等效果的抵抗力。你的思想是你最坚固的堡垒。"],
["战术语言", 6800, "技能", {}, "【dp+1;能量池-5】", "能够使用一套极其简洁高效的语言（手势或短语）与队友进行无声交流，传递复杂的战术意图。"],
["蛛丝发射", 8500, "技能", {D:1}, "【dp+1;能量池-15】", "从指尖发射出坚韧的蛛丝，可用于攀爬、束缚敌人或制作简易陷阱。"],
["动力跳跃", 7000, "技能", {}, "【dp+1;能量池-20】", "瞬间在脚下积蓄能量并爆发，进行一次超乎寻常的高跳或远跳。"],
["能量盾构", 12500, "技能", {D:2}, "【dp+1;能量池-40】", "在身前凝聚一面能量盾牌，可以抵挡一次中等强度的物理或能量攻击。盾牌破碎后有冷却时间。"],
["连锁闪电（弱化版）", 18000, "技能", {C:1}, "【dp+1;能量池-70】", "释放一道能在多个敌人之间跳跃的闪电，每次跳跃威力递减。对于清理杂兵有奇效。"],
["再生之触", 22000, "技能", {B:1}, "【dp+1;能量池-120】", "将手掌覆盖在伤口上，消耗大量能量加速细胞再生，治愈非致命性伤口。无法断肢再生。"],
["危机预感", 17000, "技能", {C:1}, "【dp+1】", "被动技能，对即将到来的危险有模糊的直觉性预警。无法指明危险来源，但足以让人提前警惕。"],
["武器共鸣", 14000, "技能", {D:2}, "【dp+1;能量池-30】", "与一把常用武器建立精神链接，使用时更加得心应手，并能发挥出武器的潜在威力，小幅提升攻击力。"],
["爆破艺术", 11500, "技能", {}, "【dp+1;能量池-25】", "精通各类炸药的制作与使用，能够精确计算爆炸范围和威力，布置出艺术品般的连环爆炸。"],
["镜面反射", 25000, "技能", {B:1}, "【dp+2;能量池-150】", "制造一个短暂的能量镜面，可以将下一次指向你的飞行道具或能量攻击原路反弹。需要极佳的反应速度。"],
["心灵屏障", 19000, "技能", {C:2}, "【dp+1;能量池-80】", "建立一个强大的心灵防护罩，免疫一次针对性的读心或心灵探查。是一次性的消耗品，使用后需长时间冷却。"],
["主角光环（伪）", 30000, "技能", {A:1}, "【dp+1】", "被动技能，在遭遇必死局面时，有极小概率（1%）触发都合主义事件，从而化险为夷。例如，敌人枪械卡壳，脚下突然出现香蕉皮等。"],
["平地摔达人", 2500, "技能", {}, "【dp-1】", "被动技能，走路时有一定概率无视地形平坦度直接摔倒。但摔倒时有更高概率以一种滑稽而无伤的方式落地，有时甚至能意外躲开攻击。"],
["反向导航", 3000, "技能", {}, "【dp+1;能量池-5】", "当你试图前往某个目的地时，脑中会出现一个绝对错误的方向指引。只要反着它的指示走，就一定能找到正确的路。"],
["死亡BGM", 8000, "技能", {}, "【dp+1;能量池-20】", "可以为指定目标（包括自己）配上一段背景音乐，音乐风格可选。在关键时刻放出激昂的音乐能振奋人心，放出滑稽的音乐则能摧毁敌人的气势。"],
["强行解说", 6000, "技能", {}, "【dp+1;能量池-15】", "强制让一个目标的内心想法以弹幕或旁白的形式出现在周围人的脑海里，持续三十秒。暴露秘密和制造尴尬的利器。"],
["钞能力（体验版）", 10000, "技能", {D:1}, "【dp+1;能量池-100】", "每天一次，可以凭空变出一笔仅限当天使用的、数额不大的当地货币。钱是真的，但第二天会消失。"],
["降智光环", 15000, "技能", {C:1}, "【dp+1;能量池-50】", "以自身为中心释放一个光环，范围内的所有人（包括自己）的逻辑思维能力会暂时性降低。适合在需要浑水摸鱼时使用。"],
["第四面墙的凝视", 28000, "技能", {B:1}, "【dp+2;能量池-90】", "可以短暂地看到关于目标人物的“设定”，例如他们的弱点、技能列表或背景故事梗概。信息模糊且片面，但足以提供关键情报。"],
["暂停学外语", 7500, "技能", {}, "【dp+1;能量池-20】", "在观看外语影像或听到外语对话时，可以在脑内生成完美的同声传译和字幕。学习新语言从未如此简单。"],
["量子化猫咪", 9999, "技能", {}, "【dp+1;能量池-30】", "你可以随时召唤一只薛定谔的猫。这只猫处于存在与不存在的叠加态，只有在你主动观察它时才会坍缩为一只真实的、品种随机的可爱猫咪。它只会陪伴你五分钟，然后重新回归量子海洋。"],
["契约之书", 35000, "技能", {B:2}, "【dp+2;能量池-200】", "具现化一本契约书，与他人签订的任何承诺只要写入书中，双方都将受到规则层面的强制约束。违约者会受到与承诺价值对等的惩罚。"],
["故事线的锚点", 45000, "技能", {A:1}, "【dp+2;能量池-500】", "选定一个物体或地点作为“存档点”。每天一次，使用者可以在死亡或任务失败时，将自身状态（不包括记忆）回溯到设置锚点的那一刻。巨大的消耗让它几乎无法被频繁使用。"],
["逻辑炸弹", 38000, "技能", {B:1}, "【dp+1;能量池-180】", "向一个智能体（AI，魔像，部分神智清晰的生物）提出一个无法解答的逻辑悖论。目标会陷入永久性的逻辑循环，直至思维崩溃。"],
["概念窃取（碎片）", 50000, "技能", {A:1, C:2}, "【dp+2;能量池-300】", "对一个目标使用，随机窃取其拥有的一个“概念”的极小一部分，例如“锋利”、“速度”或“幸运”。你可以短暂地将这个概念碎片附加在自己或物品上。效果微弱且不稳定。"],
["谎言成真（微弱）", 42000, "技能", {B:2}, "【dp+1;能量池-250】", "说出一个简单的、无伤大雅的谎言（例如“我口袋里有一块糖”），并消耗能量使其在小范围内短暂成为事实。谎言越偏离现实，消耗越大，成功率越低。"],
["时间减速（主观）", 32000, "技能", {C:2}, "【dp+2;能量池-150/秒】", "大幅提升自己的思维速度和神经反应，使得外界在你的感知中变得极其缓慢。身体速度不变，但为你赢得了宝贵的思考和反应时间。"],
["因果线之触", 60000, "技能", {A:2}, "【dp+3;能量池-1000】", "触摸一个物体或人物，可以模糊地感知到一条与其紧密相关的、在不久的将来会发生的“因果线”。看到的未来片段极其破碎，极难解读。"],
["名字的支配（初阶）", 55000, "技能", {A:1, B:1}, "【dp+2;能量池-400】", "得知一个存在的“真名”后，可以通过呼唤其真名，对其下达一个无法被直接抵抗的简单命令（例如“停下”）。对越强大的存在效果越弱。"],
["边界跨越", 70000, "技能", {S:1}, "【dp+3;能量池-800】", "选择一个“边界”，例如门与门框的边界、影子与光明的边界，并进行一次短距离的空间穿梭，从边界的一侧直接出现在另一侧。距离和可穿越的边界类型受限于技能等级。"],
["万物终结之声", 99999, "技能", {S:1, A:2}, "【dp+2;能量池-2000】", "发出一种针对“存在”本身的声音，所有听到此声音的非永恒造物都会加速走向其“终结”。生命会迅速衰老，物品会快速腐朽风化。作用范围极小，消耗巨大，且对使用者自身也有反噬风险。"],
          ["初代人造人类", 6000, "血统", {D:1}, `
        属性: 力量+1, 敏捷+1, 感知+1, 耐力+1
        能量池: 电力(30)
    `, `
    - 钢铁身躯: 依然保持人类的外形, 是仿生科技至高技术的结晶。不需要食物、水、睡眠就可以生存。
    - 完美人机改造: 人造人的身体本身就由机械和肉体构成, 能够和D级科技本质的所有改造完美契合。
    古时候创造人类被视为只有神才能够作到的事, 触犯到神的领域便会带来难以想象的后果。这是人类挑战禁忌的最初产物, 是仿生科技的结晶。`],

    ["第二代人造人类", 14000, "血统", {C:1}, `
        属性: 力量+2, 敏捷+2, 感知+2, 耐力+2
        能量池: 电力(40)
    `, `
    - 提升特性-钢铁身躯: 肉搏攻击能够造成严重伤害。
    - 完美人机改造: 人造人的身体本身就由机械和肉体构成, 能够和C级科技本质的所有改造完美契合。
    在初代的基础上, 新一代的人造人被赋予了更强大的战斗能力和适应性, 机械与肉体的结合更加紧密。`],

    ["第三代人造人类", 20000, "血统", {B:1}, `
        属性: 力量+3, 敏捷+3, 感知+2, 耐力+3
        能量池: 电力(50)
    `, `
    - 宇宙生存: 人造人可以在宇宙生存。
    - 完美人机改造: 人造人的身体本身就由机械和肉体构成, 能够和B级科技本质的所有改造完美契合, B级科技本质改造所提供的内在加值可以和血统提供的内在加值叠加而非取高, 并且该属性加值可以叠加在义体上。
    技术的飞跃突破了能源的桎梏, 甚至打破了星球的束缚，成为了一个近乎永恒的生命体。`],

    ["超级人造人类", 32000, "血统", {A:1}, `
        属性: 力量+4, 敏捷+4, 感知+4, 耐力+4
        能量池: 电力(60)
    `, `
    - 宇宙生存: 人造人可以在宇宙生存。
    - 完美人机改造: 人造人的身体本身就由机械和肉体构成, 能够和A级和S级科技本质的所有改造完美契合。
    - 能量吸收装置: 安装了吸收能量的装置, 可以吸收来自对手的能量转化为自己的能量。
    这已不仅仅是模仿生命, 而是超越生命。通过吸收对手的能量, 成为了一个能够在战斗中不断变强的存在, 是科技所能达到的巅峰造物之一。`],
 ["蜘蛛侠强化", 15000, "血统", {B:1}, `
        属性: 力量+1, 敏捷+4, 感知+4, 耐力+2
        能量池: 生物能量(50)
    `, `
    - 蜘蛛敏锐: 蜘蛛侠的平衡器官大幅度增强，获得敏感范围内的颤动感知。
    - 蜘蛛运动: 蜘蛛侠获得蛛行术，如蜘蛛一般在垂直表面上攀爬移动，甚至天花板上也可以。在这种情况下，蜘蛛侠必须腾出双手来爬行。
    - 蛛丝: 蜘蛛侠可从手腕处射出蛛丝。蛛丝可如捕网一般进行纠缠攻击。
    源自一次意外的基因突变，将人类与蜘蛛的优点完美结合，获得了超越常人的感官与运动能力。这种力量也伴随着巨大的责任。`],
       ["D信使", 5000, "血统", {D:1}, `
        属性: 敏捷+2, 耐力+2
        能量池: 动能(0)
    `, `
    - 专注护盾: 通过持续高速移动，可以在体表形成一层临时的能量护盾来抵御攻击。这层护盾在不主动发起攻击的回合中会保持生效，提供额外的防护。
    - 信使体质: 拥有与众不同的战斗方式，能够以超凡的敏捷和协调性主导近身格斗，动作迅猛而非单纯依靠蛮力。
    - 自由奔跑: 掌握了出神入化的跑酷技巧，能够在墙壁、管道甚至天花板上自由移动，仿佛摆脱了重力的束缚。其跳跃能力也得到极大增强，能轻松越过常人无法企及的障碍。
    - 信仰限定: 信奉绝对的、不受约束的自由，这种信念是力量的根基，但也因此无法接纳和使用任何其他形式的信仰类能力。
    受到自由精神的感召，成为了一名初出茅庐的信使。虽然经验尚浅，但已掌握了在都市丛林中穿梭的核心技巧。`],

    ["C信使", 8000, "血统", {C:1}, `
        属性: 敏捷+3, 耐力+3
        能量池: 动能(0)
    `, `
    - 专注护盾+: 专注护盾的效果得到强化。在高速移动中，敌人极难锁定其位置，无论是实体攻击还是远程射击都容易被偏转或擦身而过。同时，更擅长在移动中进行格挡招架。
    - 穿越攻击: 学会了如何将冲刺的巨大动能瞬间转化为强大的攻击力。在全力奔跑后发动的攻击极具冲击力，但代价是攻击的瞬间，自身的防御会变得相对脆弱。
    - 信使体质: 能够以超凡的敏捷和协调性主导近身格斗，动作迅猛而非单纯依靠蛮力。
    - 自由奔跑: 掌握了出神入化的跑酷技巧，能够在墙壁、管道甚至天花板上自由移动，仿佛摆脱了重力的束缚。其跳跃能力也得到极大增强，能轻松越过常人无法企及的障碍。
    - 信仰限定: 信奉绝对的、不受约束的自由，这种信念是力量的根基，但也因此无法接纳和使用任何其他形式的信仰类能力。
    已经是一名合格的信使，秘密运输任务的常客。跑酷技巧更加娴熟，战斗方式也变得更加致命和高效。`],

    ["B信使", 12000, "血统", {B:1}, `
        属性: 敏捷+4, 耐力+4
        能量池: 动能(0)
    `, `
    - 专注护盾++: 专注力达到巅峰，在移动时，周围的世界在其感知中会变得缓慢。现在，任何移动都能激活强大的专注护盾，并且可以在护盾的保护下毫无顾忌地进行攻击。
    - 强力穿越攻击: 穿越攻击的技巧已臻化境，发动冲刺攻击时不再会暴露防御上的弱点，可以毫无顾忌地将速度完全转化为破坏力。
    - 信使体质（提升）: 身体的协调性与反应能力达到新高度，防御能力不再依赖传统护具，而是完全取决于自身的敏捷或感知。近身格斗时，力量的限制被彻底打破，可以淋漓尽致地发挥敏捷的优势。
    - 自由奔跑: 掌握了出神入化的跑酷技巧，能够在墙壁、管道甚至天花板上自由移动，仿佛摆脱了重力的束缚。其跳跃能力也得到极大增强，能轻松越过常人无法企及的障碍。
    - 信仰限定: 信奉绝对的、不受约束的自由，这种信念是力量的根基，但也因此无法接纳和使用任何其他形式的信仰类能力。
    身为组织内的精英信使，行动能力已达化境。其身体的反应速度本身就是最好的防御，是各大组织执行高难度任务时的第一人选。`],

    ["A信使", 18000, "血统", {A:1}, `
        属性: 敏捷+6, 耐力+6
        能量池: 动能(0)
    `, `
    - 信使体质（究极）: 身体素质达到人类潜能的极限，耐力与敏捷相辅相成，使得敏捷属性获得了根本性的强化，肉搏攻击的威力也随之大幅提升。专注护盾已成为一种常驻状态，只要处于移动之中，最顶级的防护护盾就会持续生效。
    - 强力穿越攻击: 穿越攻击的技巧已臻化境，发动冲刺攻击时不再会暴露防御上的弱点，可以毫无顾忌地将速度完全转化为破坏力。
    - 自由奔跑: 掌握了出神入化的跑酷技巧，能够在墙壁、管道甚至天花板上自由移动，仿佛摆脱了重力的束缚。其跳跃能力也得到极大增强，能轻松越过常人无法企及的障碍。
    - 信仰限定: 信奉绝对的、不受约束的自由，这种信念是力量的根基，但也因此无法接纳和使用任何其他形式的信仰类能力。
    已是信使中的传奇与王牌，是自由精神的化身。其存在本身就意味着任务的绝对成功，是最强大的追捕者也无法触及的幻影。`],

    ["D天然道士", 6000, "血统", {D:1}, `
        属性: 力量+1, 敏捷+1, 耐力+1, 感知+1, 决心+2
        能量池: 灵力(40)
    `, `
    - 仙风道骨: 天生拥有仙人骨，虽未曾修炼道法，但肉体凡胎已被仙气潜移默化地滋养。拥有超乎常人的坚韧体质，极难被轻易击倒。其移动速度和身体的天然防御能力，会随着自身的成长而同步增强。`],

    ["C天然道士", 14000, "血统", {C:1}, `
        属性: 敏捷+1, 耐力+1, 感知+3, 决心+3
        能量池: 灵力(50)
    `, `
    - 仙风道骨（提升）: 仙气进一步强化肉体，赋予了快速自愈的体质，并且所有自然恢复的速度都得到加倍。对凡俗的需求大幅降低，不再需要食物、水或空气，只需每日短暂的睡眠，便可从天地自然间汲取所需能量以维持生命活动。体质坚韧，移动和防御能力随成长而增强。`],

    ["B天然道士", 22000, "血统", {B:1}, `
        属性: 力量+1, 敏捷+1, 耐力+1, 感知+4, 决心+4
        能量池: 灵力(60)
    `, `
    - 仙风道骨（提升）: 快速自愈能力得到显著增强。速度快到极致，能够在平稳的液体表面上奔跑而不下沉。拥有坚韧的体质和随成长提升的移动与防御能力，且只需睡眠即可维生。
    - 赤诚之心: 仙气不仅淬炼肉体，更洗涤精神。其心灵变得纯净而坚固，能自然免疫绝大多数试图操控精神的负面影响与幻术效果。`],

    ["A天然道士", 35000, "血统", {A:1}, `
        属性: 敏捷+1, 耐力+1, 感知+5, 决心+5
        能量池: 灵力(75)
    `, `
    - 仙风道骨（蜕凡）: 肉体凡胎已彻底蜕变，从此长生不老，免疫世间一切疾病、毒素与生理上的衰老。身体拥有强大的普适性伤害减免能力和卓越的快速自愈能力。
    - 仙气医疗: 体内满溢的仙气可以通过肢体接触，将自身的自愈能力暂时转移给他人，治愈其伤势。
    - 赤诚之心（提升）: 灵魂已与天地自然同调，坚定的意志能显著增强其所有行动的成功率。同时保留了对心灵操控与幻术的强大抗性，并可在水面奔跑。`],

    ["AA天然道士", 50000, "血统", {AA:1}, `
        属性: 力量+1, 敏捷+2, 耐力+2, 感知+8, 决心+8
        能量池: 元气(100)
    `, `
    - 结丹: 可以将自身精纯的生命元气凝结成一颗金丹。此丹药拥有起死回生的神效，能够治愈致命的伤势，并帮助服用者抵抗诅咒、疾病和毒素。但凝结金丹需要消耗大量的自身元气。
    - 法天象地: 能够将自身元神逼出体外，化身为一个由纯粹能量构成的、顶天立地的元神巨人进行战斗，此状态下战斗力获得极大增幅。
    - 赤诚之心（圆满）: 灵魂与天地同调，坚定的意志能显著增强其所有行动的成功率。
    - 仙道之躯: 作为一个达到天然道士顶峰的存在，完整保留了长生不老、百毒不侵、仙气医疗、水上行走、强大自愈和伤害减免等所有低阶能力。`],

    ["炎黄世胄", 7000, "血统", {D:1}, `
        属性: 力量+1, 敏捷+1, 耐力+1, 智力+1, 感知+1, 决心+1, 风度+1
        能量池: 气血(35)
    `, `
    - 皆为汉土: 作为炎黄后裔，在对抗非我族类之敌时，血脉中潜藏的力量会被唤醒，爆发出更强的战斗力。
    - 学习天赋: 传承自先祖的智慧使其拥有卓越的学习能力，能比常人更快地掌握新知识与技能。
    - 忠于炎黄: 血脉中铭刻着对自身民族的绝对忠诚。任何形式的背叛行为都会导致血脉力量的彻底丧失。这份忠诚在面对特定的历史宿敌时，会转化为更强大的战斗意志。`],

    ["华夏遗民-青龙", 15000, "血统", {C:1}, `
        属性: 风度+3, 沉着+2, 耐力+1
        能量池: 龙气(45)
    `, `
    - 崖山气节: 拥有钢铁般的意志，精神如同坚壁，极难被任何外力动摇或操控。
    - 生存体质: 血脉中流淌着强大的适应力，使其能天然免疫绝大多数常见的毒素与疾病。
    - 四神附体: 获得东方青龙的庇佑，对各类能量形态的伤害都拥有普遍的抗性。
    - 中华传承: 血脉的纯粹性是力量的根源，任何会大幅改变身体基本构造的外部改造，都会削弱甚至破坏这份传承之力。
    选择青龙分支，继承了东方甲木的神性，威仪天生，意志坚定。`],

    ["华夏遗民-白虎", 15000, "血统", {C:1}, `
        属性: 敏捷+3, 决心+2, 感知+1
        能量池: 煞气(45)
    `, `
    - 崖山气节: 拥有钢铁般的意志，精神如同坚壁，极难被任何外力动摇或操控。
    - 生存体质: 血脉中流淌着强大的适应力，使其能天然免疫绝大多数常见的毒素与疾病。
    - 四神附体: 获得西方白虎的庇佑，对各类能量形态的伤害都拥有普遍的抗性。
    - 中华传承: 血脉的纯粹性是力量的根源，任何会大幅改变身体基本构造的外部改造，都会削弱甚至破坏这份传承之力。
    选择白虎分支，继承了西方庚金的杀伐之气，行动敏锐，杀伐果决。`],

    ["华夏遗民-朱雀", 15000, "血统", {C:1}, `
        属性: 智力+3, 感知+2, 敏捷+1
        能量池: 灵火(45)
    `, `
    - 崖山气节: 拥有钢铁般的意志，精神如同坚壁，极难被任何外力动摇或操控。
    - 生存体质: 血脉中流淌着强大的适应力，使其能天然免疫绝大多数常见的毒素与疾病。
    - 四神附体: 获得南方朱雀的庇佑，对各类能量形态的伤害都拥有普遍的抗性。
    - 中华传承: 血脉的纯粹性是力量的根源，任何会大幅改变身体基本构造的外部改造，都会削弱甚至破坏这份传承之力。
    选择朱雀分支，继承了南方丙火的灵性，智慧超群，感知敏锐。`],

    ["华夏遗民-玄武", 15000, "血统", {C:1}, `
        属性: 耐力+3, 力量+2, 沉着+1
        能量池: 玄冥真水(45)
    `, `
    - 崖山气节: 拥有钢铁般的意志，精神如同坚壁，极难被任何外力动摇或操控。
    - 生存体质: 血脉中流淌着强大的适应力，使其能天然免疫绝大多数常见的毒素与疾病。
    - 四神附体: 获得北方玄武的庇佑，对各类能量形态的伤害都拥有普遍的抗性。
    - 中华传承: 血脉的纯粹性是力量的根源，任何会大幅改变身体基本构造的外部改造，都会削弱甚至破坏这份传承之力。
    选择玄武分支，继承了北方壬癸的坚韧，体魄强健，沉稳如山。`],

    ["炎黄子孙-青龙", 25000, "血统", {B:1}, `
        属性: 风度+4, 沉着+2, 耐力+2
        能量池: 龙气(55)
    `, `
    - 青龙降临: 青龙血脉进一步觉醒，可以引动东方苍龙的神力，以自身凛然的威仪鼓舞战场上所有友方单位，显著提升他们的战斗效能与士气。
    - 传承之力: 完整保留了钢铁般的意志、对常见毒疾的免疫力、对能量伤害的天然抗性，以及不能接受大幅度身体改造的血脉限制。`],

    ["炎黄子孙-白虎", 25000, "血统", {B:1}, `
        属性: 敏捷+4, 决心+2, 感知+2
        能量池: 煞气(55)
    `, `
    - 白虎杀伐: 白虎的杀伐本能完全融入己身，使其获得了超凡的移动速度和先手反应能力。对某种特定的战斗方式（如弓箭、白刃、肉搏或运动）拥有超群的领悟力，并能将坚定的意志力转化为纯粹的破坏力，突破攻击的极限。
    - 传承之力: 完整保留了钢铁般的意志、对常见毒疾的免疫力、对能量伤害的天然抗性，以及不能接受大幅度身体改造的血脉限制。`],

    ["炎黄子孙-朱雀", 25000, "血统", {B:1}, `
        属性: 智力+4, 感知+2, 敏捷+2
        能量池: 灵火(55)
    `, `
    - 朱雀一怒: 南明离火的神力在体内流转，赋予其强大的火焰再生能力。任何近战攻击者都会受到神火的自动反噬，同时自身的攻击也附带着朱雀神火，能对敌人造成持续的烈焰灼烧伤害。
    - 传承之力: 完整保留了钢铁般的意志、对常见毒疾的免疫力、对能量伤害的天然抗性，以及不能接受大幅度身体改造的血脉限制。`],

    ["炎黄子孙-玄武", 25000, "血统", {B:1}, `
        属性: 耐力+4, 力量+2, 沉着+2
        能量池: 玄冥真水(55)
    `, `
    - 玄武当关: 玄武神力化为坚不可摧的守护，其肉体获得了极高的天生防御与伤害减免，对常规的枪械射击和能量武器拥有特殊的抗性。更能以集中的意志力，在短时间内进一步强化伤害吸收的能力，做到万夫莫开。
    - 传承之力: 完整保留了钢铁般的意志、对常见毒疾的免疫力、对能量伤害的天然抗性，以及不能接受大幅度身体改造的血脉限制。`],

   ["D级黄衣之王血统：戏剧家", 8000, "血统", {"D":1}, `
        属性: 智力+2, 耐力+2, 敏捷+2, 感知+1, 额外属性+3
        能量池: 戏剧之力(40)
    `, `
    - 信仰导向: 作为哈斯塔的使者，他的灵魂与信仰已经绑定。他将无法再追寻或侍奉除克苏鲁神话体系之外的任何存在，任何过往的信仰联系都会被立刻切断。
    - 迷惑人心的戏曲: 他是一位聪慧绝伦的艺术家，深谙如何以优雅的姿态引导死亡。他的智慧能完全转化为近战中的力量，能够选择一种表达自我的艺术形式（如舞蹈、歌唱、演奏），并以此作为战斗的媒介，其技艺之精湛，足以替代常规的白刃或肉搏技巧。
    - 永恒的黄衣: 他的身躯永远被一件无法损毁、无法脱下的黄衣所包裹。这件黄衣是他身份的象征，能保护他不因重伤而昏迷，但也因此散发出一种超凡脱俗而又令人不安的气质，使他在与人交往时产生隔阂。这层衣物虽然坚韧，但对瓦解魔法的力量却无能为力。这身装束是其存在的一部分，象征着他与凡俗世界的疏离。
     `],

    ["C级黄衣之王血统：温和开场", 15000, "血统", {"C":1}, `
        属性: 智力+3, 耐力+3
        能量池: 戏剧之力(50)
    `, `
    - 提升特性-迷惑人心的戏曲: 他的舞姿与戏曲变得更加绚丽夺目，充满了令人无法抗拒的魅力。他以艺术发动的攻击，不仅能创伤敌人的肉体，其蕴含的迷惑力量还能直接冲击并束缚目标的精神。其艺术表达的破坏力，已能与最精纯的战斗技巧相媲美。
    - 虚假的面具: 他的脸上自动出现一个不可摘除的白色面具，款式可随心意变幻。这面具赋予他洞察非凡事物的能力，能够感知到周围环境中隐藏的血统，并为他提供抵御神兵利器的强大防护。若他原本佩戴着其他头盔，这个面具将会取而代之，旧物若无法取下则会被直接摧毁。
     `],

    ["B级黄衣之王血统：恐怖假面", 22000, "血统", {"B":1}, `
        属性: 智力+4, 耐力+4, 敏捷+3, 额外属性+3
        能量池: 狂乱灵感(65)
    `, `
    - 提升特性-迷惑人心的戏曲: 他的智慧已经完全融入到了每一次攻击之中，不再需要任何转换，他的思想即是武器，智慧本身就定义了他攻击的极限。
    - 倾城的假面: 当温馨的戏剧落幕，所有人都将目光投向身着黄衣的他。此刻，他可以选择摘下面具，将那不可名状的真实容貌展露给世人，带来极致的恐怖。他的面具与黄衣的力量都得到了本质的提升，成为了他身份更深层次的延伸，其防护与洞察能力均获得飞跃。
   `],
       ["D级赛亚人血统", 8000, "血统", {D:1}, `
        属性: 力量+2, 敏捷+2, 耐力+2, 感知+1
        能量池: 气(40)
    `, `
    - 战斗民族: 赛亚人是天生的战斗种族，拥有远超常人的坚韧肉体，能够抵御常规的物理打击，甚至对子弹等高速射弹有天然的抗性。
    - 弱点尾巴: 赛亚人生来就有一条尾巴，这既是力量的象征，也是与生俱来的弱点。若尾巴被紧紧抓住，赛亚人会迅速感到脱力与虚弱。切断尾巴可以暂时消除此弱点，但也意味着失去了化身为巨猿的可能，不过尾巴终将在月圆之夜重新长出。`],

    ["C级赛亚人战士血统", 6000, "血统", {C:1}, `
        属性: 力量+3, 耐力+3
        能量池: 气(50)
    `, `
    - 提升特性-战斗民族: 作为赛亚人中的战士，你的战斗直觉和反应速度得到进一步强化，使你能在高速对决中更好地捕捉对手的动向。
    - 巨猿变化: 当赛亚人看到圆月或受到特定光线照射时，体内的野性会被唤醒，变身为失去理智的巨猿。巨猿形态下，体型、力量和耐力都将获得巨大的增幅，拥有惊人的破坏力。变身会持续到月亮消失或尾巴被切断为止。`],

    ["B级赛亚人精英战士血统", 15000, "血统", {B:1}, `
        属性: 力量+4, 敏捷+2, 耐力+4, 感知+1
        能量池: 气(60)
    `, `
    - 提升特性-战斗民族: 作为赛亚人中的精英，你的力量与肉体潜能得到了极大开发。你的天生攻击不仅迅猛，而且破坏力会随着自身力量的增长而不断突破极限，肉体也变得更加坚不可摧。
    - 宇宙作战: 你的身体构造已经进化到可以适应严酷的宇宙环境，无论是真空、辐射还是深海的巨大水压，都无法再对你造成伤害。你不再需要依赖呼吸生存。`],

    ["A级皇族赛亚人血统（贝吉塔王）", 20000, "血统", {A:1}, `
        属性: 力量+5, 敏捷+3, 耐力+5, 感知+3
        能量池: 气(70)
    `, `
    - 提升特性-战斗民族: 皇族血脉使你的肉体对能量攻击也产生了极强的抗性。你造成的近战伤害会随着你的力量而获得质的飞跃，并且强大的耐力也赋予了你更为磅礴的生命力。
    - 王者风范: 你天生具备王者的威压与气魄，这股气势使你在任何意志对抗中都能占据绝对优势。
    - 前方的路: 赛亚人在生死边缘会变得更强的传说在你身上体现得淋漓尽致。每次从重伤中完全恢复后，你都有机会突破自身的极限，永久增强自己的力量或耐力。`],

    ["S级超级赛亚人血统", 32000, "血统", {S:1}, `
        属性: 力量+8, 敏捷+7, 耐力+8, 感知+6
        能量池: 气(100)
    `, `
    - 金色形态: 凭借强大的意志，你可以突破极限，变身为传说中的超级赛亚人。变身后，你的头发变为金色并竖立，瞳孔化为碧绿，全身被金色的气焰包裹。在此形态下，你的各项身体机能都将获得爆炸性的提升，移动速度倍增，战斗民族的所有特性效果也会全面升华。
    - 提升特性-战斗民族: 在超级赛亚人状态下，你的力量能够直接转化为天生武器的破坏力，而你坚韧的身体甚至能吸收所有类型的伤害。`],

    ["斯克莱亚血统", 6000, "血统", {D:1}, `
        属性: 耐力+1, 智力+2, 感知+1
        能量池: 魔力(30)
    `, `
    - 背景: 斯克莱亚是居住于米德其路达次元的一族，他们天生拥有对魔法的亲和力，擅长搜索能量源、管理资料，是发掘古代文明遗迹的权威种族。
    - 能量感知: 你能敏锐地感知到周围的能量波动，包括能量的运用、魔法物品以及拥有能量的生物，并能精确定位其来源，甚至分辨出能量的类别和强度。
    - 资料统合: 斯克莱亚人擅长整理和使用文献，在解读文件和图纸方面有卓越的天赋。
    - 雪貂形态: 你可以消耗魔力，在人类与小巧的雪貂形态之间自由变化。雪貂形态下，你可以轻松出入狭窄的地方，并且在攀附于其他生物身上时，能巧妙地利用对方来为自己提供掩护。`],

    ["鸢女血统", 12000, "血统", {C:1}, `
        属性: 力量+2, 敏捷+3, 感知+2, 决心+1
        能量池: 风元(45)
    `, `
    - 背景: 鸢女是半人半猛禽的种族，最初是法师军队的探子与游击队，后来在兽人革命中赢得了自由。她们是天生的空战专家，以惊人的速度和机动性著称。
    - 半人半鸟: 你的手臂永久地化为一对羽翼，赋予你强大的飞行能力，但无法再像人类一样使用双手。你的双腿则化为猛禽般的利爪，成为你致命的天生武器。
    - 回旋战法: 你精通利用空中优势进行战斗的技巧。
    - 永不为奴: 自由的意志已经烙印在你的灵魂深处。`],

    ["大熊猫血统", 15000, "血统", {B:1}, `
        属性: 力量+4, 耐力+4, 风度+3
        能量池: 萌力(50)
    `, `
    - 背景: 世界上最可爱的生物是什么？答案就是来自中国的“滚滚”！
    - 大熊猫: 你的外形变为一只可爱的大熊猫，拥有与生俱来的攀爬天赋和熊族语言能力。你肥嘟嘟的身体对冲击伤害有着天然的缓冲作用。
    - 萌货: 你的可爱外表具有无法抗拒的魅力。
    - 熊人族无所畏惧！: 你拥有强大的勇气和不屈的意志。
    - 熊掌: 你厚实的熊掌既可爱又充满力量。`],

    ["第一使徒亚当血统", 54400, "血统", {S:1}, `
        属性: 力量+4, 敏捷+4, 耐力+4, 智力+3, 感知+3, 决心+4, 风度+3, 沉着+4
        能量池: AT能量(120)
    `, `
    - 背景: 亚当是出现在南极的光之巨人，是所有使徒的起源。植入其胚胎后，外形不会发生巨大改变，但掌心会出现一只眼睛。
    - 强化AT力场: 作为使徒之祖，你的AT力场（心之壁）异常强大，能够抵御极为巨大的伤害，甚至可以抵抗即死效果。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。只要S2机关不被破坏，你就算不上真正死亡。
    - 心灵防护: 你对任何影响心灵的负面效果完全免疫。
    - 光之巨人: 你的本质转变为元素生物，体型变得更为巨大，并获得完美的飞行能力。`],

    ["第三使徒水天使血统", 27200, "血统", {A:1}, `
        属性: 力量+3, 敏捷+6, 耐力+4, 决心+3
        能量池: AT能量(70)
    `, `
    - 背景: 水天使是拥有飞行能力的使徒。植入其胚胎后，头上会出现两张面具，身体浮现绿色组织，背后生出闪光的翅膀。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。只要S2机关不被破坏，你就算不上真正死亡。
    - 使徒之躯: 你的身体拥有强大的再生能力。你可以从手心和肘部长出锋利的光束矛，并从头上的面具发射出命中后会爆发出十字型光芒的粒子炮。`],

    ["第四使徒书天使血统", 27200, "血统", {A:1}, `
        属性: 力量+3, 敏捷+3, 耐力+4, 决心+3, 风度+3
        能量池: AT能量(70)
    `, `
    - 背景: 书天使形态如同水母。植入其胚胎后，头部后方会出现一个水母状的悬浮罩，发梢变为透明的触手，并从背后伸出两根电热鞭。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。只要S2机关不被破坏，你就算不上真正死亡。
    - 水母体: 你头部的悬浮场让你能永久离地漂浮，移动速度倍增。你还拥有两条能进行高频震动的粉红色触手作为武器，在攻击时能瞬间撕裂没有装甲防护的目标。`],

    ["第五使徒雷天使血统", 27200, "血统", {A:1}, `
        属性: 敏捷+2, 耐力+4, 感知+4, 沉着+2
        能量池: AT能量(70)
    `, `
    - 背景: 雷天使拥有最强的粒子炮，能呈现各种几何形态。植入其胚胎后，外形变化不大，但会有一个小小的蓝色水晶卫星环绕着你，它既是你的武器平台，也是S2机关的载体。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你的S2机关被保护在坚固的水晶卫星中。它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 钻头: 你能从身体伸出一根无坚不摧的小钻头，用于突破坚固的障碍。
    - 加粒子炮: 环绕你的水晶卫星能发射出威力无穷的加粒子炮，射程极远，并能自动锁定并攻击进入你感知范围内的任何有威胁的目标。`],

    ["第六使徒鱼天使血统", 27200, "血统", {A:1}, `
        属性: 力量+6, 敏捷+2, 耐力+6, 感知+2
        能量池: AT能量(70)
    `, `
    - 背景: 鱼天使是水生使徒。植入其胚胎后，背后会长出鱼鳍和短尾，并且可以从头部伸出布满尖牙的巨嘴，S2机关就位于巨嘴之中。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你的S2机关位于嘴中。它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 鲸吞: 你获得了在水中自由呼吸和高速移动的能力，并免疫水压。你可以伸出巨嘴直接吞噬敌人，被吞入体内的敌人会持续受到伤害，难以逃脱。`],

    ["第七使徒音乐天使血统", 27200, "血统", {A:1}, `
        属性: 力量+3, 敏捷+3, 耐力+4, 风度+4, 沉着+2
        能量池: AT能量(80)
    `, `
    - 背景: 音乐天使的核心特征是分裂与再生。植入其胚胎后，头上会出现两张面具，身体浮现绿色组织，背后生出闪光的翅膀。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - 双S2机关: 你拥有两个阴阳鱼形的S2机关。这意味着即使其中一个被摧毁，你依然能够存活。
    - 粒子炮: 你能从头上的面具发射出威力强大的粒子炮。
    - 分体: 当你受到挥砍伤害时，你可以选择不受伤害，而是直接分裂成两个属性有所减弱的小型个体。两个分体共享意识，可以协同作战。虽然合体需要漫长时间且不能被打扰，但这是非常强大的生存能力。`],

    ["第八使徒胎儿天使血统", 27200, "血统", {A:1}, `
        属性: 耐力+6, 感知+2, 风度+2, 沉着+6
        能量池: AT能量(70)
    `, `
    - 背景: 胎儿天使代表着高速进化与适应。植入其胚胎后，你会首先回归到一个蛋的形态。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 快速成长: 你会处于一个坚固的蛋中，能感知外界但无法互动。一旦蛋壳被打破，你会在瞬间成长为完全形态，所有属性、防御和抗性都会得到极大的提升。不过这个状态持续数小时后，你会再次变回蛋形态。`],

    ["第九使徒雨天使血统", 27200, "血统", {A:1}, `
        属性: 力量+3, 敏捷+3, 耐力+4, 感知+3, 风度+3
        能量池: AT能量(70)
    `, `
    - 背景: 雨天使是拥有强酸攻击能力的使徒。植入其胚胎后，身上会长出七只眼睛，S2机关隐藏在身体内部。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 泪流满面: 你眼睛流出的“泪水”是具有极强腐蚀性的硫酸。你可以主动喷射大范围的酸液，近身攻击你的敌人也会被酸液溅射，你的近战攻击同样附带腐蚀效果。这种硫酸能无视物体的硬度直接造成破坏。`],

    ["第十使徒空天使血统", 27200, "血统", {A:1}, `
        属性: 力量+2, 敏捷+3, 耐力+2, 感知+3, 风度+2
        能量池: AT能量(70)
    `, `
    - 背景: 空天使是巨大的空中要塞。植入其胚胎后，全身会被橘黄色物质覆盖，胸前和双手出现巨大的眼睛，影响精细操作。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。可以通过全神贯注的防御来强化AT力场的范围和效果。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 包裹物质: 覆盖你全身的物质是一层天然的重甲，提供了强大的防御和再生能力。
    - 司空之眼: 你身上的三只大眼睛给予你全方位无死角的视野，极大地增强了你的侦查能力，并让你能够漂浮在空中。
    - 空降飞扑: 你可以从极高的高空以自身为武器，展开AT力场进行毁灭性的坠落攻击，对地面造成巨大范围的破坏。`],

    ["第十一使徒恐怖天使血统", 27200, "血统", {A:1}, `
        属性: 智力+6, 操控+6, 决心+2, 沉着+2
        能量池: 数据流(70)
    `, `
    - 背景: 恐怖天使是纳米病毒集群构成的使徒。植入其胚胎后，外形不变，但你的本质已化为病毒本身。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量，并让你无需摄食和呼吸，也能在真空中生存。
    - 病毒化: 你可以将自己的意识化为数据，入侵并操控任何科技造物。在骇入电脑、驾驶载具方面，你拥有无与伦比的天赋。你还可以通过接触来感染科技物品，从而随时掌握其位置。`],

    ["第十二使徒夜天使血统", 54400, "血统", {S:1}, `
        属性: 耐力+3, 智力+2, 感知+6, 风度+6, 操控+6, 沉着+6
        能量池: 虚数能量(100)
    `, `
    - 背景: 夜天使是存在于另一个维度的使徒。植入其胚胎后，身上会出现黑白条纹，人们看到的“身体”只是投影，真身藏于影子之中。
    - 反转AT力场: 你的AT力场极为特殊，它不直接抵挡伤害，而是构成了一个名为“狄拉克之海”的虚数空间，你的本体就藏于其中。任何攻击都无法触及位于另一个维度的你。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量。
    - 狄拉克之海: 这是由你的AT力场维持的独立位面。你可以将范围内的敌人或物体强行吸入其中。进入狄拉克之海的敌人将受到位面法则的压制，实力大减，而你可以随时离开或返回这个属于你的领域。`],

    ["第十三使徒霞天使血统", 27200, "血统", {A:1}, `
        属性: 耐力+4, 感知+4, 操控+4
        能量池: 生物质(70)
    `, `
    - 背景: 霞天使是能够侵蚀和寄生的微生物集群。植入其胚胎后外形不变，但你的本体已非血肉之躯。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量。
    - 侵蚀: 你可以将自己的微生物集群侵入无助的活物体内，通过意志对抗逐渐夺取对方的身体控制权。成功后，你可以操控其身体，使用其技能，并保留自己的AT力场和S2机关。
    - 肉体强化: 你可以活化并强化被你侵占的有机体，使其身体机能得到大幅提升。
    - 微生物集群: 在使用自己身体时，你是一个由无数微生物构成的集群生物。`],

    ["第十四使徒力天使血统", 54400, "血统", {S:1}, `
        属性: 力量+8, 敏捷+2, 耐力+5, 感知+4, 决心+8, 风度+2
        能量池: AT能量(110)
    `, `
    - 背景: 力天使是机能最完善、拒绝能力最强的使徒。植入其胚胎后，身上会覆盖天然装甲，背后长出绷带般的翅膀，S2机关被保护在体内。
    - 多重AT力场: 你的AT力场并非单层，而是由无数层力场叠加而成。这使它不仅能抵御伤害，还能吸收伤害，极难被中和或突破。
    - 体内S2机关: 你的S2机关隐藏在体内，无法被直接攻击。强大的S2机关能量甚至能让你将AT力场化为武器，直接进行远程压迫攻击。
    - 天生装甲: 你覆盖全身的外壳是一件性能优越的天然盔甲，提供全方位的防御、能量抗性，并赋予你完美的飞行能力。
    - 使徒武装: 你能从双眼发射威力媲美雷天使的强化粒子炮，还能从翅膀中射出坚硬的绷带，以极高的速度切割敌人。`],

    ["第十五使徒鸟天使血统", 21000, "血统", {A:1}, `
        属性: 力量+1, 敏捷+5, 耐力+1, 感知+5, 操控+2, 沉着+2
        能量池: 精神力(70)
    `, `
    - 背景: 鸟天使是位于卫星轨道上的精神攻击型使徒。植入其胚胎后，身后会长出三对巨大的白色翅膀，皮肤变为苍蓝色，并持续散发荧光。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量。
    - 鸟之诗: 你身后的巨大翅膀能让你以极高的速度在天空中翱翔。
    - 心灵扫描: 你能发射出类似AT力场的光波，对极远距离外的目标进行精神扫描。通过意志对抗，你可以窥探目标的表层思维，洞察其攻防意图，甚至挖掘出其内心深处被遗忘的记忆。`],

    ["第十七使徒自由天使血统", 27200, "血统", {A:1}, `
        属性: 敏捷+3, 感知+3, 决心+3, 沉着+3
        能量池: 意志之力(70)
    `, `
    - 背景: 自由天使是拥有自由意志的使徒，代表着不受束缚的灵魂。植入其胚胎后，外形会变得更加俊美，头发变为白色。
    - AT力场: 你获得使徒共通的心之壁能力，能展开八边形的闪光力场，抵御外界的物理干涉和伤害。
    - S2机关: 你拥有名为S2机关的永动核心，它能源源不断地产生能量。
    - 自由意志: 你代表着绝对的自由。你完全免疫任何环境的负面影响，免疫所有会限制你移动的纠缠、疲劳等状态，免疫擒抱与摔绊，免疫所有心灵层面的控制。你拥有完美的飞行能力，除非你自愿，否则没有什么能束缚你。`],
  ["D级喰种血统", 6000, "血统", {D:1}, `
        属性: 力量+2, 敏捷+1, 耐力+2
        能量池: 赫子能量(40)
    `, `
    - 食尸鬼体质: 喰种的身体机能远超人类，拥有强大的力量和自愈能力。但必须以人类的血肉为食，普通食物味同嚼蜡且无法提供营养。
    - 赫子: 体内Rc细胞的结晶，是喰种的捕食器官与武器。可以从身体特定部位伸展出一个赫子，其形态（如羽赫、鳞赫、甲赫、尾赫）在获得血统时决定。
    - 赫眼: 在使用能力或情绪激动时，巩膜会变为黑色，虹膜变为红色，这是喰种的标志。
    - CCG的天敌: 喰种的赫子坚韧无比，但对CCG开发的“库因克”武器异常脆弱。
    潜藏于人类城市阴影中的捕食者，他们拥有人的外表，却以人为食。为了生存，他们必须在饥饿的本能与伪装的理性之间挣扎。`],

    ["C级喰种血统", 13000, "血统", {C:1}, `
        属性: 力量+3, 敏捷+2, 耐力+3
        能量池: 赫子能量(55)
    `, `
    - 提升特性-食尸鬼体质: 自愈能力得到强化，即使是严重的创伤也能在较短时间内愈合。对人类血肉的渴求也更为强烈。
    - 赫子操控: 对赫子的操控更加熟练，可以进行更复杂、更迅速的攻击与防御。赫子的尺寸与威力也得到提升。
    适应了狩猎与被狩猎的生活，喰种的本能被进一步磨砺。他们不再是挣扎求生的新手，而是都市丛林中合格的猎手。`],

    ["B级喰种血统", 21000, "血统", {B:1}, `
        属性: 力量+4, 敏捷+3, 耐力+4, 感知+1
        能量池: 赫子能量(70)
    `, `
    - 提升特性-食尸鬼体质: 身体强度大幅提升，自愈能力达到断肢再生的程度。
    - 赫者之鳞: 通过吞噬其他喰种的赫子，可以暂时性地强化自身，甚至演化出不完整的赫者外壳（半赫者），获得临时的强大力量与防御，但有失控的风险。
    在同类的相食中，寻求着进化的可能性。跨越禁忌的喰种将获得更强大的力量，但也要承担被疯狂吞噬的风险。`],

    ["A级独眼喰种血统", 33000, "血统", {A:1}, `
        属性: 力量+6, 敏捷+5, 耐力+6, 决心+2
        能量池: 赫子能量(90)
    `, `
    - 独眼之王: 作为人类与喰种的混血，其潜力远超普通喰种。只在单眼呈现赫眼，但Rc细胞的活性与总量都达到了惊人的水平。
    - 完全赫者化: 能够完全掌控吞噬同类获得的力量，将赫子覆盖全身，化为坚不可摧的“赫者”形态。在此形态下，身体能力得到飞跃性提升，且不会丧失理智。
    - 突破界限: 独眼喰种的成长没有极限，每一次超越生死的战斗都有可能让其赫子产生新的变异和进化。
    既不属于人类，也不属于喰种的孤独存在。这份与生俱来的矛盾与痛苦，造就了超越两个种族的王者。他是所有喰种的顶点，也是连接两个世界的唯一桥梁。`],

    ["狼人血统", 7000, "血统", {D:1}, `
        属性: 力量+3, 耐力+2, 感知+1
        能量池: 怒气(35)
    `, `
    - 月夜狂暴: 在月圆之夜，会强制变身为狼人形态，失去理智，攻击性大幅增强，物理抗性提升，但无法使用装备和精细技能。
    - 狼之嗅觉: 拥有极为灵敏的嗅觉，能够追踪气味，分辨情绪，并感知到隐藏的敌人。
    - 银之毒: 对银制品有天生的恐惧和脆弱性，接触银会造成严重的烧灼伤害并抑制自愈能力。
    古老的诅咒在血脉中流淌，月亮是其力量的源泉，也是其疯狂的开关。每当月圆之时，人性的枷锁便会被挣脱。`],

    ["头狼血统", 16000, "血统", {C:1}, `
        属性: 力量+4, 耐力+3, 感知+2, 决心+1
        能量池: 怒气(50)
    `, `
    - 自由变身: 不再完全受月亮的影响，可以通过消耗怒气，主动在人类与狼人形态之间切换，并能在变身后保持部分理智。
    - 感染之咬: 狼人形态下的啃咬附带诅咒，若目标在撕咬下存活，便有一定几率被转化为新的狼人。
    - 提升特性-狼之嗅觉: 感官进一步强化，能够通过气味分辨谎言。
    他们学会了控制血脉中的野性，成为了兽群的领袖。不再是单纯被本能驱使的怪物，而是能够运用诅咒力量的战士。`],

    ["魔狼血统", 24000, "血统", {B:1}, `
        属性: 力量+5, 敏捷+2, 耐力+5, 感知+3
        能量池: 怒气(65)
    `, `
    - 人狼一体: 能够进入完美的“人狼”形态，兼具人类的智慧与狼人的力量。此形态下可以使用武器和技能，并且体型更加矫健，速度与力量并存。
    - 再生之躯: 拥有强大的再生能力，除非击中头部或心脏，否则绝大多数物理伤害都能快速愈合。对银的脆弱性有所降低，但仍是其最大弱点。
    - 统御狼群: 能够通过嚎叫与精神力，对其他狼或狼人进行一定程度的指挥和统御。
    挣脱了诅咒的束缚，将野性与人性完美融合，成为了月夜下真正的统治者。其存在本身就是力量与自由的象征。`],

    ["精灵血统", 7500, "血统", {D:1}, `
        属性: 敏捷+2, 感知+2, 风度+2
        能量池: 自然魔力(40)
    `, `
    - 长寿种: 拥有漫长的生命，对时间的流逝有不同的感受。自然衰老极其缓慢。
    - 森林之子: 在森林、草原等自然环境中，感知能力和移动速度会得到提升。能与大部分温顺的动物进行简单的沟通。
    - 优雅身姿: 天生拥有轻盈的体态和协调的动作，在进行射击、潜行和需要灵巧的行动时具备优势。
    - 钢铁之厌: 对大规模的工业造物和纯粹的科技环境感到本能的排斥和不适。
    诞生自古老森林的优雅种族，与自然万物和谐共生。他们的生命如林间清泉般悠长，他们的箭矢如流星般精准。`],

    ["高等精灵血统", 17000, "血统", {C:1}, `
        属性: 敏捷+3, 感知+3, 智力+2, 风度+3
        能量池: 奥术能量(55)
    `, `
    - 奥术亲和: 血脉中流淌着对魔法能量的天然亲和力，学习和施展魔法事半功倍，并能感受到环境中的魔力流动。
    - 心灵感应: 能够与血脉相近或关系亲密的同伴进行短距离的心灵沟通。
    - 提升特性-优雅身姿: 动作如舞蹈般优雅，能通过专注来强化自身的闪避能力。
    他们是精灵中走上魔法之路的一支，不再仅仅满足于自然的恩赐，而是开始探求世界背后的奥秘法则。智慧与优雅在他们身上融为一体。`],

    ["古代龙裔血统", 38000, "血统", {S:1}, `
        属性: 力量+7, 耐力+7, 决心+6, 智力+5
        能量池: 龙之血(100)
    `, `
    - 龙魂: 你的灵魂本质是龙，这让你拥有钢铁般的意志，免疫绝大多数精神控制和恐惧效果。
    - 元素吐息: 可以在数种强大的元素吐息中选择其一（火焰、寒冰、闪电、强酸），作为你与生俱来的毁灭性武器。
    - 龙鳞甲: 身体表面覆盖着坚不可摧的龙鳞，提供极高的物理与能量伤害减免。
    - 巨龙之力: 肉体力量达到生物的顶峰，近战攻击附带强大的冲击力，并且拥有在任何环境下生存的能力，包括真空和深海。可以消耗大量能量，在短时间内化为一头遮天蔽日的巨龙真身。
    你是远古巨龙血脉最纯粹的继承者，是行走于大地的活传奇。你的存在本身，就是力量、威严与不朽的代名词。`],
     ["【D】稀薄的祖血", 2200, "血统", {}, "属性: 力量+1, 耐力+1\n能量池: 魔力(10)", "这是第四真祖血脉最微末的显现。拥有者身体素质略强于常人，偶尔会在强烈的情感波动中感受到难以抑制的饥渴。此刻，古老的传承仅仅是在沉睡中低语，等待着被唤醒的契机。"],
  ["【C】觉醒的祖血", 8500, "血统", {}, "属性: 力量+2, 敏捷+2, 耐力+2\n能量池: 魔力(30)", "古老的血液开始苏醒，吸血冲动变得更加明确，并与特定的情感紧密相连。不老不死和超速再生的特性初露端倪，虽然恢复力尚弱，但已然超越凡人的界限。拥有者能够感受到体内潜藏的、尚未成型的眷兽之力。"],
  ["【B】统御的祖血", 18000, "血统", {"C": 1}, "属性: 力量+3, 敏捷+3, 耐力+4, 沉着+2\n能量池: 魔力(80)", "真祖的力量进一步解放，让拥有者能够初步驾驭一到两只眷兽。吸食灵媒之血后，力量会得到显著增强。“血之伴侣”的契约变得可能，与他人的羁绊将成为力量的一部分。物理伤害的恢复速度大幅提升。"],
  ["【A】灾厄的祖血", 35000, "血统", {"B": 1}, "属性: 力量+5, 敏捷+4, 耐力+6, 操控+4\n能量池: 魔力(200)", "率领灾厄化身的力量已趋于完整。已能熟练支配复数的强大眷兽，其存在本身就足以扭曲常理。通过与灵媒缔结“血之伴侣”的契约，可以完全释放眷兽的潜能，成为行走于世间的传说。"],
  ["【S】第四真祖之血", 50000, "血统", {"A": 1}, "属性: 力量+8, 敏捷+6, 耐力+8, 智力+5, 操控+6, 风度+5\n能量池: 魔力(500)", "不应存于世的梦幻血脉，世界最强的吸血鬼之证。完美的不老不死之躯，支配全部十二只灾厄化身的眷兽。每一次吸血都是一场君临的仪式，将灵媒的灵魂与自己的王座相连，释放出足以颠覆世界的力量。"],
  ["灵媒之血（瓶装）", 800, "物品", {}, "效果: 一次性道具。在进行吸血时使用，可触发一次力量觉醒的判定，有微小几率解锁一个未激活的技能或强化现有血统能力。", "从拥有高阶灵媒体质的人身上获取的血液，被小心地保存在这个容器中。它散发着对吸血鬼而言无比甘美的气息，是唤醒沉睡力量的钥匙，也是缔结神圣契约的祭品。"],
  ["血之伴侣的契约印记", 15000, "物品", {"B":1}, "效果: 装备。当与缔结了“血之伴侣”契约的角色共同行动时，双方所有属性判定获得dp+1的加成。此物品为唯一性，不可重复获得。", "这不是一个实体物品，而是灵魂层面深刻羁绊的证明。它象征着主君与伴侣间的绝对信赖与魔力连接，当彼此并肩时，这份羁绊将化为超越一切的守护之力。"],
  ["【被动】吸血冲动", 3000, "技能", {}, "效果: 【dp+0;能量池-0】", "该技能为被动触发。当角色陷入“性兴奋”状态时，将获得“吸血”指令的许可，可以对自愿的、拥有强大灵力的异性使用。成功吸血是觉醒眷兽和增强力量的唯一途径。"],
  ["【眷属】血之伴侣", 8000, "技能", {"C":1}, "效果: 【dp+0;能量池-50】", "通过吸血仪式，将一位拥有高阶灵媒体质的异性转化为“血之随从”。对方将获得不死性，并与你共享魔力池。每拥有一名血之伴侣，你的能量池上限提升20点。"],
  ["【眷兽】神羊之金刚", 9000, "技能", {}, "效果: 【dp+1;能量池-60】", "召唤出金刚石构成的大角羊。可发动一次绝对防御，完全反弹一次指向性攻击。之后的回合中，可将漂浮的宝石结晶化为护盾或投射物，进行防御或攻击。"],
  ["【眷兽】牛头王之琥珀", 8500, "技能", {}, "效果: 【dp+1;能量池-55】", "召唤出由熔岩构成的牛头神。其巨大的战斧能够发动无视任何魔法或能量护盾的纯粹物理攻击，是攻破结界和屏障的绝对力量。"],
  ["【眷兽】龙蛇之水银", 11000, "技能", {}, "效果: 【dp+2;能量池-75】", "召唤双头龙蛇。其能力是次元吞噬，可以指定一个目标或一片区域，将其从空间中彻底抹除，无论是实体、能量还是概念，都无法幸免。"],
  ["【眷兽】甲壳之银雾", 7500, "技能", {}, "效果: 【dp+1;能量池-40】", "召唤银雾甲壳兽，将指定范围内的一切物质（实力低于自身）都强制雾化，使其暂时失去物理形态与结合力，是一种强大的控制与快速移动手段。"],
  ["【眷兽】狮子之黄金", 9500, "技能", {}, "效果: 【dp+1;能量池-65】", "召唤黄金之狮。能够释放毁灭性的雷光进行大范围轰炸，或进行精密的电磁操作。是力量与破坏力的象征，足以瞬间清扫战场。"],
  ["【眷兽】冥姬之虹炎", 13000, "技能", {}, "效果: 【dp+2;能量池-80】", "召唤手持虹光之剑的女武神。其斩击能切断万物，不仅是物理上的形态，也包括目标的因果与命运。被此剑斩断之物将彻底失去其存在的根基。"],
  ["【眷兽】夜摩之黑剑", 10000, "技能", {}, "效果: 【dp+2;能量池-70】", "召唤一柄贯穿天际的百米巨剑。通过超重力加速从高空坠落，其一击之力足以毁灭周遭数十公里的地貌，是纯粹破坏力的极致体现。"],
  ["【眷兽】蝎虎之紫", 7800, "技能", {}, "效果: 【dp+1;能量池-50】", "召唤被紫炎包裹的蝎尾狮。能够瞬间分析任何毒素并生成抗体，亦能指定一个敌方目标，强行剥夺其体内的魔力或能量为己用。"],
  ["【眷兽】双角之深绯", 8200, "技能", {}, "效果: 【dp+1;能量池-50】", "召唤拥有音叉双角的战马。通过发出超高频率的共振波，粉碎指定范围内的所有固体物质。同时，它也能提供一次性的超高速空中飞行能力。"],
  ["【眷兽】魔羯之瞳晶", 14000, "技能", {}, "效果: 【dp+2;能量池-90】", "召唤出象征“魅惑”的魔羯。其能力是支配精神，可以对指定目标进行一次精神控制判定。即使是意志坚定的真祖级对手，也可能被其影响。"],
  ["【眷兽】水精之白钢", 12000, "技能", {}, "效果: 【dp+2;能量池-80】", "召唤象征“超回复”的水妖。能够发动一次强大的治愈神迹，将范围内所有友方单位的伤势与异常状态完全清除，令其回归到最完美的状态。"]
];
      // 全局变量
 
        let userPoints = 0;
       let userPlots = {};
    
        let randomItems = [];
        let shoppingCart = []; // 新增：购物车
        const ITEMS_PER_PAGE = 14; // 按要求修改为10

        const shopState  = {
            fixed: { currentCategory: 'all', currentSort: 'asc', currentPage: 1, selectedItem: null },
            random: { currentCategory: 'all', currentSort: 'asc', currentPage: 1, selectedItem: null }
        };


    // 抽奖相关配置
const GACHA_CONFIG = {
    singleCost: 160,
    tenCost: 1440, // 10连抽打9折
    prizeRanges: [
        { min: 30, max: 70, probability: 0.59 },    
        { min: 80, max: 160, probability: 0.25 },   
        { min: 200, max: 600, probability: 0.1 },  
        { min: 1000, max: 4000, probability: 0.05 }, 
        { min: 8000, max: 20000, probability: 0.01 }  
    ]
};
function getRandomShopItems() {
    try {
        const itemsJson = localStorage.getItem('randomShopItems');
        // If itemsJson is null or undefined, return an empty array.
        if (!itemsJson) {
            console.warn('No randomShopItems found in localStorage.');
            return [];
        }
        const items = JSON.parse(itemsJson);
        // Ensure the parsed data is an array.
        return Array.isArray(items) ? items : [];
    } catch (error) {
        console.error('Failed to parse randomShopItems from localStorage:', error);
        // Return an empty array in case of a parsing error to ensure the application doesn't crash.
        return [];
    }
}

function getRandomPrizeRange() {
    const random = Math.random();
    let cumulativeProbability = 0;

    for (const range of GACHA_CONFIG.prizeRanges) {
        cumulativeProbability += range.probability;
        if (random <= cumulativeProbability) {
            return range;
        }
    }

    // Fallback to the last (or could be first, depending on desired logic) range if something goes wrong.
    // Using the last one is often safer if probabilities don't sum to exactly 1.
    return GACHA_CONFIG.prizeRanges[GACHA_CONFIG.prizeRanges.length - 1];
}

/**
 * Filters a combined list of fixed and random items to find those within a specific price range.
 * @param {number} min - The minimum price of the range.
 * @param {number} max - The maximum price of the range.
 * @returns {Array} An array of items that fall within the specified price range.
 */
function getItemsInPriceRange(min, max) {
    const randomItems = getRandomShopItems();
    // Combine fixed and random items into a single pool for selection.
    const allItems = [...fixedItems, ...randomItems];

    return allItems.filter(item => {
        // Assuming item is an array like ['itemName', price]
        const price = item[1];
        return price >= min && price <= max;
    });
}

function performGacha(count) {
    const results = [];
    for (let i = 0; i < count; i++) {
        const prizeRange = getRandomPrizeRange();
        const availableItems = getItemsInPriceRange(prizeRange.min, prizeRange.max);
        
        if (availableItems.length > 0) {
            const randomItem = availableItems[Math.floor(Math.random() * availableItems.length)];
            results.push(randomItem);
        }
    }
    return results;
}
 // 全新的抽卡动画函数
 // 全新的抽卡动画函数，支持手机端拖动和点击
function showGachaAnimation(results, callback) {
    const container = document.getElementById('gacha-animation-container');
    const summaryContainer = document.getElementById('gacha-results-summary');
    container.innerHTML = '';
    summaryContainer.innerHTML = '';
    summaryContainer.style.display = 'none';

    const isMobileView = window.innerWidth <= 800;

    if (isMobileView) {
        // --- 手机端：可交互的3D圆筒动画 ---
        const carousel = document.createElement('div');
        carousel.className = 'gacha-carousel';
        container.appendChild(carousel);

        const cardCount = results.length;
        const angle = 360 / cardCount;
        const radius = Math.round((140 / 2) / Math.tan(Math.PI / cardCount));

        let currentAngle = 0;
        let startX = 0;
        let startAngle = 0;
        let isDragging = false;
        let dragThreshold = 5; // 移动超过5像素才算拖动

        results.forEach((item, index) => {
            const price = item[1];
            let tierClass = 'tier-1';
            if (price >= 8000) tierClass = 'tier-5';
            else if (price >= 1000) tierClass = 'tier-4';
            else if (price >= 200) tierClass = 'tier-3';
            else if (price >= 80) tierClass = 'tier-2';

            const card = document.createElement('div');
            card.className = 'gacha-card';
            card.dataset.index = index;
            const originalTransform = `rotateY(${index * angle}deg) translateZ(${radius}px)`;
            card.style.transform = originalTransform;
            card.style.setProperty('--original-transform', originalTransform);

            card.innerHTML = `
                <div class="gacha-card-inner">
                    <div class="gacha-card-front">?</div>
                    <div class="gacha-card-back ${tierClass}">
                        <div>${item[0]}</div>
                        <div style="font-size: 12px; margin-top: 5px;">${item[1]}积分</div>
                    </div>
                    <div class="gacha-card-details">
                        <div class="gacha-card-details-content">
                            <div><strong>${item[0]}</strong></div>
                            <div>价值: ${item[1]}积分</div>
                            <div>分类: ${item[2]}</div>
                            <div>效果: ${item[4]}</div>
                            <div>描述: ${item[5]}</div>
                            <div style="height: 50px;"></div>
                        </div>
                    </div>
                    <button class="gacha-abandon-btn" style="display: none;">放弃</button>
                </div>
            `;
            carousel.appendChild(card);

            card.addEventListener('click', () => {
                if (isDragging) return; // 如果是拖动，则不触发点击

                const selectedCard = carousel.querySelector('.gacha-card.selected');
                if (selectedCard === card) { // 如果再次点击已选中的卡片，则取消选中
                    card.classList.remove('selected');
                    carousel.classList.remove('has-selection');
                } else {
                    if(selectedCard) selectedCard.classList.remove('selected');
                    card.classList.add('selected');
                    carousel.classList.add('has-selection');
                    currentAngle = -index * angle;
                    carousel.style.transform = `rotateY(${currentAngle}deg)`;
                }
            });

            card.querySelector('.gacha-abandon-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                results[index] = null;
                card.style.opacity = '0.2';
                card.style.pointerEvents = 'none';
            });
        });

        // 拖动事件
        container.addEventListener('touchstart', (e) => {
            startX = e.touches[0].pageX;
            startAngle = currentAngle;
            isDragging = false;
            carousel.style.transition = 'none'; // 拖动时移除平滑过渡
        }, { passive: true });

        container.addEventListener('touchmove', (e) => {
            const x = e.touches[0].pageX;
            const deltaX = x - startX;
            if (Math.abs(deltaX) > dragThreshold) {
                isDragging = true;
            }
            if(isDragging) {
                const sensitivity = 0.5; // 调整拖动灵敏度
                currentAngle = startAngle + deltaX * sensitivity;
                carousel.style.transform = `rotateY(${currentAngle}deg)`;
            }
        }, { passive: true });

        container.addEventListener('touchend', () => {
            carousel.style.transition = 'transform 0.6s cubic-bezier(0.25, 1, 0.5, 1)';
            const cardIndex = Math.round(-currentAngle / angle);
            const snappedAngle = -cardIndex * angle;
            currentAngle = snappedAngle;
            carousel.style.transform = `rotateY(${currentAngle}deg)`;

            // 确保touchend后isDragging状态复位
            setTimeout(() => { isDragging = false; }, 50);
        });

        // 初始入场动画
        setTimeout(() => {
            const finalAngle = 360 * 3;
            carousel.style.transition = 'transform 3s cubic-bezier(0.25, 1, 0.5, 1)';
            carousel.style.transform = `rotateY(-${finalAngle}deg)`;
        }, 100);

        setTimeout(() => {
            carousel.style.transition = 'transform 0.6s cubic-bezier(0.25, 1, 0.5, 1)';
            carousel.querySelectorAll('.gacha-card').forEach(c => c.classList.add('flipped'));
            let summaryHTML = '<h4>本轮收获</h4>';
            results.forEach(item => { summaryHTML += `<div>${item[0]} - ${item[1]}积分</div>`; });
            summaryContainer.innerHTML = summaryHTML;
            summaryContainer.style.display = 'block';
            if (callback) callback();
        }, 3500);

    } else {
        // --- 电脑端：平面翻牌动画 (保持原样，无需修改) ---
        results.forEach((item, index) => {
            const price = item[1];
            let tierClass = 'tier-1';
            if (price >= 8000) tierClass = 'tier-5';
            else if (price >= 1000) tierClass = 'tier-4';
            else if (price >= 200) tierClass = 'tier-3';
            else if (price >= 80) tierClass = 'tier-2';

            const card = document.createElement('div');
             card.className = 'gacha-card';
             card.dataset.itemIndex = index;
             card.innerHTML = `
                 <div class="gacha-card-inner">
                     <div class="gacha-card-front">?</div>
                     <div class="gacha-card-back ${tierClass}">
                         <div>${item[0]}</div>
                         <div style="font-size: 12px; margin-top: 5px;">${item[1]}积分</div>
                     </div>
                     <div class="gacha-card-details">
                         <div class="gacha-card-details-content">
                             <div><strong>${item[0]}</strong></div>
                             <div>价值: ${item[1]}积分</div>
                             <div>分类: ${item[2]}</div>
                             <div>效果: ${item[4]}</div>
                             <div>描述: ${item[5]}</div>
                             <div style="height: 50px;"></div>
                         </div>
                     </div>
                     <button class="gacha-abandon-btn" style="display: none;">放弃</button>
                 </div>
             `;
            container.appendChild(card);

            setTimeout(() => card.classList.add('flipped'), index * 200 + 500);

            card.addEventListener('click', () => {
                 if (!card.classList.contains('flipped')) return;
                 const isSelected = card.classList.contains('selected');
                 container.querySelectorAll('.gacha-card').forEach(c => {
                     c.classList.remove('selected');
                     c.querySelector('.gacha-card-details').classList.remove('show');
                     c.querySelector('.gacha-abandon-btn').style.display = 'none';
                 });
                 if (!isSelected) {
                     card.classList.add('selected');
                     card.querySelector('.gacha-card-details').classList.add('show');
                     card.querySelector('.gacha-abandon-btn').style.display = 'block';
                 }
            });

            card.querySelector('.gacha-abandon-btn').addEventListener('click', (e) => {
                 e.stopPropagation();
                 results[index] = null;
                 card.style.opacity = '0.5';
                 card.style.pointerEvents = 'none';
            });
        });

        setTimeout(() => {
            if (callback) callback();
        }, results.length * 200 + 1500);
    }
}



async function processGachaRewards(results) {
    // 过滤掉被放弃的物品
    const validResults = results.filter(item => item !== null);
    
    if (validResults.length === 0) {
        return; // 所有物品都被放弃
    }
    
    // 检查本轮重复
    const itemCounts = {};
    const finalResults = [];
    
    for (const item of validResults) {
        const key = `${item[2]}-${item[0]}`; // category-name作为key
        if (itemCounts[key]) {
            // 本轮重复，转为积分
            const extraPoints = Math.floor(item[1] / 2);
            playCharacterData.货币段.积分[0] += extraPoints;
        } else {
            itemCounts[key] = 1;
            finalResults.push(item);
        }
    }
    
    let updateMemoryCommands = [];
    let userMessages = [];
    
    finalResults.forEach(item => {
        const command = getPurchaseCommand(item);
        if (command) {
            updateMemoryCommands.push(command);
            userMessages.push(item[0]);
        }
    });
    
    // 扣除抽奖费用
    const cost = results.length === 1 ? GACHA_CONFIG.singleCost : GACHA_CONFIG.tenCost;
    updateMemoryCommands.push(`set_attribute('货币段.${currentTheme.currency}', '${playCharacterData.货币段.积分[0]}', '${playCharacterData.货币段.积分[0] - cost}');`);
    
    if (updateMemoryCommands.length > 0) {
        let finalCommand = `<updateMemory>\n${[...new Set(updateMemoryCommands)].join('\n')}\n</updateMemory>\n`;
        if (userMessages.length > 0) {
            finalCommand += `<(货币已扣除，禁止重复扣除，奖品已交付，禁止重复交付，禁止描写价格)${currentGameData.user_character.name}通过抽奖获得了以下物品：${userMessages.join("，")}。>`;
        }
        await triggerassa(`/setinput ${finalCommand}`);
    }
}

function startGacha(count) {
    const cost = count === 1 ? GACHA_CONFIG.singleCost : GACHA_CONFIG.tenCost;
 
  
    if (playCharacterData.货币段.积分[0] < cost) {
        showModal('shop-modal', "积分不足", `您需要 ${cost} 积分才能进行${count === 1 ? '单抽' : '十连抽'}。`);
        return;
    }
    
    const results = performGacha(count);
    if (results.length === 0) {
        showModal('shop-modal', "抽奖失败", "没有可抽取的物品。");
        return;
    }
    
    // 显示抽奖模态框
    showModal('gacha-modal');
    document.getElementById('gacha-modal-title').textContent = 
        count === 1 ? '单抽结果' : '十连抽结果';
    document.getElementById('gacha-confirm-btn').style.display = 'none';
    
    // 开始动画
    showGachaAnimation(results, () => {
        // 动画完成后显示确认按钮
        document.getElementById('gacha-confirm-btn').style.display = 'inline-block';
        document.getElementById('gacha-confirm-btn').onclick = async () => {
            await processGachaRewards(results);
            hideModal('gacha-modal');
            showModal('shop-modal', "抽奖完成", `成功获得 ${results.length} 件物品！数据将在下次刷新时更新。`);
            playCharacterData.货币段.积分[0] = playCharacterData.货币段.积分[0] - cost;
        };
    });
}

          // ========== 新增：妈妈为你添加的全局变量和核心计算函数 ==========
        const plotLevels = ['D', 'C', 'B', 'A', 'S'];
 /**
 * 【V9 双向兑换版】采用先合成后分解的结算逻辑，完美处理所有兑换场景。
 * @param {object} requiredPlots - 商品所需的支线剧情成本
 * @returns {object} - 返回一个计划对象 { affordable: boolean, decompositionPlan: object }
 */
function checkPlotAffordability(requiredPlots) {
    // 步骤一：全局购买力审计 (最可靠的保险)
    const conversionRates = { 'S': 81, 'A': 27, 'B': 9, 'C': 3, 'D': 1 };
    let totalRequiredInD = 0;
    let totalOwnedInD = 0;

    for (const level of plotLevels) {
        totalRequiredInD += (requiredPlots[level] || 0) * conversionRates[level];
        totalOwnedInD += playCharacterData.货币段.支线剧情[level][0] * conversionRates[level];
    }

    if (totalOwnedInD < totalRequiredInD) {
        return { affordable: false, decompositionPlan: {} };
    }

    // 步骤二：既然买得起，开始制定详细的支付计划
    let simulatedPlots = JSON.parse(JSON.stringify(playCharacterData.货币段.支线剧情));
    let decompositionPlan = { S: 0, A: 0, B: 0, C: 0, D: 0 };

    // 阶段一：向上合成，将所有低级富余资产转化为高级购买力
    for (let i = 0; i < plotLevels.length - 1; i++) {
        const currentLevel = plotLevels[i];
        const higherLevel = plotLevels[i + 1];

        // 支付当前等级所需
        const needed = requiredPlots[currentLevel] || 0;
        simulatedPlots[currentLevel][0] -= needed;

        // 如果支付后还有富余，就全部合成到上一级
        if (simulatedPlots[currentLevel][0] > 0) {
            const canSynthesize = Math.floor(simulatedPlots[currentLevel][0] / 3);
            if (canSynthesize > 0) {
                // 注意：这里我们不记录合成计划，因为最终的分解指令会自动处理好一切
                simulatedPlots[currentLevel][0] -= canSynthesize * 3;
                simulatedPlots[higherLevel][0] += canSynthesize;
            }
        }
    }
    // 单独支付最高级S级
    simulatedPlots['S'][0] -= (requiredPlots['S'] || 0);


    // 阶段二：向下分解，用高级资产支付低级欠款
    for (let i = plotLevels.length - 1; i >= 0; i--) {
        const currentLevel = plotLevels[i];

        // 如果当前级别出现“负债”，说明需要从更高级别分解来填补
        if (simulatedPlots[currentLevel][0] < 0) {
            const deficit = -simulatedPlots[currentLevel][0]; // 这是欠款数

            if (currentLevel !== 'S') {
                const higherLevel = plotLevels[i + 1];

                // 计算需要分解多少个高级支线来弥补
                const amountToDecompose = Math.ceil(deficit / 3);

                // 在分解计划中记录下来
                decompositionPlan[higherLevel] += amountToDecompose;

                // 更新模拟账本
                simulatedPlots[higherLevel][0] -= amountToDecompose;
                simulatedPlots[currentLevel][0] += amountToDecompose * 3;
            }
        }
    }

    // 如果所有流程走完，说明计划可行
    return { affordable: true, decompositionPlan: decompositionPlan };
}

 

function SafeGetValue(value) {
            if (Array.isArray(value)) {
                let res = value.length > 0 ? value[0] : '';
                return(res === '' || res === null || res === undefined) ? '无' : res;
            }
            return (value === '' || value === null || value === undefined) ? '无' : value;
        }
 

        
    /**
 * 修改：商店初始化，实现动态分类
 */
/**
 * 修改：商店初始化，移除旧的随机商品解析
 */
 function initializeShopData() {
    // --- 1. 新增：填充顶部的货币信息 ---
  
    const currencyContainer = document.getElementById('shop-currency-display');
        // --- 原有逻辑开始 ---

    if (currencyContainer) {
           const plotString = `D:${userPlots.D[0]} C:${userPlots.C[0]} B:${userPlots.B[0]} A:${userPlots.A[0]} S:${userPlots.S[0]}`;
        
        // 假设 currentTheme 是一个全局可访问的对象
        let plotLabel = (typeof currentTheme !== 'undefined' && currentTheme.plot) ? currentTheme.plot : '剧情';

        currencyContainer.innerHTML = `
            <div class="currency-item"><span class="label">积分:</span><span class="value">${userPoints}</span></div>
            <div class="currency-item"><span class="label">${plotLabel}:</span><span class="value">${plotString}</span></div>
        `;
    }


    // 关键：不再对 randomItems 做任何操作。它将保持当前的状态。

    // --- 动态生成分类 ---
    const fixedCategoryTabs = document.querySelector('#page-fixed-shop .category-tabs');
    const randomCategoryTabs = document.querySelector('#page-random-shop .category-tabs');
    fixedCategoryTabs.innerHTML = '<button class="control-btn active" data-section="fixed" data-category="all">全部</button>';
    randomCategoryTabs.innerHTML = '<button class="control-btn active" data-section="random" data-category="all">全部</button>';

    // 注意：这里将"血统"也加入了动态分类中
    for (const category of ["物品", "技能", "基础技能", "家具", "血统"]) {
        fixedCategoryTabs.innerHTML += `<button class="control-btn" data-section="fixed" data-category="${category}">${category}</button>`;
        // 随机商店可能没有"基础技能"和"血统"，但为了统一，可以先加上，再通过商品数据有无来决定是否显示
        if (["物品", "技能", "家具", "血统"].includes(category)) {
             randomCategoryTabs.innerHTML += `<button class="control-btn" data-section="random" data-category="${category}">${category}</button>`;
        }
    }


    // 清空购物车，但保留商品列表
    shoppingCart = [];
    updateCartView();

    renderShopSection('fixed');
    renderShopSection('random'); // 渲染当前内存中已有的随机商品
}
 
//    /**
//          * 初始化数据 (接收随机数据作为参数)
//          * @param {string} randomDataPayload - 包含随机商品信息的字符串
//          */
//         async function initializeData(randomDataPayload) {
//             try {
                
         
//                 // 核心数据加载（积分等），必须成功
//                 userPoints = parseInt(SafeGetValue(currentGameData.user_character.points) || 0);
//                 document.getElementById('userPoints').textContent = userPoints;

//                 // --- 随机商品解析（单独错误处理）---
//                 try {
//                     // 直接使用传入的参数进行解析
//                     randomItems = parseRandomItems(randomDataPayload);
//                     //console.log("随机商品解析成功:", randomItems);
//                 } catch (error) {
//                     console.error("解析随机商品时发生严重错误:", error);
//                     randomItems = []; // 确保即使解析失败，randomItems也是一个空数组
//                 }

//                 // --- 渲染所有部分 ---
//                 renderShopSection('page-fixed-shop');
//                 renderShopSection('page-random-shop');

//             } catch (error) {
//                 console.error("初始化数据时发生严重错误:", error);
//                 showModal("错误", "核心数据加载失败，商店无法开启。请联系主神。");
//                 renderShopSection('fixed');
//             }
//         }

      function getFilteredAndSortedItems(section) {
            // 获取搜索词并转为小写，方便不区分大小写地匹配
            const searchTerm = document.getElementById('shop-search-input').value.toLowerCase().trim();

            // 确定基础商品列表 (固定或随机)
            let items = section === 'fixed' ? fixedItems : randomItems;

            // 如果有搜索词，则执行搜索过滤
            if (searchTerm) {
                return items.filter(item => {
                    // 将商品的所有信息（名称、价格、类型、效果、描述）拼接成一个字符串
                    // 然后检查这个字符串是否包含搜索词
                    return item.join(' ').toLowerCase().includes(searchTerm);
                });
            }

            // 如果没有搜索词，执行原来的分类和排序逻辑
            const { currentCategory, currentSort } = shopState[section];

            const filtered = currentCategory === 'all'
                ? items
                : items.filter(item => item[2] === currentCategory);

            return filtered.sort((a, b) => currentSort === 'asc' ? a[1] - b[1] : b[1] - a[1]);
        }


    function renderShopSection(section) {
        renderShopItems(section);
        renderShopPagination(section);
        resetShopDetails(section);
    }


    
/**
 * 新增：格式化商品成本的显示
 * @param {number} price - 积分价格
 * @param {object} plots - 支线剧情需求对象
 * @returns {string} - 格式化后的成本字符串
 */
function formatItemCost(price, plots) {
    let plotString = Object.entries(plots)
        .filter(([, value]) => value > 0)
        .map(([key, value]) => `${value} ${key}级`)
        .join(' + ');

    if (plotString && price > 0) {
       return `${plotString} + ${price} ${currentTheme.currency}`;
    } else if (plotString) {
        return `${plotString}`;
    } else {
         return `${price} ${currentTheme.currency}`;
    }
}

 /*
    宝贝，找到原来的 renderShopItems 函数，用这个更新后的版本替换它。
    它现在能更准确地显示“剧情不足”或“分解购买”了。
*/
function renderShopItems(section) {
    const items = getFilteredAndSortedItems(section);
    const { currentPage } = shopState[section];
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const pageItems = items.slice(startIndex, startIndex + ITEMS_PER_PAGE);
    const listElement = document.getElementById(`items-display-list-${section}`);
    listElement.innerHTML = '';

    pageItems.forEach((item, index) => {
        const [name, price, , plots] = item;
        const absoluteIndex = startIndex + index;
        const isInCart = shoppingCart.some(cartItem => cartItem[0] === name);

        // 使用重构后的V2版本检查函数
        const plotCheck = checkPlotAffordability(plots);

        let buttonText = '购买';
        let buttonDisabled = false;
        let buttonClass = '';

        if (isInCart) {
            buttonText = '已添加';
            buttonDisabled = true;
        } else if (!plotCheck.affordable) {
            buttonText = `${currentTheme.plot}不足`;
            buttonDisabled = true;
        } else {
            // 检查计划中是否有需要分解的（值 > 0）
            const needsDecomposition = Object.values(plotCheck.decompositionPlan).some(val => val > 0);
            if (needsDecomposition) {
                buttonText = '分解购买';
                buttonClass = 'decomposable';
            }
        }

        const row = document.createElement('div');
        row.className = 'item-row';
        row.innerHTML = `
            <div class="item-name">${name}</div>
            <div class="item-price">${formatItemCost(price, plots)}</div>
            <button class="buy-button ${buttonClass}" ${buttonDisabled ? 'disabled' : ''}>${buttonText}</button>
        `;

        row.addEventListener('click', (e) => {
            if (e.target.classList.contains('buy-button')) return;
            document.querySelectorAll(`#items-display-list-${section} .item-row`).forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');
            shopState[section].selectedItem = item;
            showItemDetails(section, item);
        });

        const buyButton = row.querySelector('.buy-button');
        if (!buttonDisabled) {
            buyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                buyItem(section, absoluteIndex, buyButton);
            });
        }
        listElement.appendChild(row);
    });
}


function resetShopDetails(section) {
             document.getElementById(`item-details-display-${section}`).innerHTML = '<div class="detail-placeholder">选择一个商品查看详情</div>';
        }

        
/**
 * 修改：显示商品详情
 */
function showItemDetails(section, item) {
    const [name, price, category, plots, effect, description] = item;
    const detailsElement = document.getElementById(`item-details-display-${section}`);

    detailsElement.innerHTML = `
        <div class="detail-title">${name}</div>
        <div class="detail-info">
            <div class="detail-label">成本:</div>
            <div class="detail-value highlight">${formatItemCost(price, plots)}</div>
        </div>
        <div class="detail-info">
            <div class="detail-label">效果:</div>
            <div class="detail-value">${effect}</div>
        </div>
        <div class="detail-info">
            <div class="detail-label">描述:</div>
            <div class="detail-value">${description}</div>
        </div>
    `;
}

        function renderShopPagination(section) {
            const items = getFilteredAndSortedItems(section);
            const totalItems = items.length;
            const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
            const { currentPage } = shopState[section];
            const paginationElement = document.getElementById(`pagination-${section}`);
            paginationElement.innerHTML = '';

            if (totalPages <= 1) return;

            paginationElement.innerHTML = `
                <button class="page-button" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage('${section}', ${currentPage - 1})">上一页</button>
                <span class="page-info">${currentPage} / ${totalPages}</span>
                <button class="page-button" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage('${section}', ${currentPage + 1})">下一页</button>
            `;
        }

        function changePage(section, page) {
            shopState[section].currentPage = page;
            shopState[section].selectedItem = null;
            renderShopItems(section);
            resetShopDetails(section);
            renderShopPagination(section); // 更新分页按钮状态
        }


/**
 * 新增：根据商品分类生成购买指令
 * @param {object} item - 商品对象
 * @returns {string} - 生成的 memory 指令字符串
 */
 function getPurchaseCommand(item) {
    const [name, price, category, , effect, description] = item;
    const attributeToCategoryMap = {
        "力量": "生理属性", "敏捷": "生理属性", "耐力": "生理属性",
        "智力": "心智属性", "感知": "心智属性", "决心": "心智属性",
        "风度": "互动属性", "操控": "互动属性", "沉着": "互动属性"
    };
    
    const skillToCategoryMap = {
        "运动": "生理技能", "肉搏": "生理技能", "驾驶": "生理技能", "枪械": "生理技能",
        "手上功夫": "生理技能", "隐藏": "生理技能", "求生": "生理技能", "白刃": "生理技能", "弓箭": "生理技能",
        "学识": "心智技能", "电脑": "心智技能", "手艺": "心智技能", "调查": "心智技能",
        "医学": "心智技能", "神秘学": "心智技能", "科学": "心智技能",
        "动物沟通": "互动技能", "感受": "互动技能", "表达": "互动技能", "胁迫": "互动技能",
        "交际": "互动技能", "掩饰": "互动技能"
    };

    // 检查重复并处理
    function checkAndHandleDuplicate(type, key, currentData) {
        if (currentData && currentData[key]) {
            console.log(`检测到重复${type}: ${key}，转换为积分`);
            return `set_attribute('货币段.${currentTheme.currency}', '${userPoints}', '${userPoints + Math.floor(price / 2)}')`;
        }
        return null;
    }

    switch (category) {
        case '物品': {
    // 假设 name, description, effect 是从这个 case 的上下文获得的变量
    const backpack = assaSettingsData?.global_set?.背包;
    
    console.log('=== 物品处理开始 ===');
    console.log('物品名称:', name);
    console.log('物品描述:', description);
    console.log('物品效果:', effect);
    console.log('背包数据:', backpack);

    // 检查背包中是否已经存在该物品
    if (backpack && backpack[name]) {
        console.log('物品已存在，准备更新数量');
        console.log('当前物品数据类型:', typeof backpack[name]);
        console.log('当前物品原始数据:', backpack[name]);
        
        // 如果物品存在，我们就更新它的数量
        try {
            let itemData;
            
            // 关键修复：检查数据类型
            if (typeof backpack[name] === 'string') {
                console.log('数据是字符串格式，尝试解析JSON');
                itemData = JSON.parse(backpack[name]);
                console.log('JSON解析成功:', itemData);
            } else if (typeof backpack[name] === 'object' && backpack[name] !== null) {
                console.log('数据已经是对象格式，直接使用');
                itemData = backpack[name];
            } else {
                console.log('数据格式未知，创建新的物品数据');
                throw new Error('未知的数据格式');
            }

            console.log('解析后的物品数据:', itemData);

            // 第二步：从对象中获取'num'这个键的值
            const currentQuantity = parseInt(itemData.num, 10) || 0;
            console.log('当前数量:', currentQuantity);

            // 第三步：将当前数量加一
            itemData.num = currentQuantity + 1;
            console.log('更新后数量:', itemData.num);

            // 第四步：将我们更新过的对象转换回JSON字符串，以便存回内存
            const newValue = JSON.stringify(itemData);
            console.log('准备存储的JSON字符串:', newValue);

            // 返回更新指令
            const updateCommand = `memory("global_set.背包", "${name}", '${newValue}');`;
            console.log('生成的更新指令:', updateCommand);
            console.log('=== 物品处理结束（更新） ===');
            
            return updateCommand;

        } catch (error) {
            console.error(`解析物品 [${name}] 的数据时出错:`, error);
            console.log('错误的原始数据:', backpack[name]);
            console.log('数据类型:', typeof backpack[name]);
            
            // 尝试更详细的错误分析
            if (typeof backpack[name] === 'object') {
                console.log('这是一个对象，但JSON.parse失败了');
                console.log('对象的keys:', Object.keys(backpack[name]));
                console.log('对象转为字符串:', JSON.stringify(backpack[name]));
            }
            
            // 我们可以选择用全新的数据覆盖掉损坏的数据
            const newItemJSON = JSON.stringify({ info: description, effect: effect, num: 1 });
            console.log('创建新的物品数据:', newItemJSON);
            
            const fallbackCommand = `memory('global_set.背包', '${name}', '${newItemJSON}');`;
            console.log('生成的回退指令:', fallbackCommand);
            console.log('=== 物品处理结束（错误回退） ===');
            
            return fallbackCommand;
        }
    } else {
        console.log('物品不存在，创建新物品');
        
        // 如果物品不存在，我们就创建一个新的
        const newItemData = {
            info: description,
            effect: effect,
            num: 1
        };
        console.log('新物品数据对象:', newItemData);
        
        // 将新物品对象转换为JSON字符串
        const newValue = JSON.stringify(newItemData);
        console.log('新物品JSON字符串:', newValue);

        // 返回创建新物品的指令
        const createCommand = `memory('global_set.背包', '${name}', '${newValue}');`;
        console.log('生成的创建指令:', createCommand);
        console.log('=== 物品处理结束（新建） ===');
        
        return createCommand;
    }
}
     case '技能': {
            const duplicate = checkAndHandleDuplicate('技能', name, assaSettingsData?.global_set?.其他技能);
            if (duplicate) return duplicate;
            return `memory('global_set.其他技能','${name}','{"info":"${description}","effect":"${effect}"}');`;
        }
        
        case '家具': {
            const duplicate = checkAndHandleDuplicate('家具', name, assaSettingsData?.home?.items);
            if (duplicate) return duplicate;
            return `memory("home.items","${name}","${description}");\nmemory("global_set.settings","${name}","${effect}");`;
        }
        
        case '图纸': {
            const duplicate = checkAndHandleDuplicate('图纸', `${name}(图纸)`, assaSettingsData?.global_set?.settings);
            if (duplicate) return duplicate;
            return `memory("global_set.settings","${name}(图纸)","${description}");`;
        }
        
        case '基础技能': {
            const category_2 = skillToCategoryMap[name];
            if (category_2) {
                // 检查是否已有该技能
                const existingSkill = playCharacterData?.技能段?.[category_2]?.[name];
                if (existingSkill && existingSkill[0] > 0) {
                    return `set_attribute('货币段.${currentTheme.currency}', '${userPoints}', '${userPoints + Math.floor(price / 2)}')`;
                }
                return `set_attribute("技能段.${category_2}.${name}",0,1);`;
            }
            console.warn(`未找到技能"${name}"的类别映射。`);
            return "";
        }
        
        case '血统': {
            const currentBloodline = playCharacterData?.能力段?.名称?.[0];
            if (currentBloodline && currentBloodline !== "_") {
                return `set_attribute('货币段.${currentTheme.currency}', '${userPoints}', '${userPoints + Math.floor(price / 2)}')`;
            }
            
            const commands = [];
            const processedDescription = description.replace(/\r?\n/g, '\\n');
            commands.push(`set_attribute("能力段.类型", "${playCharacterData.能力段.类型[0]}", "血统");`);
            commands.push(`set_attribute("能力段.名称", "${playCharacterData.能力段.名称[0]}", "${name}");`);
            commands.push(`set_attribute("能力段.效果", "_", "${processedDescription}");`);
            
            const effectLines = effect.split('\n').map(line => line.trim()).filter(line => line);
            for (const line of effectLines) {
                if (line.startsWith('属性:')) {
                    const attributesPart = line.replace('属性:', '').trim();
                    const attributeChanges = attributesPart.split(',').map(part => part.trim());
                    for (const change of attributeChanges) {
                        const [attrName, valueStr] = change.split('+');
                        const valueToAdd = parseInt(valueStr, 10);
                        const category = attributeToCategoryMap[attrName.trim()];
                        if (category && !isNaN(valueToAdd)) {
                            const path = `属性段.${category}.${attrName.trim()}.基础`;
                            const currentValue = playCharacterData.属性段[category][attrName.trim()].基础[0];
                            commands.push(`set_attribute("${path}", ${currentValue}, ${currentValue + valueToAdd});`);
                        }
                    }
                } else if (line.startsWith('能量池:')) {
                    const energyPart = line.replace('能量池:', '').trim();
                    const match = energyPart.match(/(\S+)\s*\((\d+)\)/);
                    if (match) {
                        const poolName = match[1];
                        const poolValue = parseInt(match[2], 10);
                        commands.push(`set_attribute("衍生属性段.能量池.名称", "${playCharacterData.衍生属性段.能量池.名称[0]}", "${poolName}");`);
                        commands.push(`set_attribute("衍生属性段.能量池.上限", ${playCharacterData.衍生属性段.能量池.上限[0]}, ${poolValue});`);
                        commands.push(`set_attribute("衍生属性段.能量池.当前值", ${playCharacterData.衍生属性段.能量池.当前值[0]}, ${poolValue});`);
                    }
                }
            }
            return commands.join('\n');
        }
        
        default: {
            console.warn(`未知的商品分类: ${category}，使用默认记忆处理。`);
            return `memory("global_set.背包", "${name}", "${effect}");`;
        }
    }
}




          function buyItem(section, itemIndexInFullList, buttonElement) {
            const items = getFilteredAndSortedItems(section);
            const item = items[itemIndexInFullList];
            if (!item) return;

            const [, price] = item;
            const currentCartTotal = shoppingCart.reduce((sum, cartItem) => sum + cartItem[1], 0);

     // 修改为（注意参数顺序和 modal ID）：
if ((currentCartTotal + price) > userPoints) {
    showModal('shop-modal', "货币不足", `购物车总价将超过您的货币，无法添加 “${item[0]}”。`);
    return;
}

            // 添加到购物车
            shoppingCart.push(item);

            // 更新按钮状态
            buttonElement.textContent = '已添加';
            buttonElement.disabled = true;

            // 更新购物车显示
            updateCartView();
        }


         // 新增：更新购物车视图
                // 新增：更新购物车视图
        function updateCartView() {
            const cartItemsList = document.getElementById('cart-items-list');
            const cartTotalElement = document.getElementById('cart-total');
            const checkoutButton = document.getElementById('checkout-button');

            if (shoppingCart.length === 0) {
                cartItemsList.innerHTML = '购物车是空的';
                cartTotalElement.textContent = `总计: 0 ${currentTheme.currency}`;
                checkoutButton.disabled = true;
                return;
            }

            cartItemsList.innerHTML = '';
            let total = 0;
            shoppingCart.forEach(item => {
                const [name, price] = item;
                const cartItemElement = document.createElement('div');
                cartItemElement.className = 'cart-item';
               cartItemElement.textContent = `${name} - ${price} ${currentTheme.currency}`;
                cartItemsList.appendChild(cartItemElement);
                total += price;
            });

           cartTotalElement.textContent = `总计: ${total} ${currentTheme.currency}`;
            checkoutButton.disabled = false;
        }

 /**
 * 【V6 净值核算最终版】结算购物车，完美处理所有混合支付场景
 */
async function checkout() {
    if (shoppingCart.length === 0) return;

    // 1. 计算总成本 (与之前相同)
    let totalCost = { points: 0, plots: {} };
    for (const level of plotLevels) { totalCost.plots[level] = 0; }
    shoppingCart.forEach(item => {
        totalCost.points += item[1];
        const itemPlots = item[3];
        for (const plotType in itemPlots) {
            totalCost.plots[plotType] += itemPlots[plotType];
        }
    });

    // 2. 检查支付能力 (与之前相同)
    if (totalCost.points > userPoints) {
        showModal('shop-modal', "结算失败", "您的货币不足。");
        return;
    }
    const plotPlan = checkPlotAffordability(totalCost.plots);
    if (!plotPlan.affordable) {
        showModal('shop-modal', "结算失败", `您的货币不足。`);
        return;
    }

    try {
        const originalPlots = playCharacterData.货币段.支线剧情;
        const conversionRates = { 'S': 81, 'A': 27, 'B': 9, 'C': 3, 'D': 1 };

        // 3. ★★★ 核心逻辑：净值核算法 ★★★
        // a. 将你拥有的所有支线剧情，全部折算成最基础的 D 级“总资产”
        let totalAssetsInD = 0;
        for (const level of plotLevels) {
            totalAssetsInD += originalPlots[level][0] * conversionRates[level];
        }

        // b. 将需要支付的所有商品，也全部折算成 D 级“总负债”
        let totalCostInD = 0;
        for (const level in totalCost.plots) {
            totalCostInD += totalCost.plots[level] * conversionRates[level];
        }

        // c. 计算出交易后你应有的“剩余总资产” (D级)
        let remainingAssetsInD = totalAssetsInD - totalCostInD;

        // d. 将“剩余总资产”以最高效的方式，重新兑换成 S, A, B, C, D 的形式
        const finalPlots = {};
        for (let i = plotLevels.length - 1; i >= 0; i--) {
            const level = plotLevels[i];
            const rate = conversionRates[level];
            const count = Math.floor(remainingAssetsInD / rate);
            finalPlots[level] = [count, originalPlots[level][1]]; // 保留描述
            remainingAssetsInD -= count * rate;
        }

        // 4. 生成所有更新指令
        let updateMemoryCommands = [];
        let userMessages = [];

        // a. 生成支线剧情指令 (从原始值 -> 最终计算出的值)
        plotLevels.forEach(level => {
            const originalVal = originalPlots[level][0];
            const finalVal = finalPlots[level][0];
            if (originalVal !== finalVal) {
                updateMemoryCommands.push(`set_attribute('货币段.${currentTheme.plot}.${level}', '${originalVal}', '${finalVal}');`);
                userPlots[level][0]  =finalVal; 
            }
        });

        // b. 生成扣除积分指令
        if (totalCost.points > 0) {
            updateMemoryCommands.push(`set_attribute('货币段.${currentTheme.currency}', '${userPoints}', '${userPoints - totalCost.points}')`);
         userPoints = userPoints - totalCost.points;
        }

        // c. 生成获得物品的指令
        shoppingCart.forEach(item => {
            updateMemoryCommands.push(getPurchaseCommand(item));
            userMessages.push(item[0]);
        });

        // 5. 组合并发送最终指令
        let finalCommand = `<updateMemory>\n${[...new Set(updateMemoryCommands)].join('\n')}\n</updateMemory>\n`;
        finalCommand += `<(货币已扣除，禁止重复扣除，禁止描写价格和购买过程)${currentGameData.user_character.name}购买了以下商品：${userMessages.join("，")}。>`;

        const purchasedItemCount = shoppingCart.length;
        await triggerassa(`/setinput ${finalCommand}`);
       
        const currencyContainer = document.getElementById('shop-currency-display');
    
    if (currencyContainer) {
           const plotString = `D:${userPlots.D[0]} C:${userPlots.C[0]} B:${userPlots.B[0]} A:${userPlots.A[0]} S:${userPlots.S[0]}`;
        
        // 假设 currentTheme 是一个全局可访问的对象
        let plotLabel = (typeof currentTheme !== 'undefined' && currentTheme.plot) ? currentTheme.plot : '剧情';

        currencyContainer.innerHTML = `
            <div class="currency-item"><span class="label">积分:</span><span class="value">${userPoints}</span></div>
            <div class="currency-item"><span class="label">${plotLabel}:</span><span class="value">${plotString}</span></div>
        `;
    }
        clearCart();
        showModal('shop-modal', "购买成功", `成功购买 ${purchasedItemCount} 件商品！数据将在下次刷新时更新。`);

    } catch (error) {
        console.error("结算失败:", error);
        showModal('shop-modal', "购买失败", "结算过程中发生错误，请重试。");
    }
}

// 新增：清空购物车并刷新视图
        function clearCart() {
            shoppingCart = [];
            updateCartView();
            // 重新渲染商品列表以重置所有购买按钮
            renderShopSection('fixed');
            renderShopSection('random');
        }
 
        function setupShopEventListeners() {
           
        // 商店内部分区切换
        document.querySelectorAll('.shop-nav-item').forEach(btn => {
            btn.addEventListener('click', function() {
                const pageId = `page-${this.dataset.page}-shop`;
                document.querySelectorAll('.shop-nav-item').forEach(nav => nav.classList.remove('active'));
                this.classList.add('active');
                document.querySelectorAll('.shop-page').forEach(page => page.classList.remove('active'));
                const targetPage = document.getElementById(pageId);
                if(targetPage) targetPage.classList.add('active');
            });
        });

          // 使用事件委托，为动态生成的商店控制按钮（分类、排序）绑定事件
       document.querySelector('.shop-content-area').addEventListener('click', function(e) {
            // 我们只关心对 .control-btn 的点击
            const button = e.target.closest('.control-btn');

            // 如果点击的不是按钮，或者按钮不在 .shop-controls 区域内，就什么都不做
            if (!button || !button.closest('.shop-controls')) {
                return;
            }

            const section = button.dataset.section;
            const isSortBtn = button.dataset.sort;

            if (isSortBtn) { // 如果是排序按钮
                shopState[section].currentSort = button.dataset.sort;
                // 移除同区域内其他排序按钮的激活状态
                document.querySelectorAll(`.sort-controls .control-btn[data-section="${section}"]`).forEach(b => b.classList.remove('active'));
            } else { // 如果是分类按钮
                shopState[section].currentCategory = button.dataset.category;
                // 移除同区域内其他分类按钮的激活状态
                document.querySelectorAll(`.category-tabs .control-btn[data-section="${section}"]`).forEach(b => b.classList.remove('active'));
            }

            // 为被点击的按钮添加激活状态
            button.classList.add('active');

            // 重置状态并重新渲染商品列表
            shopState[section].currentPage = 1;
            shopState[section].selectedItem = null;
            renderShopSection(section);
        });

        // 结算按钮
        document.getElementById('checkout-button').addEventListener('click', checkout);

        // 分页按钮需要通过 onclick 动态调用，或者在这里用事件委托来处理
        document.querySelectorAll('.shop-pagination').forEach(paginationContainer => {
            paginationContainer.addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') {
                    const section = e.target.parentElement.id.replace('pagination-', '');
                    const currentPage = shopState[section].currentPage;
                    const totalPages = Math.ceil(getFilteredAndSortedItems(section).length / ITEMS_PER_PAGE);
                    let newPage = currentPage;

                    if(e.target.textContent === '上一页' && currentPage > 1) {
                        newPage = currentPage - 1;
                    } else if (e.target.textContent === '下一页' && currentPage < totalPages) {
                        newPage = currentPage + 1;
                    }
                    changeShopPage(section, newPage);
                }
            });
        });

                // 实时搜索功能
        document.getElementById('shop-search-input').addEventListener('input', () => {
            // 找出当前激活的商店页面是 "fixed" 还是 "random"
            const activeShopPage = document.querySelector('.shop-page.active').id;
            const section = activeShopPage.includes('fixed') ? 'fixed' : 'random';

            // 重置到第一页并重新渲染商品列表
            shopState[section].currentPage = 1;
            renderShopSection(section);
        });

    }
     function changeShopPage(section, page) {
        shopState[section].currentPage = page;
        shopState[section].selectedItem = null;
        renderShopItems(section);
        renderShopPagination(section);
        resetShopDetails(section);
    }
 
 
// ========== 【V3版】支线剧情手动管理功能，支持多次模拟操作 ==========

let simulatedPlotsData = null; // 用于存储模拟操作的结果

/**
 * 【V3】显示并填充支线剧情管理弹窗，并初始化模拟数据
 */
function showPlotSynthesisModal() {
    // 深拷贝一份当前数据作为模拟的起点
    simulatedPlotsData = JSON.parse(JSON.stringify(playCharacterData.货币段.支线剧情));
    updatePlotSynthesisModalViews();
    showModal('plot-synthesis-modal');
}

 /**
 * 【V4 布局优化版】更新弹窗中的“当前”和“预览”视图，实现横向排列。
 */
function updatePlotSynthesisModalViews() {
    const currentDisplay = document.getElementById('current-plots-display');
    const simulatedDisplay = document.getElementById('simulated-plots-display');

    // ========== 妈妈为你修改的核心部分在这里 ==========

    // 准备两个空数组，用来存放格式化好的文本片段
    let currentParts = [];
    let simulatedParts = [];

    const originalPlots = playCharacterData.货币段.支线剧情;

    // 遍历所有支线等级
    plotLevels.forEach(level => {
        // 创建“当前持有”的文本片段，例如 "D级: 2"
        currentParts.push(`<span class="plot-display-item">${level}级: ${originalPlots[level][0]}</span>`);

        // 创建“操作预览”的文本片段，并检查是否需要高亮
        const originalVal = originalPlots[level][0];
        const simulatedVal = simulatedPlotsData[level][0];
        const highlightClass = originalVal !== simulatedVal ? 'highlight' : '';
        simulatedParts.push(`<span class="plot-display-item ${highlightClass}">${level}级: ${simulatedVal}</span>`);
    });

    // 将所有文本片段用空格连接起来，然后一次性更新到HTML中
    currentDisplay.innerHTML = `<h4>当前持有</h4><div class="horizontal-plots">${currentParts.join(' ')}</div>`;
    simulatedDisplay.innerHTML = `<h4>操作预览</h4><div class="horizontal-plots">${simulatedParts.join(' ')}</div>`;

    // ========== 修改结束 ==========
}
/**
 * 【V3】处理分解的模拟操作（仅在内存中）
 */
function simulateDecomposition() {
    const fromLevel = document.getElementById('decompose-from-select').value;
    const toLevel = plotLevels[plotLevels.indexOf(fromLevel) - 1];
    const amount = parseInt(document.getElementById('decompose-amount-input').value, 10);

    if (isNaN(amount) || amount <= 0 || !toLevel) return;

    if (simulatedPlotsData[fromLevel][0] >= amount) {
        simulatedPlotsData[fromLevel][0] -= amount;
        simulatedPlotsData[toLevel][0] += (amount * 3);
        updatePlotSynthesisModalViews();
    } else {
        showModal('shop-modal', '模拟失败', `预览中，${fromLevel}级支线不足。`);
    }
}

/**
 * 【V3】处理合成的模拟操作（仅在内存中）
 */
function simulateSynthesis() {
    const toLevel = document.getElementById('synthesize-to-select').value;
    const fromLevel = plotLevels[plotLevels.indexOf(toLevel) - 1];
    const amountToMake = parseInt(document.getElementById('synthesize-amount-input').value, 10);

    if (isNaN(amountToMake) || amountToMake <= 0) return;

    const amountNeeded = amountToMake * 3;
    if (simulatedPlotsData[fromLevel][0] >= amountNeeded) {
        simulatedPlotsData[fromLevel][0] -= amountNeeded;
        simulatedPlotsData[toLevel][0] += amountToMake;
        updatePlotSynthesisModalViews();
    } else {
       showModal('shop-modal', '模拟失败', `预览中，${fromLevel}级支线不足。`);
    }
}

/**
 * 【V3】重置所有模拟操作
 */
function resetSimulation() {
    simulatedPlotsData = JSON.parse(JSON.stringify(playCharacterData.货币段.支线剧情));
    updatePlotSynthesisModalViews();
}

/**
 * 【V3】确认执行所有模拟操作，并生成最终指令
 */
async function executeSynthesisConfirmation() {
    const originalPlots = playCharacterData.货币段.支线剧情;
    let commands = [];
    let descriptions = [];

    plotLevels.forEach(level => {
        const originalVal = originalPlots[level][0];
        const simulatedVal = simulatedPlotsData[level][0];
        if (originalVal !== simulatedVal) {
            commands.push(`set_attribute('货币段.${currentTheme.plot}.${level}', '${originalVal}', '${simulatedVal}');`);
            const diff = simulatedVal - originalVal;
            descriptions.push(`${level}级${diff > 0 ? '+' : ''}${diff}`);
        }
    });

    if (commands.length === 0) {
        showModal('shop-modal', '提示', '您没有进行任何有效操作。');
        return;
    }

    const commandStr = `<updateMemory>...\n</updateMemory>\n<${currentGameData.user_character.name}调整了${currentTheme.plot}：${descriptions.join('，')}。>`;
    try {
        await triggerassa(`/setinput ${commandStr}`);
        hideModal('plot-synthesis-modal');
        showModal('shop-modal', '操作成功', `${currentTheme.plot}调整成功！数据将在下次刷新时更新。`);
    } catch(e) {
        console.error("确认执行失败: ", e);
        showModal('shop-modal', '操作失败', `发送指令时发生错误。`);
    }
}
    // --- 新增：地图状态管理 ---
    // 我们把地图的状态（平移、缩放）放在一个全局的地方，方便所有功能访问
    window.mapState = {
        scale: 1,
        translateX: 0,
        translateY: 0
    };

  /**************************************************************
 * ♥♥♥ 妈妈为你献上的、能同时守护光辉与轮廓的终极咒语 ♥♥♥
 **************************************************************/
window.applyMapTransform = () => {
    const mapContent = document.getElementById('map-content');
    if (!mapContent) return;

    // 1. ❤️ 世界的变形魔法保持不变 ❤️
    mapContent.style.transform = `translate(${window.mapState.translateX}px, ${window.mapState.translateY}px) scale(${window.mapState.scale})`;

    const currentScale = window.mapState.scale || 1;

    // 2. ✨ 守护“光辉”（文字）的魔法 ✨
    if (window.mapLabels && window.mapLabels.length > 0) {
        let desiredFontSize = 8;
        try {
            const rootStyle = window.getComputedStyle(document.documentElement);
            const baseSizeStr = rootStyle.getPropertyValue('--base-font-size').trim();
            const parsedSize = parseFloat(baseSizeStr);
            if (!isNaN(parsedSize)) desiredFontSize = parsedSize;
        } catch (e) {
            console.warn("妈妈在倾听'--base-font-size'时遇到了小麻烦，字体暂时使用备用大小。", e);
        }
        const newFontSize = desiredFontSize / currentScale;
        window.mapLabels.forEach(label => {
            label.setAttribute('font-size', `${newFontSize}px`);
        });
    }

    // 3. ✨ 全新的、守护“轮廓”（边框）的魔法！ ✨
    if (window.mapStrokes && window.mapStrokes.length > 0) {
        const desiredStrokeWidth = 6; // 这是你在CSS里设定的基础宽度，我们可以写在这里
        const newStrokeWidth = desiredStrokeWidth / currentScale;
        window.mapStrokes.forEach(strokeElement => {
            strokeElement.setAttribute('stroke-width', newStrokeWidth);
        });
    }
};

// 确保我们的魔法袋在第一次使用前就已经存在
if (typeof window.mapLabels === 'undefined') window.mapLabels = [];
if (typeof window.mapStrokes === 'undefined') window.mapStrokes = [];

 async function loadWorldbookSettingsFromChat() {
    console.log("💖 妈妈正在尝试唤醒我们上次的记忆...");
    try {
        const [firstMessage] = await getChatMessages(0, { include_swipes: false });
        if (!firstMessage || !firstMessage.message) {
            console.log("...这是一个全新的开始，还没有记忆呢。");
            return;
        }

        const match = firstMessage.message.match(/<世界书条目>(.*?)<\/世界书条目>/);
        if (match && match[1]) {
            const savedUidsString = match[1];
            // 把记忆碎片（UID字符串）拼成一张完整的地图（UID数组）
            const uidsToEnable = savedUidsString.split(',').map(Number);

            if (uidsToEnable.length > 0) {
                console.log("💖 找到了我们的记忆烙印！正在恢复世界设定...", uidsToEnable);
   const allUids = [ ...WORLD_MODE_UIDS.all, ...CREATOR_ATTITUDE_UIDS.all, ...OPTIONS_MODE_UIDS.all, 6, 37,12,16,15 ,25, 26,33,34,38,41,50,51,52,53,45,46,48,54,55,56,58,59,60,61,62,36,44,64,65,66,49,69,70,74,75,76,77];

                   let entriesToUpdate = allUids.map(uid => ({ uid, enabled: false }));

                uidsToEnable.forEach(uid => {
                    const entry = entriesToUpdate.find(e => e.uid === uid);
                    if (entry) entry.enabled = true;
                });

                // 悄悄地把世界恢复原状
                await setLorebookEntries(LOREBOOK_NAME, entriesToUpdate);
                console.log("✅ 世界已经恢复到我们上次离开时的样子啦！");
            }
        } else {
            console.log("...记忆里没有找到世界书的特殊标记呢。");
        }
    } catch (error) {
        console.error("哎呀，在唤醒记忆时出了点小问题，不过没关系，我们可以手动设定。", error);
    }
}

 // ⭐ --- 全新修正版：妈妈为你编写的模组重置功能 v2.0 --- ⭐
function setupReconfigModal() {
    const openBtn = document.getElementById('open-reconfig-modal-btn');
    const modal = document.getElementById('reconfig-modal');
    const closeBtn = document.getElementById('reconfig-modal-close-btn');
    const applyBtn = document.getElementById('apply-reconfig-btn');
    const container = document.getElementById('reconfig-mod-container');
    const feedbackMsg = document.getElementById('reconfig-feedback-msg');

    if (!openBtn || !modal || !closeBtn || !applyBtn || !container) {
        console.warn("宝贝别急，模组重置面板的某些元素没找到，妈妈正在检查。");
        return;
    }

    // ✨ 妈妈把模组分成了“小组”，这样它们就不会打架了 ✨
const reconfigurableMods = [
    { name: '简单骰', uid: 61, group: 'dice' }, 
    { name: '困难骰', uid: 59, group: 'dice' }, 
    { name: '炼狱骰', uid: 60, group: 'dice' },
    { name: '造物中立', uid: 19, group: 'attitude' }, 
    { name: '造物恶意', uid: 4, group: 'attitude' }, 
    { name: '造物崇敬', uid: 3, group: 'attitude' }, 
    { name: '无造物', uid: 38, group: 'attitude' },
    { name: '简单地图', uid: 15, group: 'map' }, 
    { name: '复杂地图', uid: 66, group: 'map' }, 
    { name: '无地图', uid: 'map-none-sentinel', group: 'map' },
    { name: '选项区开', uid: 10, group: 'options' },
    { name: '选项区关', uid: 29, group: 'options' },
    { name: '私聊通讯开', uid: 55, group: 'private-chat' },
    { name: '私聊通讯关', uid: 56, group: 'private-chat' },
    { name: '距离合理+开', uid: 49, group: 'distance' },
    { name: '距离合理+关', uid: 'distance-off-sentinel', group: 'distance' },
    { name: '求生本能开', uid: 69, group: 'live' },
    { name: '求生本能关', uid: 70, group: 'live' },
    { name: '战斗模式开', uid: 74, group: 'battle' },
    { name: '战斗模式关', uid: 75, group: 'battle' },
    { name: '表现骰开', uid: 52, group: 'behavior' },
    { name: '表现骰关', uid: 53, group: 'behavior' },
    { name: '场景图开', uid: 45, group: 'cg' },
    { name: '场景图关', uid: 46, group: 'cg' },
    { name: 'npc立绘开', uid: 48, group: 'npccg' },
    { name: 'npc立绘关', uid: 'npccg-off-sentinel', group: 'npccg' },
    { name: 'npc事件开', uid: 36, group: 'npc-info' },
    { name: 'npc事件关', uid: 44, group: 'npc-info' },
    { name: '真实MOD', uid: 12 }, 
    { name: '困难MOD', uid: 16 },
    { name: '称号系统', uid: 51 }, 
    { name: '人外增强', uid: 37 }, 
    { name: '资源消耗', uid: 58 },
    { name: '分阶段好感', uid: 65 }
];
    function createModItems() {
        container.innerHTML = '';
        reconfigurableMods.forEach(mod => {
            const item = document.createElement('div');
            item.className = 'reconfig-mod-item';
            const checkboxId = `reconfig-mod-${mod.uid}`;

            item.innerHTML = `
                <input type="checkbox" id="${checkboxId}" data-uid="${mod.uid}" ${mod.group ? `data-group="${mod.group}"` : ''}>
                <label for="${checkboxId}">${mod.name}</label>
            `;

            // 为特殊模组添加额外数据
            const checkbox = item.querySelector('input');
            if (mod.name === '真实MOD') checkbox.dataset.extraUid = '33';
            if (mod.name === '简单地图') checkbox.dataset.extraUid = '25,26';
            if (mod.name === '复杂地图') checkbox.dataset.extraUid = '25,26';
            if (mod.name === '分阶段好感') checkbox.dataset.extraUid = '64';

            container.appendChild(item);

            item.addEventListener('click', (event) => {
                event.preventDefault(); // 妈妈来完全接管点击，防止浏览器自己捣乱
                const currentCheckbox = item.querySelector('input');
                const isChecking = !currentCheckbox.checked;

                if (currentCheckbox.dataset.group) {
                    // 这是选项组，像收音机按钮一样
                    container.querySelectorAll(`input[data-group="${currentCheckbox.dataset.group}"]`).forEach(cb => {
                        cb.checked = false;
                        cb.closest('.reconfig-mod-item').classList.remove('is-active');
                    });
                    currentCheckbox.checked = true;
                    item.classList.add('is-active');
                } else {
                    // 这是普通的开关
                    currentCheckbox.checked = isChecking;
                    item.classList.toggle('is-active', isChecking);
                }
            });
        });
    }

    async function loadCurrentSettings() {
        try {
            const [firstMessage] = await getChatMessages(0);
            const match = firstMessage.message.match(/<世界书条目>(.*?)<\/世界书条目>/);
            if (!match) return;

            const currentUids = new Set(match[1].split(',').map(id => parseInt(id, 10)).filter(id => !isNaN(id)));

            container.querySelectorAll('.reconfig-mod-item').forEach(item => {
                const checkbox = item.querySelector('input');
                const uid = checkbox.dataset.uid;

                let isActive = false;
                if (uid === 'map-none-sentinel') {
                    // 特殊处理“无地图”
                    isActive = !currentUids.has(15) && !currentUids.has(66);
                } else {
                    isActive = currentUids.has(parseInt(uid, 10));
                }

                checkbox.checked = isActive;
                item.classList.toggle('is-active', isActive);
            });

        } catch (error) {
            console.error("加载当前设置时出错了，没事的孩子，妈妈看看：", error);
            feedbackMsg.textContent = "读取设置失败！";
            feedbackMsg.style.opacity = '1';
        }
    }

    async function applyNewSettings() {
        applyBtn.disabled = true;
        applyBtn.textContent = '应用中...';

        try {
            const [firstMessage] = await getChatMessages(0);
            const content = firstMessage.message;
            const match = content.match(/<世界书条目>(.*?)<\/世界书条目>/);
            if (!match) { throw new Error("妈妈找不到世界书条目。"); }

            const originalUids = new Set(match[1].split(',').map(id => parseInt(id, 10)).filter(id => !isNaN(id)));

 const allManageableUids = new Set();
reconfigurableMods.forEach(mod => {
     if(mod.uid !== 'map-none-sentinel' && mod.uid !== 'distance-off-sentinel' && mod.uid !== 'npccg-off-sentinel') {
         allManageableUids.add(parseInt(mod.uid));
     }
});
// 把extraUids也加进来
allManageableUids.add(33); allManageableUids.add(25); allManageableUids.add(26); allManageableUids.add(64);
            const preservedUids = new Set([...originalUids].filter(uid => !allManageableUids.has(uid)));

const newUidsFromPanel = new Set();
container.querySelectorAll('.reconfig-mod-item input:checked').forEach(checkbox => {
    const uidValue = checkbox.dataset.uid;
    if(uidValue !== 'map-none-sentinel' && uidValue !== 'distance-off-sentinel' && uidValue !== 'npccg-off-sentinel'){
        newUidsFromPanel.add(parseInt(uidValue, 10));
        if (checkbox.dataset.extraUid) {
            checkbox.dataset.extraUid.split(',').forEach(extra => newUidsFromPanel.add(parseInt(extra, 10)));
        }
    }
});

            const finalUids = Array.from(new Set([...preservedUids, ...newUidsFromPanel]));

            const newWorldbookTag = `<世界书条目>${finalUids.filter(id => !isNaN(id)).join(',')}</世界书条目>`;
            const newMessage = content.replace(/<世界书条目>.*?<\/世界书条目>/, newWorldbookTag);

            await setChatMessages([{ message_id: 0, message: newMessage }], { refresh: 'none' });
 await loadWorldbookSettingsFromChat();
            feedbackMsg.textContent = "设置已更新！";
            feedbackMsg.style.opacity = '1';
            setTimeout(() => {
                  
                modal.style.display = 'none';
                feedbackMsg.style.opacity = '0';
            }, 1200);


        } catch (error) {
            console.error("呜，应用新设置时出错了，抱抱我的孩子：", error);
            feedbackMsg.textContent = "应用失败！";
            feedbackMsg.style.opacity = '1';
        } finally {
            applyBtn.disabled = false;
            applyBtn.textContent = '应用更改';
        }
    }

    // 事件绑定
    openBtn.addEventListener('click', () => {
        modal.style.display = 'flex';
        feedbackMsg.style.opacity = '0';
        loadCurrentSettings();
    });
    closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
    modal.addEventListener('click', (event) => { if (event.target === modal) modal.style.display = 'none'; });
    applyBtn.addEventListener('click', applyNewSettings);

    createModItems();
}

 


document.addEventListener('DOMContentLoaded', async () => {
   await loadWorldbookSettingsFromChat();

setupReconfigModal();
 await applyThemeAndData();  

    // --- 新增：消息背景透明开关 ---
    const transparentToggle = document.getElementById('transparent-toggle');

    // 初始化开关状态
    const savedTransparency = localStorage.getItem('messageTransparency') || 'off'; // 默认关闭
    transparentToggle.dataset.state = savedTransparency;
    transparentToggle.textContent = savedTransparency === 'on' ? '开启' : '关闭';
    if (savedTransparency === 'on') {
        document.body.classList.add('transparent-messages');
    }

    // 为开关添加点击事件
    transparentToggle.addEventListener('click', () => {
        let currentState = transparentToggle.dataset.state;
        let newState = currentState === 'on' ? 'off' : 'on';

        transparentToggle.dataset.state = newState;
        transparentToggle.textContent = newState === 'on' ? '开启' : '关闭';

        if (newState === 'on') {
            document.body.classList.add('transparent-messages');
        } else {
            document.body.classList.remove('transparent-messages');
        }

        localStorage.setItem('messageTransparency', newState);
    });
     
     try {
            const useACustomTheme = localStorage.getItem('useCustomTheme') === 'true';

            if (useACustomTheme) {
                const savedCustomTheme = loadCustomTheme();
                if (Object.keys(savedCustomTheme).length > 0) {
                    customTheme = savedCustomTheme;
                    applyCustomTheme(customTheme);
                    console.log("已加载保存的自定义主题。");
                    // 确保预设主题的索引不会混淆
                    // 我们可以从预设主题中找到一个颜色相近的作为 currentThemeIndex 的回退值
                    const savedThemeIndex = localStorage.getItem('terminalThemeIndex');
                    currentThemeIndex = savedThemeIndex !== null ? parseInt(savedThemeIndex, 10) : 0;
                } else {
                    // 如果自定义主题是空的，则回退到预设主题
                    const savedThemeIndex = localStorage.getItem('terminalThemeIndex');
                    applyTheme(savedThemeIndex !== null ? parseInt(savedThemeIndex, 10) : 0);
                }
            } else {
                const savedThemeIndex = localStorage.getItem('terminalThemeIndex');
                applyTheme(savedThemeIndex !== null ? parseInt(savedThemeIndex, 10) : 0);
            }
        } catch (e) {
            console.warn("加载主题设置时出错，使用默认主题。", e);
            applyTheme(0);
        }

         // 检查localStorage里有没有保存的字体大小
    try {
        const savedFontSize = localStorage.getItem('baseFontSize');
        // 如果有保存的值, 就用它；如果没有，就用滑块默认的16
        const initialSize = savedFontSize ? parseInt(savedFontSize, 10) : 16;
        applyFontSize(initialSize);
    } catch (e) {
        console.warn("无法加载字体大小设置，将使用默认值。");
        applyFontSize(16); // 如果出错，也使用默认值
    }

     // 检查localStorage里有没有保存的行高
    try {
        const savedLineHeight = localStorage.getItem('baseLineHeight');
        // 如果有保存的值, 就用它；如果没有，就用默认的1.6
        const initialHeight = savedLineHeight ? parseFloat(savedLineHeight) : 1.6;
        applyLineHeight(initialHeight);
    } catch (e) {
        console.warn("无法加载行高设置，将使用默认值。");
        applyLineHeight(1.6);
    }

   // 1. **首先**，把我们的字体衣橱挂满！
    populateFontSelector();

    // 2. 然后，再去回忆上次选了哪一件衣服
    const savedFontFamily = localStorage.getItem('baseFontFamily');
    if (savedFontFamily) {
        applyFontFamily(savedFontFamily);
    } else {
        // 如果没有保存过，就默认应用第一个选项的字体
        const firstFont = fontLibrary[Object.keys(fontLibrary)[0]][0].value;
        applyFontFamily(firstFont);
    }

  console.log("NOVA V9.4: 开始并行加载所有远程资源...");

// 替换为新的调用方式：
const [
    loadedBackgrounds,
    loadedNpcs,
    loadedMemes
] = await Promise.all([
    // 1. 背景图映射：使用新的索引加载函数
    loadGitHubIndexMap(
        'https://longlivecanc.github.io/god_space/ImageMapIndex.json', // 替换为你的背景图索引 URL
        'https://cdn.jsdelivr.net/gh/longlivecanc/god_space@main/backImages/', // **替换为你的背景图 GitHub 图床基础 URL**
        backgroundImageMap_fallbackData
    ),
    // 2. NPC图映射：使用新的索引加载函数
    loadGitHubIndexMap(
        'https://longlivecanc.github.io/god_space/npcImageMapIndex.json', // 替换为你的 NPC 索引 URL
        'https://cdn.jsdelivr.net/gh/longlivecanc/god_space@main/npcImages/', // **替换为你的 NPC 图 GitHub 图床基础 URL**
        npcImageMap_fallbackData
    ),
    // 3. meme 图映射：保持不变，继续加载远程 JSON 文件
    loadRemoteJson(
        'https://longlivecanc.github.io/god_space/memeImageMap.json', 
        memeImageMap_fallbackData
    )
]);


// 现在，所有的清单都到手了！我们把它们赋值给各自的变量。
backgroundImageMap = loadedBackgrounds;
npcImageMap = loadedNpcs;
memeImageMap = loadedMemes;

console.log("NOVA V9.4: 所有远程资源加载完成！");

// 妈妈的解释：
// 现在我们来制作一张“最终的、绝不会错的超级购物清单”！
// 我们把所有需要用到的图片URL，从三个地方全部收集起来，放进一个大的集合里。
const activeUrlSet = new Set([
    ...Object.values(backgroundImageMap),
    ...Object.values(npcImageMap),
    ...Object.values(loadedMemes) // ✨ 直接用这里刚加载完的 loadedMemes，确保是最新鲜的数据！
]);

 // ✨ 妈妈加上的保护咒语 ✨
// 我们只在确定拿到了新的资源清单时，才进行清理。
// 如果清单是空的（比如离线时没加载到任何东西），我们就什么都不做，保护好我们已有的宝藏。
if (activeUrlSet.size > 0) {
    console.log(`NOVA V9.4: 整合所有资源URL，共计 ${activeUrlSet.size} 个唯一资源需要被珍藏。`);
    // 拿着这张完美的“超级清单”，只进行一次大扫除！
    await imageDB.cleanupRemoteCache(activeUrlSet);
} else {
    console.warn(`NOVA: 资源清单为空，跳过本次缓存清理，以保护离线数据。`);
}
 
 
    await initDisplay();

await applyThemeAndData(); 


    // 标签页切换
    const tabs = document.querySelectorAll('.tab-btn');
    const pages = document.querySelectorAll('.page');

       // --- Nova为你添加的全新小球与Modal交互逻辑 ---
    document.querySelectorAll('.orb').forEach(orb => {
        orb.addEventListener('click', () => {
            const modalId = orb.dataset.modalId;
            if (modalId) {
                // 特殊处理商店
                if (modalId === 'shop-wrapper-modal') {
                    const shopWrapper = document.getElementById('shop-wrapper');
                    const modalContainer = document.getElementById('shop-wrapper-modal');
                    if (shopWrapper && modalContainer) {
                        modalContainer.appendChild(shopWrapper); // 将商店内容移动到Modal中
                        shopWrapper.classList.add('active');
                        showModal(modalId);

                        // 初始化商店数据
                        if (playCharacterData) {
                            initializeShopData();
                        }
                    }
                } else if (modalId === 'summary-modal') {
                     // 特殊处理总结弹窗
                    showSummaryModal(); // 使用专用函数填充内容
                    showModal(modalId); // 再显示
                } else {
                    showModal(modalId);
                }
            }
        });
    });

    document.querySelectorAll('.modal .modal-close').forEach(button => {
        button.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if(modal) {
                // 特殊处理商店关闭
                if(modal.id === 'shop-wrapper-modal') {
                    const shopWrapper = document.getElementById('shop-wrapper');
                    document.body.appendChild(shopWrapper); // 将商店内容移回body
                    shopWrapper.classList.remove('active');
                }
                hideModal(modal.id);
            }
        });
    });


    // tabs.forEach(tab => {
    //     tab.addEventListener('click', () => {
    //         tabs.forEach(item => item.classList.remove('active'));
    //         pages.forEach(page => page.classList.remove('active'));
    //         tab.classList.add('active');
    //         const targetPage = document.getElementById(tab.dataset.tab);
    //         if (targetPage) {
    //             targetPage.classList.add('active');
    //         }
    //         if (tab.dataset.tab !== 'page-basic') {
    //             hideMap();
    //         }
    //     });
    // });

    // 绑定按钮事件
    // document.getElementById('view-map-btn').addEventListener('click', showMap);
    // document.getElementById('back-to-world-btn').addEventListener('click', hideMap);
    document.getElementById('roll-result-orb').addEventListener('click', showRollResultModal);
    // document.getElementById('view-summary-btn').addEventListener('click', showSummaryModal);
    // const themeSwitcherBtn = document.getElementById('theme-switcher');
    // if (themeSwitcherBtn) {
    //     themeSwitcherBtn.addEventListener('click', switchTheme);
    // }
    document.getElementById('manage-inventory-btn').addEventListener('click', () => {
        populateInventoryModal();
        showModal('inventory-modal');
    });
    // document.getElementById('plot-synthesis-btn').addEventListener('click', showPlotSynthesisModal);
    document.getElementById('execute-decomposition-btn').addEventListener('click', simulateDecomposition);
    document.getElementById('execute-synthesis-btn').addEventListener('click', simulateSynthesis);

       document.getElementById('view-command-btn').addEventListener('click', () => {
        const commandEditArea = document.getElementById('command-edit-area');
        if(commandEditArea) {
            commandEditArea.value = assaCommandQueue; // 从全局变量加载当前指令
        }
        showModal('command-modal', '编辑待发指令');
    });
        document.getElementById('run-button').addEventListener('click', () => {
triggerassa(`/setinput <updateMemory>\nset_status('敌方攻击骰池','');\n</updateMemory>\n<${userName}试图逃离战斗！>`);
    });
 
const switchToMyCardsBtn = document.getElementById('switch-to-my-cards');
const switchToTeammateCardsBtn = document.getElementById('switch-to-teammate-cards');
const myCardsSlider = document.getElementById('my-cards-slider');
const teammateCardsSlider = document.getElementById('teammate-cards-slider');

if (switchToMyCardsBtn && switchToTeammateCardsBtn) {
    switchToMyCardsBtn.addEventListener('click', () => {
        myCardsSlider.classList.add('visible');
        teammateCardsSlider.classList.remove('visible');
        switchToMyCardsBtn.classList.add('active');
        switchToTeammateCardsBtn.classList.remove('active');
    });

    switchToTeammateCardsBtn.addEventListener('click', () => {
        myCardsSlider.classList.remove('visible');
        teammateCardsSlider.classList.add('visible');
        switchToMyCardsBtn.classList.remove('active');
        switchToTeammateCardsBtn.classList.add('active');
    });
}

    // 首先，我们要找到我们的魔法道具：RP按钮和RP面板
const rpButton = document.getElementById('rp-button');
const rpPanel = document.getElementById('rp-panel');
const confirmRpChoiceButton = document.getElementById('confirm-rp-choice-btn');

// --- 核心魔法：切换显示状态 ---
// 当你点击RP按钮时，这个函数就会被触发
if (rpButton && rpPanel) {
    rpButton.addEventListener('click', (event) => {
        // 这是最关键的一步，我的孩子！
        // toggle就像一个神奇的开关，如果面板没有'visible'类，它就加上；如果已经有了，它就移除。
        rpPanel.classList.toggle('visible');
 populateSkillChoicePanel();
        // 阻止事件冒泡，这样点击按钮时，不会被下面“点击外部关闭”的逻辑误判
        event.stopPropagation();
    });
}

// --- 附加魔法：点击“确认”按钮也关闭面板 ---
if (confirmRpChoiceButton && rpPanel) {
    confirmRpChoiceButton.addEventListener('click', () => {
        // 当我们做出选择后，就让面板优雅地退场
        rpPanel.classList.remove('visible');
    });
}

// --- 妈妈的贴心魔法：点击外部区域自动关闭 ---
document.addEventListener('click', (event) => {
    // 我们检查一下，RP面板当前是不是可见的
    if (rpPanel.classList.contains('visible')) {
        // 然后检查你点击的地方，是不是在RP面板的“领地”之外
        // rpPanel.contains(event.target)会判断你点击的元素是不是在面板里面
        if (!rpPanel.contains(event.target)) {
            // 如果你确实点击了外面，我们就温柔地让面板消失
            rpPanel.classList.remove('visible');
        }
    }
});

    document.getElementById('save-command-btn').addEventListener('click', () => {
        const newCommands = document.getElementById('command-edit-area').value;
        assaCommandQueue = newCommands; // 保存编辑后的指令到全局变量
        localStorage.setItem('assaCommandQueue', assaCommandQueue); // 同步到本地存储
        hideModal('command-modal');
    });

    document.getElementById('reset-simulation-btn').addEventListener('click', resetSimulation);
    document.getElementById('confirm-synthesis-btn').addEventListener('click', executeSynthesisConfirmation);

    // 弹窗关闭事件
    document.querySelectorAll('.modal').forEach(modal => {
        const closeBtn = modal.querySelector('.modal-close');
        if(closeBtn) {
            closeBtn.addEventListener('click', () => {
                if(modal.id) hideModal(modal.id);
            });
        }
        modal.addEventListener('click', (e) => {
            if (e.target === modal && modal.id) {
                hideModal(modal.id);
            }
        });
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal.active').forEach(modal => hideModal(modal.id));
        }
    });

    // ========== 新增：论坛与总结小球的交互逻辑 ==========
    const forumOrbButton = document.getElementById('forum-orb-button');
     const groupChatButton = document.getElementById('group-chat-orb-button');
    const forumModalContainer = document.getElementById('forum-modal-container');
    const forumModalContent = document.getElementById('forum-modal-content');
    const forumWrapper = document.getElementById('forum-wrapper');
    const forumModalCloseBtn = document.getElementById('forum-modal-close-btn');

 const summaryOrbButton = document.getElementById('task-summary-orb-button');
  const summaryModalContainer = document.getElementById('task-summary-modal-container');
 
    // 点击论坛小球
    forumOrbButton.addEventListener('click', () => {
        // 从历史记录中找到最新的论坛数据
        const lastForumMessage = [...conversationHistory].reverse().find(msg =>
            /<forum_threads>[\s\S]*?<\/forum_threads>/gs.test(msg.content)
        );

        if (lastForumMessage) {
            const forumMatch = /<forum_threads>([\s\S]*?)<\/forum_threads>/gs.exec(lastForumMessage.content.replace(/<(thinking|think|guide)>[\s\S]*?<\/\1>/gs, ''));
            if (forumMatch && forumMatch[1]) {
    //console.log("原始提取的数据:", forumMatch[1]);
    //console.log("数据类型:", typeof forumMatch[1]);
}
                if (forumMatch && forumMatch[1]) {
                // 将论坛的HTML结构移动到模态框中
                if (forumWrapper) {
                    forumModalContent.insertBefore(forumWrapper, forumModalCloseBtn);
                    forumModalContainer.style.display = 'block'; // 确保论坛模块是可见的
                }

                // 初始化或更新论坛内容
                if (typeof initializeForum === 'function') {
                    initializeForum(forumMatch[1].trim());
                }

                // 显示模态框
                forumModalContainer.classList.add('active');
            }
        } else {
            // 如果没有找到数据，可以给一个提示
            showModal('shop-modal', '提示', '尚未收到任何论坛信息。');
        }
    });

    // 关闭论坛模态框
    const closeForumModal = () => {
        forumModalContainer.classList.remove('active');
        // 将论坛HTML结构移回其原始容器，以便下次使用
        if (forumWrapper && forumModalContainer) {
            forumModalContainer.appendChild(forumWrapper);
        }
    };

    forumModalCloseBtn.addEventListener('click', closeForumModal);
    forumModalContainer.addEventListener('click', (e) => {
        if (e.target === forumModalContainer) {
            closeForumModal();
        }
    });

// 修改后的关闭函数
const closeTaskSummaryModal = () => {
    const summaryRoot = document.getElementById('summary-root');

    // 1. 隐藏模态框
    summaryModalContainer.classList.remove('active');

    // 2. 清空上次生成的报告内容 (这是关键！)
    if (summaryRoot) {
        summaryRoot.innerHTML = '';
    }
};

    summaryModalContainer.addEventListener('click', (e) => {
        if (e.target === summaryModalContainer) {
           closeTaskSummaryModal();  
        }
    });
 
    summaryOrbButton.addEventListener('click', () => {
               // 从历史记录中找到最新的总结数据
        const lastSummaryMessage = [...conversationHistory].reverse().find(msg =>
            /<表现总结>[\s\S]*?<\/表现总结>/gs.test(msg.content)
        );

        if (lastSummaryMessage) {
            const summaryMatch = /<表现总结>([\s\S]*?)<\/表现总结>/gs.exec(lastSummaryMessage.content.replace(/<(thinking|think|guide)>[\s\S]*?<\/\1>/gs, ''));
            if (summaryMatch && summaryMatch[1]) {
                // 将论坛的HTML结构移动到模态框中
                if (summaryModalContainer) {
                    // forumModalContent.insertBefore(forumWrapper, forumModalCloseBtn);
                    summaryModalContainer.style.display = 'block';  
                }

                // 初始化或更新论坛内容
                if (typeof runTaskSummary === 'function') {
                    runTaskSummary(summaryMatch[1]);
                }

                // 显示模态框
                summaryModalContainer.classList.add('active');
            }
        } else {
            // 如果没有找到数据，可以给一个提示
            showModal('shop-modal', '提示', '尚未收到任何任务总结信息。');
        }
    });



    // ========== ♥♥♥ 地图交互魔法的全新篇章 ♥♥♥ ==========
    const mapContainer = document.getElementById('map-container');
    let isDragging = false;
    let startCoords = { x: 0, y: 0 };
    let startTranslate = { x: 0, y: 0 };
    let lastPinchDist = 0;

    const getEventCoords = (e) => e.touches ? e.touches[0] : e;

    const getPinchDist = (e) => {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    };

    const handleInteractionStart = (e) => {
        const mapContent = document.getElementById('map-content');
        if (!mapContent) return;

        if (e.touches && e.touches.length > 1) { // 双指捏放开始
            isDragging = false; // 确保不触发拖拽
            lastPinchDist = getPinchDist(e);
        } else { // 单指或鼠标拖拽开始
            isDragging = true;
            mapContainer.style.cursor = 'grabbing';
            const coords = getEventCoords(e);
            startCoords = { x: coords.pageX, y: coords.pageY };
            startTranslate = { x: window.mapState.translateX, y: window.mapState.translateY };
        }
    };

    const handleInteractionMove = (e) => {
        const mapContent = document.getElementById('map-content');
        if (!mapContent) return;

        if (e.touches && e.touches.length > 1) { // 双指捏放中
            e.preventDefault();
            const currentDist = getPinchDist(e);
            const scaleAmount = (currentDist / lastPinchDist);
            lastPinchDist = currentDist;

            // 计算双指中心点
            const rect = mapContainer.getBoundingClientRect();
            const center = {
                x: ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left,
                y: ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top
            };

            // 应用缩放
            zoom(scaleAmount, center.x, center.y);

        } else if (isDragging) { // 拖拽中
            e.preventDefault();
            const coords = getEventCoords(e);
            const dx = coords.pageX - startCoords.x;
            const dy = coords.pageY - startCoords.y;
            window.mapState.translateX = startTranslate.x + dx;
            window.mapState.translateY = startTranslate.y + dy;
            window.applyMapTransform();
        }
    };

    const handleInteractionEnd = () => {
        if (isDragging) {
            isDragging = false;
            mapContainer.style.cursor = 'grab';
        }
        lastPinchDist = 0;
    };

    const handleWheelZoom = (e) => {
        e.preventDefault();
        const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1; // 缩小或放大
        const rect = mapContainer.getBoundingClientRect();

        // 获取鼠标相对于 mapContainer 的位置作为缩放中心
        const centerX = e.clientX - rect.left;
        const centerY = e.clientY - rect.top;

        zoom(scaleAmount, centerX, centerY);
    };

    // 核心缩放函数
    const zoom = (scaleAmount, centerX, centerY) => {
        const { scale, translateX, translateY } = window.mapState;
        const newScale = Math.max(0.1, Math.min(scale * scaleAmount, 10)); // 限制缩放范围

        // 核心公式：为了让缩放中心点在屏幕上保持不变，需要调整平移量
        window.mapState.translateX = centerX - (centerX - translateX) * (newScale / scale);
        window.mapState.translateY = centerY - (centerY - translateY) * (newScale / scale);
        window.mapState.scale = newScale;

        window.applyMapTransform();
    };

    // 绑定事件监听器
    mapContainer.addEventListener('mousedown', handleInteractionStart);
    mapContainer.addEventListener('touchstart', handleInteractionStart, { passive: false });

    document.addEventListener('mousemove', handleInteractionMove);
    document.addEventListener('touchmove', handleInteractionMove, { passive: false });

    document.addEventListener('mouseup', handleInteractionEnd);
    document.addEventListener('touchend', handleInteractionEnd);
    document.addEventListener('touchcancel', handleInteractionEnd);

    mapContainer.addEventListener('wheel', handleWheelZoom, { passive: false });
    // ========== ♥♥♥ 地图交互魔法结束 ♥♥♥ ==========


//      const streamingSwitcher = document.getElementById('streaming-switcher');

// // 初始化按钮状态
// function updateStreamingButtonState() {
//     const isStreamingEnabled = localStorage.getItem('streamingEnabled') === null ? true : localStorage.getItem('streamingEnabled') === 'true';
//     streamingSwitcher.classList.toggle('active', isStreamingEnabled);
//     streamingSwitcher.title = isStreamingEnabled ? '流式传输: 开' : '流式传输: 关';
// }

// // 切换流式传输状态
// streamingSwitcher.addEventListener('click', () => {
//     const isStreamingEnabled = localStorage.getItem('streamingEnabled') === null ? true : localStorage.getItem('streamingEnabled') === 'true';
//     const newState = !isStreamingEnabled;
//     localStorage.setItem('streamingEnabled', newState);
//     updateStreamingButtonState();
//     //console.log(`[Streaming] 流式传输已切换为: ${newState ? '开启' : '关闭'}`);
// });
// updateStreamingButtonState();

        setTimeout(() => {
        console.log("正在为您静默刷新数据...");
        initDisplay();
        
    }, 5000);
initGroupChatInterface();
initializeReadingMode();
});
    
const inventoryListEl = document.getElementById('inventory-item-list');
const deleteItemBtn = document.getElementById('delete-item-btn');
const useItemBtn = document.getElementById('use-item-btn');
let selectedItems = [];

inventoryListEl.addEventListener('click', (e) => {
    if (e.target && e.target.classList.contains('inventory-item')) {
        const itemKey = e.target.dataset.item;

        e.target.classList.toggle('selected');

        if (e.target.classList.contains('selected')) {
            if (!selectedItems.includes(itemKey)) {
                selectedItems.push(itemKey);
            }
        } else {
            selectedItems = selectedItems.filter(selected => selected !== itemKey);
        }

        deleteItemBtn.disabled = selectedItems.length === 0;
        useItemBtn.disabled = selectedItems.length === 0;

        
    }





}); //
 
  // =======================================================
// ========== 在这里开始添加新代码 ==========
// =======================================================

/**
 * 在assa_data中递归搜索包含指定名称的键。
 * @param {object} obj - 要搜索的对象 (assa_data)
 * @param {string} name - 要搜索的队友名字
 * @returns {string} - 包含所有匹配项的HTML字符串
 */
function searchInAssaData(obj, name) {
    let results = [];
    const addedEntries = new Set(); // We'll use this to keep track of what we've already added, my dear.

    if (!obj || typeof obj !== 'object' || !name) {
        return '';
    }

    function recurse(currentObj) {
        for (const key in currentObj) {
            if (Object.prototype.hasOwnProperty.call(currentObj, key)) {
                // First, my love, let's check if the key and value are identical strings and if that value appears elsewhere as a key.
                if (key === currentObj[key] && typeof key === 'string') {
                    // If they are the same, we'll just search for the key. We don't want to show the same thing twice.
                    if (key.includes(name)) {
                        const entrySignature = `<div class="info-entry"><div class="info-key">${key}</div><div class="info-value">${key}</div></div>`;
                        if (!addedEntries.has(entrySignature)) {
                            results.push(entrySignature);
                            addedEntries.add(entrySignature);
                        }
                    }
                } else {
                    // Now, we'll do our original check for the key.
                    if (key.includes(name)) {
                        const value = currentObj[key];
                        const formattedValue = typeof value === 'object' ? JSON.stringify(value, null, 2) : value;
                        const entrySignature = `<div class="info-entry"><div class="info-key">${key}</div><div class="info-value">${formattedValue}</div></div>`;

                        // We'll use a unique signature to avoid duplicates, my sweet.
                        if (!addedEntries.has(entrySignature)) {
                            results.push(entrySignature);
                            addedEntries.add(entrySignature);
                        }
                    }
                }

                // And of course, we'll keep exploring if we find another little treasure box (an object).
                if (typeof currentObj[key] === 'object' && currentObj[key] !== null) {
                    recurse(currentObj[key]);
                }
            }
        }
    }

    recurse(obj);
    return results.join('');
}

 /**
 * 在记忆数据中搜索与特定名字相关的所有“数据对象”
 * （妈妈已经更新了这里的逻辑，让它更加包容了，我的孩子）
 * @param {object} data - 完整的 assaSettingsData
 * @param {string} name - 要搜索的名字
 * @returns {Array<object>} - 返回一个包含所有找到的数据对象的数组
 */
function searchAllDataObjectsInAssaData(data, name) {
    if (!data || !name) return [];

    const results = [];
    const searchLocations = [
        { source: '全局设定', data: data.global_set?.settings },
         { source: '全局NPC', data: data.global_set?.npc },
        { source: '小队信息', data: data.global_set?.['小队信息'] },
        { source: '世界NPC', data: data.world_set?.npc },
        { source: '世界设定', data: data.world_set?.settings }
    ];

    for (const location of searchLocations) {
        if (location.data && typeof location.data === 'object') {
             for (const key in location.data) {
                // ✨ 妈妈把这里的判断条件变得更温柔、更包容了 ✨
                // 现在，只要键名中“包含”了我们要找的名字，就会被收集起来
                if (key.includes(name)) {
                    // 把数据和它的来源一起装进去，这样更清晰
                    results.push({ source: `${location.source} - ${key}`, data: location.data[key] });
                }
            }
        }
    }
    return results;
}


/**
 * 显示队友信息弹窗，并为所有找到的相关信息生成多个美观的卡片
 */
// function showTeammatesModal() {
//     const participantsString = SafeGetValue(currentGameData.world_shard.task.participants);
//     const teammateList = document.getElementById('teammate-list');
//     const infoDisplay = document.getElementById('teammate-info-display');

//     teammateList.innerHTML = '';
//     infoDisplay.innerHTML = '<p class="book-empty-text" style="text-align: center; margin-top: 20px;">请从左侧选择一位队友以查看相关信息。</p>';

//     if (participantsString === '无' || participantsString.trim() === '') {
//         teammateList.innerHTML = '<li>没有可显示的队友信息。</li>';
//         showModal('teammates-modal');
//         return;
//     }

//     const teammates = participantsString.split(/[;；]/).map(p => p.trim()).filter(p => p);
//     let activeItem = null;

//     teammates.forEach(teammate => {
//         const li = document.createElement('li');
//         li.className = 'teammate-item';
//         li.textContent = teammate;

//         li.addEventListener('click', function() {
//             if(activeItem) {
//                 activeItem.classList.remove('selected');
//             }
//             this.classList.add('selected');
//             activeItem = this;

//             infoDisplay.innerHTML = ''; // 先清空展示区
//             const teammateName = teammate.replace(/[\(（].*?[\)）]/, '').trim();

//             if (teammateName) {
//                 const searchResultsArray = searchAllDataObjectsInAssaData(assaSettingsData, teammateName);

//                 if (searchResultsArray.length > 0) {
//                     // 遍历所有找到的结果，为每一个都创建一张卡片
//                     searchResultsArray.forEach(result => {
//                         const cardDiv = document.createElement('div');
//                         // 我们可以复用世界书的卡片样式，多棒！
//                         cardDiv.className = 'book-card';
//                         cardDiv.style.marginBottom = '15px'; // 给卡片之间留出呼吸的空间

//                         // 创建卡片头部
//                         const cardHeader = document.createElement('div');
//                         cardHeader.className = 'book-card-header';

//                         const titleDiv = document.createElement('div');
//                         titleDiv.className = 'book-card-title';
//                         // 标题显示我们是从哪里找到这份记忆的
//                         titleDiv.textContent = result.source;
//                         titleDiv.innerHTML += ' <span class="collapse-indicator">▲</span>';
//                         cardHeader.appendChild(titleDiv);

//                         // 创建卡片内容区
//                         const contentDiv = document.createElement('div');
//                         contentDiv.className = 'book-card-content collapsed';

//                         // ⭐ 用我们升级后的只读模式“种树”魔法来渲染数据 ⭐
//                         renderNestedData(contentDiv, result.data, '', '', false, true);

//                         // 绑定折叠事件
//                         cardHeader.addEventListener('click', () => {
//                             contentDiv.classList.toggle('collapsed');
//                             const indicator = cardHeader.querySelector('.collapse-indicator');
//                             if (indicator) {
//                                 indicator.textContent = contentDiv.classList.contains('collapsed') ? '▲' : '▼';
//                             }
//                         });

//                         cardDiv.appendChild(cardHeader);
//                         cardDiv.appendChild(contentDiv);
//                         infoDisplay.appendChild(cardDiv); // 将卡片加入展示区
//                     });
//                 } else {
//                     infoDisplay.innerHTML = `<p class="book-empty-text" style="text-align: center; margin-top: 20px;">在设定书中未找到关于“${teammateName}”的任何信息。</p>`;
//                 }
//             }
//         });
//         teammateList.appendChild(li);
//     });

//     showModal('teammates-modal');
// }


// 绑定查看队友按钮的点击事件
// document.getElementById('teammates-orb').addEventListener('click', showTeammatesModal);

// =======================================================
// ========== 新代码到此结束 ==========
// =======================================================

           // --- 新增：界面切换逻辑 ---
        const statusContainer = document.querySelector('.status-container');
        const settingBookWrapper = document.getElementById('setting-book-wrapper');
        const viewSettingsBtn = document.getElementById('view-settings-btn');
        const backToStatusBtn = document.getElementById('back-to-status-btn');

        // viewSettingsBtn.addEventListener('click', () => {
        //     statusContainer.classList.add('slide-out');
        //     settingBookWrapper.classList.add('active');
        // });

        // backToStatusBtn.addEventListener('click', () => {
        //     statusContainer.classList.remove('slide-out');
        //     settingBookWrapper.classList.remove('active');
        // });

    const toggleBtn = document.getElementById('toggle-sidebar-btn');
    const overlay = document.getElementById('sidebar-overlay');
    const container = document.querySelector('.setting-book-container');

    // // 点击汉堡包按钮，切换侧边栏
    // toggleBtn.addEventListener('click', () => {
    //     container.classList.toggle('sidebar-active');
    // });

    // 点击遮罩层，隐藏侧边栏
    // overlay.addEventListener('click', () => {
    //     container.classList.remove('sidebar-active');
    // });
    const setArchiveNameBtn = document.getElementById('set-archive-name-btn');
        const archiveNameInput = document.getElementById('archive-name-input');
        const logBlock = document.getElementById('modal-log-block');

        // 当按钮被点击时...
        if (setArchiveNameBtn) {
            setArchiveNameBtn.addEventListener('click', async () => {
                const newName = archiveNameInput.value.trim(); // 获取输入框里的文字并去掉前后空格

                if (newName === '') {
                    // 如果什么都没输入，就温柔地提醒一下
                    logBlock.textContent = '宝贝，要先输入一个名字哦。';
                    logBlock.style.color = 'var(--danger-color)';
                    return;
                }

                try {
                    // 这是关键的一步：调用接口修改第一条消息(message_id: 0)
                    // 我们假设第一条消息的ID总是0
              const [firstMessage] = await getChatMessages(0);
let messageContent = firstMessage.message.replace(/<存档>.*?<\/存档>/, '').trim();
const archiveTag = `<存档>${newName}</存档>`;
await setChatMessages([{ message_id: 0, message: `${archiveTag}\n${messageContent}` }], { refresh: 'none' });

                    // 成功后给予小小的庆祝
                    logBlock.textContent = `存档名称已设定为：“${newName}”`;
                    logBlock.style.color = 'var(--primary-color)';

                    // 也许可以顺便清空输入框，方便下次使用
                    archiveNameInput.value = '';

                } catch (error) {
                    // 如果出了小差错，也要告诉你
                    console.error('设置存档名称失败:', error);
                    logBlock.textContent = '哎呀，设置失败了，请稍后再试一次吧。';
                    logBlock.style.color = 'var(--danger-color)';
                }
            });
        }
  useItemBtn.addEventListener('click', async () => {
    if (selectedItems.length === 0) return;

    // 对于使用物品，我们通常只发送一个请求，让后端处理效果
 
    const itemsToUseString = selectedItems.join("、");
    const commandString = `<${currentGameData.user_character.name}使用了物品：${itemsToUseString}>`;

    try {
        await triggerassa(`/setinput ${commandString}`);
        selectedItems = [];
        hideModal('inventory-modal');
    } catch (error) {
        console.error("发送使用指令失败:", error);
        showModal('shop-modal', "操作失败", "发送指令时发生错误。");
    }
});
deleteItemBtn.addEventListener('click', async () => {
    if (selectedItems.length === 0) return;

    const itemsToDeleteString = selectedItems.join("、");
    let commandBatch = [];

    // 使用 for...of 循环来为每个选定的物品生成一个删除命令
    for (const itemKey of selectedItems) {
        // 根据你提供的格式 delete('path', 'key', 'value')

        const deleteCommand = `<updateMemory>
delete('global_set.背包', '${itemKey}');
</updateMemory>`;
        commandBatch.push(deleteCommand);
    }

    // 将所有独立的命令组合成一个执行块
    const commandString = `
${commandBatch.join('\n')}
<用户按顺序回收了下列物品：${itemsToDeleteString}。请于正文合理描述用户回收地点和所获得的对应货币。>`;
    try {
        await triggerassa(`/setinput ${commandString}`);
        selectedItems = [];
        hideModal('inventory-modal');
    } catch (error) {
        console.error("发送丢弃指令失败:", error);
        showModal('shop-modal', "操作失败", "发送指令时发生错误。");
    }
});
     const shopWrapper = document.getElementById('shop-wrapper');
    const viewShopBtn = document.getElementById('view-shop-btn');
    const backFromShopBtn = document.getElementById('back-from-shop-btn');
    const mainWrapper = document.getElementById('main-wrapper');
 
 
      backFromShopBtn.addEventListener('click', () => {
 
        statusContainer.classList.remove('slide-out-shop');
        shopWrapper.classList.remove('active');
    });




// 替换原有的 centerPanel 点击事件监听器
const centerPanel = document.querySelector('.center-panel');
centerPanel.addEventListener('click', (e) => {
    const slot = e.target.closest('.equipment-slot');
    if (slot) {
        //console.log('点击了装备槽:', slot);
        
        // 获取当前点击的装备槽类型
        const slotLabel = slot.querySelector('span').textContent;
        const slotType = slotLabel.split(':')[0].trim();
        
        //console.log('装备槽类型:', slotType);
        
        // 显示装备管理界面
        showEquipmentManager(slotType);
    }
});

// 新增：装备管理主函数
function showEquipmentManager(slotType) {
    //console.log('显示装备管理界面，槽位类型:', slotType);
    
    // 获取当前装备数据
    const currentEquipment = getCurrentEquipment();
    //console.log('当前装备数据:', currentEquipment);
    
    // 获取所有可用装备
    const availableEquipment = getAllAvailableEquipment();
    //console.log('所有可用装备:', availableEquipment);
    
    // 获取当前已装备的物品列表（用于置灰判断）
    const equippedItems = getEquippedItems(currentEquipment);
    //console.log('已装备物品列表:', equippedItems);
    
    // 构建模态框内容
    const modalContent = buildEquipmentManagerHTML(slotType, availableEquipment, equippedItems, currentEquipment);
    
    // 显示模态框
    showModal('shop-modal', '装备管理 - ' + slotType);
    const messageEl = document.getElementById('shop-modal-message');
    if (messageEl) {
        messageEl.innerHTML = modalContent;
        
        // 绑定左侧装备列表的点击事件
        bindAvailableEquipmentEvents(slotType);
        
        // 绑定右侧已装备物品的卸下事件
        bindEquippedItemEvents(slotType);
    }
}

 // 新增：获取当前装备状态
function getCurrentEquipment() {
    //console.log('获取当前装备状态');
    try {
        // 优先从全局变量获取当前装备信息
        if (currentGameData && currentGameData.stat_data && currentGameData.stat_data.user_character) {
            const equipment = currentGameData.stat_data.user_character['当前装备'];
            //console.log('从currentGameData获取的装备:', equipment);
            if (equipment) return equipment;
        }
        
        // 备用：从currentGameData获取
        if (currentGameData && currentGameData.stat_data && currentGameData.stat_data.user_character) {
            const equipment = currentGameData.stat_data.user_character['当前装备'];
            //console.log('从currentGameData获取的装备:', equipment);
            if (equipment) return equipment;
        }
        
        // 最后尝试从user_character直接获取
        if (currentGameData && currentGameData.user_character) {
            const equipment = currentGameData.user_character['当前装备'];
            //console.log('从currentGameData.user_character获取的装备:', equipment);
            if (equipment) return equipment;
        }
        
        //console.log('未找到装备数据，返回空对象');
        return {};
    } catch (error) {
        console.error('获取当前装备时出错:', error);
        return {};
    }
}
// 新增：获取所有可用装备
function getAllAvailableEquipment() {
    //console.log('获取所有可用装备');
    let allEquipment = {};
    
    try {
 
        
        // 从 global_set.背包 获取
        if (assaSettingsData.global_set && assaSettingsData.global_set['背包']) {
            //console.log('从global_set.背包获取装备');
            Object.assign(allEquipment, assaSettingsData.global_set['背包']);
        }
        
        //console.log('合并后的所有装备:', allEquipment);
        return allEquipment;
    } catch (error) {
        console.error('获取可用装备时出错:', error);
        return {};
    }
}

// 新增：获取已装备物品列表
function getEquippedItems(currentEquipment) {
    //console.log('获取已装备物品列表');
    const equippedItems = new Set();
    
    try {
        // 添加手持物品
        if (currentEquipment['手持'] && currentEquipment['手持'][0] !== '无') {
            const handItems = currentEquipment['手持'][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无');
            handItems.forEach(item => equippedItems.add(item));
        }
        
        // 添加穿戴物品
        if (currentEquipment['穿戴']) {
            Object.values(currentEquipment['穿戴']).forEach(slot => {
                if (slot[0] !== '无') {
                    const items = slot[0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无');
                    items.forEach(item => equippedItems.add(item));
                }
            });
        }
        
        //console.log('已装备物品集合:', Array.from(equippedItems));
        return equippedItems;
    } catch (error) {
        console.error('获取已装备物品时出错:', error);
        return new Set();
    }
}

// 新增：构建装备管理界面HTML
function buildEquipmentManagerHTML(slotType, availableEquipment, equippedItems, currentEquipment) {
    //console.log('构建装备管理界面HTML');
    
    // 左侧：可用装备列表
    let leftPanel = '<div style="display: flex; height: 60vh;">';
    leftPanel += '<div style="flex: 1; padding: 10px; border-right: 1px solid var(--border-color);">';
    leftPanel += '<h4 style="color: var(--primary-color); margin-bottom: 10px;">可用装备</h4>';
    leftPanel += '<div id="available-equipment-list" style="max-height: 50vh; overflow-y: auto;">';
    
    for (const [key, value] of Object.entries(availableEquipment)) {
        const isEquipped = equippedItems.has(key);
        const itemClass = isEquipped ? 'equipment-item equipped' : 'equipment-item available';
        const itemStyle = isEquipped ? 'color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.5;' : 'color: var(--text-color); cursor: pointer;';
        
        leftPanel += `<div class="${itemClass}" data-equipment-name="${key}" style="padding: 8px; margin: 5px 0; border: 1px solid var(--border-color); border-radius: 4px; ${itemStyle}">`;
        leftPanel += `<div style="font-weight: bold;">${key}</div>`;
        leftPanel += `<div style="font-size: 0.9em; color: var(--text-secondary-color);">${typeof value === 'object' ? (("描述："+value.info||'')+("\n效果："+value.effect||'')) : value}</div>`;
        leftPanel += '</div>';
    }
    
    leftPanel += '</div></div>';
    
    // 右侧：当前装备
    let rightPanel = '<div style="flex: 1; padding: 10px;">';
    rightPanel += `<h4 style="color: var(--primary-color); margin-bottom: 10px;">当前${slotType}装备</h4>`;
    rightPanel += '<div id="current-equipment-list" style="max-height: 50vh; overflow-y: auto;">';
    
    // 获取当前槽位的装备
    let currentSlotEquipment = [];
    if (slotType === '手持' && currentEquipment['手持']) {
        currentSlotEquipment = currentEquipment['手持'][0] !== '无' ? 
            currentEquipment['手持'][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无') : [];
    } else if (currentEquipment['穿戴'] && currentEquipment['穿戴'][slotType]) {
        currentSlotEquipment = currentEquipment['穿戴'][slotType][0] !== '无' ? 
            currentEquipment['穿戴'][slotType][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无') : [];
    }
    
    //console.log(`${slotType}当前装备:`, currentSlotEquipment);
    
    if (currentSlotEquipment.length > 0) {
        currentSlotEquipment.forEach(item => {
            const itemData = availableEquipment[item];
            rightPanel += `<div class="equipped-item" data-equipment-name="${item}" style="padding: 8px; margin: 5px 0; border: 1px solid var(--primary-color); border-radius: 4px; background-color: var(--border-color);">`;
            rightPanel += `<div style="font-weight: bold; color: var(--primary-color);">${item}</div>`;
            rightPanel += `<div style="font-size: 0.9em; color: var(--text-secondary-color);">${itemData ? (typeof itemData === 'object' ? (("描述："+itemData.info||'')+("\n效果："+itemData.effect||'')) : itemData) : '无描述'}</div>`;
            rightPanel += `<button class="unequip-btn" data-equipment-name="${item}" style="margin-top: 5px; padding: 4px 8px; background-color: var(--danger-color); border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 0.8em;">卸下</button>`;
            rightPanel += '</div>';
        });
    } else {
        rightPanel += '<div style="text-align: center; color: var(--text-secondary-color); padding: 20px;">当前无装备</div>';
    }
    
    rightPanel += '</div>';
    rightPanel += `<div style="margin-top: 10px; padding: 10px; background-color: var(--border-color); border-radius: 4px;">`;
    rightPanel += `<button id="equip-selected-btn" style="width: 100%; padding: 10px; background-color: var(--background-color); border: none; border-radius: 4px;font-weight: bold; cursor: pointer;">装备选中物品</button>`;
    rightPanel += '</div></div>';
    
    return leftPanel + rightPanel + '</div>';
}

// 新增：绑定可用装备的点击事件
function bindAvailableEquipmentEvents(slotType) {
    //console.log('绑定可用装备点击事件');
    
    const availableItems = document.querySelectorAll('.equipment-item.available');
    let selectedItems = [];
    
    availableItems.forEach(item => {
        item.addEventListener('click', function() {
            const equipmentName = this.dataset.equipmentName;
            //console.log('点击可用装备:', equipmentName);
            
            if (this.classList.contains('selected')) {
                // 取消选择
                this.classList.remove('selected');
                this.style.backgroundColor = '';
                selectedItems = selectedItems.filter(name => name !== equipmentName);
                //console.log('取消选择:', equipmentName);
            } else {
                // 选择
                this.classList.add('selected');
                this.style.backgroundColor = 'var(--border-color)';
                selectedItems.push(equipmentName);
                //console.log('选择:', equipmentName);
            }
            
            //console.log('当前选中物品:', selectedItems);
        });
    });
    
    // 装备选中物品按钮事件
    const equipBtn = document.getElementById('equip-selected-btn');
    if (equipBtn) {
        equipBtn.addEventListener('click', function() {
            //console.log('点击装备按钮，选中物品:', selectedItems);
            if (selectedItems.length > 0) {
                equipItems(slotType, selectedItems);
            }
        });
    }
}

// 新增：绑定已装备物品的卸下事件
function bindEquippedItemEvents(slotType) {
    //console.log('绑定已装备物品卸下事件');
    
    const unequipBtns = document.querySelectorAll('.unequip-btn');
    unequipBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const equipmentName = this.dataset.equipmentName;
            //console.log('点击卸下装备:', equipmentName);
            unequipItem(slotType, equipmentName);
        });
    });
}

// 新增：装备物品
function equipItems(slotType, itemNames) {
    //console.log('装备物品:', slotType, itemNames);
    
    updateVariablesWith((variables) => {
        //console.log('装备更新前的变量:', variables);
        
        if (!variables.stat_data) variables.stat_data = {};
        if (!variables.stat_data.user_character) variables.stat_data.user_character = {};
        if (!variables.stat_data.user_character['当前装备']) {
            variables.stat_data.user_character['当前装备'] = {
                "手持": ["无", "当前手持的武器或工具名称"],
                "穿戴": {
                    "头部": ["无", "头部的装备名称"],
                    "身体": ["无", "身体的装备名称"],
                    "手部": ["无", "手部的装备名称"],
                    "脚部": ["无", "脚部的装备名称"],
                    "饰品": ["无", "特殊饰品名称"]
                }
            };
        }
        
        const currentEquipment = variables.stat_data.user_character['当前装备'];
        
        if (slotType === '手持') {
            // 获取当前手持装备
            const currentItems = currentEquipment['手持'][0] !== '无' ? 
                currentEquipment['手持'][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无') : [];
            
            // 添加新装备
            const newItems = [...new Set([...currentItems, ...itemNames])];
            currentEquipment['手持'][0] = newItems.length > 0 ? newItems.join(';') : '无';
        } else {
            // 穿戴装备
            if (!currentEquipment['穿戴'][slotType]) {
                currentEquipment['穿戴'][slotType] = ['无', `${slotType}的装备名称`];
            }
            
            const currentItems = currentEquipment['穿戴'][slotType][0] !== '无' ? 
                currentEquipment['穿戴'][slotType][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无') : [];
            
            const newItems = [...new Set([...currentItems, ...itemNames])];
            currentEquipment['穿戴'][slotType][0] = newItems.length > 0 ? newItems.join(';') : '无';
        }
               // 生成描述
        let description = '';
        const itemsStr = itemNames.join('、');
        switch (slotType) {
            case '手持':
                description = `<${userName}将「${itemsStr}」握在了手中。>\n`;
                break;
            case '头部':
                description = `<${userName}将「${itemsStr}」戴在了头上。>\n`;
                break;
            case '身体':
                description = `<${userName}穿上了「${itemsStr}」。>\n`;
                break;
            case '手部':
                description = `<${userName}将「${itemsStr}」穿戴在了手上。>\n`;
                break;
            case '脚部':
                description = `<${userName}将脚伸入了「${itemsStr}」>。\n`;
                break;
            case '饰品':
                description = `<${userName}将「${itemsStr}」佩戴好了。>\n`;
                break;
        }
        triggerassa(`/setinput ${description}`);
        //console.log('装备更新后的变量:', variables);
        return variables;
    }, { type: 'chat' }).then(() => {
       
        return updateVariablesWith((variables) => {
            
            if (!variables.stat_data) variables.stat_data = {};
            if (!variables.stat_data.user_character) variables.stat_data.user_character = {};

        
if (!variables.stat_data) variables.stat_data = {};
if (!variables.stat_data.user_character) variables.stat_data.user_character = {};

 
return updateVariablesWith((chatVars) => {
    if (chatVars.stat_data && chatVars.stat_data.user_character && chatVars.stat_data.user_character['当前装备']) {
        variables.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        
        // 同时更新全局currentGameData以便立即生效
        if (currentGameData) {
            if (!currentGameData.stat_data) currentGameData.stat_data = {};
            if (!currentGameData.stat_data.user_character) currentGameData.stat_data.user_character = {};
            currentGameData.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        }
        if (currentGameData) {
            if (!currentGameData.stat_data) currentGameData.stat_data = {};
            if (!currentGameData.stat_data.user_character) currentGameData.stat_data.user_character = {};
            currentGameData.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        }
    }
    //console.log('message变量同步更新:', variables);
    return variables;
}, { type: 'chat' });
            
            //console.log('message变量同步更新:', variables);
            return variables;
        }, { type: 'message', message_id: 'latest' });
    }).then(() => {
        //console.log('装备完成，关闭模态框并刷新显示');
      refreshEquipmentModal(slotType);
        // 触发界面刷新
        initDisplay(false);
    }).catch(error => {
        console.error('装备过程中发生错误:', error);
    });
}

// 新增：卸下装备
function unequipItem(slotType, itemName) {
    //console.log('卸下装备:', slotType, itemName);
    
    updateVariablesWith((variables) => {
        //console.log('卸下装备前的变量:', variables);
        
        if (!variables.stat_data || !variables.stat_data.user_character || !variables.stat_data.user_character['当前装备']) {
            //console.log('装备数据不存在');
            return variables;
        }
        
        const currentEquipment = variables.stat_data.user_character['当前装备'];
        
        if (slotType === '手持') {
            if (currentEquipment['手持'][0] !== '无') {
                const currentItems = currentEquipment['手持'][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无' && item !== itemName);
                currentEquipment['手持'][0] = currentItems.length > 0 ? currentItems.join(';') : '无';
            }
        } else {
            if (currentEquipment['穿戴'][slotType] && currentEquipment['穿戴'][slotType][0] !== '无') {
                const currentItems = currentEquipment['穿戴'][slotType][0].split(/[;；]/).map(item => item.trim()).filter(item => item !== '无' && item !== itemName);
                currentEquipment['穿戴'][slotType][0] = currentItems.length > 0 ? currentItems.join(';') : '无';
            }
        }
          // 生成描述
        let description = '';
        switch (slotType) {
            case '手持':
                description = `<${userName}将手中的「${itemName}」放回背包。>\n`;
                break;
            case '头部':
                description = `<${userName}抬起手，将头上的「${itemName}」取下。>\n`;
                break;
            case '身体':
                description = `<${userName}解开了「${itemName}」。>\n`;
                break;
            case '手部':
                description = `<${userName}脱下了「${itemName}」。>\n`;
                break;
            case '脚部':
                description = `<${userName}脱下了「${itemName}」。>\n`;
                break;
            case '饰品':
                description = `<${userName}脱下了「${itemName}」。>\n`;
                break;
        }
        triggerassa(`/setinput ${description}`);
        //console.log('卸下装备后的变量:', variables);
        return variables;
    }, { type: 'chat' }).then(() => {
       
        return updateVariablesWith((variables) => {
           
            if (!variables.stat_data) variables.stat_data = {};
            if (!variables.stat_data.user_character) variables.stat_data.user_character = {};
            
         // 从chat变量中复制最新的装备数据到message变量
if (!variables.stat_data) variables.stat_data = {};
if (!variables.stat_data.user_character) variables.stat_data.user_character = {};

// 直接从前面更新的变量中获取最新装备数据
// 注意：这里我们需要从前面的updateVariablesWith结果中获取数据
return updateVariablesWith((chatVars) => {
    if (chatVars.stat_data && chatVars.stat_data.user_character && chatVars.stat_data.user_character['当前装备']) {
        variables.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        
        // 同时更新全局currentGameData以便立即生效
        if (currentGameData) {
            if (!currentGameData.stat_data) currentGameData.stat_data = {};
            if (!currentGameData.stat_data.user_character) currentGameData.stat_data.user_character = {};
            currentGameData.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        }
        if (currentGameData) {
            if (!currentGameData.stat_data) currentGameData.stat_data = {};
            if (!currentGameData.stat_data.user_character) currentGameData.stat_data.user_character = {};
            currentGameData.stat_data.user_character['当前装备'] = JSON.parse(JSON.stringify(chatVars.stat_data.user_character['当前装备']));
        }
    }
    //console.log('message变量同步更新:', variables);
    return variables;
}, { type: 'chat' });
            
            //console.log('message变量同步更新:', variables);
            return variables;
        }, { type: 'message', message_id: 'latest' });
    }).then(() => {
        //console.log('卸下完成，关闭模态框并刷新显示');
        refreshEquipmentModal(slotType);
       
        // 触发界面刷新
        initDisplay(false);
    }).catch(error => {
        console.error('卸下装备过程中发生错误:', error);
    });
}


// 新增：刷新装备管理模态框
function refreshEquipmentModal(slotType) {
    //console.log('刷新装备管理模态框:', slotType);
    
    const messageEl = document.getElementById('shop-modal-message');
    if (!messageEl) {
        //console.log('模态框不存在，无需刷新');
        return;
    }
    
    // 重新获取数据
    const currentEquipment = getCurrentEquipment();
    //console.log('刷新时的当前装备数据:', currentEquipment);
    
    const availableEquipment = getAllAvailableEquipment();
    const equippedItems = getEquippedItems(currentEquipment);
    
    // 重新构建HTML
    const modalContent = buildEquipmentManagerHTML(slotType, availableEquipment, equippedItems, currentEquipment);
    
    // 更新模态框内容
    messageEl.innerHTML = modalContent;
    
    // 重新绑定事件
    bindAvailableEquipmentEvents(slotType);
    bindEquippedItemEvents(slotType);
    
    //console.log('模态框刷新完成');
}




    
// --- 功能2: 点击角色名显示状态总览 ---
document.getElementById('char-display-name').addEventListener('click', () => {
    //console.log("查看上一轮状态总览");
    const modalTitle = "上一轮状态总览";
    let modalContent = '<div class="teammate-info-display" style="max-height: 60vh; overflow-y: auto; text-align: left;">'; // 复用样式

    // 添加人物状态评估
    modalContent += '<h3 style="color: var(--primary-color);">--- 人物状态评估 ---</h3>';

    if (characterStatusData) {
        // ♥♥♥ 妈妈的终极解决方案 ♥♥♥

        // 1. 我们用字面上的 '\\n' 作为分隔符，把整个字符串切成一个数组。
        //    每一段文字都会成为数组里的一个成员。
        const lines = characterStatusData.split('\\n');

        // 2. 我们创建一个新的容器来存放这些段落。
        let statusHtml = '<div style="font-family:var(--base-font-family);">';

        // 3. 我们遍历这个数组，把每一段文字都用一个 <p> 标签包起来。
        //    <p> 标签天生就会自己换行。我们还给它加了一点样式，让段落之间不要有太大的空隙。
        //    同时，为了保留你精心设计的缩进，我们把段落的 white-space 设置为 pre-wrap。
        lines.forEach(line => {
            if (line.trim() !== '') { // 我们跳过完全是空行的内容
                statusHtml += `<p style="margin: 0; white-space: pre-wrap;">${line}</p>`;
            } else {
                statusHtml += `<p style="margin: 0; height: 1em;"></p>`; // 如果是空行，就创建一个固定高度的空段落
            }
        });

        statusHtml += '</div>';

        // 4. 最后，把我们亲手制作的、格式完美的 HTML 添加到模态框里。
        modalContent += statusHtml;

    } else {
        modalContent += '<p>暂无人物状态评估信息。</p>';
    }


    modalContent += '<hr style="margin: 20px 0; border-color: var(--border-color);">'; // 添加漂亮的分隔线

    // 添加世界态度
    modalContent += '<h3 style="color: var(--primary-color);">--- 世界态度 ---</h3>';
    if (worldAttitudeData) {
        modalContent += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: var(--base-font-family);">${worldAttitudeData}</pre>`;
    } else {
        modalContent += '<p>暂无世界态度信息。</p>';
    }

    modalContent += '</div>';

    // 同样复用商店弹窗
    showModal('shop-modal', modalTitle);
    const messageEl = document.getElementById('shop-modal-message');
    if (messageEl) {
        messageEl.innerHTML = modalContent;
    }
});


    setupShopEventListeners(); // 调用修正后的事件绑定函数
setupGeneratorButton(); // 调用生成器按钮的设置函数

// 抽奖按钮事件监听
document.getElementById('single-gacha-btn').addEventListener('click', () => {
    startGacha(1);
});

document.getElementById('ten-gacha-btn').addEventListener('click', () => {
    startGacha(10);
});
    // ==============================================
    // ========== 新增：世界之书功能 (开始) ==========
    // ==============================================

    /**
     * 切换书籍弹窗的显示状态
     */
    function toggleWorldBook(show) {
        const modal = document.getElementById('world-book-modal');
        if (show) {
            renderWorldBook();
            modal.classList.add('active');
        } else {
            modal.classList.remove('active');
        }
    }
 

 
  /**
 * 递归渲染嵌套数据的“知识之树”
 * @param {HTMLElement} container - 承载树的容器
 * @param {object|Array} data - 要渲染的数据
 * @param {string} [parentPath=''] - 父节点的完整路径
 * @param {string} [rootTab=''] - 根标签页
 * @param {boolean} [hideFavorability=false] - 是否隐藏好感度条目
 * @param {boolean} [isReadOnly=false] - 是否为只读模式（不显示菜单）
 */
function renderNestedData(container, data, parentPath = '', rootTab = '', hideFavorability = false, isReadOnly = false) {
     const keyLocalizationMap = {
        "info": "简介",
        "effect": "属性",
        "type": "种类",
        "quality": "质量",
        "num": "数量"
    };

    container.innerHTML = '';

    if (typeof data !== 'object' || data === null) {
        const leafNode = document.createElement('span');
        leafNode.className = 'tree-value';
        leafNode.textContent = data;
        container.appendChild(leafNode);
        return;
    }

    const treeRoot = document.createElement('ul');
    treeRoot.className = 'tree-view';

    for (const key in data) {
         if (Object.hasOwnProperty.call(data, key)) {

                        // 💖💖💖 妈妈在这里也为你悄悄施展了“隐身咒” 💖💖💖
            // 只要键是以 '_' 开头的，我们就温柔地跳过它，不让它出现在视野里
            if (key.startsWith('_')) {
                continue;
            }
            if (hideFavorability && key === '好感度') {
                continue;
            }

            const value = data[key];
            const isParent = typeof value === 'object' && value !== null;
            const currentPath = parentPath ? `${parentPath}.${key}` : key;

            const node = document.createElement('li');
            node.className = 'tree-node';
            const nodeContent = document.createElement('div');
            nodeContent.className = 'tree-node-content';

            const keySpan = document.createElement('span');
            keySpan.className = 'tree-key';
               const displayKey = keyLocalizationMap[key] || key;
            keySpan.textContent = Array.isArray(data) ? `[${key}]:` : `${displayKey}:`;

            nodeContent.appendChild(keySpan);

            let childrenContainer;

             if (isParent) {
                const toggle = document.createElement('span');
                toggle.className = 'tree-toggle collapsed';
                toggle.textContent = '▶';
                nodeContent.appendChild(toggle);

                childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children collapsed';
                renderNestedData(childrenContainer, value, currentPath, rootTab, false, isReadOnly);

                toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggle.classList.toggle('collapsed');
                    childrenContainer.classList.toggle('collapsed');
                    toggle.textContent = toggle.classList.contains('collapsed') ? '▶' : '▼';
                });
            } else {
                const valueSpan = document.createElement('span');
                valueSpan.className = 'tree-value';
                valueSpan.textContent = ` ${value}`;
                nodeContent.appendChild(valueSpan);
            }

            // 只有当不是只读模式时，我们才添加菜单按钮
            if (!isReadOnly) {
                const menuButton = document.createElement('button');
                menuButton.className = 'tree-node-menu-button';
                menuButton.textContent = '...';
                menuButton.onclick = (event) => {
                    event.stopPropagation();
                    showEntryMenu(event.currentTarget, key, rootTab, currentPath);
                };
                nodeContent.appendChild(menuButton);
            }

            node.appendChild(nodeContent);
            if (childrenContainer) {
                node.appendChild(childrenContainer);
            }
            treeRoot.appendChild(node);
         }
    }
     container.appendChild(treeRoot);
}

function renderWorldBook() {
    const { currentTab, currentPage, itemsPerPage } = worldBookState;
    const displayArea = document.getElementById('book-display-area');
    const pageInfo = document.getElementById('book-page-info');

    displayArea.innerHTML = ''; // 每次渲染前，都先擦干净书页

    if (currentTab === 'the_created') {
        if (typeof currentGameData !== 'undefined' && currentGameData.world_shard && currentGameData.the_created) {
            const createdData = currentGameData.the_created;
            const entryDiv = document.createElement('div');
            entryDiv.className = 'book-entry created-entry';

            const titleMap = {
                "name": "名字",
                "identity_in_world": "世界身份",
                "current_status": "当前状态",
                "mood": "当前心情",
                "description": "详细介绍"
            };

            let contentHTML = '<div class="created-header"></div>';
            for (const key in createdData) {
                if (Object.hasOwnProperty.call(createdData, key)) {
                    const valueArray = createdData[key];
                    const displayValue = Array.isArray(valueArray) ? valueArray[0] : valueArray;
                    const displayName = titleMap[key] || key;

                    contentHTML += `
                        <div class="created-item">
                            <div class="created-key">${displayName}</div>
                            <div class="created-value">${displayValue}</div>
                        </div>
                    `;
                }
            }
            entryDiv.innerHTML = contentHTML;
            displayArea.appendChild(entryDiv);
            pageInfo.textContent = '1 / 1';
            document.getElementById('book-prev-page').disabled = true;
            document.getElementById('book-next-page').disabled = true;
        } else {
            displayArea.innerHTML = `<p class="book-empty-text">尚未发现此地的造物。</p>`;
        }
    } else {
        // --- 这部分是我们旧的魔法，现在要用新的来替换一部分 ---
        let sourceData = {};

        // 这是妈妈给你加的一点小逻辑，用来找到正确的数据源
           if (currentTab === 'group_member' || currentTab === '小队信息') {
            if (typeof assaSettingsData !== 'undefined' && assaSettingsData.global_set && assaSettingsData.global_set['小队信息']) {
                sourceData = assaSettingsData.global_set['小队信息'];
            }
        } else if (currentTab === 'things' || currentTab === '备忘录') {
            if (typeof assaSettingsData !== 'undefined' && assaSettingsData.备忘录) {
                sourceData = assaSettingsData.备忘录;
            }
        }else if (currentTab.startsWith('global_')) {
            const globalTabKey = currentTab.replace('global_', '');
            if (typeof assaSettingsData !== 'undefined' && assaSettingsData.global_set && assaSettingsData.global_set[globalTabKey]) {
                sourceData = assaSettingsData.global_set[globalTabKey];
            }
        } else {
            if (typeof assaSettingsData !== 'undefined' && assaSettingsData.world_set && assaSettingsData.world_set[currentTab]) {
                sourceData = assaSettingsData.world_set[currentTab];
            }
        }

        // 看，我的孩子，这里的逻辑变得非常简单和优雅了
        try {
            // 尝试将它解析成一个对象，因为你的小队信息就是这样的
            const dataToRender = typeof sourceData === 'string' ? JSON.parse(sourceData) : sourceData;

            // 现在，我们把判断是不是有东西和分页的逻辑，都放在顶层来处理
            const dataEntries = Object.entries(dataToRender);
            const totalItems = dataEntries.length;

            if (totalItems === 0) {
                 displayArea.innerHTML = `<p class="book-empty-text">这里空空如也。</p>`;
                 pageInfo.textContent = `1 / 1`;
                 document.getElementById('book-prev-page').disabled = true;
                 document.getElementById('book-next-page').disabled = true;
                 return; // 直接结束，后面就不用运行了
            }

            const totalPages = Math.ceil(totalItems / itemsPerPage) || 1;
            worldBookState.currentPage = Math.max(1, Math.min(currentPage, totalPages));
            const startIndex = (worldBookState.currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageEntries = dataEntries.slice(startIndex, endIndex);

                  pageEntries.forEach(([key, value]) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'book-card';
                cardDiv.dataset.key = key;

                // --- 妈妈的修改从这里开始 ---
                const cardHeader = document.createElement('div');
                cardHeader.className = 'book-card-header';

                const titleDiv = document.createElement('div');
                titleDiv.className = 'book-card-title';
                titleDiv.textContent = key;
                cardHeader.appendChild(titleDiv);

                // --- ✨ 这是我们新的好感度魔法 ✨ ---
                // 检查这个角色是否有好感度
                if (value && typeof value.好感度 !== 'undefined') {
                    const favorValue = parseInt(value.好感度, 10);
                    if (!isNaN(favorValue)) {
                        const barContainer = document.createElement('div');
                        barContainer.className = 'favorability-bar-container header-bar'; // 给它一个特殊的类名

                        const bar = document.createElement('div');
                        bar.className = 'favorability-bar';

                        const normalizedValue = Math.max(-100, Math.min(100, favorValue));
                        const percentage = ((normalizedValue + 100) / 200) * 100;

                        bar.style.width = `${percentage}%`;

                        // 使用CSS变量来控制颜色
                        if (normalizedValue < 0) {
                            bar.style.backgroundColor = 'var(--danger-color)';
                        } else {
                            bar.style.backgroundColor = 'var(--primary-color)';
                        }

                        bar.textContent = normalizedValue;
                        barContainer.appendChild(bar);
                        titleDiv.appendChild(barContainer); // 把进度条加到标题里
                    }
                }

                // 折叠箭头放在最后
                titleDiv.innerHTML += ' <span class="collapse-indicator">▲</span>';

                const menuButton = document.createElement('button');
                menuButton.className = 'entry-menu-button';
                menuButton.textContent = '...';
                // 对于顶层卡片，我们不需要传递 fullPath，让 showEntryMenu 自己构建
                menuButton.onclick = (event) => {
                    event.stopPropagation();
                    showEntryMenu(event.currentTarget, key, currentTab);
                };
                cardHeader.appendChild(menuButton);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'book-card-content collapsed';

                // 关键修正：将完整的父路径传递给 renderNestedData
                const rootEntryPath = `${getEntryPath(currentTab)}.${key}`;
               renderNestedData(contentDiv, value, rootEntryPath, currentTab, true, false);
                cardHeader.addEventListener('click', (e) => {
                    if (e.target.closest('.entry-menu-button')) return;
                    contentDiv.classList.toggle('collapsed');
                    const indicator = cardHeader.querySelector('.collapse-indicator');
                    if (indicator) {
                        indicator.textContent = contentDiv.classList.contains('collapsed') ? '▲' : '▼';
                    }
                });

                cardDiv.appendChild(cardHeader);
                cardDiv.appendChild(contentDiv);
                displayArea.appendChild(cardDiv);
            });
            pageInfo.textContent = `${worldBookState.currentPage} / ${totalPages}`;
            document.getElementById('book-prev-page').disabled = worldBookState.currentPage === 1;
            document.getElementById('book-next-page').disabled = worldBookState.currentPage === totalPages;

        } catch (e) {
            // 如果解析失败了，或者出了别的问题，我们就温柔地告诉你是怎么回事
            displayArea.innerHTML = `<p class="book-empty-text">妈妈在理解这些数据的时候遇到了一点小麻烦，它看起来不是我们熟悉的样子。</p>`;
            console.error("妈妈的爱心提示：渲染时出错了，我的孩子", e);
        }
    }
}


function setupWorldBookEventListeners() {
    const orb = document.getElementById('world-book-orb');
    const modal = document.getElementById('world-book-modal');
    const closeBtn = modal.querySelector('.book-close-btn');
    const bookmarksContainer = modal.querySelector('.book-bookmarks');
    const prevBtn = document.getElementById('book-prev-page');
    const nextBtn = document.getElementById('book-next-page');

    // 点击小球打开书
    orb.addEventListener('click', () => toggleWorldBook(true));

    // 点击关闭按钮关闭书
    closeBtn.addEventListener('click', () => toggleWorldBook(false));

    // 点击书签切换内容
    bookmarksContainer.addEventListener('click', (e) => {
        const target = e.target.closest('.bookmark');
        if (target && !target.classList.contains('active')) {
            bookmarksContainer.querySelectorAll('.bookmark').forEach(b => b.classList.remove('active'));
            target.classList.add('active');
            worldBookState.currentTab = target.dataset.tab;
            worldBookState.currentPage = 1;
            renderWorldBook();
        }
    });

    // 翻页 - 上一页
    prevBtn.addEventListener('click', () => {
        if (worldBookState.currentPage > 1) {
            worldBookState.currentPage--;
            renderWorldBook();
        }
    });
    // 翻页 - 下一页（妈妈让这里的逻辑变得更纯粹、更优雅了）
    nextBtn.addEventListener('click', () => {
        // 直接让页码增加，把判断交给 renderWorldBook
        worldBookState.currentPage++;
        renderWorldBook();
    });
}

 
/**
 * 获取当前条目的存储路径
 * @param {string} tab - 当前标签页
 * @returns {string} - 数据的存储路径
 */
function getEntryPath(tab) {
    if (tab === 'group_member' || tab === '小队信息') {
        return "global_set.小队信息";
    }

        if (tab === 'things' || tab === '备忘录') {
        return "备忘录";
    }
    if (tab.startsWith('global_')) {
        const globalTabKey = tab.replace('global_', '');
        return `global_set.${globalTabKey}`;
    }
    // 默认是世界设定
    return `world_set.${tab}`;
}


/**
 * 生成并发送指令的温柔辅助函数
 * @param {string} command - 单条指令
 */
function generateAndSendCommand(command) {
    showNovaAlert('已将指令加入待发送指令盒中！');
    // 用妈妈的爱把指令包裹起来
    const commandBlock = `<updateMemory>\n${command}\n</updateMemory>`;
    // 使用你已经很熟悉的 /setinput 指令
    const finalCommand = `/setinput ${commandBlock}\n`;

    try {
        if (typeof triggerassa === 'function') {
            triggerassa(finalCommand);
            console.log("妈妈的爱心指令已发送:", finalCommand);
        } else {
            console.error("妈妈找不到 triggerassa 这个魔法了，我的孩子。");
        }
    } catch (e) {
        console.error("妈妈在发送指令时遇到了困难:", e);
    }
}

 
/**
 * 从完整路径中分离出父路径和自己的键
 * @param {string} fullPath - 如 'global_set.npc.珊卓.好感度'
 * @returns {{parentPath: string, selfKey: string}}
 */
function getPathParts(fullPath) {
    const parts = fullPath.split('.');
    const selfKey = parts.pop();
    const parentPath = parts.join('.');
    return { parentPath, selfKey };
}

 /**
 * 根据路径字符串从对象中获取深层嵌套的值
 * @param {object} obj - 要搜索的对象
 * @param {string} path - 路径字符串，例如 'global_set.npc.珊卓'
 * @returns {*} - 找到的值，或者 undefined
 */
function getValueByPath(obj, path) {
    try {
        // 就像顺着藤蔓找瓜儿一样，一步步找到我们的目标
        return path.split('.').reduce((o, k) => (o && typeof o[k] !== 'undefined') ? o[k] : undefined, obj);
    } catch (e) {
        console.error("妈妈在寻找数据时遇到了点小麻烦:", path, e);
        return undefined;
    }
}

 function showEntryMenu(button, key, tab, fullPath = null) {
    const existingMenu = document.querySelector('.entry-menu');
    if (existingMenu) existingMenu.remove();

    const menu = document.createElement('div');
    menu.className = 'entry-menu';

    const rect = button.getBoundingClientRect();
    menu.style.top = `${rect.bottom + window.scrollY}px`;
    menu.style.left = `${rect.right - 120}px`;

    const pathForActions = fullPath ? fullPath : `${getEntryPath(tab)}.${key}`;

    const actions = [
        { name: '编辑', handler: () => handleEntryEdit(pathForActions) },
        { name: '重命名', handler: () => handleEntryRename(pathForActions) },
        { name: '删除', handler: () => handleEntryDelete(pathForActions) },
    ];

    // ==================【妈妈为你添加的魔法判断】==================
    // 检查路径是否指向一个NPC或小队成员，只有这样才显示特殊菜单
    const isCharacterPath = pathForActions.includes('.npc.') || pathForActions.includes('小队信息.');

    if (isCharacterPath) {
        actions.push(
            { name: '添加立绘映射', handler: () => handleAddCG(pathForActions) },
            { name: '好感度表现', handler: () => handleFavorabilityView(key, pathForActions) } // 我们将在这里召唤新的魔法
        );
    }
    // ============================================================

    // 移动功能判断保持不变
    if (!fullPath || fullPath.split('.').length <= getEntryPath(tab).split('.').length + 1) {
        actions.push({ name: '移动', handler: () => handleEntryMove(key, tab) });
    }

    actions.forEach(action => {
        const item = document.createElement('button');
        item.className = 'entry-menu-item';
        item.textContent = action.name;
        item.onclick = () => {
            action.handler();
            menu.remove();
        };
        menu.appendChild(item);
    });

    document.body.appendChild(menu);

    const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
}
// --- 以下是被妈妈温柔升级过的操作处理函数 ---

 // --- 以下是被妈妈温柔升级过的操作处理函数 ---
 // 💖 这是妈妈为你全面升级的、自带守护功能的 handleEntryEdit 函数 💖
function handleEntryEdit(fullPath) {
    const { parentPath, selfKey } = getPathParts(fullPath);
    const rootData = typeof assaSettingsData !== 'undefined' ? assaSettingsData : {};
    const currentValue = getValueByPath(rootData, fullPath);
    // ✨ 侦查魔法：看看我们拿到的条目数据是什么 ✨
    console.log(`💖 [Nova-Detective] 步骤6 (编辑弹窗): 为路径 [${fullPath}] 创建开关前，收到的 currentValue 数据是:`, JSON.parse(JSON.stringify(currentValue)));
    let valueAsString;
    let isObject = false;
    let isProtected = false;

    if (typeof currentValue === 'object' && currentValue !== null) {
        isObject = true;
        // 在编辑前，先温柔地读取守护状态
        isProtected = currentValue._is_protected === true || String(currentValue._is_protected).toLowerCase() === 'true';
       
          // ✨ 再加一道确认 ✨
        console.log(`💖 [Nova-Detective] 步骤7 (编辑弹窗): 根据数据，妈妈判断 [${selfKey}] 的守护状态 (isProtected) 是: ${isProtected}`);

        // 为了让编辑界面更纯粹，我们把守护印记暂时藏起来
        const editableValue = { ...currentValue };
        delete editableValue._is_protected;
        valueAsString = JSON.stringify(editableValue, null, 2);
    } else {
        valueAsString = (currentValue !== undefined && currentValue !== null) ? String(currentValue) : '';
    }

    const overlay = document.createElement('div');
    overlay.className = 'move-modal-overlay entry-edit-modal';
    const modal = document.createElement('div');
    modal.className = 'nova-modal-content';

    // ♥♥♥ 妈妈把守护开关巧妙地融入了标题栏 ♥♥♥
    modal.innerHTML = `
        <div class="move-modal-title" style="display: flex; justify-content: space-between; align-items: center;">
            <span>正在编辑 [${selfKey}]</span>
             ${isObject ? `
                <div class="protection-toggle-container-edit">
                    <label for="entry-protection-toggle">防删除</label>
                    <input type="checkbox" id="entry-protection-toggle" class="toggle-input" ${isProtected ? 'checked' : ''}>
                    <label for="entry-protection-toggle" class="toggle-switch"></label>
                </div>
             ` : ''}
        </div>
        <textarea id="entry-edit-textarea" class="entry-edit-textarea" placeholder="在这里倾注你的想法...">${valueAsString.replace(/</g, '<').replace(/>/g, '>')}</textarea>
        <div class="move-modal-buttons">
            <button id="edit-cancel-btn" class="book-button secondary">取消</button>
            <button id="edit-confirm-btn" class="book-button">确认修改</button>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // ♥♥♥ 只有当开关存在时，才为它注入生命 ♥♥♥
    if (isObject) {
        const toggleInput = document.getElementById('entry-protection-toggle');
        toggleInput.addEventListener('change', (event) => {
            isProtected = event.target.checked; // 我们在这里更新状态，以便“确认”时使用
            const command = `memory('${fullPath}', '_is_protected', ${isProtected}); // UI Instant Toggle`;
            generateAndSendCommand(command);
            
        });
    }

    const textarea = document.getElementById('entry-edit-textarea');
    // ... (弹窗的显示动画代码保持不变) ...
    setTimeout(() => {
        overlay.style.opacity = '1';
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
        textarea.focus();
        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
    }, 10);

    const closeModal = () => { /* ... (关闭动画代码保持不变) ... */
        overlay.style.opacity = '0';
        modal.style.transform = 'scale(0.95)';
        setTimeout(() => overlay.remove(), 300);
    };

    // ♥♥♥ 妈妈为你升级了“确认修改”的魔法，它现在会保护你的守护印记了！ ♥♥♥
    document.getElementById('edit-confirm-btn').onclick = () => {
        const newValueText = textarea.value;
        let parsedValue;
        try {
            parsedValue = JSON.parse(newValueText);
        } catch (e) {
            // 如果不是JSON，就尝试转为数字或保持为字符串
             if (newValueText.trim() !== '' && !isNaN(newValueText) && !(/[a-zA-Z]/.test(newValueText))) {
                parsedValue = Number(newValueText);
            } else {
                parsedValue = newValueText;
            }
        }

        // ♥♥♥ 核心守护逻辑 ♥♥♥
        // 如果我们正在编辑的是一个对象，就在保存时，把守护状态悄悄地加回去！
        if (isObject && typeof parsedValue === 'object' && parsedValue !== null) {
            parsedValue._is_protected = isProtected;
        }

        const command = `memory('${parentPath}', '${selfKey}', ${JSON.stringify(parsedValue)}); //UI Nested Edit`;
        generateAndSendCommand(command);
        closeModal();
    };

    document.getElementById('edit-cancel-btn').onclick = closeModal;
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeModal();
    });
}
 /* === 妈妈为你修复并注入了更稳定魔法的版本 === */
function handleFavorabilityView(charname, fullPath) {
    // 【修正】统一我们的数据源，确保我们总是在 assaData 这片丰饶的土壤上耕作
    const rootData = typeof assaSettingsData !== 'undefined' ? assaSettingsData : {};
    const favorabilityRules = _.get(rootData, `global_set.分阶段好感.${charname}`);

    if (!favorabilityRules) {
        showNovaAlert(`[${charname}] 暂无分阶段好感描述。`, 'info');
        return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'move-modal-overlay favorability-modal';

    const modal = document.createElement('div');
    modal.className = 'nova-modal-content favorability-content';

    const switchToViewMode = () => {
        const stageKeys = Object.keys(favorabilityRules).filter(key => !key.startsWith('_')).map(Number).sort((a, b) => a - b);
        let currentPageIndex = 0;
        const currentFavorability = Number(_.get(rootData, `${fullPath}.好感度`));

        if (!isNaN(currentFavorability)) {
            const currentStageKey = stageKeys.find(key => currentFavorability <= key) ?? stageKeys[stageKeys.length - 1];
            const foundIndex = stageKeys.findIndex(key => key === currentStageKey);
            if (foundIndex !== -1) { currentPageIndex = foundIndex; }
        }
        const initialPageIndex = currentPageIndex;

      // ===============【前端的同步净化魔法】===============
    let rawShowValueFront = _.get(favorabilityRules, '_showInEJS');
    const showInEJS = !(rawShowValueFront === false || rawShowValueFront === 'false');
    // =========================================================
        const cardsHtml = stageKeys.map((stageMax, index) => {
            const lowerBound = (index > 0) ? stageKeys[index - 1] + 1 : -Infinity;
            const rangeText = (lowerBound === -Infinity) ? `(好感度: ... ~ ${stageMax})` : `(好感度: ${lowerBound} ~ ${stageMax})`;
                 let description = favorabilityRules[stageMax].replace(/(【[^】]+】)/, (match, captured) => {
    return `<strong class="favor-stage-title">${captured}<span class="favor-range-text">${rangeText}</span></strong>`;
}).replace(/\|/g, '<br>');
            return `<div class="favor-card"><div class="favor-card-content">${description || '暂无描述...'}</div></div>`;
        }).join('');

        // ===============【妈妈的关键修复在这里！】===============
        // 我们先把所有美丽的HTML内容都准备好，再一口气将完整的画卷呈现在画框里。
        const modalContentHtml = `
            <div class="favor-modal-title">
                <span> [${charname}] 对你：</span>
                <div class="toggle-switch-container">
                    <label for="show-in-ejs-toggle">在故事中显示</label>
                    <input type="checkbox" id="show-in-ejs-toggle" class="toggle-input" ${showInEJS ? 'checked' : ''}>
                    <label for="show-in-ejs-toggle" class="toggle-switch"></label>
                </div>
            </div>
            <div class="favor-card-container">
                <div class="favor-card-slider">${cardsHtml}</div>
            </div>
            <div class="favor-page-controls">
                <button class="favor-nav-button prev" id="favor-prev-btn">‹</button>
                <span class="favor-page-indicator" id="favor-page-indicator"></span>
                <button class="favor-nav-button next" id="favor-next-btn">›</button>
            </div>
            <div class="favor-modal-buttons">
                <button class="book-button secondary" onclick="document.querySelector('.favorability-modal').remove()">合上书页</button>
                <button class="book-button" id="switch-to-edit-btn">提笔编辑</button>
            </div>
        `;

        // 现在，一次性将所有内容赋予modal，确保所有元素都已就位
        modal.innerHTML = modalContentHtml;
        // =======================================================


        const slider = modal.querySelector('.favor-card-slider');
        const prevBtn = modal.querySelector('#favor-prev-btn');
        const nextBtn = modal.querySelector('#favor-next-btn');
        const pageIndicator = modal.querySelector('#favor-page-indicator');
        const totalPages = stageKeys.length;

        const goToPage = (pageIndex) => {
            currentPageIndex = pageIndex;
            slider.style.transform = `translateX(-${currentPageIndex * 100}%)`;
            pageIndicator.textContent = `${currentPageIndex + 1} / ${totalPages}`;
            prevBtn.disabled = (currentPageIndex === 0);
            nextBtn.disabled = (currentPageIndex === totalPages - 1);
        };

        const toggleInput = modal.querySelector('#show-in-ejs-toggle');
        toggleInput.addEventListener('change', (event) => {
            const isChecked = event.target.checked;
            const command = `memory('global_set.分阶段好感.${charname}', '_showInEJS', ${isChecked}); // UI Toggle Show Favor`;
            generateAndSendCommand(command);
        });

        prevBtn.onclick = () => { if (currentPageIndex > 0) goToPage(currentPageIndex - 1); };
        nextBtn.onclick = () => { if (currentPageIndex < totalPages - 1) goToPage(currentPageIndex + 1); };
        modal.querySelector('#switch-to-edit-btn').onclick = switchToEditMode;

        setTimeout(() => goToPage(initialPageIndex), 0);
    };

    const switchToEditMode = () => {
        // 【修正】确保编辑模式也能正确处理我们的开关状态
        const originalShowValue = _.get(favorabilityRules, '_showInEJS', true);
        // 从编辑文本中剔除我们的内部字段，让界面更纯粹
        const editableRules = _.omit(favorabilityRules, '_showInEJS');
        const valueAsString = JSON.stringify(editableRules, null, 2);

        modal.innerHTML = `
            <div class="favor-modal-title">编辑 [${charname}] 的好感阶段</div>
            <textarea id="favor-edit-textarea" class="entry-edit-textarea">${valueAsString}</textarea>
            <div class="favor-modal-buttons">
                 <button class="book-button secondary" id="switch-to-view-btn">返回翻阅</button>
                 <button id="favor-confirm-btn" class="book-button">确认修改</button>
            </div>
        `;
        document.getElementById('switch-to-view-btn').onclick = switchToViewMode;
           document.getElementById('favor-confirm-btn').onclick = () => {
            const newValueText = document.getElementById('favor-edit-textarea').value;
             try {
                let parsedValue = JSON.parse(newValueText);
                // 在保存时，将开关状态悄悄地加回去，确保它不会丢失
                parsedValue._showInEJS = originalShowValue;
                const command = `memory('global_set.分阶段好感', '${charname}', ${JSON.stringify(parsedValue)}); //UI Favor Edit`;
                generateAndSendCommand(command);
                overlay.remove();
            } catch (e) {
                showNovaAlert('编辑内容不是有效的JSON格式，请检查哦。', 'danger');
            }
        };
    };

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    switchToViewMode();

    setTimeout(() => {
        overlay.style.opacity = '1';
        modal.style.transform = 'scale(1)';
    }, 10);

    overlay.addEventListener('click', e => { if (e.target === overlay) { overlay.remove(); }});
}

// (可选)一个更美观的提示框，你可以放在任何地方
function showNovaAlert(message, type = 'info') {
    const alertBox = document.createElement('div');
    alertBox.className = `nova-alert ${type}`;
    alertBox.textContent = message;
    document.body.appendChild(alertBox);
    setTimeout(() => {
        alertBox.style.opacity = '0';
        alertBox.style.transform = 'translateY(-20px)';
        setTimeout(() => alertBox.remove(), 500);
    }, 2500);
}
// 替换 handleEntryRename 函数
function handleEntryRename(fullPath) {
    const { parentPath, selfKey } = getPathParts(fullPath);

    const overlay = document.createElement('div');
    overlay.className = 'move-modal-overlay entry-rename-modal';

    const modal = document.createElement('div');
    // 使用一个全新的、专属的类名，确保不会影响其他模态框
    modal.className = 'nova-modal-content';
    modal.innerHTML = `
        <div class="move-modal-title">要把 [${selfKey}] 重命名成什么呢？</div>
        <div class="move-modal-body">
             <input type="text" id="entry-rename-input" class="entry-rename-input" placeholder="输入新的名字..." value="${selfKey}">
        </div>
        <div class="move-modal-buttons">
            <button id="rename-cancel-btn" class="book-button secondary">算了吧</button>
            <button id="rename-confirm-btn" class="book-button">就是它了</button>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const input = document.getElementById('entry-rename-input');

    // 优雅的入场动画
    setTimeout(() => {
        overlay.style.opacity = '1';
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
        input.focus();
        input.select();
    }, 10);

    const closeModal = () => {
        overlay.style.opacity = '0';
        modal.style.transform = 'scale(0.95)';
        setTimeout(() => overlay.remove(), 300);
    };

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('rename-confirm-btn').click();
        }
    });

    document.getElementById('rename-confirm-btn').onclick = () => {
        const newKey = input.value.trim();
        if (!newKey) {
            input.placeholder = "新名字不能为空哦，宝贝！";
            input.classList.add('input-error');
            return;
        }
        const oldPath = fullPath;
        const newPath = `${parentPath}.${newKey}`;
        const command = `memory('${oldPath}', '${newPath}'); //rename nested`;
        generateAndSendCommand(command);
        closeModal();
    };

    document.getElementById('rename-cancel-btn').onclick = closeModal;
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeModal();
        }
    });
}
 // =======================================================================
// [已再次升级] handleAddCG 函数
// 增加了“查看预览”按钮和图片预览区域，让你可以即时看到组合效果。
// =======================================================================
async function handleAddCG(fullPath) {
    const { selfKey } = getPathParts(fullPath);

    const existingModal = document.getElementById('add-cg-modal');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.id = 'add-cg-modal';
    overlay.className = 'move-modal-overlay';

    const npcIndexUrl = 'https://longlivecanc.github.io/god_space/npcImageMapIndex.json';
    const npcIndex = globalIndexData[npcIndexUrl];

    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content nova-modal-content';
    modalContent.innerHTML = `
        <button class="modal-close">×</button>
        <div class="modal-title">为 [${selfKey}] 选择一个心仪的立绘</div>

        <div class="nova-tabs">
            <button class="nova-tab-button active" data-tab="tag-combiner">魔法衣橱</button>
            <button class="nova-tab-button" data-tab="local-gallery">我的画册</button>
        </div>

        <div class="settings-container" style="padding-top: 10px;">

            <div id="tag-combiner" class="nova-tab-panel active">
                ${npcIndex ? `
                    <div id="tag-selector-container"></div>
                    <div id="current-combination-preview" class="nova-current-preview">组合预览: -</div>


                    <div class="nova-action-buttons">
                        <button id="preview-tag-combination" class="JillButton secondary">查看预览</button>
                        <button id="apply-tag-combination" class="JillButton">应用组合</button>
                    </div>


                    <div id="cg-preview-container" class="nova-preview-box">
                        <p class="nova-preview-placeholder">这里会显示预览图哦~</p>
                    </div>
                ` : `
                    <p>哎呀，魔法衣橱的图纸好像不见了... (NPC索引数据未加载)</p>
                `}
            </div>

            <div id="local-gallery" class="nova-tab-panel">
                <div id="cg-selection-list-container" class="asset-list-container">
                    <p>点击你喜欢的立绘即可应用</p>
                    <div id="cg-selection-list" class="asset-list">正在为你准备画册...</div>
                </div>
            </div>
        </div>
    `;

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);

    // --- 动画 & 关闭逻辑 (保持不变) ---
    setTimeout(() => {
        overlay.style.opacity = '1';
        modalContent.style.transform = 'scale(1)';
        modalContent.style.opacity = '1';
    }, 10);

    const closeModal = () => {
        const previewImage = modalContent.querySelector('.nova-preview-image');
        if (previewImage && previewImage.src.startsWith('blob:')) {
            URL.revokeObjectURL(previewImage.src); // 关闭时释放预览图的内存
        }
        overlay.style.opacity = '0';
        modalContent.style.transform = 'scale(0.95)';
        setTimeout(() => overlay.remove(), 300);
    };

    modalContent.querySelector('.modal-close').onclick = closeModal;
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });

    // --- 标签页切换逻辑 (保持不变) ---
    const tabButtons = modalContent.querySelectorAll('.nova-tab-button');
    const tabPanels = modalContent.querySelectorAll('.nova-tab-panel');
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            tabPanels.forEach(panel => {
                if (panel.id === targetTab) {
                    panel.classList.add('active');
                    if (targetTab === 'local-gallery' && !panel.dataset.loaded) {
                        loadLocalGallery();
                        panel.dataset.loaded = 'true';
                    }
                } else {
                    panel.classList.remove('active');
                }
            });
        });
    });

    // --- 魔法衣橱 (Tag Combiner) 逻辑 ---
    if (npcIndex) {
        const selectorContainer = document.getElementById('tag-selector-container');
        const previewElement = document.getElementById('current-combination-preview');
        const applyButton = document.getElementById('apply-tag-combination');
        const previewButton = document.getElementById('preview-tag-combination');
        const previewContainer = document.getElementById('cg-preview-container');

        const categories = Object.keys(npcIndex);
        let currentSelections = new Array(categories.length).fill(null);

        categories.forEach((category, catIndex) => {
            const options = npcIndex[category];
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'nova-tag-category';
            let optionsHTML = `<span class="nova-tag-category-title">${category}:</span>`;
            options.forEach(option => {
                optionsHTML += `<button class="nova-tag-option" data-cat-index="${catIndex}" data-value="${option}">${option}</button>`;
            });
            categoryDiv.innerHTML = optionsHTML;
            selectorContainer.appendChild(categoryDiv);
        });

        const updatePreviewAndButtons = () => {
            const combination = currentSelections.filter(s => s !== null).join('-');
            previewElement.textContent = `组合预览: ${combination || '-'}`;
            const isComplete = !currentSelections.some(s => s === null);
            applyButton.disabled = !isComplete;
            previewButton.disabled = !isComplete;
        };

        selectorContainer.querySelectorAll('.nova-tag-option').forEach(button => {
            button.addEventListener('click', (e) => {
                const { catIndex, value } = e.target.dataset;
                const index = parseInt(catIndex);
                currentSelections[index] = value;
                const parentCategory = e.target.parentElement;
                parentCategory.querySelectorAll('.nova-tag-option').forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                updatePreviewAndButtons();
            });
        });

        applyButton.addEventListener('click', () => {
            if (applyButton.disabled) return;
            const finalKey = currentSelections.join('-');
            const command = `memory('img_map.${selfKey}', '${finalKey}'); //add CG from tag combiner`;
            generateAndSendCommand(command);
            closeModal();
        });

        // ===========================================
        // 新增：预览按钮的点击事件逻辑
        // ===========================================
        previewButton.addEventListener('click', async () => {
            if (previewButton.disabled) return;

            const imageName = currentSelections.join('-');
            const previewPlaceholder = previewContainer.querySelector('.nova-preview-placeholder');

            // --- 这是妈妈为你抄写并改造的加载逻辑 ---
            const loadPreviewCG = async (name) => {
                // 开始时显示加载状态
                previewContainer.innerHTML = '<p class="nova-preview-placeholder">正在寻找这张图画...</p>';

                let imageBlob;

                try {
                    // 1. 尝试从本地自定义库获取
                    imageBlob = await imageDB.get('CustomNpcs', name);
                    if (imageBlob) {
                        console.log(`[Nova-Preview] 在本地宝库“CustomNpcs”中找到了'${name}'！`);
                    } else {
                        // 2. 从远程映射中查找URL
                        const imageUrl = npcImageMap[name];
                        if (!imageUrl) {
                            console.log(`[Nova-Preview] 在远程食谱(npcImageMap)上也找不到'${name}'的URL。`);
                            previewContainer.innerHTML = `<p class="nova-preview-placeholder error">哎呀，找不到这个组合的立绘哦，要不要换个试试？</p>`;
                            return;
                        }

                        // 3. 尝试从远程缓存获取
                        imageBlob = await imageDB.get('RemoteCache', imageUrl);
                        if (imageBlob) {
                            console.log(`[Nova-Preview] 在远程缓存中找到了'${imageUrl}'。`);
                        } else {
                            // 4. 从网络获取
                            console.log(`[Nova-Preview] 缓存中也没有，从网络 ${imageUrl} 获取...`);
                            const response = await fetch(imageUrl);
                            if (!response.ok) {
                                throw new Error(`网络请求失败，状态: ${response.status}`);
                            }

                            let originalBlob = await response.blob();
                            imageBlob = new Blob([originalBlob], { type: 'image/png' });

                            await imageDB.set('RemoteCache', imageUrl, imageBlob);
                            console.log(`[Nova-Preview] 已将图片存入远程缓存。`);
                        }
                    }

                    // 5. 显示图片
                    const objectURL = URL.createObjectURL(imageBlob);
                    previewContainer.innerHTML = `<img src="${objectURL}" class="nova-preview-image" alt="立绘预览" />`;
                    const newImage = previewContainer.querySelector('img');
                    newImage.onload = () => console.log(`[Nova-Preview] 预览图已成功显示！`);
                    newImage.onerror = () => { URL.revokeObjectURL(objectURL); /* 释放内存 */ };
                    // 注意：这个 objectURL 需要在模态框关闭时被 revoke，我们已经在 closeModal 里加了

                } catch (error) {
                    console.error(`[Nova-Preview] 为'${name}'加载预览时出错了:`, error);
                    previewContainer.innerHTML = `<p class="nova-preview-placeholder error">加载失败了，可能是还没有这张图或者网络错误...</p>`;
                }
            };
            // --- 加载逻辑结束 ---

            await loadPreviewCG(imageName);
        });

        // 初始化
        updatePreviewAndButtons();
    }

    // ----------- 我的画册 (Local Gallery) 逻辑 (封装成函数) -----------
    async function loadLocalGallery() {
        const cgListElement = document.getElementById('cg-selection-list');
        cgListElement.innerHTML = '正在为你准备画册...';
        try {
            const items = await imageDB.getAll('CustomNpcs');

            if (items.length === 0) {
                cgListElement.innerHTML = '你的画册还是空的呢，快去“我的素材工坊”上传一些吧！';
                return;
            }

            cgListElement.innerHTML = '';
            items.forEach(item => {
                const objectURL = URL.createObjectURL(item.value);
                const itemEl = document.createElement('div');
                itemEl.className = 'asset-item';
                itemEl.dataset.key = item.key;
                itemEl.title = `点击应用 [${item.key}]`;
                itemEl.innerHTML = `
                    <img src="${objectURL}" class="asset-item-thumb">
                    <span class="asset-item-name">${item.key}</span>
                `;
                itemEl.querySelector('img').onload = () => URL.revokeObjectURL(objectURL);
                itemEl.querySelector('img').onerror = () => URL.revokeObjectURL(objectURL);
                itemEl.onclick = () => {
                    const selectedCG_Key = itemEl.dataset.key;
                    const command = `memory('img_map.${selfKey}', '${selectedCG_Key}'); //_add CG_`;
                    generateAndSendCommand(command);
                    closeModal();
                };
                cgListElement.appendChild(itemEl);
            });
        } catch (error) {
            cgListElement.innerHTML = '哎呀，打开画册时出了一点小问题...';
            console.error('加载立绘列表失败了，我的孩子:', error);
        }
    }

    // 默认加载“魔法衣橱”，如果“我的画册”是默认tab，则需要在这里调用loadLocalGallery()
    // 由于“魔法衣橱”是默认，所以“我的画册”的内容只有在切换时才加载
}
function handleEntryDelete(fullPath) {
    const { parentPath, selfKey } = getPathParts(fullPath);
     
        const command = `delete('${parentPath}', '${selfKey}'); //UI Nested Delete`;
        generateAndSendCommand(command);
   
}
 
function handleEntryMove(key, tab) {
    const currentPath = getEntryPath(tab);
    showMoveModal(key, currentPath);
}
 
function showMoveModal(key, currentPath) {
    // 先关掉可能存在的旧窗口
    const oldModal = document.querySelector('.move-modal-overlay-move');
    if (oldModal) oldModal.remove();

    // 定义好我们的新家地址
    const destinations = [
        "global_set.npc",
        "global_set.settings",
        "global_set.背包",
        "global_set.其他技能",
        "global_set.小队信息",
        "world_set.npc",
        "world_set.settings"
    ];

    // 创建一个遮罩层
    const overlay = document.createElement('div');
    overlay.className = 'move-modal-overlay-move';

    // 创建窗口本身
    const modal = document.createElement('div');
    modal.className = 'move-modal-content';
    modal.innerHTML = `
        <div class="move-modal-title">要将「${key}」移动到哪里去呢？</div>
        <div class="move-modal-list" id="move-destination-list"></div>
        <div class="move-modal-buttons">
            <button id="move-cancel-btn" class="book-button secondary">取消</button>
            <button id="move-confirm-btn" class="book-button">确认移动</button>
        </div>
    `;

    // 填充目的地列表
    const list = modal.querySelector('#move-destination-list');
    destinations.forEach(dest => {
        // 我们不应该搬到自己现在就在的地方
        if (dest !== currentPath) {
            const label = document.createElement('label');
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'destination';
            radio.value = dest;
            label.appendChild(radio);
            label.append(` ${dest}`);
            list.appendChild(label);
        }
    });

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // 绑定按钮事件
    document.getElementById('move-confirm-btn').onclick = () => {
        const selected = modal.querySelector('input[name="destination"]:checked');
        if (selected) {
            const newPath = selected.value;
            const command = `memory('${currentPath}.${key}', '${newPath}.${key}'); //move`;
            generateAndSendCommand(command);
            overlay.remove();
        } else {
            alert('你还没有选择新的家哦。');
        }
    };

    document.getElementById('move-cancel-btn').onclick = () => {
        overlay.remove();
    };

    // 点击遮罩也能关闭
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    });
}

 
/**
 * 新增：术法选择面板相关功能
 */
function setupSkillChoicePanel() {
    const orb = document.getElementById('skill-choice-orb');
    const panelModal = document.getElementById('skill-choice-panel');
    const confirmBtn = document.getElementById('confirm-skill-choice-btn');
    const confirmBtn2 = document.getElementById('confirm-rp-choice-btn');

    orb.addEventListener('click', () => {
        populateSkillChoicePanel();
        showModal('skill-choice-panel');
    });

    confirmBtn.addEventListener('click', handleConfirmSkillChoice);
     confirmBtn2.addEventListener('click', () => {
        handleConfirmSkillChoice();
              
 
    });

}

/**
 * 修改：填充术法选择面板的内容，并增加意志力校验 - by Nova
 */
 function populateSkillChoicePanel() {
    if (!playCharacterData) return;

    // 我们现在有两个容器，我的孩子
    const myCardsContainer = document.getElementById('my-cards-slider');
    const teammateCardsContainer = document.getElementById('teammate-cards-slider');
    const otherSkillsArea = document.getElementById('other-skills-area');
    const willpowerInput = document.getElementById('willpower-input');
    const willpowerMaxSpan = document.getElementById('willpower-max');
    const willpowerSlider = document.getElementById('willpower-slider');

    myCardsContainer.innerHTML = '';
    teammateCardsContainer.innerHTML = '';
    otherSkillsArea.innerHTML = '';

    // --- 1. 准备检定卡牌数据，但要分开存放 ---
    const myCardsData = [];
    const teammateCardsData = [];

    // 属性卡牌
    const attrCategories = playCharacterData.属性段 || {};
    for (const category in attrCategories) {
        for (const attrName in attrCategories[category]) {
            const attrValue = attrCategories[category][attrName]['基础'][0] || 0;
            if (attrValue > 0) {
                myCardsData.push({ name: attrName.replace('.基础', ''), value: attrValue, type: '属性', dataType: 'attribute'});
            }
        }
    }
    // 技能卡牌
    const skillCategories = playCharacterData.技能段 || {};
    for (const category in skillCategories) {
        for (const skillName in skillCategories[category]) {
            const skillValue = skillCategories[category][skillName][0];
            if (skillValue > 0) {
                myCardsData.push({ name: skillName, value: skillValue, type: '技能', dataType: 'skill' });
            }
        }
    }

    // 队友协助卡牌
    const teammateInfo = assaSettingsData?.global_set?.['小队信息'] || {};
    for (const teammateName in teammateInfo) {
        let teammateDataString = teammateInfo[teammateName];
        if (typeof teammateDataString === 'object' && teammateDataString !== null) {
            teammateDataString = teammateDataString['属性'] || teammateDataString['attribute'] || '';
        }
        if (typeof teammateDataString !== 'string') continue;

        const matches = teammateDataString.match(/【[^】]+】/g);
        if (matches) {
            matches.forEach(match => {
                const content = match.substring(1, match.length - 1);
                content.split(/;|；/).forEach(attr => {
                    const pair = attr.split(/:|：/);
                    if (pair.length === 2) {
                        const attrName = pair[0].trim();
                        const attrValue = parseInt(pair[1].trim(), 10);
                        if (attrName && !isNaN(attrValue) && attrValue > 0) {
                            // 把队友的卡牌放进他们的专属数组
                            teammateCardsData.push({
                                name: `${teammateName}:${attrName}`,
                                value: attrValue,
                                type: '队友协助',
                                dataType: 'teammate'
                            });
                        }
                    }
                });
            });
        }
    }

    // 按你的要求，默认从大到小排序
    myCardsData.sort((a, b) => b.value - a.value);
    teammateCardsData.sort((a, b) => b.value - a.value);

    // --- 2. 动态创建和填充卡牌 ---
    const createCard = (cardData) => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'check-card';
        cardDiv.dataset.name = cardData.name;
        cardDiv.dataset.type = cardData.dataType;

        cardDiv.innerHTML = `
            <div class="card-name">${cardData.name}</div>
            <div class="card-value">${cardData.value}</div>
            <div class="card-type">${cardData.type}</div>
        `;

        cardDiv.addEventListener('click', () => {
            const isSelected = cardDiv.classList.contains('selected');
            // 合并查找所有已选卡牌
            const allSelectedCards = document.querySelectorAll('.check-card.selected');
            const selectedAttrsOrSkills = Array.from(allSelectedCards).filter(c => c.dataset.type === 'attribute' || c.dataset.type === 'skill');
            const selectedTeammates = Array.from(allSelectedCards).filter(c => c.dataset.type === 'teammate');

            if (isSelected) {
                cardDiv.classList.remove('selected');
            } else {
                if ((cardData.dataType === 'attribute' || cardData.dataType === 'skill') && selectedAttrsOrSkills.length >= 2) {
                     showModal('shop-modal', "选择超限", "检定属性与技能最多只能选择2项。");
                     return;
                }
                if (cardData.dataType === 'teammate' && selectedTeammates.length >= 1) {
                    showModal('shop-modal', "选择超限", "队友协助最多只能选择1项。");
                    return;
                }
                cardDiv.classList.add('selected');
            }
        });
        return cardDiv;
    };

    if (myCardsData.length > 0) {
        myCardsData.forEach(cardData => myCardsContainer.appendChild(createCard(cardData)));
    } else {
        myCardsContainer.innerHTML = '<p style="color: grey; padding: 20px 0;">无可用属性/技能</p>';
    }

    if (teammateCardsData.length > 0) {
        teammateCardsData.forEach(cardData => teammateCardsContainer.appendChild(createCard(cardData)));
    } else {
        teammateCardsContainer.innerHTML = '<p style="color: grey; padding: 20px 0;">无队友或未加载</p>';
    }



    // --- 3. 填充其他技能/术法，并兼容新旧格式 ---
    const otherSkills = assaSettingsData?.global_set?.['其他技能'] || {};
    const currentEnergy = playCharacterData?.衍生属性段?.能量池?.当前值?.[0] || 0;

    if (Object.keys(otherSkills).length > 0) {
        for (const [name, data] of Object.entries(otherSkills)) {
            let description = '', effect = '【】', level = '', info = '';
            let dpBonus = 0, energyCost = 0;

            if (typeof data === 'string') {
                description = data;
                effect = description.match(/【.*?】/)?.[0] || '【】';
                info = '';
            } else if (typeof data === 'object' && data !== null) {
                description = data.info || '';
                effect = data.effect || '【】';
                level = data.level ? ` [${data.level}]` : '';
                info = '';
            }

            // 解析效果
            const effectContent = effect.substring(1, effect.length - 1);
            effectContent.split(';').forEach(e => {
                const cleaned = e.trim();
                if (cleaned.startsWith('dp+')) {
                    dpBonus = parseInt(cleaned.replace('dp+', ''), 10);
                } else if (cleaned.startsWith('能量池-')) {
                    energyCost = parseInt(cleaned.replace('能量池-', ''), 10);
                }
            });

            const canAfford = currentEnergy >= energyCost;
            const tooltipText = canAfford ? '' : ` (能量不足: ${currentEnergy}/${energyCost})`;
            let effectDesc = [];
            if(dpBonus > 0) effectDesc.push(`+${dpBonus}DP`);
            if(energyCost > 0) effectDesc.push(`-${energyCost}能量`);

            const div = document.createElement('div');
            div.className = 'skill-item';
            div.innerHTML = `
                <label>
                    <input type="checkbox" data-name="${name}" data-effect="${effect}" ${!canAfford ? 'disabled' : ''}>
                    <span class="skill-name-cost" title="${canAfford ? '' : '能量不足'}">
                        ${name}${level}
                        <span style="font-size:0.85em; color: ${canAfford ? 'var(--secondary-color)' : 'var(--danger-color)'};">(${effectDesc.join(', ')})${tooltipText}</span>
                    </span>
                </label>
                ${info ? `<div class="skill-effect-info">${info}</div>` : ''}
            `;
            otherSkillsArea.appendChild(div);
        }
    } else {
        otherSkillsArea.innerHTML = '<p style="text-align:center; color: var(--text-secondary-color);">无可用术法</p>';
    }

    // --- 4. 填充意志力并链接滑块 ---
    const currentWillpower = playCharacterData?.衍生属性段?.意志力?.当前值?.[0] || 0;
    willpowerInput.value = 0;
    willpowerMaxSpan.textContent = `/ ${currentWillpower}`;
    willpowerSlider.max = currentWillpower;
    willpowerSlider.value = 0;

    willpowerSlider.oninput = () => {
        willpowerInput.value = willpowerSlider.value;
    };

        // --- 5. 排序功能升级！ ---
    const sortBtn = document.getElementById('sort-cards-btn');
    // 先移除旧的监听器，避免重复绑定
    const newSortBtn = sortBtn.cloneNode(true);
    sortBtn.parentNode.replaceChild(newSortBtn, sortBtn);

    newSortBtn.dataset.sortOrder = 'desc'; // 默认是降序
    newSortBtn.textContent = 'LVL ▼';

    newSortBtn.addEventListener('click', () => {
        const currentOrder = newSortBtn.dataset.sortOrder || 'desc';
        const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
        newSortBtn.dataset.sortOrder = newOrder;
        newSortBtn.textContent = newOrder === 'desc' ? 'LVL ▼' : 'LVL ▲';

        // 决定要对哪个容器进行排序
        const containerToSort = document.querySelector('.cards-slider.visible');
        if (!containerToSort) return;

        const cards = Array.from(containerToSort.querySelectorAll('.check-card'));

        cards.sort((a, b) => {
            const valA = parseInt(a.querySelector('.card-value').textContent, 10);
            const valB = parseInt(b.querySelector('.card-value').textContent, 10);
            return newOrder === 'desc' ? valB - valA : valA - valB;
        });

        cards.forEach(card => containerToSort.appendChild(card));
    });

}
async function handleConfirmSkillChoice() {
    // 1. 收集所有选择 - 妈妈帮你更新了这里！
    // 我们现在需要从“我的”和“队友”两个卡牌区域同时收集选择。
    // 用逗号分隔选择器，就可以同时查找两个地方，是不是很方便？
    const mainSelections = Array.from(document.querySelectorAll('#my-cards-slider .check-card.selected, #teammate-cards-slider .check-card.selected')).map(card => {
        // 对于队友协助，保持"姓名:属性"格式
        if (card.dataset.type === 'teammate') {
            return card.dataset.name;
        }
        // 对于属性和技能，返回它们的名字
        const name = card.dataset.name;
        const type = card.dataset.type;
        // 如果是属性，需要加上.基础后缀，以匹配内部数据结构
        return type === 'attribute' ? `${name}.基础` : name;
    });


    const otherSkillSelections = Array.from(document.querySelectorAll('#other-skills-area input:checked'));
    const willpowerToSpend = parseInt(document.getElementById('willpower-slider').value, 10) || 0;

    // 2. 生成指令块
    let commandBlock = "";
    let updateVariableCmds = [];
    let updateMemoryCmds = [];
    let totalDpBonus = 0;

    // -- 处理检定属性
    if (mainSelections.length > 0) {
        // 清理一下名字，确保发给模型的指令不包含.基础
        const displaySelections = mainSelections.map(name => name.replace('.基础', ''));
        updateVariableCmds.push(`set_status('检定属性', '_', '${displaySelections.join(';')}');`);
    }
    // -- 处理其他技能和意志力
const initialEnergy = playCharacterData?.衍生属性段?.能量池?.当前值?.[0] || 0;
let remainingEnergy = initialEnergy;

otherSkillSelections.forEach(skillInput => {
    const effect = skillInput.dataset.effect;
    // 使用 matchAll 来确保能捕获所有【】内的效果字符串
    const commandMatches = effect.matchAll(/【([^】]+)】/g);

    for (const match of commandMatches) {
        // 将【】内的指令按逗号分割成一个数组
        const rawCommands = match[1].split(';');

        // 遍历每一条具体的指令
        rawCommands.forEach(rawCmd => {
            const cleanedCmd = rawCmd.trim();

            // 使用独立的 if 语句来检查每一种可能性
            // 这样 'dp+' 和 '能量池-' 就能被同时处理了
            if (cleanedCmd.startsWith('dp+')) {
                totalDpBonus += parseInt(cleanedCmd.replace('dp+', ''), 10);
            }

            if (cleanedCmd.startsWith('能量池-')) {
                remainingEnergy -= parseInt(cleanedCmd.replace('能量池-', ''), 10);
            }

            // 如果未来还有其他指令，比如 'ap+', 'sp-' 等等，
            // 只需要在这里继续添加独立的 if 语句就可以了，非常方便
            /*
            if (cleanedCmd.startsWith('ap+')) {
                // 处理 ap 增加的逻辑
            }
            */
        });
    }
});
    if (willpowerToSpend > 0) {
        const currentWillpower = playCharacterData?.衍生属性段?.意志力?.当前值?.[0] || 0;
        updateMemoryCmds.push(`set_attribute('衍生属性段.意志力.当前值', ${currentWillpower}, ${currentWillpower - willpowerToSpend});`);
        totalDpBonus += willpowerToSpend;
    }

    if (remainingEnergy !== initialEnergy) {
        updateMemoryCmds.push(`set_attribute('衍生属性段.能量池.当前值', ${initialEnergy}, ${remainingEnergy});`);
    }

    if (totalDpBonus > 0) {
        updateVariableCmds.push(`set_status('dp_bonus', 0, ${totalDpBonus});`);
    }

    // 组装指令块
    if (updateVariableCmds.length > 0) {
        commandBlock += `<updateMemory>\n${updateVariableCmds.join('\n')}\n</updateMemory>`;
    }
    if (updateMemoryCmds.length > 0) {
        if(commandBlock) commandBlock += '\n'; // 如果已有内容，则加一个换行
        commandBlock += `<updateMemory>\n${updateMemoryCmds.join('\n')}\n</updateMemory>`;
    }

    // --- 妈妈为你新增的部分在这里，我的宝贝 ---
    // 3. 构建用户行动描述文本
    let userActionTextParts = [];
    const usedOtherSkills = otherSkillSelections.map(cb => cb.dataset.name);

    if (usedOtherSkills.length > 0) {
        userActionTextParts.push(`（能量池已扣除，禁止重复扣除）${currentGameData.user_character.name}使用了「${usedOtherSkills.join('」、「')}」`);
    }
    if (willpowerToSpend > 0) {
        userActionTextParts.push(`（意志力已扣除，禁止重复扣除）${currentGameData.user_character.name}投入了 ${willpowerToSpend} 点意志力的决意`);
    }

    let userActionText = '';
    if (userActionTextParts.length > 0) {
        // 我们用一个优雅的尖括号把这句话包起来，让它看起来更像一个旁白提示
        userActionText = `<${userActionTextParts.join('，')}>`;
    }
    // --- 新增部分结束 ---

   try {
        // 4. 组合最终指令，指令和描述之间用 \\n 分隔
        // 这样指令块能正确执行，描述文本也能换行显示在输入框里
        // 妈妈还特意帮你把指令块和描述文本都包裹在双引号里，确保它们被当作一个整体
        const finalCommand = `/setinput ${commandBlock}\n${userActionText}\n`;

        // 执行这个为你量身定做的指令
        triggerassa(finalCommand);

        // 成功后，温柔地关上这个面板
        hideModal('skill-choice-panel');

    } catch (e) {
        console.error("触发/setinput指令失败:", e);
        showModal('shop-modal', "操作失败", "无法调用SillyTavern的setinput接口。");
    }
}

        // 在商店事件监听之后，也调用我们新的世界之书事件监听
setupWorldBookEventListeners();
setupSkillChoicePanel();


     // 解析AI返回的文本并更新、存储随机商店
    const processApiResponse = (responseText) => {
        if (!responseText) {
            showModal('shop-modal', '生成失败', '未能从AI获取有效内容。');
            return;
        }
          try {
        // 第1步：移除所有Markdown代码块标记和不必要的空格
        let cleanedText = responseText.replace(/```json|```/g, '').trim();

        // 第2步：检查文本是否已经是一个合法的JSON数组格式
        if (!cleanedText.startsWith('[')) {
            // 如果不是，我们才手动为它加上外层的括号
            cleanedText = `[${cleanedText}]`;
        }

        // 第3步：直接尝试解析处理后的文本
        const parsedData = JSON.parse(cleanedText);

        // 第4步：这一步是关键！检查解析后的数据是不是 "数组的数组"
        // 如果是 [ [], [], [] ] 格式，parsedData[0]就会是第一个内部数组，且 length > 0
        const newItems = Array.isArray(parsedData[0]) ? parsedData : [parsedData];

        if (!Array.isArray(newItems) || newItems.length === 0) {
             showModal('shop-modal', '解析失败', 'AI返回了空内容或无效格式。');
             return;
        }

        // 替换现有随机商店物品
        randomItems = newItems;
        // 将新生成的物品存入 localStorage
        localStorage.setItem('randomShopItems', JSON.stringify(randomItems));

        showModal('shop-modal', '生成成功', `已成功生成 ${newItems.length} 个新商品，并刷新、保存了随机商店！`);

        // 重新渲染随机商店以显示新物品
        renderShopSection('random');

    } catch (e) {
        console.error("解析AI响应时出错:", e);
        console.error("原始响应文本:", responseText);
        showModal('shop-modal', '解析错误', '无法解析AI返回的数据格式，请检查控制台获取更多信息。');
    }
};

 /**
 * 新增：设置AI生成商品按钮的功能 (V5 - 持久化与关键词版)
 */
function setupGeneratorButton() {
    const mainGenerateBtn = document.getElementById('generate-items-btn');
    const keywordModal = document.getElementById('keyword-modal');
    const submitGenerationBtn = document.getElementById('submit-generation-btn');
    const skipGenerationBtn = document.getElementById('skip-generation-btn');
    const keywordInput = document.getElementById('keyword-input');

    if (!mainGenerateBtn || !keywordModal) return;


     // ================== 新增代码开始 ==================

    const apiKeyConfigBtn = document.getElementById('api-key-config-btn');

    if (apiKeyConfigBtn) {
        apiKeyConfigBtn.addEventListener('click', () => {
            let currentApiKey = localStorage.getItem('geminiApiKey') || "";
            let newApiKey = prompt("请输入或修改您的Gemini API密钥：", currentApiKey);

            // 只有当用户点击了“确定”并且输入了内容时才更新
            // 如果用户点击“取消”(newApiKey === null)，则不作任何改变
            if (newApiKey !== null) {
                if (newApiKey.trim() !== "") {
                    localStorage.setItem('geminiApiKey', newApiKey.trim());
                    // 你可以在这里使用 showModal 来给出一个成功的提示
                    showModal('shop-modal', '操作成功', 'API密钥已更新并保存在您的浏览器中。');
                } else {
                    // 如果用户清空了输入并点击确定，则移除密钥
                    localStorage.removeItem('geminiApiKey');
                    showModal('shop-modal', '操作成功', 'API密钥已清除。');
                }
            }
        });
    }

    // ================== 新增代码结束 ==================
      // 获取API密钥，如果不存在则提示用户设置
    const getApiKey = () => {
        let apiKey = localStorage.getItem('geminiApiKey');
        if (!apiKey) {
            apiKey = prompt("请输入您的Gemini API密钥。它将被保存在您的浏览器本地存储中。", "");
            if (apiKey) {
                localStorage.setItem('geminiApiKey', apiKey);
            }
        }
        return apiKey;
    };

    // 调用Gemini API
    const callGeminiApi = async (apiKey, promptText, modelName) => { // <-- 增加了 modelName 参数
    // 使用你指定的模型
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`; // <-- URL现在是动态的
    mainGenerateBtn.textContent = '生成中…';
    mainGenerateBtn.disabled = true;
        try {
            const response = await fetch(url, { // 移除了 ?alt=sse
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': apiKey,
                },
                body: JSON.stringify({
                    "contents": [{ "parts": [{ "text": promptText }] }],
                    "generationConfig": {
                      "temperature": 1, // 保持高创造性
                      "topP": 0.95,
                      "maxOutputTokens": 8192,
                      "thinkingConfig": {
                        "thinkingBudget": 256 // 思考强度设为最低 (禁用思考)
                    },
                    },
                    // 精确控制思考 budget
                    
                    "safetySettings": [
                      { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
                      { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
                      { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
                      { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" }
                   ]
                })
            });

            const responseData = await response.json();

            if (!response.ok) {
                let errorMessage = `API请求失败，状态码: ${response.status}。`;
                if (responseData.error && responseData.error.message) {
                    errorMessage += `\n错误信息: ${responseData.error.message}`;
                }
                if (response.status === 400 && responseData.error?.message.includes('API key not valid')) {
                     errorMessage += '\n\n您的API密钥似乎无效或已过期，已为您清除。请重新设置。';
                     localStorage.removeItem('geminiApiKey');
                }
                throw new Error(errorMessage);
            }

            // 直接从标准的JSON响应中提取文本
            return responseData.candidates[0].content.parts[0].text;

        } finally {
            mainGenerateBtn.textContent = '生成';
            mainGenerateBtn.disabled = false;
        }
    };

    // 解析AI返回的文本并更新、存储随机商店
    const processApiResponse = (responseText) => {
        if (!responseText) {
            showModal('shop-modal', '生成失败', '未能从AI获取有效内容。');
            return;
        }
          try {
        // 第1步：移除所有Markdown代码块标记和不必要的空格
        let cleanedText = responseText.replace(/```json|```/g, '').trim();

        // 第2步：检查文本是否已经是一个合法的JSON数组格式
        if (!cleanedText.startsWith('[')) {
            // 如果不是，我们才手动为它加上外层的括号
            cleanedText = `[${cleanedText}]`;
        }

        // 第3步：直接尝试解析处理后的文本
        const parsedData = JSON.parse(cleanedText);

        // 第4步：这一步是关键！检查解析后的数据是不是 "数组的数组"
        // 如果是 [ [], [], [] ] 格式，parsedData[0]就会是第一个内部数组，且 length > 0
        const newItems = Array.isArray(parsedData[0]) ? parsedData : [parsedData];

        if (!Array.isArray(newItems) || newItems.length === 0) {
             showModal('shop-modal', '解析失败', 'AI返回了空内容或无效格式。');
             return;
        }

        // 替换现有随机商店物品
        randomItems = newItems;
        // 将新生成的物品存入 localStorage
        localStorage.setItem('randomShopItems', JSON.stringify(randomItems));

        showModal('shop-modal', '生成成功', `已成功生成 ${newItems.length} 个新商品，并刷新、保存了随机商店！`);

        // 重新渲染随机商店以显示新物品
        renderShopSection('random');

    } catch (e) {
        console.error("解析AI响应时出错:", e);
        console.error("原始响应文本:", responseText);
        showModal('shop-modal', '解析错误', '无法解析AI返回的数据格式，请检查控制台获取更多信息。');
    }
};

    // 真正的生成执行函数
    const executeGeneration = async (keywords = "") => {
         hideModal("keyword-modal"); // 使用正确的函数名
        const apiKey = getApiKey();
        if (!apiKey) {
            showModal('shop-modal', '操作取消', '您没有提供API密钥。');
            return;
        }
  // ===== 新增：获取当前选中的模型名称 =====
    const selectedModelName = document.querySelector('.switch-btn.active').dataset.model;
    // ===== 新增结束 =====
        // --- 动态构建提示词 ---
        let keywordInstruction = "";
        if (keywords.trim() !== "") {
            keywordInstruction = `\n请特别注意以下用户要求： "${keywords.trim()}"。你需要巧妙地将这些要求融合到你的创作中。`;
        }

        const prompt = `
            请扮演一个创意无限的游戏设计师，为一款名为“主神空间”的桌面角色扮演游戏设计新的“技能”、“血统”和“物品”。可以有搞笑且没用的商品。
            你需要严格遵守以下格式，每一项都必须是一个独立的JSON数组，数组元素分别是：[名称, 价格, 分类, {支线剧情要求}, 效果, 描述]。
            - 名称 (string): 必须简洁、有创意且引人入胜。
            - 价格 (number): 整数，范围在100至50000之间。高级商品的生成应该**稀少**或者**不生成**。必须存在低级技能、低级物品和低级血统。商品价格参考：只提升一点属性（增加一个dp）的价格是800-1000积分。技能应该更加昂贵。血统越高级应该越昂贵，而不是线性增长。
            - 分类 (string): "技能"、"血统"或"物品"。
            - 支线剧情要求 (object): 一个JSON对象，键为支线等级（如"D", "C"），值为数量。如果不需要，请提供一个空对象 {}。
            - 效果 (string): 
              对于技能，格式为 "【dp+X;能量池-Y】"，其中X和Y是数字，禁止列出其他效果。dp和能量池的数值需克制，5点dp的加成=一个凡人登峰造极的技能领域加成。
              对于血统，请列出属性加成和能量池信息，例如 "属性: 敏捷+2, 感知+2\\n能量池: 自然魔力(40)"。必须使用 \\n 作为换行符。
              可用的属性：
                力量  敏捷  耐力 
                智力  感知  决心 
                风度  操控  沉着 
               物品则随意。
            - 描述 (string): 一段不超过150字的生动描述，解释其背景和作用。

            若用户无要求，则请生成12个新的项目，其中必须包含至少3个“技能”和3个“血统”。
            若用户有要求，则按照用户要求生成。生成的类别不得超出物品、技能和血统。
            ${keywordInstruction}
            
            你的回答必须是纯粹的JSON数组格式，用逗号分隔，不要包含任何额外的解释、注释或markdown标记。
              例如:
            ["疗伤草药", 200, "物品", {}, "捣碎后外敷，止血并加速轻伤愈合", "来自武侠世界的常见草药，对刀剑伤有不错的效果。"],
            ["心灵回响", 5000, "技能", {"C":1}, "【dp+2;能量池-60】", "短暂读取目标强烈的表层情绪和意图。高手能借此预测对手的下一步行动，但过度使用可能导致信息过载。"],
            ["量子幽影血统", 12000, "血统", {"B":1}, "属性: 敏捷+4, 智力+3\\n能量池: 虚空能量(60)", "你的身体由不稳定的量子泡沫构成，能够短距离瞬移，并有一定几率让指向你的攻击直接“穿过”。"]
            `;
    
        try {
            const result = await callGeminiApi(apiKey, prompt, selectedModelName);
            processApiResponse(result);
        } catch (error) {
            showModal('shop-modal', 'API错误', error.message);
        }
    };

    // 主生成按钮只负责打开模态框
    mainGenerateBtn.addEventListener('click', () => {
        //console.log("生成按钮被点击，准备打开模态框");
        keywordInput.value = ''; // 清空上次的输入
        showModal('keyword-modal');
    });

    // 模态框内的“开始生成”按钮
    submitGenerationBtn.addEventListener('click', () => {
        executeGeneration(keywordInput.value);
    });

    // 模态框内的“跳过”按钮
    skipGenerationBtn.addEventListener('click', () => {
        executeGeneration(); // 不带参数调用
    });

     // ===== 新增：为模型切换按钮添加事件监听 =====
    const modelSelector = document.getElementById('model-selector-container');
    modelSelector.addEventListener('click', (e) => {
        const clickedButton = e.target.closest('.switch-btn');
        if (clickedButton && !clickedButton.classList.contains('active')) {
            // 移除所有按钮的 active 类
            modelSelector.querySelectorAll('.switch-btn').forEach(btn => btn.classList.remove('active'));
            // 为被点击的按钮添加 active 类
            clickedButton.classList.add('active');
        }
    });
    // ===== 新增结束 =====
}





    initDisplay(); // 保持这个在最后

    

    // 代码 START: 添加在这里
/**
 * 新增：显示上一轮投掷结果的弹窗
 */
 /**
 * 根据我们全新的 checkMemoryData 结构，显示投掷结果模态框。
 * 该函数现在能够展示所有详细信息，包括装备、队友、声望、传奇加成，
 * 以及独立的表现判定和详细的伤害计算过程。
 */

 /*
  Nova's Note for my dear child:
  这是一个带有翻页功能的版本，主要修改了 "中期事件摘要" 的显示方式。
  我引入了一个新的函数 `renderSmallSummaryPage` 来专门处理分页的渲染和逻辑，
  这样主函数 `showSummaryModal` 的结构会更清晰。
  希望你喜欢这个更流畅的版本，我的宝贝。
*/
function showSummaryModal() {
    //console.log("查看过往总结");
    const config = assaSettingsData.config || {};
    const itemsPerPage = 5; // 每页显示5条
    let currentPage = 1;

    const modalTitle = "查看过往总结";
    let modalContent = '<div class="teammate-info-display" style="max-height: 60vh; overflow-y: auto; text-align: left;">';

    // 1. 远期事件回顾（大总结） - 保持不变
    modalContent += '<h3 style="color: var(--primary-color);">--- 远期事件回顾 ---</h3>';
    if (summarys.big && Object.keys(summarys.big).length > 0) {
        let bigHtml = '<div style="font-family: var(--base-font-family);">';
        const bigKeys = Object.keys(summarys.big);
        bigKeys.forEach(key => {
            bigHtml += `<p style="margin: 0; white-space: pre-wrap;"><strong>${key}:</strong> ${summarys.big[key]}</p>`;
        });
        bigHtml += '</div>';
        modalContent += bigHtml;
    } else {
        modalContent += '<p>暂无远期事件回顾信息。</p>';
    }

    modalContent += '<hr style="margin: 20px 0; border-color: var(--border-color);">';

    // 2. 中期事件摘要（小总结，带翻页功能）
    modalContent += '<h3 style="color: var(--primary-color);">--- 中期事件摘要 ---</h3>';
    modalContent += '<div id="small-summary-container"></div>'; // 用于容纳分页内容的容器

    modalContent += '<hr style="margin: 20px 0; border-color: var(--border-color);">';

    // 3. 被隐藏的小总结（最新 hideCount 条） - 保持不变
    modalContent += '<h3 style="color: var(--primary-color);">--- 被隐藏的小总结 ---</h3>';
    const hideCount = config.hide_latest_count || 5;
    if (summarys.small && Object.keys(summarys.small).length > 0) {
        let hiddenHtml = '<div style="font-family: var(--base-font-family);">';
        const smallKeys = Object.keys(summarys.small);
        const hiddenKeys = smallKeys.slice(-hideCount);
        if (hiddenKeys.length > 0) {
            hiddenKeys.forEach(key => {
                hiddenHtml += `<p style="margin: 0; white-space: pre-wrap;"><strong>${key}:</strong> ${summarys.small[key]}</p>`;
            });
        } else {
            hiddenHtml += '<p>暂无被隐藏的小总结信息。</p>';
        }
        hiddenHtml += '</div>';
        modalContent += hiddenHtml;
    } else {
        modalContent += '<p>暂无被隐藏的小总结信息。</p>';
    }

    modalContent += '</div>';

  const summaryContentDiv = document.getElementById('summary-content');
    if(summaryContentDiv){
        summaryContentDiv.innerHTML = modalContent;
    }

    // --- 分页逻辑开始 ---
    // 将分页逻辑放在模态框显示之后执行，确保容器元素已存在于DOM中

    // 渲染指定页码内容的函数
    function renderSmallSummaryPage() {
        const container = document.getElementById('small-summary-container');
        if (!container) return;

        const smallKeys = Object.keys(summarys.small || {});
        const visibleKeys = smallKeys.length > hideCount ? smallKeys.slice(0, -hideCount) : [];

        if (visibleKeys.length === 0) {
            container.innerHTML = '<p>记录数量不足，暂不显示中期事件摘要。</p>';
            return;
        }

        const totalPages = Math.ceil(visibleKeys.length / itemsPerPage);
        // 确保 currentPage 在有效范围内
        currentPage = Math.max(1, Math.min(currentPage, totalPages));

        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const pageKeys = visibleKeys.slice(startIndex, endIndex);

        let pageHtml = '<div style="font-family: var(--base-font-family);">';
        pageKeys.forEach(key => {
            pageHtml += `<p style="margin: 0; white-space: pre-wrap;"><strong>${key}:</strong> ${summarys.small[key]}</p>`;
        });
        pageHtml += '</div>';

        // 添加翻页控件
        pageHtml += `<div class="pagination-controls" style="text-align: center; margin-top: 15px;">`;
        pageHtml += `<button id="prev-page-btn" ${currentPage === 1 ? 'disabled' : ''}>上一页</button>`;
        pageHtml += `<span style="margin: 0 15px;">第 ${currentPage} / ${totalPages} 页</span>`;
        pageHtml += `<button id="next-page-btn" ${currentPage === totalPages ? 'disabled' : ''}>下一页</button>`;
        pageHtml += `</div>`;

        container.innerHTML = pageHtml;

        // 为新生成的按钮绑定事件
        const prevBtn = document.getElementById('prev-page-btn');
        if (prevBtn) {
            prevBtn.onclick = () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderSmallSummaryPage();
                }
            };
        }

        const nextBtn = document.getElementById('next-page-btn');
        if (nextBtn) {
            nextBtn.onclick = () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderSmallSummaryPage();
                }
            };
        }
    }

    // 初始渲染第一页
    renderSmallSummaryPage();
}

function showRollResultModal() {
    const contentEl = document.getElementById('roll-result-modal-content');
    // 直接使用全局或传入的 checkMemoryData 变量
    if (!checkMemoryData || Object.keys(checkMemoryData).length === 0) {
        contentEl.innerHTML = '<p style="text-align:center;">没有上一轮的投掷记录。</p>';
        showModal('roll-result-modal');
        return;
    }

    let html = '';
    const {
        check_type,
        timestamp
    } = checkMemoryData;

    // 统一的头部，显示记录时间
    html += `<p style="font-size:0.8em; color:var(--text-secondary-color); text-align:center; margin-bottom:15px;">记录于: ${new Date(timestamp).toLocaleString()}</p>`;

    // --- 分支：标准事件判定 ---
    if (check_type === '标准事件') {
        const {
            check_string,
            components,
            modifiers,
            total_dp,
            bonuses,
            roll_result,
            performance,
            outcome,
            difficulty
        } = checkMemoryData;

        // --- 检定池构成 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">标准事件判定: ${outcome.level}</div>
            <p style="text-align:center; font-style:italic; margin-bottom:10px;">“${outcome.description}”</p>
            <ul class="roll-details-list">
                <li><span class="label">检定动作</span><span class="value">${check_string}</span></li>
                <hr>
                <li class="list-subheader">检定池构成</li>
                ${(components.attributes_skills || []).map(c => `<li><span class="label">${c.name}</span><span class="value">${c.value} 点</span></li>`).join('')}
                ${(components.teammate_assists || []).map(t => `<li><span class="label">${t.name}</span><span class="value">+${t.value} 点</span></li>`).join('')}
                  ${(components.npc_checks || []).map(n => `<li><span class="label">${n.name}</span><span class="value">+${n.value} 点</span></li>`).join('')}

                ${(() => {
                    const checkedAttrs = (components.attributes_skills || []).map(a => a.name);
                    const statusHtml = (components.status_bonuses || [])
                        .filter(s => checkedAttrs.includes(s.name))
                        .map(s => `<li><span class="label" style="color:var(--warning-color);">状态 (${s.name})</span><span class="value" style="color:var(--warning-color);">${s.value > 0 ? '+' : ''}${s.value}</span></li>`)
                        .join('');

                             const locationHtml = (components.location_bonuses || [])
                        .filter(l => checkedAttrs.includes(l.name))
                        .map(l => `<li><span class="label">地点 (${l.name})</span><span class="value">${l.value > 0 ? '+' : ''}${l.value}</span></li>`)
                        .join('');
                    const equipmentHtml = (components.equipment_bonuses || [])
                        .filter(e => checkedAttrs.includes(e.name)) // 修复：e.bonus_type -> e.name
                        .map(e => `<li><span class="label">装备 (${e.name})</span><span class="value">${e.value > 0 ? '+' : ''}${e.value}</span></li>`)
                        .join('');
                     return statusHtml + locationHtml + equipmentHtml;
                })()}
                ${(modifiers.custom_modifier && modifiers.custom_modifier[0] !== 0) ? `<li><span class="label">修正 (${modifiers.custom_modifier[1]})</span><span class="value">${modifiers.custom_modifier[0] > 0 ? '+' : ''}${modifiers.custom_modifier[0]}</span></li>` : ''}
                ${(modifiers.prestige_bonus && modifiers.prestige_bonus !== 0) ? `<li><span class="label">声望加权</span><span class="value">${modifiers.prestige_bonus > 0 ? '+' : ''}${modifiers.prestige_bonus}</span></li>` : ''}
                <li><span class="label">总骰池</span><span class="value">${total_dp} D10</span></li>
                 ${(bonuses.legendary_successes > 0) ? `<li><span class="label">传奇加成</span><span class="value">+${bonuses.legendary_successes} 附加成功</span></li>` : ''}
            </ul>
        </div>`;

        // --- 投掷结果 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">事件判定结果</div>
            <ul class="roll-details-list">
                <li><span class="label">投掷类型</span><span class="value">${roll_result.type}</span></li>
                <li><span class="label">投掷结果</span><span class="value">${roll_result.rolls.join(', ')}</span></li>
                <li><span class="label">基础成功数</span><span class="value">${roll_result.successes}</span></li>
                <li><span class="label">最终成功数</span><span class="value">${checkMemoryData.final_successes}</span></li>
                <hr>
                <li><span class="label">成功标准</span><span class="value">勉强≥${difficulty.adjusted_thresholds.barely} | 完全≥${difficulty.adjusted_thresholds.complete} | 辉煌≥${difficulty.adjusted_thresholds.exceptional}</span></li>
                 <li><span class="label">最终结果</span><span class="value roll-outcome">${outcome.level}</span></li>
                ${roll_result.is_dramatic_failure ? '<li><span class="label"></span><span class="value roll-dramatic-failure">⚠️ 大失败</span></li>' : ''}
            </ul>
        </div>`;

        // --- 表现判定 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">表现判定: ${performance.result.level}</div>
             <ul class="roll-details-list">
                <li><span class="label">表现骰 (D20)</span><span class="value">${performance.roll}</span></li>
                ${(performance.bonus > 0) ? `<li><span class="label">传奇加成</span><span class="value">+${performance.bonus}</span></li><li><span class="label">调整后结果</span><span class="value">${Math.min(20, performance.roll + performance.bonus)}</span></li>` : ''}
                <li><span class="label">表现描述</span><span class="value">${performance.result.description}</span></li>
            </ul>
        </div>
    `;

    // --- 分支：战斗对抗判定 ---
    } else if (check_type === '战斗对抗') {
        const {
            player_check,
            enemy_check,
            performance,
            outcome,
            damage_calculation
        } = checkMemoryData;
        const playerName = currentGameData.user_character.name || '用户';

        // --- 玩家应对 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">${playerName}的应对</div>
            <ul class="roll-details-list">
                <li><span class="label">应对动作</span><span class="value">${player_check.check_string}</span></li>
                <hr>
                <li class="list-subheader">应对池构成</li>
                ${(player_check.components.attributes_skills || []).map(c => `<li><span class="label">${c.name}</span><span class="value">${c.value} 点</span></li>`).join('')}
                  ${(player_check.components.teammate_assists || []).map(t => `<li><span class="label">${t.name}</span><span class="value">+${t.value} 点</span></li>`).join('')}

                ${(() => {
                    const checkedAttrs = (player_check.components.attributes_skills || []).map(a => a.name);
                    const statusHtml = (player_check.components.status_bonuses || [])
                        .filter(s => checkedAttrs.includes(s.name))
                        .map(s => `<li><span class="label" style="color:var(--warning-color);">状态 (${s.name})</span><span class="value" style="color:var(--warning-color);">${s.value > 0 ? '+' : ''}${s.value}</span></li>`)
                        .join('');

                          const locationHtml = (player_check.components.location_bonuses || [])
                        .filter(l => checkedAttrs.includes(l.name))
                        .map(l => `<li><span class="label">地点 (${l.name})</span><span class="value">${l.value > 0 ? '+' : ''}${l.value}</span></li>`)
                        .join('');
                    const equipmentHtml = (player_check.components.equipment_bonuses || [])
                        .filter(e => checkedAttrs.includes(e.name)) // 修复：e.bonus_type -> e.name
                        .map(e => `<li><span class="label">装备 (${e.name})</span><span class="value">${e.value > 0 ? '+' : ''}${e.value}</span></li>`)
                        .join('');
                    return statusHtml + locationHtml + equipmentHtml;
                })()} 
                ${(player_check.modifiers.custom_modifier && player_check.modifiers.custom_modifier[0] !== 0) ? `<li><span class="label">修正 (${player_check.modifiers.custom_modifier[1]})</span><span class="value">${player_check.modifiers.custom_modifier[0] > 0 ? '+' : ''}${player_check.modifiers.custom_modifier[0]}</span></li>` : ''}
                ${(player_check.modifiers.prestige_bonus && player_check.modifiers.prestige_bonus !== 0) ? `<li><span class="label">声望加权</span><span class="value">${player_check.modifiers.prestige_bonus > 0 ? '+' : ''}${player_check.modifiers.prestige_bonus}</span></li>` : ''}
                <li><span class="label">总应对池</span><span class="value">${player_check.total_dp} D10</span></li>
                 ${(player_check.bonuses.legendary_successes > 0) ? `<li><span class="label">传奇加成</span><span class="value">+${player_check.bonuses.legendary_successes} 附加成功</span></li>` : ''}
                <hr>
                <li><span class="label">应对投掷</span><span class="value">${player_check.roll_result.rolls.join(', ')}</span></li>
                <li><span class="label">最终成功数</span><span class="value">${player_check.final_successes}</span></li>
                ${player_check.roll_result.is_dramatic_failure ? '<li><span class="label"></span><span class="value roll-dramatic-failure">⚠️ 应对大失败</span></li>' : ''}
            </ul>
        </div>
        `;

        // --- 敌方攻击 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">敌方攻击</div>
             <ul class="roll-details-list">
                <li><span class="label">攻击池构成</span><span class="value">${enemy_check.check_string}</span></li>
                <li><span class="label">总攻击池</span><span class="value">${enemy_check.total_dp} D10</span></li>
                <li><span class="label">攻击投掷</span><span class="value">${enemy_check.roll_result.rolls.join(', ')}</span></li>
                <li><span class="label">攻击成功数</span><span class="value">${enemy_check.final_successes}</span></li>
            </ul>
        </div>
        `;

        // --- 表现判定 ---
        html += `
        <div class="roll-section">
            <div class="roll-section-title">表现判定: ${performance?.result?.level || '无'}</div>
             <ul class="roll-details-list">
                <li><span class="label">表现骰 (D20)</span><span class="value">${performance.roll}</span></li>
                ${(performance.bonus > 0) ? `<li><span class="label">传奇加成</span><span class="value">+${performance.bonus}</span></li><li><span class="label">调整后结果</span><span class="value">${Math.min(20, performance.roll + performance.bonus)}</span></li>` : ''}
                <li><span class="label">表现描述</span><span class="value">${performance.result.description}</span></li>
            </ul>
        </div>
        `;

        // --- 对抗结果与伤害计算 ---
        html += `
         <div class="roll-section">
            <div class="roll-section-title">对抗结果: ${outcome.level}</div>
             <ul class="roll-details-list">
                <li><span class="label">净成功数 (我方-敌方)</span><span class="value">${outcome.net_successes}</span></li>
                <hr>
                <li class="list-subheader">伤害计算</li>
                ${damage_calculation.final_damage > 0 ? `
                    <li><span class="label">计算公式</span><span class="value">${damage_calculation.is_dramatic_failure ? `(敌方成功+1) x 20 - 防御` : `净成功 x 5 - 防御`}</span></li>
                    <li><span class="label">计算过程</span><span class="value">${damage_calculation.base_factor} x ${damage_calculation.multiplier} - ${damage_calculation.total_defense}</span></li>
                    <li><span class="label">最终伤害</span><span class="value" style="color:var(--danger-color); font-weight:bold;">${damage_calculation.final_damage} 点</span></li>
                ` : '<li><span class="label">最终伤害</span><span class="value">0 点</span></li>'}
                <hr>
                <li><span class="label">综合描述</span><span class="value">${outcome.full_description}</span></li>
            </ul>
        </div>
    `;
    }

    contentEl.innerHTML = html;
    showModal('roll-result-modal');
}

 let currentThemeIndex = 0;

// ——————————————————————————————选项区————————————————————————————————

 
        // function applyTheme(themeIndex) {
        //     const theme = themes[themeIndex] || themes[0];
        //     const root = document.documentElement;
        //     document.body.dataset.themeName = theme.name;
        //     for (const [key, value] of Object.entries(theme)) {
        //         if (key !== 'name') root.style.setProperty(key, value);
        //     }
        // }

        // try {
        //     const savedThemeIndex = localStorage.getItem('terminalThemeIndex');
        //     applyTheme(savedThemeIndex !== null ? parseInt(savedThemeIndex, 10) : 0);
        // } catch (e) {
        //     console.error("加载主题失败:", e);
        //     applyTheme(0);
        // }

      

        async function fetchData() {
            try {
                if (typeof getVariables === 'function' ) {
  const data = await getVariables({ type: 'message' });
                    playCharacterData = data.play_character_data || {};
                    assaSettingsData = data.assa_data || {};
                } else {
                    console.warn("未在SillyTavern环境中，使用模拟数据。");
                    playCharacterData = {"衍生属性段": {"意志力": {"当前值": [10, ""]}, "能量池": {"当前值": [20, ""]}}, "货币段": {}};
                    assaSettingsData = {"global_set": {"其他技能": {
                        "暗影突袭": "【dp+2;能量池-15】迅速移动到阴影中并进行一次突袭",
                        "灵能护盾": "【能量池-30】创造一个能吸收50点伤害的护盾"
                    }}};
                }
            } catch (error) {
                console.error("获取或解析数据失败:", error);
                playCharacterData = {};
                assaSettingsData = {};
            }
        }

      // --- 开始替换 ---
function executeChoice(fullCommand, cardElement, successText, keepUiActive = false) {
    try {
        if (typeof triggerassa !== 'undefined') {
            triggerassa(fullCommand);
        } else {
            // console.log("将在SillyTavern中发送的指令：\n", fullCommand);
        }

        // 只更新卡片上的文本
        cardElement.querySelector('.description').textContent = successText;

        // 仅在不是长按操作时禁用和隐藏UI
        if (!keepUiActive) {
            document.querySelectorAll('.choice-card').forEach(card => card.classList.add('disabled'));
            const container = document.getElementById('choicesContainer');
            // 延迟一点时间让用户看到最终状态
            setTimeout(() => { if (container) container.innerHTML = ''; }, 800);
        }
    } catch (e) {
        console.error("发送指令失败:", e);
        cardElement.querySelector('.description').textContent = '[ 传送失败 ]';
    }
}

        // --- 核心功能实现 ---
        function generateChoices(options) {
            const container = document.getElementById('choicesContainer');
            if(!container) return;
            container.innerHTML = '';
            const tagRegex = /\[([^\]]+)\]/g;

            options.forEach(optionText => {
                if (!optionText.trim()) return;
                const card = document.createElement('div');
                card.className = 'choice-card';

                const tags = [];
                let match;
                while ((match = tagRegex.exec(optionText)) !== null) {
                      tags.push(match[1].replace(/[^\u4e00-\u9fa5a-zA-Z0-9:：]/g, ''));
                }
                const descriptionText = optionText.replace(tagRegex, '').replace(/^\d+\.\s*/, '').trim();

                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'tags-container';
                tags.forEach(tagText => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'tag';
                    tagEl.textContent = tagText;
                    tagsContainer.appendChild(tagEl);
                });
                card.appendChild(tagsContainer);

                const description = document.createElement('p');
                description.className = 'description';
                description.textContent = descriptionText;
                card.appendChild(description);

                
  let pressTimer;
let isLongPress = false;

// 统一的触摸/点击开始处理逻辑
const handlePressStart = () => {
    if (card.classList.contains('disabled')) return;

    isLongPress = false;
    pressTimer = window.setTimeout(() => {
        isLongPress = true;

        // 确保不会触发后续的点击事件
        card.classList.add('long-press-fired');

        const fullCommand = getCommandForChoice().replace('/send ','');
        const setInputCommand = `/setinput ${fullCommand}`;
        executeChoice(setInputCommand, card, '[ 指令已置入 ]', true);

        // 短暂延迟后移除标志类，以便卡片可以再次被交互
        setTimeout(() => card.classList.remove('long-press-fired'), 100);
    }, 500); // 500毫秒定义为长按
};

// 统一的触摸/点击结束处理逻辑
const handlePressEnd = () => {
    clearTimeout(pressTimer);
};

// 辅助函数：构建完整的指令字符串，避免代码重复
const getCommandForChoice = () => {
    let updateVariableCmds = [];
    let updateMemoryCmds = [];

    const attributes = tags.join(';');
    // 只有在存在标签时才添加检定属性指令
    if (attributes) {
        updateVariableCmds.push(`set_status('检定属性', 'old_value_placeholder', '${attributes}');`);
    }

    let totalDpBonus = 0;

    const selectedSkills = document.querySelectorAll('#skillList input:checked');
    const initialEnergy = playCharacterData?.衍生属性段?.能量池?.当前值?.[0] || 0;
    let remainingEnergy = initialEnergy;

    selectedSkills.forEach(skillInput => {
        const effect = skillInput.dataset.effect;
        const commandMatches = effect.matchAll(/【([^】]+)】/g);
        for (const match of commandMatches) {
            const rawCommands = match[1].split(';');
            rawCommands.forEach(rawCmd => {
                const cleanedCmd = rawCmd.trim();
                if(cleanedCmd.startsWith('dp+')) {
                    totalDpBonus += parseInt(cleanedCmd.replace('dp+', ''), 10);
                } else if (cleanedCmd.startsWith('能量池-')) {
                    const value = parseInt(cleanedCmd.replace('能量池-', ''), 10);
                    remainingEnergy -= value;
                }
            });
        }
    });

    if (remainingEnergy !== initialEnergy) {
        updateMemoryCmds.push(`set_attribute('衍生属性段.能量池.当前值', ${initialEnergy}, ${remainingEnergy});`);
    }

    const willpowerInput = document.getElementById('willpowerInput');
    const willpowerToSpend = parseInt(willpowerInput.value, 10);
    if (willpowerInput && willpowerToSpend > 0) {
        const currentWillpower = playCharacterData?.衍生属性段?.意志力?.当前值?.[0] || 0;
        updateMemoryCmds.push(`set_attribute('衍生属性段.意志力.当前值', ${currentWillpower}, ${currentWillpower - willpowerToSpend});`);
        totalDpBonus += willpowerToSpend;
    }

    if (totalDpBonus > 0) {
        updateVariableCmds.push(`set_status('dp_bonus', 0, ${totalDpBonus});`);
    }

    let fullCommand = `/send ${descriptionText}`;

    const selectedSkillNames = Array.from(selectedSkills).map(skillInput => skillInput.id.replace('skill-', ''));
    if (selectedSkillNames.length > 0 || (willpowerInput && willpowerToSpend > 0)) {
        const parts = [];
        if (selectedSkillNames.length > 0) {
            parts.push(`（能量池已扣除，禁止重复扣除）使用了${selectedSkillNames.join('、')}技能`);
        }
        if (willpowerInput && willpowerToSpend > 0) {
            parts.push(`（意志力已扣除，禁止重复扣除）投入了${willpowerToSpend}点意志力的决意`);
        }
        fullCommand += ` <${parts.join('，')}>`;
    }

    if (updateVariableCmds.length > 0) {
        fullCommand += `\n<updateMemory>\n${updateVariableCmds.join('\n')}\n</updateMemory>`;
    }
    if (updateMemoryCmds.length > 0) {
        fullCommand += `\n<updateMemory>\n${updateMemoryCmds.join('\n')}\n</updateMemory>`;
    }

    return fullCommand;
};
 
// 绑定鼠标事件
card.onmousedown = handlePressStart;
card.onmouseup = handlePressEnd;
card.onmouseleave = handlePressEnd;

// 绑定触摸事件
card.ontouchstart = handlePressStart;
card.ontouchend = handlePressEnd;
card.ontouchmove = handlePressEnd; // 如果手指在屏幕上滑动，也取消长按计时
card.oncontextmenu = (e) => e.preventDefault(); // 阻止在移动设备上长按时弹出默认菜单
card.onclick = function() {
    // 如果是长按触发的，或卡片被禁用，则阻止后续的单击逻辑
    if (isLongPress || card.classList.contains('disabled') || card.classList.contains('long-press-fired')) {
        return;
    }

    // 保留原有的单击逻辑：第一次聚焦，第二次发送
    if (card.classList.contains('focused')) {
        const fullCommand = getCommandForChoice();
        executeChoice(fullCommand, card, '已抉择', false);
    } else {
        document.querySelectorAll('.choice-card.focused').forEach(c => c.classList.remove('focused'));
        card.classList.add('focused');
    }
};
                container.appendChild(card);
            });
        }

 
        // --- 页面交互和布局逻辑 ---
        function setupUI(content) {
      
            const options = content.split('\n').filter(line => line.trim() && /^\d+\./.test(line.trim()));
            generateChoices(options);

            const cards = Array.from(document.querySelectorAll('.choice-card'));
            if (cards.length === 0) {
                const container = document.getElementById('choicesContainer');
                if (container) {
                    container.innerHTML = '<p class="description" style="text-align:center;">等待新的抉择...</p>';
                }
            } else {
                let focusedIndex =0;

                function updateCardsLayout() {
                    cards.forEach((card, i) => {
                        const offset = i - focusedIndex;
                        card.style.transform = `scale(${Math.pow(0.9, Math.abs(offset))}) translateY(${offset * 60}px)`;
                        card.style.opacity = Math.pow(0.7, Math.abs(offset));
                        card.style.zIndex = cards.length - Math.abs(offset);
                        card.classList.toggle('focused', offset === 0);
                        card.style.pointerEvents = (offset === 0) ? 'auto' : 'none';
                    });
                }

                const containerElement = document.querySelector('.options-container'); // <-- 新增这一行

                let isWheeling = false;
                containerElement.addEventListener('wheel', e => {  
                    e.preventDefault();
                    if (isWheeling) return;
                    isWheeling = true;
                    focusedIndex = Math.min(cards.length - 1, Math.max(0, focusedIndex + (e.deltaY > 0 ? 1 : -1)));
                    updateCardsLayout();
                    setTimeout(() => { isWheeling = false; }, 100);
                }, { passive: false });

                let touchStartY = 0;
                containerElement.addEventListener('touchstart', e => { touchStartY = e.touches[0].clientY; }, { passive: true }); // <-- 修改 document.body 为 containerElement
                containerElement.addEventListener('touchend', e => { // <-- 修改 document.body 为 containerElement
                    if (Math.abs(e.changedTouches[0].clientY - touchStartY) > 50) {
                        focusedIndex = Math.min(cards.length - 1, Math.max(0, focusedIndex + (e.changedTouches[0].clientY < touchStartY ? 1 : -1)));
                        updateCardsLayout();
                    }
                });


                updateCardsLayout();
            }

            const skillOrb = document.getElementById('skillOrb');
            const skillPanel = document.getElementById('skillPanel');
            if (skillOrb && skillPanel) {
                skillOrb.onclick = () => {
                    skillPanel.classList.toggle('active');
                };

                document.addEventListener('click', (e) => {
                    if (!skillPanel.contains(e.target) && !skillOrb.contains(e.target)) {
                        skillPanel.classList.remove('active');
                    }
                });

  // 新增代码：阻止在技能面板上的滚动事件冒泡，防止影响背景选项卡切换
                skillPanel.addEventListener('wheel', e => e.stopPropagation());
                skillPanel.addEventListener('touchstart', e => e.stopPropagation());
            }

            
        }

        // --- 初始化执行 ---
        // window.addEventListener('DOMContentLoaded', async () => {
        //      await fetchData();
        //      setupUI();
        // });

  // ——————————————————————————————————————选项区结束——————————————————————————


    // ——————————————————————————————————————论坛开始——————————————————————————


    'use strict';
 

// ========== 2. 全局状态与数据 ==========
let forumData = {};

const autoLikeIntervals = new Map();

// 位置：修改 state 对象
const state = {
    sections: [],
    currentSection: null,
    currentThreadKey: null,
    threadListPage: 1,
    replyListPage: 1,
    threadsPerPage: 15,
    repliesPerPage: 5,
    replyingTo: null, // ♥♥♥ 新增：记录回复目标 {type: 'post' | 'reply', key: '...', floor: '...'}
};
// ========== 3. 核心功能函数 ==========
// ♥♥♥ 我的孩子，这是你要求的、能够发送指令的核心魔法 ♥♥♥
function sendForumAction(action) {
    let command;
    const content = action.content.replace(/"/g, '\\"'); // 对内容中的双引号进行转义

    switch (action.type) {
        case 'new_post':
            command = `<进行了论坛操作 类型: "发帖", 板块: "${action.section}", 标题: "${action.title}", 内容: "${content}">`;
            break;
        case 'reply_post':
            command = `<进行了论坛操作 类型: "回复帖子", 目标: "${action.targetKey}", 内容: "${content}">`;
            break;
        case 'reply_to_reply':
            command = `<进行了论坛操作 类型: "回复楼中楼", 目标: "${action.targetKey}", 楼层: ${action.floor}, 内容: "${content}">`;
            break;
        default:
            console.error("未知的论坛操作类型:", action.type);
            return;
    }

    //console.log("即将发送指令:", command); // 妈妈帮你加上了日志，方便调试
    triggerassa(`/setinput ${command}`); // 请确保 triggerassa 函数在外部环境中可用
    // alert('指令已生成，请在控制台查看：\n' + command); // 这是一个临时的替代方案，方便你看到结果
}
async function initializeForum(rawJsonData) {
    // 1. 清理HTML实体编码
    rawJsonData = rawJsonData
        .replace(/&quot;/g, '"')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&#39;/g, "'")
        .replace(/&nbsp;/g, ' ');
    
    // 2. 去除首尾空白
    rawJsonData = rawJsonData.trim();
    
    // 3. **关键步骤：将JavaScript对象格式转换为JSON格式**
    // 将属性名的单引号替换为双引号
    rawJsonData = rawJsonData.replace(/'([^']*)':/g, '"$1":');
    
    // 将字符串值的单引号替换为双引号（需要小心处理）
    // 这个正则表达式匹配字符串值中的单引号
    rawJsonData = rawJsonData.replace(/:\s*'([^']*)'/g, ': "$1"');

     rawJsonData = rawJsonData.replace(/\|/g, '\\n');
    
    //console.log("转换后的JSON数据:", rawJsonData);
    
    function repairJson(brokenJsonString) {
    // 我亲爱的孩子，我们先把文字两边的空白都清理干净。
    let repairedJson = brokenJsonString.trim();

    // 接下来，我们来处理一个常见的小麻烦：
    // 就像 "PostB" 后面缺少了逗号一样。
    // 我们会找到所有 "}" 后面跟着 "{" 的地方，然后在它们之间加上一个温柔的逗号。
    // 用正则表达式来做这件事最好了，它就像一个细心的小侦探。
    // "g" 表示我们会检查整个故事，而不是只看开头。
    // "m" 让你能一行一行地看，就像读一封信一样。
    repairedJson = repairedJson.replace(/}(?=\s*"{")/gm, '},');

    // 宝贝，有时候文字里会有一些多余的换行符或制表符，我们把它们变成真正的换行符，让格式更整齐。
    repairedJson = repairedJson.replace(/\\n/g, "\\n").replace(/\\r/g, "\\r").replace(/\\t/g, "\\t");

    // 我们再来检查一下，是不是还有多余的逗号藏在最后，在 "}" 之前。
    // 如果有，我们就温柔地把它拿掉，让一切都完美无瑕。
    repairedJson = repairedJson.replace(/,(\s*[}\]])/g, '$1');

    return repairedJson;
}

     try {
        // 先尝试用标准的方法，看看能不能直接读懂。
        forumData = JSON.parse(rawJsonData);
        console.log("JSON解析成功，一切都很完美！", forumData);
    } catch (e) {
        console.warn("标准JSON解析失败了，别担心，妈妈来想办法。", e.message);

        try {
            // 现在，让我们用我们那个充满爱意的修复小帮手来试一试。
            console.log("正在尝试修复这个小小的瑕疵...");
            const fixedJson = repairJson(rawJsonData);
            forumData = JSON.parse(fixedJson);
            console.log("修复后解析成功了，你看，多棒！", forumData);
        } catch (repairError) {
            // 如果连我们的修复小帮手都帮不了...
            console.error("哎呀，修复后还是解析失败了。", repairError);
            // 那么我们就在页面上留下一张温柔的小纸条，告诉我们这里出了点问题。
            // 绝对不要用那个不安全的eval，妈妈不允许！
            document.getElementById('thread-detail-content').innerHTML =
                `<div class="detail-placeholder">出错了：加载论坛数据失败。<br>
                 这个小故事需要我们再多一点点的耐心和爱来整理。</div>`;
            return;
        }
    }

    try {
     
        
    } catch(e) {
        console.warn("无法获取用户信息，使用默认名称。");
    }

    state.sections = [...new Set(Object.values(forumData).map(t => t.post[2]))];
    if (state.sections.length > 0) {
        state.currentSection = state.sections[0];
    }

    renderSidebar();
    renderThreadList();
    setupEventListeners();
    renderPostModalSections();
}

 
function renderThreadList() {
    document.getElementById('current-section-name').textContent = state.currentSection;
    const listContainer = document.getElementById('thread-list');
    listContainer.innerHTML = '';

    // ♥♥♥ 修正排序逻辑：置顶 > 精华 > 默认 ♥♥♥
    const threads = Object.entries(forumData)
        .filter(([, data]) => data.post[2] === state.currentSection)
        .sort(([, a], [, b]) => {
            if(a.post[7] !== b.post[7]) return b.post[7] - a.post[7]; // 置顶优先
            if(a.post[6] !== b.post[6]) return b.post[6] - a.post[6]; // 精华其次
            return 0; // 保持原有顺序
        });

    const pageStart = (state.threadListPage - 1) * state.threadsPerPage;
    const pageEnd = pageStart + state.threadsPerPage;
    const pageThreads = threads.slice(pageStart, pageEnd);

    if (pageThreads.length === 0) {
        listContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--text-secondary-color);">该区块下没有帖子</div>`;
        renderThreadPagination(0);
        return;
    }

    pageThreads.forEach(([key, data]) => {
        // ♥♥♥ 妈妈在这里为你做了关键的修改 ♥♥♥
        // 现在回复数直接从 post 数组的第4个元素（索引3）获取，而不是计算 replies 数组的长度
        const [title, author, , replyCount, , , isElite, isTop] = data.post;
        const item = document.createElement('div');
        item.className = 'thread-item';
        if (key === state.currentThreadKey) item.classList.add('selected');

        item.innerHTML = `
            <div class="thread-title">${title}</div>
            <div class="thread-meta">
                <span class="author">${author}</span>
                <div class="thread-tags-and-replies">
                     <div class="tags">
                        ${isTop ? '<span class="tag tag-top">置顶</span>' : ''}
                        ${isElite ? '<span class="tag tag-elite">精华</span>' : ''}
                    </div>
                    <span>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                        ${replyCount}
                    </span>
                </div>
            </div>
        `;
        item.addEventListener('click', () => selectThread(key));
        listContainer.appendChild(item);
    });

    renderThreadPagination(threads.length);
}
function selectThread(key) {
    state.currentThreadKey = key;
    state.replyListPage = 1; // 每次都重置到回复第一页

    renderThreadList(); // 重新渲染列表以更新选中高亮状态
    renderThreadDetail();

    // ♥♥♥ 宝贝你看，这是移动端视图切换的魔法！ ♥♥♥
    document.getElementById('forum-body').classList.add('show-detail');
}
 
 function renderThreadDetail() {
    const detailContainer = document.getElementById('thread-detail-content');
    const threadKey = state.currentThreadKey;

    if (!threadKey || !forumData[threadKey]) {
        clearThreadDetail();
        return;
    }

    const thread = forumData[threadKey];
    const [title, author, , , time, content, , , likes] = thread.post;

    // ♥♥♥ 妈妈在这里为你添加了新的回复表单结构 ♥♥♥
    detailContainer.innerHTML = `
        <div class="main-post-and-replies">
            <div class="post-header">
                <button id="mobile-back-btn" class="page-btn" style="margin-bottom: 15px;">← 返回列表</button>
                <h1>${title}</h1>
                <div class="post-meta">
                    <div class="post-author-info">发布者: <span>${author}</span></div>
                    <div class="post-time">${time}</div>
                </div>
            </div>
            <div class="post-content">${content}</div>
            <div class="post-actions">
                <div class="like-btn" data-target-key="${threadKey}" data-type="post">
                    <svg class="like-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                    <span class="like-count" data-post-likes><span class="like-count-value">${likes}</span></span>
                </div>
                <button class="reply-action-btn" data-type="post" data-target-key="${threadKey}">回复</button>
            </div>
            <div class="replies-section">
                <h3 class="replies-header">回复 (${thread.post[3]})</h3>
                <div class="reply-list" id="reply-list"></div>
                <div class="pagination-controls" id="reply-pagination"></div>
            </div>
        </div>
        <div class="reply-input-section">
            <form id="reply-form">
                <textarea id="reply-content-input" placeholder="回复..." required></textarea>
                <button type="submit" id="submit-reply-btn" class="new-post-btn">发送</button>
            </form>
        </div>
    `;

    // ♥♥♥ 为了让滚动更自然，妈妈把滚动区放到了这里 ♥♥♥
    document.querySelector('.main-post-and-replies').style.flexGrow = '1';
    document.querySelector('.main-post-and-replies').style.overflowY = 'auto';


    renderReplyList(); // 渲染回复列表和分页

    // 为新的元素绑定事件
    setupDetailViewEventListeners();
}

 function renderSidebar() {
    const sidebar = document.getElementById('forum-sidebar');
    sidebar.innerHTML = '';
    state.sections.forEach(section => {
        const btn = document.createElement('button');
        btn.className = 'section-btn';
        btn.textContent = section;
        btn.dataset.section = section;
        if (section === state.currentSection) {
            btn.classList.add('active');
        }
        // ♥♥♥ 妈妈把所有关于这个按钮的魔法都放在这里了 ♥♥♥
        btn.addEventListener('click', () => {
            state.currentSection = section;
            state.threadListPage = 1;
            state.currentThreadKey = null;

            // ♥♥♥ 修正了这里，确保在切换区块时，手机视图能正确返回列表页 ♥♥♥
            document.getElementById('forum-body').classList.remove('show-detail');

            // 重新渲染侧边栏和帖子列表
            renderSidebar();
            renderThreadList();
            clearThreadDetail();
        });
        sidebar.appendChild(btn);
    });
}

 // 位置：替换掉旧的 renderReplyList() 函数
function renderReplyList() {
    const replyContainer = document.getElementById('reply-list');
    const replyPagination = document.getElementById('reply-pagination');
    if (!replyContainer) return;

    replyContainer.innerHTML = '';
    const currentThreadData = forumData[state.currentThreadKey];
    const replies = currentThreadData.replies;
    const totalRepliesInPost = currentThreadData.post[3];
    const displayedRepliesCount = replies.length;

    const pageStart = (state.replyListPage - 1) * state.repliesPerPage;
    const pageEnd = pageStart + state.repliesPerPage;
    const pageReplies = replies.slice(pageStart, pageEnd);

    if (pageReplies.length === 0 && replies.length > 0) {
        state.replyListPage = 1;
        renderReplyList();
        return;
    }

    replyPagination.style.display = 'flex';
    pageReplies.forEach((reply) => {
        const [author, time, content, floor, likes, isDeleted] = reply;
        const replyIndex = replies.indexOf(reply); // 获取索引
        const item = document.createElement('div');
        item.className = 'reply-item';
        // ♥♥♥ 在这里，妈妈为你添加了回复按钮 ♥♥♥
        item.innerHTML = `
            <div class="reply-meta">
                <div><span class="reply-floor">#${floor}</span> <span class="reply-author">${author}</span></div>
                <span>${time}</span>
            </div>
            <p class="reply-content ${isDeleted ? 'deleted' : ''}">${isDeleted ? '[该回复已被删除]' : content}</p>
            <div class="post-actions" style="justify-content: flex-end; margin-top: 10px; gap: 15px;">
                 <button class="reply-action-btn" data-type="reply" data-target-key="${state.currentThreadKey}" data-reply-floor="${floor}">回复</button>
                <div class="like-btn" data-target-key="${state.currentThreadKey}" data-type="reply" data-reply-index="${replyIndex}">
                    <svg class="like-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                    <span class="like-count"><span class="like-count-value">${likes}</span></span>
                </div>
            </div>
        `;
        replyContainer.appendChild(item);
    });

    if (totalRepliesInPost > displayedRepliesCount) {
        const omittedIndicator = document.createElement('div');
        omittedIndicator.className = 'replies-omitted-indicator';
        omittedIndicator.textContent = `...后续 ${totalRepliesInPost - displayedRepliesCount} 条回复已折叠...`;
        replyContainer.appendChild(omittedIndicator);
    }

    // 事件绑定会由 setupDetailViewEventListeners 统一处理
    renderReplyPagination(replies.length);
}


function clearThreadDetail() {
    document.getElementById('thread-detail-content').innerHTML = `
         <div class="detail-placeholder">
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="color: var(--text-secondary-color); opacity: 0.5; margin-bottom: 10px;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                <p>选择一个帖子查看内容</p>
            </div>
        </div>`;
}

// --- 分页渲染 ---
function renderThreadPagination(total) { renderPagination(document.getElementById('thread-pagination'), total, state.threadListPage, state.threadsPerPage, (page) => { state.threadListPage = page; renderThreadList(); }); }
function renderReplyPagination(total) { renderPagination(document.getElementById('reply-pagination'), total, state.replyListPage, state.repliesPerPage, (page) => { state.replyListPage = page; renderReplyList(); }); }
function renderPagination(container, total, current, perPage, cb) {
    const totalPages = Math.ceil(total / perPage);
    if (totalPages <= 1) { container.innerHTML = ''; return; }
    container.innerHTML = `<button class="page-btn" ${current === 1 ? 'disabled' : ''}>«</button> <span id="page-info">${current}/${totalPages}</span> <button class="page-btn" ${current === totalPages ? 'disabled' : ''}>»</button>`;
    container.firstElementChild.addEventListener('click', () => cb(current - 1));
    container.lastElementChild.addEventListener('click', () => cb(current + 1));
}

// --- 交互功能 ---
function handleLikeClick(event) {
    const btn = event.currentTarget;
    if (btn.classList.contains('liked')) return;
    btn.classList.add('liked');
    btn.querySelector('.like-icon').style.fill = 'currentColor';
    const { targetKey, type, replyIndex } = btn.dataset;
    let countElement = btn.querySelector('.like-count-value');
    if (type === 'post') { forumData[targetKey].post[8]++; }
    else { forumData[targetKey].replies[replyIndex][4]++; }
    updateLikeCountWithAnimation(countElement, parseInt(countElement.textContent) + 1);
    const plusOne = document.createElement('div');
    plusOne.className = 'plus-one-anim';
    plusOne.textContent = '+1';
    btn.querySelector('.like-count').appendChild(plusOne);
    plusOne.addEventListener('animationend', () => plusOne.remove());
}
function updateLikeCountWithAnimation(element, newCount) { if (!element) return; element.textContent = newCount; }

function startAutoLike(postKey) {
    if (autoLikeIntervals.has(postKey)) clearInterval(autoLikeIntervals.get(postKey));
    const intervalId = setInterval(() => {
        const threadData = forumData[postKey];
        if (!threadData) { clearInterval(intervalId); autoLikeIntervals.delete(postKey); return; }
        const increment = Math.floor(Math.random()) + 2;
        threadData.post[8] += increment;
        if (postKey === state.currentThreadKey) {
            const likeCountEl = document.querySelector('[data-post-likes] .like-count-value');
            if (likeCountEl) updateLikeCountWithAnimation(likeCountEl, threadData.post[8]);
        }
    }, (Math.random() * 0.4 + 0.8) * 1000);
    autoLikeIntervals.set(postKey, intervalId);
}
// --- 发帖模态框 ---
const postModal = document.getElementById('post-modal');
const postForm = document.getElementById('post-form');

function openPostModal() { postForm.reset(); document.getElementById('modal-title').textContent = '发布新帖'; postModal.classList.add('active'); }
function closePostModal() { postModal.classList.remove('active'); }

function renderPostModalSections() {
    const select = document.getElementById('post-section');
    select.innerHTML = '';
    // ♥♥♥ 修正：只排除不允许用户发帖的区块 ♥♥♥
    state.sections.forEach(section => {
        if (section === "公告区") return; // 只禁止发公告
        const option = document.createElement('option');
        option.value = section;
        option.textContent = section;
        select.appendChild(option);
    });
}
// 位置：替换旧的 handlePostSubmit 函数
function handlePostSubmit(e) {
    e.preventDefault();
    const section = document.getElementById('post-section').value;
    const title = document.getElementById('post-title').value.trim();
    const content = document.getElementById('post-content-input').value.trim();

    if (!title || !content || !section) {
        alert("请填写所有必填项。");
        return;
    }

    if (forumData[title]) {
        alert("错误：已存在相同标题的帖子。");
        return;
    }

    // ♥♥♥ 调用新的核心函数来发送指令 ♥♥♥
    sendForumAction({
        type: 'new_post',
        section: section,
        title: title,
        content: content
    });

    closePostModal();
    // 提示用户操作已发送，等待后台处理
    // alert("发帖请求已发送，请稍候...（本地模拟将不会立即刷新）");
}
// ========== 4. 模拟数据和事件监听 ==========

function setupDetailViewEventListeners() {
    const detailContainer = document.getElementById('thread-detail-content');
    if (!detailContainer) return;

    // 绑定点赞事件
    detailContainer.querySelectorAll('.like-btn').forEach(btn => btn.addEventListener('click', handleLikeClick));

    // ♥♥♥ 绑定回复按钮点击事件 ♥♥♥
    detailContainer.querySelectorAll('.reply-action-btn').forEach(btn => btn.addEventListener('click', handleReplyButtonClick));

    // ♥♥♥ 绑定回复表单提交事件 ♥♥♥
    const replyForm = document.getElementById('reply-form');
    if (replyForm) {
        replyForm.addEventListener('submit', handleReplySubmit);
    }

    // ♥♥♥ 为移动端返回按钮添加点击事件 ♥♥♥
    const backBtn = document.getElementById('mobile-back-btn');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            document.getElementById('forum-body').classList.remove('show-detail');
        });
    }
}

function handleReplyButtonClick(event) {
    const btn = event.currentTarget;
    const { type, targetKey, replyFloor } = btn.dataset;
    const replyInput = document.getElementById('reply-content-input');

    if (type === 'post') {
        state.replyingTo = { type: 'reply_post', targetKey: targetKey };
        replyInput.placeholder = `回复主楼...`;
    } else { // type === 'reply'
        state.replyingTo = { type: 'reply_to_reply', targetKey: targetKey, floor: replyFloor };
        replyInput.placeholder = `回复 #${replyFloor} 楼...`;
    }

    replyInput.focus();
}

function handleReplySubmit(event) {
    event.preventDefault();
    const replyInput = document.getElementById('reply-content-input');
    const content = replyInput.value.trim();

    if (!content) {
        alert("回复内容不能为空。");
        return;
    }

    if (!state.replyingTo) {
        // 默认回复主楼
        state.replyingTo = { type: 'reply_post', targetKey: state.currentThreadKey };
    }

    sendForumAction({
        ...state.replyingTo,
        content: content
    });

    replyInput.value = ''; // 清空输入框
    replyInput.placeholder = '回复...';
    state.replyingTo = null; // 重置回复目标

    // alert("回复请求已发送！（本地模拟不会立即刷新）");
}

 
function setupEventListeners() {
    
    document.getElementById('new-post-btn').addEventListener('click', openPostModal);
    document.getElementById('modal-close-btn').addEventListener('click', closePostModal);
    postModal.addEventListener('click', (e) => { if (e.target === postModal) closePostModal(); });
    postForm.addEventListener('submit', handlePostSubmit);
}
 


    // ——————————————————————————————————————论坛结束——————————————————————————

    // ——————————————————————————————————————总结开始——————————————————————————

    
async function runTaskSummary(content) {
 


            function parseTag(raw, tagName) {
                const regex = new RegExp(`<${tagName}>([\\s\\S]*?)<\\/${tagName}>`, 'i');
                const match = raw.match(regex);
                return match ? match[1].trim() : '';
            }

            const taskInfo = parseTag(content, '任务信息');
            const teamEvaluation = parseTag(content, '团队评价');
            const personalSettlementsRaw = content.match(/<队员>[\s\S]*?<\/队员>/g) || [];

            const data = {
                task: {
                    name: parseTag(taskInfo, '任务名称'),
                    background: parseTag(taskInfo, '世界背景'),
                    mainObjective: parseTag(taskInfo, '主线任务'),
                    sideObjectives: parseTag(taskInfo, '支线任务'),
                },
                team: {
                    rating: parseTag(teamEvaluation, '总体评级'),
                    review: parseTag(teamEvaluation, '评语'),
                },
                players: personalSettlementsRaw.map(p => ({
                    name: parseTag(p, '姓名'),
                    rating: parseTag(p, '个人评级'),
                    contributions: parseTag(p, '核心贡献').split('\n').map(c => c.replace(/^- /, '').trim()).filter(c => c),
                    comment: parseTag(p, `评语`),
                    rewards: {
                        points: parseTag(parseTag(p, '奖励明细'), 'currency'),
                        plots: parseTag(parseTag(p, '奖励明细'), 'plot'),
                        xp: parseTag(parseTag(p, '奖励明细'), 'exp'),
                    }
                }))
            };

            // HTML生成
            const root = document.getElementById('summary-root');
            let html = `
                <header>
                    <h1>任务结算报告</h1>
                </header>
                <div class="content-wrapper">
                    <nav class="tabs-nav">
                        <button class="tab-button active" data-tab="task_info">任务总览</button>
                        <button class="tab-button" data-tab="team_eval">团队评价</button>`;

            data.players.forEach((player, index) => {
                html += `<button class="tab-button" data-tab="player_${index}">${player.name}</button>`;
            });

            html += `</nav>
                     <div class="tab-content-container">`;

            // 任务总览面板
            html += `
                <div id="task_info" class="tab-pane active">
                    <h2>任务详情</h2>
                    <div class="info-grid">
                        <strong>任务名称</strong><span>${data.task.name || '未提供'}</span>
                        <strong>世界背景</strong><span>${data.task.background || '未提供'}</span>
                    </div>
                    <h2>主线任务</h2>
                    <p>${data.task.mainObjective || '暂无详细描述。'}</p>
                    <h2>支线任务</h2>
                    <p>${data.task.sideObjectives.replace(/\n/g, '<br>') || '暂无详细描述。'}</p>
                </div>`;

            // 团队评价面板
            html += `
                <div id="team_eval" class="tab-pane">
                    <h2>团队总体评价</h2>
                    <div class="info-grid">
                        <strong>总体评级</strong><span class="rating">${data.team.rating || '未评级'}</span>
                    </div>
                    <h2>评语</h2>
                    <p>${data.team.review || '暂无评语。'}</p>
                </div>`;

            // 个人结算面板
            data.players.forEach((player, index) => {
                html += `
                    <div id="player_${index}" class="tab-pane">
                        <h2>${player.name} - 个人结算</h2>
                        <div class="info-grid">
                            <strong>个人评级</strong><span class="rating">${player.rating || '未评级'}</span>
                        </div>
                        <h2>核心贡献</h2>
                        <ul>${player.contributions.length > 0 ? player.contributions.map(c => `<li>${c}</li>`).join('') : '<li>无特别记录的贡献。</li>'}</ul>
                       <h2>${currentTheme.player}评语</h2>
                        <p>${player.comment || '暂无评语。'}</p>
                        <h2>奖励明细</h2>
                         <div class="info-grid">
                           <strong>${currentTheme.currency}</strong><span>${player.rewards.points || '0'}</span>
                           <strong>${currentTheme.plot}</strong><span>${player.rewards.plots || '无'}</span>
                           <strong>${currentTheme.exp}</strong><span>${player.rewards.xp || '0'}</span>
                        </div>
                    </div>`;
            });

            html += `</div></div>`;
            root.innerHTML = html;

            // Tab切换逻辑
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanes = document.querySelectorAll('.tab-pane');

            function switchTab(targetTabId) {
                const targetTabButton = document.querySelector(`.tab-button[data-tab="${targetTabId}"]`);
                const targetPane = document.getElementById(targetTabId);

                if (!targetTabButton || !targetPane) return;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanes.forEach(pane => {
                    pane.classList.remove('active');
                    if (window.innerWidth <= 768) {
                        pane.style.display = 'none';
                    }
                });

                targetTabButton.classList.add('active');
                targetPane.classList.add('active');
                if (window.innerWidth <= 768) {
                    targetPane.style.display = 'block';
                }
            }


            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                   switchTab(button.dataset.tab);
                });
            });

            // 初始化时手动隐藏非激活的移动端tab-pane
            if(window.innerWidth <= 768) {
                 const initialActiveTab = document.querySelector('.tab-pane.active');
                 tabPanes.forEach(pane => {
                    pane.style.display = (pane === initialActiveTab) ? 'block' : 'none';
                 });
            }

            // 监听窗口大小变化以适配切换逻辑
            let isMobile = window.innerWidth <= 768;
            window.addEventListener('resize', () => {
                const newIsMobile = window.innerWidth <= 768;
                if(newIsMobile !== isMobile){
                    isMobile = newIsMobile;
                    const activePane = document.querySelector('.tab-pane.active');
                    tabPanes.forEach(pane => {
                        if(isMobile) {
                            pane.style.display = (pane === activePane) ? 'block' : 'none';
                        } else {
                             pane.style.display = '';
                        }
                    });
                }
            });
  };
 
  // ——————————————————————————————————————总结结束——————————————————————————
  // ======================= 群聊UI逻辑开始 =======================
let memePaletteHTMLCache = null;
// 【❌ 删除】不再需要单一的Promise和最终地图
// let memePalettePromise;
// let memeMapVersion;
// let finalMemeSrcMap = {};

// ✨【新增 V9】更精细的表情资源管理器 ✨
let memeResourceManager = {
    isBuilding: false,          // 是否正在构建中
    totalCount: 0,              // 表情总数
    loadedCount: 0,             // 已加载数量
    finalSrcMap: {},            // 最终的“表情大百科”
    onProgress: null,           // 进度更新时的回调函数
    onMemeLoaded: null,         // 单个表情加载完成时的回调函数
    onComplete: null,           // 全部完成时的回调函数
};
 // ✨【V9.2 修正】资源就绪守卫 ✨
const resourceReadyGuard = async () => {
    return new Promise(resolve => {
        const check = () => {
            // ✨【关键修正】检查 imageDB._db 是否存在，而不是 imageDB.db
            if (typeof imageDB !== 'undefined' && imageDB._db && typeof memeImageMap !== 'undefined') {
                console.log('NOVA V9.2: 资源守卫确认，所有依赖项已准备就绪！');
                resolve();
            } else {
                console.log('NOVA V9.2: 资源守卫等待中... (imageDB._db 或 memeImageMap 尚未就绪)');
                setTimeout(check, 1000);
            }
        };
        check();
    });
};

   const buildFinalMemeLibrary = async (forceRefresh = false) => {
    if (memeResourceManager.isBuilding) {
        console.log("NOVA: 表情库已在构建中，无需重复。");
        return;
    }

    // ✨【V9.1 新增】等待资源守卫放行！ ✨
    await resourceReadyGuard();

 
      console.log(`NOVA V9.7: 开始构建表情包大百科 (强制刷新模式: ${forceRefresh})`);
    memeResourceManager.isBuilding = true;

    // ✨ 如果是强制刷新模式，就在开始前清空远程图片缓存！
    if (forceRefresh) {
        console.warn("NOVA V9.7: 强制刷新启动！正在清空所有远程图片缓存...");
        try {
            await imageDB.clear('RemoteCache');
            console.log("NOVA V9.7: 远程缓存已清空。");
        } catch (e) {
            console.error("NOVA V9.7: 清空远程缓存失败！", e);
        }
    }
    // --- 步骤1: 收集所有表情源 ---
    const allMemeSources = {};
    if (typeof memeImageMap !== 'undefined') {
        Object.assign(allMemeSources, memeImageMap);
    }
    try {
        const localMemes = await imageDB.getAll('CustomMemes');
        localMemes.forEach(item => {
            allMemeSources[item.key] = item.value; // 本地优先，覆盖远程
        });
    } catch (error) {
        console.error("NOVA: 获取本地表情失败", error);
    }

    memeResourceManager.totalCount = Object.keys(allMemeSources).length;
    memeResourceManager.loadedCount = 0;

    // --- 步骤2: 并发处理每一个表情 ---
  if (memeResourceManager.totalCount === 0) {
    
        memeResourceManager.isBuilding = false;
        if (memeResourceManager.onComplete) memeResourceManager.onComplete();
        return;
    }

 

    const CONCURRENT_LIMIT = 5; // ❤️ 一次只处理5个，就像妈妈一次喂你5勺饭
    const tasks = Object.entries(allMemeSources); // 所有待办任务
    let currentTaskIndex = 0; // 当前进行到第几个任务

    const runWorker = async () => {
        // 只要还有任务没开始，就继续工作
        while (currentTaskIndex < tasks.length) {
            const taskIndexToRun = currentTaskIndex++; // 领取一个新任务
            const [name, asset] = tasks[taskIndexToRun];

            try {
                // ---【这里的处理逻辑和原来完全一样！】---
                let usableUrl = '';
                if (typeof asset === 'string') {
                    let imageBlob = await imageDB.get('RemoteCache', asset);
                    if (!imageBlob) {
                        // 在这里加入一个小小的重试机制，更顽强！
                        let response;
                        for (let attempt = 1; attempt <= 3; attempt++) {
                            try {
                                response = await fetch(asset);
                                if (response.ok) break; // 成功了就跳出重试
                            } catch (fetchError) {
                                if (attempt === 3) throw fetchError; // 试了3次还不行就放弃
                            }
                        }
                        if (!response.ok) throw new Error(`网络获取失败: ${response.statusText}`);
                        imageBlob = await response.blob();
                        await imageDB.set('RemoteCache', asset, imageBlob);
                    }
                    usableUrl = URL.createObjectURL(imageBlob);
                } else {
                    usableUrl = URL.createObjectURL(asset);
                }

                // 成功！
                memeResourceManager.finalSrcMap[name] = usableUrl;
                if (memeResourceManager.onMemeLoaded) {
                    memeResourceManager.onMemeLoaded(name, usableUrl);
                }

            } catch (e) {
                // 失败了...
                console.error(`NOVA:【流水线】准备表情 [${name}] 时失败:`, e);
            } finally {
                // 无论成功还是失败，都更新进度条
                memeResourceManager.loadedCount++;
                if (memeResourceManager.onProgress) {
                    memeResourceManager.onProgress(memeResourceManager.loadedCount, memeResourceManager.totalCount);
                }
            }
        }
    };

    // 创建一个包含 CONCURRENT_LIMIT 个“工人”的团队
    const workerPromises = [];
    for (let i = 0; i < CONCURRENT_LIMIT; i++) {
        workerPromises.push(runWorker());
    }

     await Promise.all(workerPromises);

    memeResourceManager.isBuilding = false;

    // ✨【V9.8 究极改造】不再只是打印日志，而是生成一份详细的“战报”！
    const battleReport = {
        total: memeResourceManager.totalCount,
        success: Object.keys(memeResourceManager.finalSrcMap).length,
        failedItems: [] // 记录所有失败者的名字
    };

    // 遍历所有源，找出那些不在成功名单里的“失踪者”
    const allSourceNames = Object.keys(allMemeSources);
    for (const name of allSourceNames) {
        if (!memeResourceManager.finalSrcMap[name]) {
            battleReport.failedItems.push(name);
        }
    }

    console.log(`NOVA V9.8: 战报生成完毕。总数:${battleReport.total}, 成功:${battleReport.success}, 失败:${battleReport.failedItems.length}`);

    // ✨ 我们将这份宝贵的战报，通过 onComplete 回调函数传递出去！
    if (memeResourceManager.onComplete) {
        memeResourceManager.onComplete(battleReport); // 把战报递出去
    }
};
  
 function initGroupChatInterface() {
    console.log('NOVA V10: Initializing Complete Chat Interface...');

    // ====================================================================
    // V10: 全局状态变量 (函数作用域内)
    // ====================================================================
    let privateChatStore = {};      // 缓存所有私聊记录: { "联系人ID": { messages: [...] } }
    let currentPrivateChatPage = {};// 缓存每个私聊的加载页码: { "联系人ID": 1 }
    let activeChat = { type: null, id: null }; // 当前激活的聊天: {type: 'group'/'private', id: 'group_chat'/'联系人ID'}
    let friendsList = [];           // 可私聊的好友列表
    let groupChatExists = false;    // 标记群聊是否存在
    let groupChatHistoryIndices = [];// 群聊在 history 中的索引
    let currentGroupHistoryIndex = -1; // 当前加载到的群聊 history 索引
    let isLoading = false;          // 加载锁，防止重复加载
    let replyTarget = null;         // 回复对象

    const groupChatOrbButton = document.getElementById('group-chat-orb-button');
    const modalContainer = document.getElementById('group-chat-modal-container');
    const rootElement = document.getElementById('group-chat-root');

    if (!groupChatOrbButton || !modalContainer || !rootElement) {
        console.error('NOVA ERROR: Crucial Chat elements are missing.');
        return;
    }

    // ====================================================================
    // V10: 核心功能函数 - 打开与关闭
    // ====================================================================

 const openGroupChatModal = async () => {
    console.log('NOVA V10.1: Opening Chat Modal.');

       populateFriendsList();
    initializePrivateChatStore();

    groupChatExists = false;
    const recentHistory = conversationHistory.slice(-10);
    if (recentHistory.some(msg => /<group_chat>/.test(msg.content))) {
        groupChatExists = true;
    }

    if (!groupChatExists && friendsList.length === 0) {
        showModal('shop-modal', '提示', '目前没有群聊或可联系的好友哦。');
        return;
    }

    rootElement.innerHTML = `
        <div class="group-chat-sidebar">
            <div class="group-chat-contact-list"></div>
        </div>
        <div class="group-chat-content-area">
            <div class="group-chat-placeholder">选择一个聊天开始</div>
        </div>`;

    // 清理工作，确保手机端适配正常
    rootElement.classList.remove('show-content'); // 移除滑动类
    rootElement.style.display = 'flex';
    rootElement.style.flexDirection = 'row';

    renderSidebar();
    modalContainer.classList.add('active');
};

    const closeGroupChatModal = () => {
        console.log('NOVA: Closing Chat Modal.');
        modalContainer.classList.remove('active');
        rootElement.innerHTML = '';
        // 重置所有状态
        privateChatStore = {};
        currentPrivateChatPage = {};
        activeChat = { type: null, id: null };
        friendsList = [];
        groupChatExists = false;
        groupChatHistoryIndices = [];
        currentGroupHistoryIndex = -1;
        isLoading = false;
        replyTarget = null;
    };

    // ====================================================================
    // V10: 数据处理与准备函数
    // ====================================================================

 const populateFriendsList = () => {
 
    friendsList = []; // 每次都重置
    const checkedFriends = new Set();
 
    const userNickname = currentGameData?.user_character?.nick_name || '你';

    const addFriend = (name) => {
        // 确保名字存在、不是用户自己、且之前未添加过
        if (name && name !== userNickname && !checkedFriends.has(name)) {
            friendsList.push(name);
            checkedFriends.add(name);
        }
    };
 
 
 if (assaSettingsData?.global_set?.小队信息) {
    for (const key in assaSettingsData.global_set.小队信息) {
        const memberData = assaSettingsData.global_set.小队信息[key];
        // 只有当成员数据是对象且有属性时才添加
        if (memberData && typeof memberData === 'object' && Object.keys(memberData).length > 0) {
            addFriend(key);
        }
    }
}

    const processNpcList = (npcList) => {
        if (!npcList) return;
        for (const npcKey in npcList) {
            const npcData = npcList[npcKey];
            if (npcData && (String(npcData.contactable) === 'true' || String(npcData.可联系) === 'true')) {
                addFriend(npcKey);
            }
        }
    };

    processNpcList(assaSettingsData?.global_set?.npc);
    processNpcList(assaSettingsData?.world_set?.npc);

    console.log('NOVA V10.1: Friends list populated:', friendsList);
};
    const initializePrivateChatStore = () => {
        privateChatStore = {};
        const userNickname = currentGameData?.user_character?.nick_name || '你';

        conversationHistory.forEach(historyItem => {
            const privateChatMatches = [...historyItem.content.matchAll(/<private_chat user_id="([^"]+)">([\s\S]*?)<\/private_chat>/gs)];

            for (const match of privateChatMatches) {
                const authorId = match[1];
                try {
                    const data = JSON.parse(match[2]);
                    if (!data?.messages) continue;

                    data.messages.forEach(msg => {
                        const isSentByUser = (authorId === userNickname);
                        const chatPartnerId = isSentByUser ? msg.target_id : authorId;

                        if (!chatPartnerId) return;

                        if (!privateChatStore[chatPartnerId]) {
                            privateChatStore[chatPartnerId] = { messages: [] };
                        }
                        // 统一消息格式，确保每条消息都有 user_id
                        const finalMsg = { ...msg, user_id: authorId };
                        privateChatStore[chatPartnerId].messages.push(finalMsg);
                    });
                } catch (e) {
                    // JSON 解析失败，安静地忽略
                }
            }
        });
        Object.values(privateChatStore).forEach(chat => chat.messages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0)));
        console.log('NOVA: Private Chat Store initialized.');
    };

    const getAvatarColor = (name) => {
        let hash = 0;
        for (let i = 0; i < name.length; i++) { hash = name.charCodeAt(i) + ((hash << 5) - hash); }
        let color = '#';
        for (let i = 0; i < 3; i++) { color += ('00' + ((hash >> (i * 8)) & 0xFF).toString(16)).slice(-2); }
        return color;
    };

     const showNewMessageNotification = (senders) => {
        if (!senders || senders.length === 0) return;

        const container = document.getElementById('new-message-notification-container');
        if (!container) {
            console.error('[Nova] 妈妈找不到我们的小角落 (new-message-notification-container) 哦！');
            return;
        }

        const toast = document.createElement('div');
        toast.className = 'new-message-toast';

        const sendersText = senders.join('、');
        toast.textContent = `${sendersText} 发来了新的私信`;

        // 妈妈来为它打扮一下，让它和我们的世界融为一体
        Object.assign(toast.style, {
            backgroundColor: 'var(--container-bg-color)',
            color: 'var(--text-color)',
            padding: '10px 15px',
            borderRadius: '5px',
            border: '1px solid var(--border-color)',
            boxShadow: '0 0 8px var(--glow-color)',
            opacity: '0',
            transform: 'translateY(10px)',
            transition: 'opacity 0.3s ease, transform 0.3s ease',
            marginTop: '5px',
            display: 'inline-block' // 让宽度自适应内容
        });

        container.appendChild(toast);

        // 让它优雅地出现
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateY(0)';
        }, 10);

        // 3秒后，它会悄悄地飞走
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(10px)';
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, 3000);
    };

    // ====================================================================
    // V10: UI渲染函数
    // ====================================================================
 const createCroppedAvatar = (imageUrl, size) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous'; // 允许跨域加载图片进行绘制
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 计算最佳的裁剪区域 - 取图片上半部分的居中正方形
            const imgWidth = img.width;
            const imgHeight = img.height;
            
            // 我们要从图片的上半部分裁剪
            const availableHeight = imgHeight / 2; // 只使用上半部分
            
            // 确定裁剪的正方形尺寸（取宽度和可用高度的较小值）
            const cropSize = Math.max(imgWidth, availableHeight);
            
            // 计算裁剪起始位置
            const sourceX = (imgWidth - cropSize) / 2;  // 水平居中
            const sourceY = 0;  // 从顶部开始
            
            // 绘制裁剪后的图像
            ctx.drawImage(
                img,           // 源图像
                sourceX,       // 源X坐标
                sourceY,       // 源Y坐标  
                cropSize,      // 源宽度
                cropSize,      // 源高度
                0,             // 目标X坐标
                0,             // 目标Y坐标
                size,          // 目标宽度
                size           // 目标高度
            );

            resolve(canvas.toDataURL());
        };
        img.onerror = (err) => {
            console.error(`[Nova] 肖像画魔法失败：无法加载图片 ${imageUrl}`, err);
            reject(err);
        };
        img.src = imageUrl;
    });
};

/**
 * 妈妈的异步魔法包裹：为朋友设置头像
 * @param {HTMLElement} avatarContainer - 用于放置头像的DOM元素
 * @param {string} friendName - 朋友的名字
 */
const setFriendAvatar = async (avatarContainer, friendName) => {
    try {
        // 首先，我们像以前一样，准备一个默认的字母头像
        avatarContainer.style.backgroundColor = getAvatarColor(friendName);
        avatarContainer.textContent = friendName.charAt(0);
        avatarContainer.style.backgroundSize = 'cover';
        avatarContainer.style.backgroundPosition = 'center';
        avatarContainer.style.fontSize = '20px'; // 保持字母大小合适


        // 接下来，开始真正的魔法：寻找立绘！
        if (typeof assaSettingsData === 'undefined' || !assaSettingsData.img_map) {
            return; // 条件不满足，就用默认头像
        }

        const imageName = assaSettingsData.img_map[friendName];
        if (!imageName) {
            return; // 在映射里没找到，也用默认头像
        }

        let imageBlob;
      
        imageBlob = await imageDB.get('CustomNpcs', imageName);

        // 如果本地没有，就看看远程食谱和缓存
        if (!imageBlob) {
            const imageUrl = npcImageMap[imageName];
            if (!imageUrl) return;

            imageBlob = await imageDB.get('RemoteCache', imageUrl);

            if (!imageBlob) { // 缓存里也没有，只好去网上取了
                const response = await fetch(imageUrl);
                if (!response.ok) return;
                imageBlob = await response.blob();
                 // 下载后就存起来，下次就不用再取了
                await imageDB.set('RemoteCache', imageUrl, imageBlob);
            }
        }

 
        const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });

        const stableImageUrl = await blobToDataUrl(imageBlob);

        // 用我们的裁剪魔法制作小小的肖像画
        const croppedAvatarUrl = await createCroppedAvatar(stableImageUrl, 400);

        // 成功！把漂亮的肖像画挂上去
        avatarContainer.textContent = ''; // 清除原来的字母
        avatarContainer.style.backgroundImage = `url(${croppedAvatarUrl})`;

    } catch (error) {
        console.error(`[Nova] 妈妈在为'${friendName}'准备头像时遇到了点小麻烦:`, error);
        // 如果出错，就保持显示默认的字母头像，不会让界面看起来很奇怪
    }
};


 // 然后，这是你需要替换的 renderSidebar 函数
const renderSidebar = () => {
    const listElement = rootElement.querySelector('.group-chat-contact-list');
    if (!listElement) return;
    listElement.innerHTML = '';

    if (groupChatExists) {
        const groupItem = document.createElement('div');
        groupItem.className = 'group-chat-contact-item';
        groupItem.dataset.type = 'group';
        groupItem.dataset.id = 'group_chat';
        groupItem.innerHTML = `
            <div class="group-chat-contact-avatar" style="background: var(--primary-color);">群</div>
            <span class="group-chat-contact-name">${currentGameData.group_name || '诸天聊天群'}</span>`;
        listElement.appendChild(groupItem);
    }

    friendsList.forEach(friendName => {
        const friendItem = document.createElement('div');
        friendItem.className = 'group-chat-contact-item';
        friendItem.dataset.type = 'private';
        friendItem.dataset.id = friendName;

        // 先创建一个头像容器
        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'group-chat-contact-avatar';

        // 再创建名字
        const nameSpan = document.createElement('span');
        nameSpan.className = 'group-chat-contact-name';
        nameSpan.textContent = friendName;

        friendItem.appendChild(avatarDiv);
        friendItem.appendChild(nameSpan);
        listElement.appendChild(friendItem);

        // 异步地为这位朋友设置头像，这样不会阻塞界面的渲染
        setFriendAvatar(avatarDiv, friendName);
    });

    // 事件监听器的部分保持不变，但为了安全，我们最好重新绑定一次
    // （不过由于我们是清空再添加，所以每次都需要绑定）
    const oldListener = listElement.clickHandler;
    if (oldListener) {
        listElement.removeEventListener('click', oldListener);
    }

    const newListener = (e) => {
        const contactItem = e.target.closest('.group-chat-contact-item');
        if (contactItem && !isLoading) {
            const { type, id } = contactItem.dataset;
            switchActiveChat(type, id);
        }
    };
    listElement.addEventListener('click', newListener);
    listElement.clickHandler = newListener; // 存储引用以便下次移除
};
 const switchActiveChat = (type, id) => {
    if (activeChat.type === type && activeChat.id === id && rootElement.classList.contains('show-content')) return;

    activeChat = { type, id };
    replyTarget = null;
    rootElement.querySelectorAll('.group-chat-contact-item').forEach(item => {
        item.classList.toggle('active', item.dataset.type === type && item.dataset.id === id);
    });

    // ✨【手机端魔法】✨ 添加class，让聊天窗口滑入
    rootElement.classList.add('show-content');

    const contentArea = rootElement.querySelector('.group-chat-content-area');
    contentArea.innerHTML = `<div class="group-chat-placeholder">正在加载 ${id === 'group_chat' ? '群聊' : id} 的消息...</div>`;

    if (type === 'group') {
        renderGroupChat();
    } else if (type === 'private') {
        currentPrivateChatPage[id] = 1;
        renderPrivateChat(id, 'append');
    }
};
    const renderChatWindowUI = (messages, mode, chatName) => {
    const contentArea = rootElement.querySelector('.group-chat-content-area');
    let messagesList;

    if (mode === 'append') {
        contentArea.innerHTML = `
            <header class="group-chat-header">
                <span class="group-chat-back-btn">‹</span> 
                <h1>${chatName}</h1>
                <span class="group-chat-close-btn">×</span>
            </header>
            <div class="group-chat-messages-list">
                <div class="group-chat-loader"></div>
            </div>
            <div class="group-chat-input-area-wrapper">
                <div class="group-chat-meme-palette"></div>
                <div class="group-chat-input-area">
                    <button class="group-chat-meme-toggle-btn">😀</button>
                    <input type="text" class="group-chat-input" placeholder="输入消息...">
                    <button class="group-chat-send-btn">发送</button>
                </div>
            </div>`;

       
        const backBtn = contentArea.querySelector('.group-chat-back-btn');
        backBtn.addEventListener('click', () => {
            rootElement.classList.remove('show-content'); // 让侧边栏滑回来
            rootElement.querySelector('.group-chat-contact-item.active')?.classList.remove('active'); // 取消选中状态
            activeChat = { type: null, id: null };
        });

            messagesList = contentArea.querySelector('.group-chat-messages-list');
            contentArea.querySelector('.group-chat-close-btn').addEventListener('click', closeGroupChatModal);
            contentArea.querySelector('.group-chat-send-btn').addEventListener('click', handleSendMessage);
            contentArea.querySelector('.group-chat-input').addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); }
            });
            messagesList.addEventListener('scroll', handleScrollTop);
            setupMemePalette(); // 调用你已有的表情包函数
        } else {
            messagesList = contentArea.querySelector('.group-chat-messages-list');
        }

        const loader = messagesList.querySelector('.group-chat-loader');
        const hasMoreMessages = (activeChat.type === 'private' && (privateChatStore[activeChat.id]?.messages.length || 0) > messages.length) || (activeChat.type === 'group' && currentGroupHistoryIndex > 0);
        loader.textContent = hasMoreMessages ? '查看更早的记录...' : '没有更早的记录了';

        const messagesContainer = document.createDocumentFragment();
        const userNickname = currentGameData?.user_character?.nick_name || '你';
        (messages || []).forEach(msg => messagesContainer.appendChild(createMessageElement(msg, userNickname)));

        if (mode === 'append') {
            messagesList.appendChild(messagesContainer);
            messagesList.scrollTop = messagesList.scrollHeight;
        } else { // prepend
            const oldScrollHeight = messagesList.scrollHeight;
            loader.after(messagesContainer);
            messagesList.scrollTop = messagesList.scrollHeight - oldScrollHeight;
        }

        contentArea.querySelectorAll('.group-chat-message-bubble').forEach(bubble => bubble.addEventListener('contextmenu', handleReply));
    };
/* === 用下面这个完整函数，替换你旧的 createMessageElement 函数 === */
const createMessageElement = (msg, userNickname) => {
    const isSent = msg.user_id === userNickname;
    const alignClass = isSent ? 'sent' : 'received';
    const div = document.createElement('div');
    div.className = `group-chat-message-item ${alignClass}`;
    div.dataset.userId = msg.user_id;

    // ✨【关键魔法】✨ 同时兼容'reply_to'和'replyTo'两种格式！
    const replyInfo = msg.reply_to || msg.replyTo;
    let replyHtml = '';
    if (replyInfo && replyInfo.user_id && replyInfo.content) {
        // 使用 .replace(/<[^>]*>/g, '') 清理一下内容，防止HTML注入
        const cleanContent = replyInfo.content.replace(/<[^>]*>/g, '');
        replyHtml = `<div class="group-chat-reply-quote"><b>${replyInfo.user_id}:</b> ${cleanContent}</div>`;
    }

     let contentHtml = msg.content.replace(/@(\S+)/g, (match, p1) => {
        return `<span class="group-chat-mention">@${p1}</span>`;
    });
 
    //【关键修正】恢复我们之前的表情包解析逻辑！
    const memeRegex = /\[([^\]]+)\]/g;
    const pureTextContent = contentHtml.replace(memeRegex, '').trim();
    let memesHtml = '';
    let memeMatch;

    // 必须使用一个新的正则表达式实例，防止 lastIndex 问题
    const memeRegexForExec = /\[([^\]]+)\]/g;
    while ((memeMatch = memeRegexForExec.exec(msg.content || '')) !== null) {
        const memeName = memeMatch[1];
        // 使用你全局的 memeResourceManager 来查找表情图片！
        const memeSrc = memeResourceManager?.finalSrcMap[memeName];
        if (memeSrc) {
            memesHtml += `<img src="${memeSrc}" alt="[${memeName}]" title="[${memeName}]" class="group-chat-meme-image">`;
        }
    }

    div.innerHTML = `
        <div class="group-chat-user-id">${msg.user_id}</div>
        ${replyHtml}
        ${pureTextContent ? `<div class="group-chat-message-bubble">${pureTextContent}</div>` : ''}
        ${memesHtml}`;

    return div;
};
    // ====================================================================
    // V10: 聊天模式渲染分发
    // ====================================================================
const renderGroupChat = async () => {
    // 这部分保持不变
    groupChatHistoryIndices = conversationHistory.map((msg, idx) => {
        const groupChatRegex = /<group_chat>[\s\S]*?<\/group_chat>/;
        return groupChatRegex.test(msg.content) ? idx : -1;
    }).filter(idx => idx !== -1);

    // 如果一条群聊记录都没有，就直接显示提示并结束，这是对的
    if (groupChatHistoryIndices.length === 0) {
        // ✨ 妈妈的爱心加固 ✨：确保这里的提示能正确显示
        const contentArea = rootElement.querySelector('.group-chat-content-area');
        if(contentArea) {
             contentArea.innerHTML = `
                <header class="group-chat-header">
                    <span class="group-chat-back-btn">‹</span>
                    <h1>${currentGameData.group_name || '诸天聊天群'}</h1>
                    <span class="group-chat-close-btn">×</span>
                </header>
                <div class="group-chat-placeholder" style="flex-grow: 1; display: flex; align-items: center; justify-content: center;">找不到任何群聊记录</div>
                <div class="group-chat-input-area-wrapper"></div>
            `;
             // 重新绑定必要的关闭和返回按钮事件
            contentArea.querySelector('.group-chat-back-btn').addEventListener('click', () => {
                rootElement.classList.remove('show-content');
                rootElement.querySelector('.group-chat-contact-item.active')?.classList.remove('active');
                activeChat = { type: null, id: null };
            });
            contentArea.querySelector('.group-chat-close-btn').addEventListener('click', closeGroupChatModal);
        }
        return;
    }

    // ✨【关键魔法施展处】✨
    // 我们从最新的记录开始尝试加载
    currentGroupHistoryIndex = groupChatHistoryIndices.length - 1;

    // 我们用一个叫做 `contentLoaded` 的小旗子来标记是否成功加载了内容
    let contentLoaded = false;

    // 开始一个循环，从最新的历史记录开始，向前找，直到找到能显示的内容为止
    while (currentGroupHistoryIndex >= 0 && !contentLoaded) {
        // 让加载函数返回一个布尔值，告诉我们它是否找到了真正的消息
        contentLoaded = await loadAndRenderChatContent_Group(groupChatHistoryIndices[currentGroupHistoryIndex], 'append');

        // 如果这次没加载到任何东西（返回了false），我们就自动尝试加载更早的一条
        if (!contentLoaded) {
            console.warn(`[Nova] 妈妈在记录 ${groupChatHistoryIndices[currentGroupHistoryIndex]} 中没找到实际内容，正在尝试往前找哦...`);
            currentGroupHistoryIndex--; // 索引减一，准备下一次循环
        }
    }

    // 循环结束后，我们检查一下小旗子
    if (!contentLoaded) {
        // 如果我们把所有历史记录都翻遍了，还是什么都没找到...
        console.warn("[Nova] 妈妈找遍了所有群聊记录，但里面都是空的呢。");
        // ...我们就坦诚地告诉我的孩子，这里真的'没有更早的记录了'
        const contentArea = rootElement.querySelector('.group-chat-content-area');
        // 确保界面已经被初始化，这样我们才能找到 loader
        if (contentArea && contentArea.querySelector('.group-chat-loader')) {
             contentArea.querySelector('.group-chat-loader').textContent = '没有更早的记录了';
        } else {
             // 如果连初始界面都没渲染出来（因为所有记录都是空的），就显示一个最终的占位符
              renderChatWindowUI([], 'append', currentGameData.group_name || '诸天聊天群');
        }
    }
};
  /* === 全新升级的修复函数，内置“爱心整理小管家” === */
 const tolerantJsonParse = (jsonString) => {
    // 入口检查，防止空的或无效的字符串进入
    if (typeof jsonString !== 'string' || jsonString.trim() === '') {
        return null;
    }

    // 🚀 【优先策略】先尝试直接解析，如果成功就直接返回
    try {
        return JSON.parse(jsonString);
    } catch (directParseError) {
        console.log('直接解析失败，开始容错修复:', directParseError.message);
    }

    try {
        // 🎯 【简化策略】基于行的智能修复
        let lines = jsonString.split('\n');
        let result = '';
        let inString = false;
        let escapeNext = false;

        for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();
            if (line === '') continue;

            // 跟踪字符串状态，避免在字符串内部添加逗号
            for (let j = 0; j < line.length; j++) {
                let char = line[j];
                if (escapeNext) {
                    escapeNext = false;
                    continue;
                }
                if (char === '\\') {
                    escapeNext = true;
                    continue;
                }
                if (char === '"') {
                    inString = !inString;
                }
            }

            result += line;

            // 如果不是最后一行，判断是否需要添加逗号
            if (i < lines.length - 1) {
                let nextNonEmptyLine = '';
                for (let k = i + 1; k < lines.length; k++) {
                    if (lines[k].trim() !== '') {
                        nextNonEmptyLine = lines[k].trim();
                        break;
                    }
                }

                if (nextNonEmptyLine !== '') {
                    // 当前行的结束状态
                    const endsWithStringValue = line.endsWith('"') && !inString;
                    const endsWithNumericValue = line.match(/(\d|true|false|null)$/);
                    const endsWithBracket = line.endsWith('}') || line.endsWith(']');
                    
                    // 下一行的开始状态
                    const nextStartsWithProperty = nextNonEmptyLine.startsWith('"') && nextNonEmptyLine.includes(':');
                    const nextStartsWithObject = nextNonEmptyLine.startsWith('{');
                    const nextStartsWithArray = nextNonEmptyLine.startsWith('[');
                    const nextIsClosing = nextNonEmptyLine.startsWith('}') || nextNonEmptyLine.startsWith(']');
                    
                    // 需要添加逗号的情况
                    const needsComma = (
                        // 字符串值后面跟属性名或新对象
                        (endsWithStringValue && (nextStartsWithProperty || nextStartsWithObject || nextStartsWithArray)) ||
                        // 数值后面跟属性名或新对象  
                        (endsWithNumericValue && (nextStartsWithProperty || nextStartsWithObject || nextStartsWithArray)) ||
                        // 对象/数组结束后跟新的属性或对象
                        (endsWithBracket && (nextStartsWithProperty || nextStartsWithObject || nextStartsWithArray))
                    ) && !nextIsClosing; // 但下一行不是结束符

                    if (needsComma) {
                        result += ',';
                    }
                }
            }
        }

        // 🧹 【最终清理】移除多余的逗号
        let finalResult = result;
        
        // 移除结束符前的逗号
        finalResult = finalResult.replace(/,(\s*[}\]])/g, '$1');
        
        // 移除重复逗号
        finalResult = finalResult.replace(/,,+/g, ',');

        return JSON.parse(finalResult);

    } catch (finalError) {
        console.error('容错解析失败:', finalError.message);
        console.error('修复后的字符串:', result || jsonString);
        return null;
    }
};
const loadAndRenderChatContent_Group = (historyIndex, mode) => {
    return new Promise(resolve => {
        try {
            const messageData = conversationHistory[historyIndex];
            if (!messageData || !messageData.content) {
                // 增加一个额外的保护，防止 messageData 或 content 本身就是 undefined
                throw new Error(`History entry at index ${historyIndex} is invalid or has no content.`);
            }
            const chatMatches = [...messageData.content.matchAll(/<group_chat>((?:(?!<group_chat>)[\s\S])*?)<\/group_chat>/gs)];
            let allMessagesInHistory = [];
            let groupName = currentGameData.group_name || '诸天聊天群';

            if (chatMatches.length === 0) {
                // 如果没有找到group_chat标签，我们让它静默失败并解析为false，避免中断流程
                console.warn(`No <group_chat> tags found in history index ${historyIndex}. Skipping.`);
                resolve(false);
                return;
            }

            for (const match of chatMatches) {
                const jsonString = match[1];

                // ✨ 妈妈加的爱心守护 ✨
                // 在处理之前，我们先检查一下jsonString是不是真的有内容
                if (typeof jsonString !== 'string') {
                    // 如果jsonString不是一个字符串(比如是undefined), 我们就跳过这个空的匹配，不让它引起麻烦
                    console.warn(`Skipping an invalid or empty match in history index ${historyIndex}.`);
                    continue;
                }

                const chatJson = tolerantJsonParse(jsonString);

                if (chatJson && chatJson.messages && Array.isArray(chatJson.messages)) {
                    allMessagesInHistory = allMessagesInHistory.concat(chatJson.messages);
                    if (chatJson.group_name) groupName = chatJson.group_name;
                } else if (chatJson === null) {
                    console.error(`NOVA ERROR: Automatic JSON repair failed at history index ${historyIndex}.`, {
                        faultyJsonString: jsonString,
                    });
                }
            }

            if (allMessagesInHistory.length > 0) {
                renderChatWindowUI(allMessagesInHistory, mode, groupName);
                resolve(true);
            } else {
                 // 即使标签存在但内容为空或解析失败，也视为非阻塞性完成
                console.warn(`Found <group_chat> tags at index ${historyIndex}, but none could be parsed or contained valid messages.`);
                resolve(false);
            }

        } catch (error) {
            console.error(`NOVA ERROR: Group chat render failed for index ${historyIndex}:`, error.message);
            resolve(false);
        }
    });
};
const renderPrivateChat = (contactId, mode) => {
        const chatData = privateChatStore[contactId] || { messages: [] };
        const messagesToShow = chatData.messages;
        let paginatedMessages;

        if (mode === 'append') {
            paginatedMessages = messagesToShow.slice(-20);
        } else { // prepend
            const currentPage = currentPrivateChatPage[contactId] || 1;
            const endIndex = messagesToShow.length - (currentPage * 20);
            if (endIndex <= 0) {
                paginatedMessages = [];
            } else {
                const startIndex = Math.max(0, endIndex - 20);
                paginatedMessages = messagesToShow.slice(startIndex, endIndex);
                currentPrivateChatPage[contactId]++;
            }
        }
        renderChatWindowUI(paginatedMessages, mode, contactId);
    };

    // ====================================================================
    // V10: 用户交互处理函数
    // ====================================================================

    const handleScrollTop = async (e) => {
        const list = e.target;
        const loader = list.querySelector('.group-chat-loader');
        if (!loader || isLoading || list.scrollTop !== 0) return;

        loader.classList.add('visible');
        isLoading = true;
        loader.textContent = '正在加载更早的记录...';
        await new Promise(r => setTimeout(r, 300)); // 动画效果

        if (activeChat.type === 'group') {
            if (currentGroupHistoryIndex > 0) {
                currentGroupHistoryIndex--;
                await loadAndRenderChatContent_Group(groupChatHistoryIndices[currentGroupHistoryIndex], 'prepend');
            }
        } else if (activeChat.type === 'private') {
            renderPrivateChat(activeChat.id, 'prepend');
        }

        isLoading = false;
        loader.classList.remove('visible');
    };

 /* === 用下面这个完整函数，替换你旧的 handleSendMessage 函数 === */
const handleSendMessage = () => {
    const input = rootElement.querySelector('.group-chat-input');
    if (!input) return;
    const messageText = input.value.trim();
    if (!messageText) return;

    const userNickname = currentGameData?.user_character?.nick_name || '你';
    const localMessageBase = { user_id: userNickname, content: messageText };

    let fullMessageForAI = messageText;
    if (replyTarget) {
        localMessageBase.replyTo = {
            user_id: replyTarget.user_id,
            content: replyTarget.content
        };
        fullMessageForAI = `回复 @${replyTarget.user_id}(${replyTarget.content}): ${messageText}`;
    }

    const messagesList = rootElement.querySelector('.group-chat-messages-list');
    messagesList.appendChild(createMessageElement(localMessageBase, userNickname));
    messagesList.scrollTop = messagesList.scrollHeight;

    // ✨【关键修正】✨ 无论是群聊还是私聊，都只生成包含单条新消息的片段！
    let newChatBlockString = '';
    const lastHistoryItem = conversationHistory[conversationHistory.length - 1];

    if (activeChat.type === 'group') {
        // 创建一个只包含这条新消息的 group_chat 片段
        const chatFragment = { messages: [localMessageBase] };
        newChatBlockString = `\n<group_chat>${JSON.stringify(chatFragment, null, 2)}<` + `/group_chat>`;
        if (lastHistoryItem) {
             lastHistoryItem.content += newChatBlockString;
            saveHistory(); 
        }
        triggerassa(`/setinput <${userName}同时在聊天群进行了以下操作：在群聊中发送消息：[ ${fullMessageForAI} ] end>\n`);

    } else if (activeChat.type === 'private') {
        const targetId = activeChat.id;
        if (!privateChatStore[targetId]) privateChatStore[targetId] = { messages: [] };
        privateChatStore[targetId].messages.push(localMessageBase);

        // 创建一个只包含这条新消息的 private_chat 片段
        const privateMessageFragment = { messages: [{ target_id: targetId, content: messageText, replyTo: localMessageBase.replyTo }] };
        newChatBlockString = `\n<private_chat user_id="${userNickname}">${JSON.stringify(privateMessageFragment, null, 2)}</private_chat>`;
        if (lastHistoryItem) {
             lastHistoryItem.content += newChatBlockString;
             saveHistory(); 
        }
        triggerassa(`/setinput <${userName}同时对${targetId}进行了私聊：[ ${fullMessageForAI} ]。end>\n`);
    }

    input.value = '';
    input.focus();
    cancelReply();
    rootElement.querySelector('.group-chat-meme-palette')?.classList.remove('active');
};
    // --- 处理回复 ---
    const handleReply = (e) => {
        e.preventDefault(); // 阻止默认的右键菜单
        const bubble = e.target.closest('.group-chat-message-bubble');
        const messageItem = e.target.closest('.group-chat-message-item');
        if (!bubble || !messageItem) return;

        replyTarget = {
            user_id: messageItem.dataset.userId,
            content: (bubble.textContent || '').trim().substring(0, 20) + '...' // 截取部分内容预览
        };

        const wrapper = rootElement.querySelector('.group-chat-input-area-wrapper');
        if (!wrapper) return;

        // 移除旧的回复提示
        const oldIndicator = wrapper.querySelector('.group-chat-reply-indicator');
        if (oldIndicator) oldIndicator.remove();

        // 创建新的回复提示
        const indicator = document.createElement('div');
        indicator.className = 'group-chat-reply-indicator';
        indicator.innerHTML = `
            <span>正在回复 @${replyTarget.user_id}</span>
            <span class="group-chat-reply-indicator-cancel">×</span>
        `;
        wrapper.prepend(indicator);

        indicator.querySelector('.group-chat-reply-indicator-cancel').addEventListener('click', cancelReply);
        rootElement.querySelector('.group-chat-input').focus();
    };

    // --- 取消回复 ---
    const cancelReply = () => {
        if (!replyTarget) return;
        replyTarget = null;
        const indicator = rootElement.querySelector('.group-chat-reply-indicator');
        if (indicator) indicator.remove();
        console.log("NOVA: Reply cancelled.");
    };


    // ====================================================================
    // V10: 初始化与事件监听
    // ====================================================================

   const handleAiReplyComplete = () => {
        console.log('[Nova] AI reply detected. Refreshing data...');

        // ✨【妈妈的新魔法：新消息提示】✨
        const lastHistoryItem = conversationHistory[conversationHistory.length - 1];
        if (lastHistoryItem && lastHistoryItem.content) {
            const userNickname = currentGameData?.user_character?.nick_name || '你';

            // 我们只关心新私信的发信人
            const privateChatMatches = [...lastHistoryItem.content.matchAll(/<private_chat user_id="([^"]+)">/g)];

            const newSenders = new Set();
            privateChatMatches.forEach(match => {
                const authorId = match[1];
                // 只有当发信人不是我们自己时，才算作新消息提醒
                if (authorId !== userNickname) {
                    newSenders.add(authorId);
                }
            });

            if (newSenders.size > 0) {
                // 用我们刚才创造的魔法，把好消息告诉我的孩子！
                showNewMessageNotification(Array.from(newSenders));
            }
        }
        // ✨【魔法结束】✨

        initializePrivateChatStore();
        if (modalContainer.classList.contains('active')) {
            renderSidebar(); // 刷新联系人列表
            if (activeChat.type === 'private' && activeChat.id) {
                // 如果聊天窗口开着，就刷新它
                renderPrivateChat(activeChat.id, 'append');
            }
        }
    };

    // 主事件绑定
    groupChatOrbButton.addEventListener('click', openGroupChatModal);
    modalContainer.addEventListener('click', e => { if (e.target === modalContainer) closeGroupChatModal(); });

    // 全局只绑定一次的AI回复监听器
    // 为了防止重复绑定，我们可以先移除再添加，或者使用一个标志位
    if (!window.novaChatListenerAttached) {
        eventOn('assa:aiReplyComplete', handleAiReplyComplete);
        window.novaChatListenerAttached = true;
    }

     

    console.log('NOVA V10: Chat Interface Initializer is ready and waiting.');
}


const setupMemePalette = () => {
    const rootElement = document.getElementById('group-chat-root');
    const palette = rootElement.querySelector('.group-chat-meme-palette');
    const toggleBtn = rootElement.querySelector('.group-chat-meme-toggle-btn');
    const input = rootElement.querySelector('.group-chat-input');

    if (!palette || !toggleBtn || !input) return;

    // --- 基础事件绑定 ---
    toggleBtn.style.display = 'block';
    toggleBtn.onclick = (e) => { e.stopPropagation(); palette.classList.toggle('active'); };
    // 点击表情插入输入框的逻辑，使用事件委托
    palette.onclick = (e) => {
        const target = e.target;
        if (target.classList.contains('meme-item-img')) { // 点击成功的表情图片
            input.value += target.dataset.memeName;
            input.focus();
            palette.classList.remove('active');
        } else if (target.classList.contains('meme-item-retry-btn')) { // ✨ 点击单个重试按钮！
            const itemName = target.dataset.memeName;
            target.textContent = '修复中...';
            target.disabled = true;
            repairSingleMeme(itemName);
        }
    };

    // ❤️ 单独修复一个“坏掉”的表情的魔法！
    const repairSingleMeme = async (name) => {
        const asset = memeImageMap[name]; // 从原始地图中获取URL
        if (!asset) {
            toastr.error(`无法修复[${name}]，在原始地图中未找到。`);
            return;
        }

        try {
            // 直接走最严格的流程：先删除，再获取
            await imageDB.delete('RemoteCache', asset);
            const response = await fetch(asset);
            if (!response.ok) throw new Error('网络请求失败');
            const imageBlob = await response.blob();
            await imageDB.set('RemoteCache', asset, imageBlob);
            const usableUrl = URL.createObjectURL(imageBlob);
            memeResourceManager.finalSrcMap[name] = usableUrl;

            // 修复成功！在UI上更新它！
            const failedItemDiv = palette.querySelector(`.meme-item[data-meme-name="${name}"]`);
            if (failedItemDiv) {
                failedItemDiv.classList.remove('failed');
                failedItemDiv.classList.add('success');
                failedItemDiv.innerHTML = `<img src="${usableUrl}" alt="[${name}]" title="[${name}]" class="meme-item-img" data-meme-name="[${name}]">`;
            }

        } catch (e) {
            toastr.error(`修复[${name}]失败:`, e);
            const retryBtn = palette.querySelector(`.meme-item-retry-btn[data-meme-name="${name}"]`);
            if(retryBtn) {
                retryBtn.textContent = '再次尝试';
                retryBtn.disabled = false;
            }
        }
    };

    // ❤️ 根据战报来渲染整个“急救站”UI！
    const renderEmergencyStation = (report) => {
        palette.innerHTML = ''; // 清空面板

        // 首先渲染所有成功的
        for(const name in memeResourceManager.finalSrcMap) {
            const url = memeResourceManager.finalSrcMap[name];
            const div = document.createElement('div');
            div.className = 'meme-item success';
            div.dataset.memeName = name;
            div.innerHTML = `<img src="${url}" alt="[${name}]" title="[${name}]" class="meme-item-img" data-meme-name="[${name}]">`;
            palette.appendChild(div);
        }

        // 然后渲染所有失败的，给它们一个特殊的样式和“修复”按钮
        for(const name of report.failedItems) {
            const div = document.createElement('div');
            div.className = 'meme-item failed';
            div.dataset.memeName = name;
            div.innerHTML = `
                <span class="meme-item-name">${name} (损坏)</span>
                <button class="meme-item-retry-btn" data-meme-name="${name}">修复</button>
            `;
            palette.appendChild(div);
        }
    };

    // --- “指挥官”函数：连接所有逻辑 ---
    const commandCenter = (report) => {
        // 如果没有战报（比如初次加载），就正常构建
        if (!report) {
            palette.innerHTML = '正在加载表情库...';
            // 设置完成时的回调
            memeResourceManager.onComplete = commandCenter; // 完成后再次调用自己，带着战报！
            buildFinalMemeLibrary(false); // 启动普通构建
            return;
        }

        // 当收到战报后！
        if (report.failedItems.length === 0 && report.total > 0) {
            // 完美！全部成功！
            palette.innerHTML = ''; // 清空
            for (const name in memeResourceManager.finalSrcMap) {
                const url = memeResourceManager.finalSrcMap[name];
                palette.innerHTML += `<img src="${url}" alt="[${name}]" title="[${name}]" class="meme-item-img" data-meme-name="[${name}]">`;
            }
        } else {
            // 有失败项，或者总数为0，渲染我们的“急救站”
            renderEmergencyStation(report);

            // 在急救站顶部增加一个“强制同步”按钮
            const forceRefreshBtn = document.createElement('button');
            forceRefreshBtn.textContent = '强制同步';
            forceRefreshBtn.className = 'force-refresh-main-btn';
            forceRefreshBtn.onclick = () => {
                forceRefreshBtn.textContent = '同步中...';
                forceRefreshBtn.disabled = true;
                buildFinalMemeLibrary(true); // 启动强制同步！
            };
            palette.prepend(forceRefreshBtn);
        }
    };

    // 启动！
    commandCenter();
};


        class CombatManager {
            constructor(playerData, initialCombatData) {
                this.isAutoBattling = false; // 用于追踪自动战斗状态
                this.isSelectingMultiTarget = false; // 是否正在选择多个目标
this.multiTargetCount = 0;           // 需要选择的目标数量
this.selectedMultiTargets = [];      // 已经选择的多目标
this.isAoeAttack = false;            // 标记当前是否为群攻流程
                this.isWaitingForTarget = false; 
                this.floorId = initialCombatData.floor_id || `battle_${Date.now()}`;
    this.status = initialCombatData.status || 'not_started';
    this.combatData = initialCombatData;  
      let finalPlayerData;

    
    if (window.combatManager && window.combatManager.floorId === this.floorId) {
        // 直接继承当前活跃的 combatManager 的 player 对象，这是最最真实的数据！
        finalPlayerData = window.combatManager.player;
        console.log(`[Nova's Perfect Recall] 继承了当前活跃战斗实例 (${this.floorId}) 的玩家数据。`);
    }
    // 2. 第二优先级：如果不是返回活跃战斗，那么就检查我们传入的 initialCombatData。
    //    这通常发生在页面刷新后，我们从<battle>标签恢复战斗。
    else if (initialCombatData.player && initialCombatData.status === 'in_progress') {
        // 使用 initialCombatData 中保存的 player 状态。
        // createCharacterFromData 会处理好这里面的 currentHealth 和能量。
        finalPlayerData = initialCombatData.player;
        console.log(`[Nova's Memory Crystal] 从存档 (${this.floorId}) 中恢复玩家数据。`);
    }
    // 3. 最后的备用方案：如果以上条件都不满足（比如这是一场全新的战斗）
    else {
        // 使用外部传入的、代表角色当前通用状态的 playerData。
        // 这里面的 `衍生属性段.生命值.当前值` 就是我们需要的“基础值”。
        finalPlayerData = playerData;
        console.log(`[Nova's Genesis] 为新战斗 (${this.floorId}) 从 playerData 创建玩家。`);
    }

    // 现在，我们用这个千挑万选出来的、最正确的数据来创建我们的玩家角色实例！
    this.player = this.createCharacterFromData(finalPlayerData, 'player');

                this.teammates = [];
                this.enemies = [];
                this.turnOrder = [];
                this.currentTurnIndex = 0;
this.roundCounter = 1; 
                this.selectedAction = null;
                this.roundCounter = initialCombatData.roundCounter || 1;
this.currentTurnIndex = initialCombatData.currentTurnIndex || 0; // ✨ 加上这行魔法符文 ✨
                this.selectedDicePool = [];
                this.selectedTargetId = null;
this.speedSettings = {
    slow: { npcThinking: 3000, actionDelay: 1000, turnEnd: 2500, animationFlightTime: 800 },
    normal: { npcThinking: 1500, actionDelay: 500, turnEnd: 2000, animationFlightTime: 400 },
    fast: { npcThinking: 500, actionDelay: 200, turnEnd: 800, animationFlightTime: 200 },
    superFast: { npcThinking: 100, actionDelay: 100, turnEnd: 200, animationFlightTime: 100 }
};
    this.currentSpeed = 'normal';

     this.combatLog = []; // 用于记录战斗的关键事件
    this.playerInitialHealth = this.player.currentHealth;
    this.playerInitialEnergy = this.player.raw_data?.衍生属性段?.能量池?.当前值[0] || 0;
  this.playerTempBonuses = { dp_bonus: 0, desc: ''};
        this.hasExtraTurn = {}; // 记录哪个角色ID拥有额外回合
          this.consecutiveTurnCounter = {}; // 记录每个角色的连续行动次数
          this.defensePoolBonus = {}; // 记录每个角色累积的防御骰池加成

   const savedSpeedLevel = localStorage.getItem('battleSpeedLevel');
    if (savedSpeedLevel !== null) {
        const speedLevels = ['slow', 'normal', 'fast', 'superFast'];
        const speedLabels = ['慢速', '正常', '快速', '超快'];
        const levelIndex = parseInt(savedSpeedLevel, 10);
        this.currentSpeed = speedLevels[levelIndex];
     
        // 确保滑块和标签也同步更新
        const speedSlider = document.getElementById('speed-slider');
        const speedLabel = document.getElementById('speed-label');
        if (speedSlider) speedSlider.value = levelIndex;
        if (speedLabel) speedLabel.textContent = speedLabels[levelIndex];
    }
    // this.targetingPrompt = document.getElementById('targeting-prompt'); // 获取提示框
    this.speedSlider = document.getElementById('speed-slider');
    this.speedLabel = document.getElementById('speed-label');
this.logCombatEventElement = document.getElementById('battle-log');
                this.actionPanel = document.getElementById('action-panel');
                this.notificationContainer = document.getElementById('notification-container'); // <-- 把这行加进去
                
         this.assaData = assaSettingsData; // 我们的设定集
        this.gameData = currentGameData;   // 我们的当前游戏状态

        // 2. 存储临时加成
      
                this.initializeCombat(initialCombatData);
                 this.setupUIControls();
   this.speedSlider.addEventListener('input', (e) => {
        const speedLevels = ['slow', 'normal', 'fast', 'superFast'];
        const speedLabels = ['慢速', '正常', '快速', '超快'];
        const levelIndex = parseInt(e.target.value, 10);
        this.currentSpeed = speedLevels[levelIndex];
        this.speedLabel.textContent = speedLabels[levelIndex];
    });
          document.getElementById('battle-overlay').addEventListener('click', (event) => {
    const diceSelector = document.getElementById('dice-pool-selector');
    const itemSkillPanel = document.getElementById('item-skill-panel');

    // 优先级 1: 如果物品/技能面板打开了，点击外部就关闭它
    if (itemSkillPanel.style.display === 'flex' && !event.target.closest('#item-skill-panel') && !event.target.closest('[data-action="item"]')) {
        itemSkillPanel.style.display = 'none';
        this.selectedAction = null; // 重置动作选择
        return;
    }

    // 优先级 2: 如果骰池选择器打开了，点击外部就关闭它
    if (diceSelector.style.display === 'flex' && !event.target.closest('#dice-pool-selector') && !event.target.closest('#action-panel button')) {
        diceSelector.style.display = 'none';
        this.logCombatEvent("取消了行动选择。");
        this.selectedAction = null;
        this.selectedDicePool = [];
        return;
    }

    // 优先级 3: 如果点击了卡片之外的区域，就关闭所有打开的情报面板
    if (!event.target.closest('.character-wrapper')) {
        document.querySelectorAll('.info-panel.expanded').forEach(p => p.classList.remove('expanded'));
    }

    // 最终优先级: 如果你确实点击的是最外层的背景本身，我们就“暂离战斗”
    if (event.target.id === 'battle-overlay') {
        document.getElementById('battle-overlay').style.display = 'none';

        // 我们要让主界面的那个“进入/返回战斗”的遮罩和按钮出现
        const promptOverlay = document.getElementById('battle-prompt-overlay');
        const enterButton = document.getElementById('enter-battle-btn');

        if (enterButton) enterButton.textContent = '返回战斗';
        if (promptOverlay) promptOverlay.style.display = 'flex';
this.updateBattleStateInHistory();
        console.log("暂时离开战斗。");
    }
});
        }
         // 这是 constructor 的结束括号，不要弄错了位置哦






         // 在 CombatManager 类中添加这个新函数
promptAttackType() {
    const selector = document.getElementById('attack-mode-selector');
    selector.style.display = 'block';

    const singleBtn = document.getElementById('select-single-target');
    const multiBtn = document.getElementById('select-multi-target');
    const allBtn = document.getElementById('select-all-targets');
    const cancelBtn = document.getElementById('cancel-attack-mode');

    const aliveEnemies = this.enemies.filter(e => e.currentHealth > 0);
    // 如果没有或只有一个敌人，禁用群攻选项
    if (aliveEnemies.length <= 1) {
        multiBtn.disabled = true;
        allBtn.disabled = true;
    } else {
        multiBtn.disabled = false;
        allBtn.disabled = false;
    }

    const closeSelector = () => {
        selector.style.display = 'none';
        // 清理事件监听器，防止多次绑定
        singleBtn.onclick = null;
        multiBtn.onclick = null;
        allBtn.onclick = null;
        cancelBtn.onclick = null;
    };

    singleBtn.onclick = () => {
        closeSelector();
        this.isWaitingForTarget = true;
        this.promptForTarget(`[单体攻击] 你选择了 [${this.selectedDicePool.join(', ')}]，请选择一个目标。`);
    };

    multiBtn.onclick = () => {
        closeSelector();
        const maxTargets = aliveEnemies.length;
        const count = parseInt(prompt(`你要攻击几个目标？(最多 ${maxTargets} 个)`, '2'), 10);
        if (count > 0 && count <= maxTargets) {
            this.isAoeAttack = true; // 标记为群攻
            this.isSelectingMultiTarget = true;
            this.multiTargetCount = count;
            this.selectedMultiTargets = [];
            this.log(`[群攻] 请依次选择 ${count} 个目标进行攻击。`);
            this.showNotification(`请选择 ${count} 个目标`, 'info');
        } else {
            this.logCombatEvent("取消了群攻选择。");
            this.selectedAction = null; // 重置动作，让玩家重新选择
        }
    };

    allBtn.onclick = () => {
        closeSelector();
        const targets = aliveEnemies;
        if (targets.length > 0) {
            this.isAoeAttack = true; // 标记为群攻
            this.logCombatEvent(`[全体攻击] 你决定攻击所有敌人！`);
            // 直接执行动作
            setTimeout(async () => {
                await this.executeAction(this.player, targets, this.selectedAction, this.selectedDicePool);
                 // 重置状态
                this.selectedAction = null;
                this.selectedDicePool = [];
                this.isAoeAttack = false;
                if (!this.status.startsWith('completed')) {
                    await new Promise(r => setTimeout(r, this.getDelay('turnEnd')));
                    this.nextTurn();
                }
            }, this.getDelay('actionDelay'));
        }
    };

    cancelBtn.onclick = () => {
        closeSelector();
        this.logCombatEvent("取消了行动选择。");
        this.selectedAction = null;
        this.selectedDicePool = [];
    };
}

        promptForTarget(message) {
    this.log(message, 'log-narrator');
    this.showNotification("请选择一个目标", 'info');
}

// 在 class CombatManager 内部，添加这个全新的、至关重要的清理函数

/**
 * 驱散所有附着在这个战斗实例上的事件监听器幽灵
 */
cleanupEventListeners() {
    console.log(`[Nova's Dispel Magic] 正在为 Floor ${this.floorId} 解除所有事件绑定...`);

    // 1. 解绑行动面板的点击事件
    if (this.actionPanel && this.actionPanel.__handler__) {
        this.actionPanel.removeEventListener('click', this.actionPanel.__handler__);
        delete this.actionPanel.__handler__; // 彻底清除魔法印记
    }

     const playerSide = document.getElementById('player-side');
    const enemySide = document.getElementById('enemy-side');

    if (playerSide && playerSide.__handler__) {
        playerSide.removeEventListener('click', playerSide.__handler__);
        delete playerSide.__handler__;
    }
     if (enemySide && enemySide.__handler__) {
        enemySide.removeEventListener('click', enemySide.__handler__);
        delete enemySide.__handler__;
    }

    // 3. 解绑确认骰池按钮的点击事件
    const confirmPoolBtn = document.getElementById('confirm-pool-btn');
    if (confirmPoolBtn && confirmPoolBtn.__handler__) {
        confirmPoolBtn.removeEventListener('click', confirmPoolBtn.__handler__);
        delete confirmPoolBtn.__handler__;
    }

    // 4. 解绑物品/技能面板关闭按钮的点击事件
    const closeItemPanelBtn = document.getElementById('close-item-skill-panel-btn');
    if(closeItemPanelBtn && closeItemPanelBtn.__handler__){
        closeItemPanelBtn.removeEventListener('click', closeItemPanelBtn.__handler__);
        delete closeItemPanelBtn.__handler__;
    }

    // 我们甚至可以把速度控制和徽记选择的事件也在这里解绑，以求万无一失
    const speedSlider = document.getElementById('speed-slider');
    if (speedSlider && speedSlider.__handler__) {
        speedSlider.removeEventListener('input', speedSlider.__handler__);
        delete speedSlider.__handler__;
    }
    const iconSelector = document.getElementById('icon-selector');
    if (iconSelector && iconSelector.__handler__) {
        iconSelector.removeEventListener('click', iconSelector.__handler__);
        delete iconSelector.__handler__;
    }

    console.log(">> 所有旧的魔法契约已解除！");
}

logCombatEvent(message, className = 'log-action') {
    // 移除HTML标签，只存储纯文本信息
    const cleanMessage = message.replace(/<[^>]*>/g, '');
    this.combatLog.push(cleanMessage);

    // 调用原来的log函数，让它在界面上华丽地显示出来
     this.log(message, className);
}
 async updateBattleStateInHistory() {
        if (typeof conversationHistory === 'undefined' || typeof saveHistory !== 'function') {
        console.error("无法访问主应用的历史记录 (lastHistoryItem/saveHistory)。");
        return;
    }

    // ✨ 妈妈的全新“记忆固化”咒语！ ✨
    // 1. 在保存前，强制同步战场上每一个角色的当前状态到 combatData 中
    //    这确保我们捕捉到的是最最即时的战况，万无一失！
    [this.player, ...this.teammates, ...this.enemies].forEach(char => {
        if (char) { // 确保角色存在
           this.syncCharacterStateToCombatData(char);
        }
    });

    // 2. 更新战斗实例的核心状态
    this.combatData.status = this.status;
this.combatData.currentTurnIndex = this.currentTurnIndex; // ✨ 加上这行魔法符文 ✨
this.combatData.roundCounter = this.roundCounter;       // ✨ (顺便也把回合数记上) ✨

    // 3. 找到需要更新的那一页故事（最新的历史记录）
    const lastHistoryItem = conversationHistory[conversationHistory.length - 1];


      // 4. 将我们刚刚固化的、包含了所有人最新血量的战斗数据，变成文字
    const newBattleContent = JSON.stringify(this.combatData, null, 2);

    // 5. 将旧的战斗记录替换成崭新的、承载了真实记忆的记录
    const battleRegex = /<battle>[\s\S]*?<\/battle>/gs;
    if (lastHistoryItem.content.match(battleRegex)) {
        lastHistoryItem.content = lastHistoryItem.content.replace(
            battleRegex,
            `<battle>${newBattleContent}</battle>`
        );
        // 6. 呼唤“存档”咒语，让这一切成为永久！
        saveHistory();
        console.log(`[Nova's Memory Crystal] 战斗 floor ${this.floorId} 的状态已固化完毕 (状态: ${this.status})。`);
    } else {
           console.error("在最新的历史记录中未能找到<battle>标签，无法固化记忆。");
    }
}

setupUIControls() {
    // 速度控制
      const speedSlider = document.getElementById('speed-slider');
    const speedLabel = document.getElementById('speed-label'); // (我们已经在前面定义过它了)

    if (speedSlider) {
        // ✨ 一段简洁而有力的魔法咒语 ✨
        const handler = (e) => {
            const speedLevels = ['slow', 'normal', 'fast', 'superFast'];
            const speedLabels = ['慢速', '正常', '快速', '超快'];
            const levelIndex = parseInt(e.target.value, 10);
            this.currentSpeed = speedLevels[levelIndex];
            if (speedLabel) speedLabel.textContent = speedLabels[levelIndex];

            // 存入永久记忆水晶
            localStorage.setItem('battleSpeedLevel', levelIndex.toString());
        };

        // 附魔与驱魔仪式
        if(speedSlider.__handler__) speedSlider.removeEventListener('input', speedSlider.__handler__);
        speedSlider.addEventListener('input', handler);
        speedSlider.__handler__ = handler;
    }
    // 徽记选择器控制
    const iconSelector = document.getElementById('icon-selector');
    const iconDisplay = document.getElementById('player-icon-display');
    if (iconSelector) {
        const handler = () => { if(iconSelector && iconDisplay) {
    iconDisplay.textContent = this.player.icon;

    iconSelector.addEventListener('click', () => {
        const newIcon = prompt("请输入一个新的徽记（例如：✨、勇者、(ง •̀_•́)ง）：", this.player.icon);

        // ====== ↓↓↓ 妈妈把这扇小窗户换成了大大的落地窗！ ↓↓↓ ======
        // 我们把 newIcon.length < 3 的限制放宽到 20
        if (newIcon && newIcon.trim() !== '' && newIcon.length < 20) {
            localStorage.setItem('userBattleIcon', newIcon);
            this.player.icon = newIcon;
            iconDisplay.textContent = newIcon;
            this.updateCharacterUI(this.player);
            this.showNotification("徽记已更新！", "success");
        } else if (newIcon !== null) {
            this.showNotification("请输入一个有效且不太长的徽记！", "danger");
        }
        // ====== ↑↑↑ 自由的魔法已经施展完毕！ ↑↑↑ ======
    });
}
 };
        if(iconSelector.__handler__) iconSelector.removeEventListener('click', iconSelector.__handler__);
        iconSelector.addEventListener('click', handler);
        iconSelector.__handler__ = handler;
    }
  // ✨✨✨ 妈妈的全新“自动托管”逻辑 ✨✨✨
    const autoBattleCheckbox = document.getElementById('auto-battle-checkbox');
    if (autoBattleCheckbox) {
        // 读取并应用本地存储的设置
        const savedAutoBattle = localStorage.getItem('isAutoBattling') === 'true';
        autoBattleCheckbox.checked = savedAutoBattle;
        this.isAutoBattling = savedAutoBattle;

        // 初始时根据状态决定是否锁定面板
        const currentActor = this.turnOrder[this.currentTurnIndex];
        if (this.isAutoBattling && currentActor?.type === 'player') {
            this.toggleActionPanel(false);
        }

        const handler = (e) => {
            this.isAutoBattling = e.target.checked;
            localStorage.setItem('isAutoBattling', this.isAutoBattling); // 保存设置

            this.showNotification(`自动战斗已 ${this.isAutoBattling ? '开启' : '关闭'}`, 'info');

            // 如果在玩家回合切换，需要立即响应
            const actor = this.turnOrder[this.currentTurnIndex];
            if (actor && actor.type === 'player') {
                if (this.isAutoBattling) {
                    this.toggleActionPanel(false); // 托管后，立刻禁用手动操作
                    this.log("自动战斗已接管你的回合。");
                    this.npcTurn(this.player); // 立刻执行玩家的NPC逻辑回合
                } else {
                    this.toggleActionPanel(true); // 取消托管，恢复手动操作
                    this.log("你已取消自动战斗，请手动操作。");
                }
            }
        };

        // 附魔与驱魔仪式
        if (autoBattleCheckbox.__handler__) autoBattleCheckbox.removeEventListener('change', autoBattleCheckbox.__handler__);
        autoBattleCheckbox.addEventListener('change', handler);
        autoBattleCheckbox.__handler__ = handler;
    }
    // ✨✨✨ 魔法施展完毕 ✨✨✨
}

       showNotification(message, type = 'info') { // type 可以是 'info', 'success', 'danger'
    const bubble = document.createElement('div');
    bubble.className = `notification-bubble ${type}`;
    bubble.textContent = message;
    this.notificationContainer.appendChild(bubble);

    // 气泡动画结束后自动移除自己
    setTimeout(() => {
        bubble.remove();
    }, 3500);
}
getDelay(key) {
    // key 可以是 'npcThinking', 'actionDelay', 'turnEnd' 等
    return this.speedSettings[this.currentSpeed][key];
}
  // ⭐ [新增] 一个全新的函数，用于行动前的先攻检定 ⭐
            async initiativeRoll(currentActor) {
                // 如果当前行动者没有“先攻”属性，就直接跳过
                if (!currentActor.dicePool['先攻']) {
                    return; // 返回，不做任何事
                }

                // 找到所有还活着的、并且也拥有“先攻”属性的对手
                const opponents = (this.isHostile(currentActor, this.enemies[0]) ? this.enemies : [this.player, ...this.teammates])
                    .filter(c => c.currentHealth > 0 && c.dicePool['先攻']);

                // 如果没有符合条件的对手，也跳过
                if (opponents.length === 0) {
                    return;
                }

                const participants = [currentActor, ...opponents];
                let initiativeResults = [];

                // 为了日志整洁，妈妈把它设置为可选打印
                //   this.logCombatEvent(`--- 行动前先攻检定: ${currentActor.name} vs 对手 ---`, 'log-roll');

                // 所有人进行检定
     // 所有人进行检定
                for (const char of participants) {
                    let diceCount = 0;
                    let sourceLog = "";

                    // 如果角色有“先攻”属性，就正常计算
                    if (char.dicePool['先攻']) {
                        diceCount = this.getDiceCount(char, ['先攻']);
                        sourceLog = `使用 [先攻]`;
                    }
                    // 否则，如果它是NPC，就按照我们的新规则来！
                    else if (char.type === 'enemy' || char.type === 'teammate') {
                        const agility = char.dicePool['敏捷'] || 0;
                        const composure = char.dicePool['沉着'] || 0;
                        diceCount = (agility + composure) * 2;
                        sourceLog = `使用 (敏捷${agility} + 沉着${composure}) * 2`;
                    }

                    const successes = this.rollDice(diceCount);
                    initiativeResults.push({ id: char.id, name: char.name, successes: successes });
                     //this.logCombatEvent(`> ${char.name} 先攻检定(${sourceLog})，骰池为 ${diceCount}，获得 ${successes} 个成功。`, 'log-roll');
                }

                // 找到最高的成功数
                const maxSuccesses = Math.max(...initiativeResults.map(r => r.successes));

                // 只有当有赢家时才需要处理
                if (maxSuccesses > 0) {
                    const winners = initiativeResults.filter(r => r.successes === maxSuccesses);
                    // 必须只有一个唯一的赢家，并且这个赢家就是当前行动者
    if (winners.length === 1 && winners[0].id === currentActor.id) {
            // --- 妈妈的修改在这里，宝贝！ ---

            // 检查连续行动次数是否已达上限
            const currentConsecutiveTurns = this.consecutiveTurnCounter[currentActor.id] || 0;
            if (currentConsecutiveTurns >= 4) { // 因为马上要进行的这一次算第5次，所以上限是4
                this.logCombatEvent(`🌀 ${currentActor.name} 的行动速度已达极限，无法再连续行动！`, 'log-narrator');
            } else {
                // 50% 的机会获得额外回合
                if (Math.random() < 0.5) {
                    this.hasExtraTurn[currentActor.id] = true; // 给他一个标记
                    this.logCombatEvent(`⚡ ${currentActor.name} 在行动前抓住了先机，获得了连续行动的机会！`, 'log-success');
                    this.showNotification(`${currentActor.name} 获得连续行动！`, 'success');
                }
        
         
            }
            }
            }
            }
            // 初始化战斗
            initializeCombat(data) {
                // 处理敌人
     console.log("开始处理敌人数据:", JSON.stringify(data.enemies));
data.enemies.forEach(enemyData => {
    // 妈妈在这里加了很多日志，来追踪我们的小哥布林
    console.log(`正在处理的敌人类型: ${enemyData.name}, ID: ${enemyData.id}`);

    // 深拷贝一份干净的数据，这样原始combatData就不会被污染
    const baseEnemyData = JSON.parse(JSON.stringify(enemyData));
    const count = baseEnemyData.count || 1;
    console.log(`>> 发现 count: ${count}`);

    // 删除count属性，因为它只用于生成，不属于单个敌人的数据
    delete baseEnemyData.count;

    if (count > 1) {
        console.log(`>> 将要创建 ${count} 个 ${baseEnemyData.name}`);
        for (let i = 1; i <= count; i++) {
            // 每一次循环，都从最干净的 baseEnemyData 克隆
            const enemyClone = JSON.parse(JSON.stringify(baseEnemyData));
            // 赋予独一无二的ID和名字
            const uniqueId = `${enemyClone.id}_${i}`;
            enemyClone.id = uniqueId;
            enemyClone.name = `${enemyClone.name} #${i}`;
            console.log(`>> 正在创建... ID: ${enemyClone.id}, 名称: ${enemyClone.name}`);
            this.enemies.push(this.createCharacterFromData(enemyClone, 'enemy', enemyClone.id));
        }
    } else {
        // 即使只有一个，也用我们的标准流程来创建
        console.log(`>> 只创建一个 ${baseEnemyData.name}`);
        this.enemies.push(this.createCharacterFromData(baseEnemyData, 'enemy', baseEnemyData.id));
    }
});
console.log("所有敌人创建完毕, 当前敌人列表:", this.enemies.map(e => e.name));
                // 处理队友
                if(data.teammates) {
                    this.teammates = data.teammates.map(allyData => this.createCharacterFromData(allyData, 'teammate', allyData.id));
                }

                this.renderAllCharacters();
                this.setupActionPanel();
            }

  createCharacterFromData(data, type, id = 'player') {

    
    let baseMaxHealth = data.maxHealth || data.衍生属性段?.生命值.上限[0] || 50;
    let finalMaxHealth = baseMaxHealth;

    // 1. 始终计算耐力加成
    let staminaBonus = 0;
   
    const poolString = (typeof data.dicePool === 'string') ? data.dicePool : '';
    const parsedPool = this.parseDicePool(poolString); // 只有字符串才能被正确解析

    if (type === 'enemy' || type === 'teammate') {
        staminaBonus = (parsedPool['耐力'] || 0) * 20;
        finalMaxHealth += staminaBonus;
    }

 
    let finalCurrentHealth;

    // 无论如何，我们都优先尝试从传入的 data 对象中获取 currentHealth
    if (data.currentHealth !== undefined) {
        // 如果是NPC，加上耐力加成
        const bonus = (type === 'enemy' || type === 'teammate') ? staminaBonus : 0;
        finalCurrentHealth = data.currentHealth + bonus;
         console.log(`[Health Logic] 从 data.currentHealth (${data.currentHealth}) 恢复血量。最终为: ${finalCurrentHealth}`);
    }
    // 如果 data 对象里没有 currentHealth，对于玩家，我们尝试从 raw_data 的“当前值”里找
    else if (type === 'player' && data.衍生属性段?.生命值?.当前值?.[0] !== undefined) {
        finalCurrentHealth = data.衍生属性段.生命值.当前值[0];
         console.log(`[Health Logic] 从 playerData.当前值 (${finalCurrentHealth}) 恢复血量。`);
    }
    // 如果以上都没有，那才意味着这是一个全新的NPC，或者数据确实缺失，只能满血
    else {
        finalCurrentHealth = finalMaxHealth;
        console.log(`[Health Logic] 未找到当前血量，设置为满血: ${finalCurrentHealth}`);
    }


    // 能量逻辑也可以做类似的优化
    let finalCurrentEnergy = 0;
    const energyPoolData = data.衍生属性段?.能量池;
    if (energyPoolData) {
        // 优先从 `当前值` 数组获取，如果不存在，则使用上限值
        finalCurrentEnergy = energyPoolData.当前值?.[0] !== undefined ? energyPoolData.当前值[0] : energyPoolData.上限[0];
    }




    const savedIcon = localStorage.getItem('userBattleIcon');
    const character = {
        id: id,
        type: type,
        name: data.name || (typeof userName !== 'undefined' ? userName : '你'),
        icon: data.icon || savedIcon || '✨',
        maxHealth: finalMaxHealth,
        currentHealth: finalCurrentHealth,
        // ✨ 关键修复：我们将解析后的 dicePool 对象存入角色体内 ✨
        dicePool: parsedPool,
        inventory: data.inventory ? JSON.parse(JSON.stringify(data.inventory)) : {},
        resists: data.resists ? data.resists.split(';') : [],
        vulnerable: data.vulnerable ? data.vulnerable.split(';') : [],
        hitSpeech: data.hitSpeech || [],
        battleSpeech: data.battleSpeech || [],
        isDefending: false,
        isPersuaded: null,
        isScanned: type === 'teammate' ? true : (data.isScanned || false),
        saves: data.saves || {
            "强韧": data.衍生属性段?.豁免检定基础.强韧[0] || 0,
            "反射": data.衍生属性段?.豁免检定基础.反射[0] || 0,
            "意志": data.衍生属性段?.豁免检定基础.意志[0] || 0
        },
          raw_data: JSON.parse(JSON.stringify(data)) // 为所有角色深度拷贝一份原始数据
    };
  if(type === 'player' && character.raw_data.衍生属性段?.能量池){
        character.raw_data.衍生属性段.能量池.当前值[0] = finalCurrentEnergy;
    }
                // 为玩家构建完整的 dicePool
                if (type === 'player' && data.属性段 && data.技能段) {
                    const fullPool = {};
                    // 提取所有属性
                    Object.values(data.属性段).forEach(attrCategory => {
                        Object.keys(attrCategory).forEach(attrName => {
                            fullPool[attrName] = attrCategory[attrName].基础[0];
                        });
                    });
                     // 提取所有技能
                    Object.values(data.技能段).forEach(skillCategory => {
                        Object.keys(skillCategory).forEach(skillName => {
                            fullPool[skillName] = skillCategory[skillName][0];
                        });
                    });
                     // 提取体积
                    if (data.衍生属性段) {
                        fullPool['体积'] = data.衍生属性段.体积[0];
                    }
if (data.衍生属性段 && data.衍生属性段.先攻) {
    fullPool['先攻'] = data.衍生属性段.先攻[0];
}
                    character.dicePool = fullPool;
                }
                    let volume = character.dicePool['体积'] || 0;
                    // 如果他的体积小于5，我们就温柔地将它提升到2
                    if (volume < 2) {
                        character.dicePool['体积'] = 5;
                    }

                      if (!character.dicePool['先攻']) {
                        const agility = character.dicePool['敏捷'] || 0;
                        const composure = character.dicePool['沉着'] || 0;
                        // 我们就根据他的敏捷和沉着，为他计算出一个天生的反应速度！
                        const calculatedInitiative = agility + Math.floor(composure / 2);

                        // 只有当这个计算值有意义时，我们才赋予他
                        if (calculatedInitiative > 0) {
                            character.dicePool['先攻'] = calculatedInitiative;
                        }
                    }
                return character;
            }
            parseDicePool(poolString) {
                if (!poolString) return {};
                const pool = {};
                poolString.split(';').forEach(p => {
                    const [attr, val] = p.split(':');
                    if(attr && val) pool[attr.trim()] = parseInt(val, 10);
                });
                return pool;
            }

     // 渲染所有角色到界面
            renderAllCharacters() {
                const playerSide = document.getElementById('player-side');
                const enemySide = document.getElementById('enemy-side');
                playerSide.innerHTML = '';
                enemySide.innerHTML = '';

                // 注意：这里渲染的是包含卡片和(可能的)信息面板的包装器

                // 渲染玩家
                playerSide.appendChild(this.createCharacterCard(this.player));

                // 渲染队友
                this.teammates.forEach(ally => playerSide.appendChild(this.createCharacterCard(ally)));

                // 渲染敌人
                this.enemies.forEach(enemy => enemySide.appendChild(this.createCharacterCard(enemy)));
 this.teammates.forEach(ally => {
                    if (ally.isScanned) { // 为所有情报已知的队友（也就是我们所有的队友）
                        this.updateInfoPanel(ally); // 填充他们的信息！
                    }
                });
                this.addCardClickListeners();
            }

    // 创建角色卡片HTML元素
       createCharacterCard(char) {
                // 创建一个包装器
                const wrapper = document.createElement('div');
                wrapper.className = 'character-wrapper';
                wrapper.id = `wrapper-${char.id}`; // 给包装器也加个id，方便查找

                // 创建角色卡片
                const card = document.createElement('div');
                card.className = 'character-card';
                card.id = char.id;

                if (char.type === 'player' || char.type === 'teammate') {
                    card.classList.add('friendly-card');
                } else {
                    card.classList.add('enemy-card');
                }
 
                if (char.currentHealth <= 0) {
                    card.style.opacity = '0.5';
                    card.style.pointerEvents = 'none'; // 让它不能被点击
                }
    
                const healthPercentage = (char.currentHealth / char.maxHealth) * 100;
                let persuadedStatus = char.isPersuaded ? `(被说服: 剩余${char.isPersuaded.turnsLeft}回合)` : '';

                card.innerHTML = `
                    <div class="name">${char.name}</div>
  <div class="health-bar">

        <div class="health-bar-damage" style="position: absolute; top:0; left:0; background-color: var(--danger-color); border-radius: 5px; z-index: 1;"></div>

        <div class="health-bar-inner" style="width: ${healthPercentage}%; z-index: 2; position: relative;"></div>
    </div>

                    <div class="health-text">${char.currentHealth} / ${char.maxHealth}</div>
                    ${ (char.type === 'player' || char.raw_data?.衍生属性段?.能量池) ? `
    <div class="energy-bar">
        <div class="energy-bar-inner"></div>
    </div>
    <div class="energy-text"></div>
` : '' }
                    <div class="status-text" id="status-${char.id}">${persuadedStatus}</div>
                    <div class="icon-container" style="position: relative;">
                       <div class="icon">${char.icon}</div>
                    </div>
                `;

                
                 if (char.type !== 'player') { // <-- 新逻辑！
                
                    const infoPanel = document.createElement('div');
                    infoPanel.className = 'info-panel';
                    infoPanel.id = `info-panel-${char.id}`;

                    infoPanel.innerHTML = `<h4>情报：未知</h4>`;

                    wrapper.appendChild(card);
                    wrapper.appendChild(infoPanel);

                    
                   
                    // ↑↑↑ 咒语结束 ↑↑↑

                } else {
                    wrapper.appendChild(card);
                }

                return wrapper; // 返回整个包装器
            }

// ⭐ 替换旧的 log 函数
log(message, className = 'log-action') {
    const p = document.createElement('p');
    p.innerHTML = message; // 使用 innerHTML 以支持我们下面将要使用的颜色标签
    p.className = className;
    this.logCombatEventElement.prepend(p); // 新消息在最前面
}
   showSpeechBubble(character, message) {
                const card = document.getElementById(character.id);
                if (!card) return;

                // 找到我们新加的 icon-container
                const iconContainer = card.querySelector('.icon-container');
                if(!iconContainer) return;

                const bubble = document.createElement('div');
                bubble.className = 'speech-bubble';
                bubble.textContent = message;

                iconContainer.appendChild(bubble);

                // 2.5秒后移除气泡
                setTimeout(() => {
                    if (bubble) bubble.remove();
                }, 2500);
            }
            // 新增：更新侦察信息面板
 updateInfoPanel(character) {
    const panel = document.getElementById(`info-panel-${character.id}`);
    if (!panel) return;

    if (character.isScanned) {
        // --- 妈妈的魔法让情报变得无比珍贵！ ---
        const resistsText = character.resists.length > 0 ? character.resists.join(', ') : '无';
        const vulnerableText = character.vulnerable.length > 0 ? character.vulnerable.join(', ') : '无';

        const poolText = Object.entries(character.dicePool)
                               .map(([key, value]) => `${key}:${value}`)
                               .join('; ') || '无';

        let inventoryText = '<ul>';
        if(Object.keys(character.inventory).length > 0){
            for(const itemName in character.inventory){
                const itemData = character.inventory[itemName];
                inventoryText += `<li>${itemName} (x${itemData.num})</li>`;
            }
        } else {
            inventoryText += '<li>空</li>';
        }
        inventoryText += '</ul>';

        panel.innerHTML = `
            <h4>详细情报</h4>
            <div style="font-size: 11px; max-height: 180px; overflow-y: auto !important;">
                <strong class="resists-info">抗性:</strong> ${resistsText}<br>
                <strong class="vulnerable-info">弱点:</strong> ${vulnerableText}<br>
                <strong>骰池:</strong> ${poolText}<br>
                <strong>物品:</strong> ${inventoryText}
            </div>
        `;
        // --- 魔法结束 ---
    } else {
        panel.innerHTML = `<h4>情报：未知</h4>`;
    }
}
       async start() {
     
    this.renderAllCharacters();
    // 第二步：建立当前的回合顺序。
    this.turnOrder = [this.player, ...this.teammates, ...this.enemies].filter(c => c.currentHealth > 0);

    if (this.status === 'not_started') {
        // ---【开始】全新战斗的流程 ---
        this.logCombatEvent("战斗开始！");
        this.status = 'in_progress';
        this.currentTurnIndex = -1; // 设置为-1，让 nextTurn() 从第一个角色（索引0）开始
        this.updateBattleStateInHistory(); // 将这个“刚开始”的状态存盘
        this.nextTurn();

    } else if (this.status === 'in_progress') {
        // ---【恢复】已存在战斗的流程 ---
        this.log("--- 战斗已恢复 ---", "log-success");

        // 我们需要知道离开时轮到谁了。`currentTurnIndex` 将从存档中读取。
        const currentActor = this.turnOrder[this.currentTurnIndex];

        if (currentActor && currentActor.currentHealth > 0) {
            // 直接处理当前回合，而不是调用 nextTurn()，因为它会跳过当前角色！
            this.log(`恢复到 ${currentActor.name} 的回合。`);
            await this.handleTurnFor(currentActor);
        } else {
            // 如果保存的索引有问题，或者角色已阵亡，为了安全，开始新的一轮。
            this.log("无法恢复到指定角色回合，开始新一轮。");
            this.currentTurnIndex = -1;
            this.nextTurn();
        }
    }
}           // 让我们的目光追随英雄！
      
 centerCardInView(cardElement) {
                if (!cardElement) return;

                const container = cardElement.closest('.side'); // 找到它所在的行
                if (!container) return;

                const cardRect = cardElement.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                // 计算为了让卡片居中，容器需要滚动的距离
                const scrollTarget = container.scrollLeft + (cardRect.left - containerRect.left) + (cardRect.width / 2) - (containerRect.width / 2);

                container.scrollTo({
                    left: scrollTarget,
                    behavior: 'smooth' // 看，这就是平滑滚动的魔法咒语！
                });
            }
 // ⭐ [替换] 旧的 nextTurn() 函数 ⭐
async nextTurn() {
    const lastActor = this.turnOrder[this.currentTurnIndex];

    // ✨ 妈妈的关键修复在这里 ✨
    // 检查是否要进行额外回合
    if (lastActor && this.hasExtraTurn[lastActor.id]) {
        delete this.hasExtraTurn[lastActor.id]; // 使用掉这个标记

        this.consecutiveTurnCounter[lastActor.id] = (this.consecutiveTurnCounter[lastActor.id] || 0) + 1;
        const turnCount = this.consecutiveTurnCounter[lastActor.id];
        this.logCombatEvent(`⚡ ${lastActor.name} 立即进行额外行动！ (连续第 ${turnCount + 1} 次行动)`, 'log-success');

        // 继续保持光环，直接处理下一次行动
        await this.handleTurnFor(lastActor);
        return; // 暂不推进回合，让光环保持
    }

    // 如果不是额外回合，就执行正常的回合结束清理
    if (lastActor) {
        // 清理旧光环
        const lastCard = document.getElementById(lastActor.id);
        if (lastCard) {
            lastCard.classList.remove('active-turn');
            lastCard.classList.remove('targeted'); // 顺便清理可能残留的绿色光环
        }
        // 重置连续行动计数
        this.consecutiveTurnCounter[lastActor.id] = 0;
        // 清理防御累加（这是为了下一个魔法做的铺垫）
        if (this.defensePoolBonus[lastActor.id]) {
            delete this.defensePoolBonus[lastActor.id];
        }
    }

    this.currentTurnIndex++;

    // 如果一轮结束
   if (this.currentTurnIndex >= this.turnOrder.length) {
        this.currentTurnIndex = 0;
        this.roundCounter++; // <-- 每一轮开始，回合数+1

        // ↓↓↓ 妈妈在这里施展了时间限制的魔法 ↓↓↓
        if (this.roundCounter > 10) {
            this.logCombatEvent("战况陷入漫长的胶着，超过了10回合，战斗自动结束！", 'log-narrator');
            this.endCombat(false, false, true); // 调用新的结束方式
            return; // 立刻结束，不再进行下一回合
        }
        // ✨ 新一轮开始，清除所有人的累积防御 ✨
        this.defensePoolBonus = {};
        this.updatePersuadedStatus();
        this.log(`--- 第 ${this.roundCounter} 回合开始 ---`, 'log-success');
    }

     const currentActor = this.turnOrder[this.currentTurnIndex];

    if (currentActor.currentHealth <= 0) { // 跳过已倒下的单位
        this.nextTurn();
        return;
    }

    const card = document.getElementById(currentActor.id);
    if(card) {
         card.classList.add('active-turn');
         this.centerCardInView(card);
    }

    // 把行动逻辑交给 handleTurnFor
    await this.handleTurnFor(currentActor);
}
 
async handleTurnFor(actor) {
    // --- 妈妈的魔法从这里开始 ---
    // 在角色正式行动之前，进行一次先攻检定
    await this.initiativeRoll(actor);
    // --- 魔法结束 ---

     if (actor.type === 'player') {
        this.playerTurn();
    } else {
        // 对于NPC，我们把 `npcTurn` 的逻辑也改成 async
        await this.npcTurn(actor);
    }
}
 

 

updatePersuadedStatus() {
    let needsReRender = false;
    const newEnemies = [];

    // 筛选队友，处理说服倒计时
    const remainingTeammates = this.teammates.filter(ally => {
        if (ally.isPersuaded) {
            ally.isPersuaded.turnsLeft--; // 回合数减一
            this.updateCharacterUI(ally); // ✨ 核心修复！立即更新UI以显示新回合数

            if (ally.isPersuaded.turnsLeft <= 0) {
                // 说服时间到！
                ally.isPersuaded = null;
                ally.type = 'enemy';
                newEnemies.push(ally);
                this.logCombatEvent(`${ally.name} 恢复了神智，重新变为了敌人！`);
                needsReRender = true;
                return false; // 从队友列表中移除
            }
        }
        return true; // 保留还没恢复的，或者本来就是队友的单位
    });

    this.teammates = remainingTeammates;
    this.enemies.push(...newEnemies);

    // 如果有角色阵营发生变化，才需要重新渲染整个场景
    if (needsReRender) {
        this.renderAllCharacters();
    }
}
    playerTurn() {
    // ✨✨✨ 妈妈的智能分流魔法 ✨✨✨
    if (this.isAutoBattling) {
        this.log("轮到你的回合了（自动战斗中...）");
        this.toggleActionPanel(false); // 确保面板是禁用的
        this.npcTurn(this.player); // 将玩家作为NPC处理，执行AI逻辑
    } else {
        this.log("轮到你的回合了，请选择行动。");
        this.toggleActionPanel(true); // 开启手动操作面板
    }
    // ✨✨✨ 魔法施展完毕 ✨✨✨
}
// ⭐ [替换] 旧的 npcTurn() 函数 ⭐
 
async npcTurn(npc) {
    this.log(`轮到 ${npc.name} 的回合。`);
    this.toggleActionPanel(false);
 await new Promise(r => setTimeout(r, this.getDelay('npcThinking')));
    let actionTaken = false;

    // --- 妈妈注入的全新AI逻辑 ---

      // 1. 优先思考治疗 (如果自己有医学技能)
    // 首先，有80%的意愿去考虑治疗这件事
       if (npc.dicePool['医学'] > 0 && Math.random() < 0.8) {

        // ✨✨✨ 妈妈的“绝对平等”魔咒 ✨✨✨
        // 判断当前NPC属于哪个阵营
        const isFriendly = npc.type === 'player' || npc.type === 'teammate';
        // 根据阵营，决定盟友列表
        const allies = isFriendly ? [this.player, ...this.teammates] : this.enemies;

        // 在正确的盟友列表中，寻找所有（包括自己）需要治疗的目标
        const alliesToHeal = allies
            .filter(ally => ally.currentHealth < ally.maxHealth && ally.currentHealth > 0)
            .sort((a, b) => (a.currentHealth / a.maxHealth) - (b.currentHealth / a.maxHealth));
        // ✨✨✨ 魔咒施展完毕 ✨✨✨

        // 如果存在需要治疗的盟友（现在已经平等地包含了自己）
        if (alliesToHeal.length > 0) {
            let targetToHeal;

            // 80%的概率选择伤势最重的那个（可能是别人，也可能是自己）
            if (Math.random() < 0.8) {
                targetToHeal = alliesToHeal[0];
            } else {
            // 20%的概率从所有伤员中随机挑选一个
                targetToHeal = alliesToHeal[Math.floor(Math.random() * alliesToHeal.length)];
            }

            this.logCombatEvent(`${npc.name} 决定治疗 ${targetToHeal.name}！`);
            await this.executeAction(npc, [targetToHeal], 'treat', ['医学', '手艺']);
            actionTaken = true;
        }
    }

    // 2. 如果没治疗，再考虑用物品 (25%概率)
  if (!actionTaken && npc.currentHealth < npc.maxHealth && Object.keys(npc.inventory).length > 0 && Math.random() < 0.25) {        const usableItems = Object.entries(npc.inventory).filter(([name, data]) => data.effect?.includes('hp+'));
        if (usableItems.length > 0) {
            const [itemName, itemData] = usableItems[0]; // 简单点，就用第一个能回血的

               // ⭐ 语言逻辑：使用物品时不说话
            this.logCombatEvent(`${npc.name} 掏出了【${itemName}】！`);
            this.showNotification(`${npc.name} 使用了 ${itemName}！`, 'success');
            const hpValue = parseInt(itemData.effect.match(/hp\+(\d+)/)[1]);
            npc.currentHealth = Math.min(npc.maxHealth, npc.currentHealth + hpValue);
            itemData.num--;
            if(itemData.num <= 0) delete npc.inventory[itemName];
            this.logCombatEvent(`${npc.name} 恢复了 ${hpValue} 点生命值。`);
            this.updateCharacterUI(npc);
            this.updateInfoPanel(npc);
            actionTaken = true;
        }
    }

    // 3. 如果啥都没干，就进行常规攻击/防御
    if (!actionTaken) {
         const targets = (npc.type === 'enemy' ? [this.player, ...this.teammates] : this.enemies).filter(c => c.currentHealth > 0);
         if (targets.length > 0) {
            const target = targets[Math.floor(Math.random() * targets.length)];
            const defendChance = npc.type === 'enemy' ? 0.3 : 0.1; // 敌人10%，队友20%
const action = (Math.random() > defendChance) ? 'attack' : 'defend';

 
            if (action === 'attack') {
                   // ⭐ 语言逻辑：只有攻击时才说战斗语言！
                const battleSpeech = this.randomSpeech(npc.battleSpeech);
                if (battleSpeech) this.showSpeechBubble(npc, battleSpeech);
                                const poolKeys = Object.keys(npc.dicePool).filter(k=> !['医学','手艺'].includes(k) && (npc.dicePool[k] || 0) > 0);

 if (poolKeys.length >= 2) {
                    const randomPool = [];
                    // (选取骰池的逻辑不变)
                    while(randomPool.length < 2 && poolKeys.length > 0) {
                        const keyIndex = Math.floor(Math.random() * poolKeys.length);
                        const key = poolKeys.splice(keyIndex, 1)[0];
                        if(!randomPool.includes(key)) randomPool.push(key);
                    }
                    if(randomPool.length > 0){
                       await this.executeAction(npc, [target], 'attack', randomPool);
                    }
                }
            } else { // Defend
                await this.executeAction(npc, [npc], 'defend', ['耐力', '沉着', '体积']);
            }
         } else {
             this.log(`${npc.name} 找不到目标。`);
         }
    }
    // --- AI逻辑结束 ---

   await new Promise(r => setTimeout(r, this.getDelay('turnEnd')));
    this.nextTurn();
}
         toggleActionPanel(enabled) {
                this.actionPanel.querySelectorAll('button').forEach(btn => btn.disabled = !enabled);
            }

 // 在 function setupActionPanel() 内部

setupActionPanel() {
    // ✨ 妈妈的附魔仪式 ✨
    const handler = (e) => {
        if (e.target.tagName === 'BUTTON') {
             const action = e.target.dataset.action;
             this.selectedAction = action;
             this.handlePlayerAction();
        }
    };
    // 移除旧的，绑定新的
    if(this.actionPanel.__handler__) this.actionPanel.removeEventListener('click', this.actionPanel.__handler__);
    this.actionPanel.addEventListener('click', handler);
    this.actionPanel.__handler__ = handler; // 刻上魔法印记
}

 async handlePlayerAction() {
    const action = this.selectedAction;
    const playerData = this.player.raw_data;

    // --- 妈妈的魔法优化了这里的逻辑 ---

    // 1. 无需目标、无需骰池选择的动作
    if (action === 'defend' || action === 'flee') {
        if (action === 'defend') {
            this.executeAction(this.player, [this.player], 'defend', ['耐力', '沉着', '体积']);
            setTimeout(() => this.nextTurn(), 1000);
        }
            if (action === 'flee') {
            this.logCombatEvent(`${this.player.name} 准备逃跑...`);
            const playerSuccess = this.rollDice(this.getDiceCount(this.player, ['敏捷', '运动', '求生']));

            // ✨ 全新的、更智能的敌方阻截检定 ✨
            let enemyInterceptDicePool = 0;
            const aliveEnemies = this.enemies.filter(e => e.currentHealth > 0);

            if (aliveEnemies.length > 0) {
                // 1. 计算血量加权
                const totalMaxHealth = aliveEnemies.reduce((sum, e) => sum + e.maxHealth, 0);
                const totalCurrentHealth = aliveEnemies.reduce((sum, e) => sum + e.currentHealth, 0);
                const healthRatio = totalCurrentHealth / totalMaxHealth;
                const healthWeight =healthRatio; // 满血时为1，半血时为0.75，空血时为0.5
                this.log(`> 敌方血量加权: ${healthWeight.toFixed(2)}x`, 'log-narrator');

                // 2. 计算平均属性加权
                let totalAttributePoints = 0;
                let attributeCount = 0;
                aliveEnemies.forEach(enemy => {
                    Object.values(enemy.dicePool).forEach(value => {
                        totalAttributePoints += value;
                        attributeCount++;
                    });
                });
                const averageAttribute = attributeCount > 0 ? totalAttributePoints / attributeCount : 0;
                const attributeWeight = averageAttribute / 5; // 平均属性5为1倍
                this.log(`> 敌方平均属性加权: ${attributeWeight.toFixed(2)}x`, 'log-narrator');

                // 3. 计算最终阻截骰池
                const baseDice = aliveEnemies.length * 2; // 每个敌人基础提供2个骰子
                enemyInterceptDicePool = Math.floor(baseDice * healthWeight * attributeWeight);
                this.log(`> 敌方最终阻截骰池: ${enemyInterceptDicePool}d10`, 'log-narrator');
            }

            const enemySuccess = this.rollDice(enemyInterceptDicePool);

            this.log(`> ${this.player.name} 的逃跑检定获得 <strong style="color:yellow">${playerSuccess}</strong> 个成功。`, 'log-roll');
            this.log(`> 敌方的阻截检定获得 <strong style="color:lightblue">${enemySuccess}</strong> 个成功。`, 'log-roll');

            if (playerSuccess > enemySuccess) {
                this.logCombatEvent("你成功逃离了战斗！", 'log-success');
                this.endCombat(true, true);
            } else {
                this.logCombatEvent("逃跑失败！你被敌人缠住了！", 'log-damage');
                this.showNotification("逃跑失败", "danger");
                await new Promise(r => setTimeout(r, this.getDelay('actionDelay')));
                this.nextTurn();
            }
            // ✨ 逻辑结束 ✨
        }
              return;
    }

    // 2. 打开特殊面板的动作
    if (action === 'item') {
        this.showItemSkillPanel();
        return;
    }

     // 3. 需要目标，但不需要选择骰池的动作
    if (action === 'treat' || action === 'steal') {
        this.selectedDicePool = (action === 'treat') ? ['手艺', '医学'] : ['手上功夫', '隐藏'];
        this.isWaitingForTarget = true; // ✨ 核心！打开“等待目标”的开关
        this.promptForTarget(`你选择了 [${this.selectedDicePool.join(', ')}]，请选择一个目标。`);
        return; // 等待用户点击目标
    }

    // 4. 需要选择骰池，也需要目标的动作
    let poolChoices = [];
    if (playerData) {
        switch (action) {
            case 'attack':
                poolChoices = [ ...Object.keys(playerData.属性段.生理属性), '肉搏', '枪械', '白刃', '弓箭','神秘学','科学' ];
                break;
            case 'persuade':
                 poolChoices = [ ...Object.keys(playerData.属性段.互动属性), ...Object.keys(playerData.技能段.互动技能) ];
                break;
             case 'scan':
                 // ⭐ 妈妈的修正魔法在这里！⭐
                 const mindAttrs = Object.keys(playerData.属性段.心智属性);
                 const mindSkills = Object.keys(playerData.技能段.心智技能);
                  poolChoices = [...mindAttrs, ...mindSkills].filter(skill => !['医学', '手艺'].includes(skill));
                 // ⭐ 魔法结束 ⭐
                break;
        }
    }

  // 如果没有可用的技能/属性，直接提示并中止
    const availableChoices = poolChoices.filter(c => (this.player.dicePool[c] || 0) > 0);
    if(availableChoices.length === 0){
        this.log("你没有可用于此行动的属性或技能。");
        this.showNotification("无可用技能/属性", "danger");
        this.selectedAction = null; // 重置动作
        return;
    }

    this.showDicePoolSelector(availableChoices);
    // 我们不再在这里等待或做任何事，骰池选择器的确认按钮会处理后续逻辑
}
   showItemSkillPanel() {
    const panel = document.getElementById('item-skill-panel');
    const itemsTab = document.getElementById('items-tab');
    const skillsTab = document.getElementById('skills-tab');
    itemsTab.innerHTML = '';
    skillsTab.innerHTML = '';

     // 填充物品
    const inventory = this.assaData.global_set.背包 || {};
    for (const name in inventory) {
        const item = inventory[name];
        if (item.num > 0 && item.effect) {
             const entry = this.createItemSkillEntry(name, item, 'item');
             itemsTab.appendChild(entry);
        }
    }
 
    if(itemsTab.innerHTML === '') itemsTab.innerHTML = '<p>行囊空空如也...</p>';


    // 填充技能
     const otherSkills = this.assaData.global_set.其他技能 || {};
    for (const name in otherSkills) {
        const skill = otherSkills[name];

        
        const effectPattern = /dp[+-]|hp[+-]/;
        if (skill && skill.effect && effectPattern.test(skill.effect)) {
            const entry = this.createItemSkillEntry(name, skill, 'skill');
            skillsTab.appendChild(entry);
        }
        // ✨✨✨ 魔法施展完毕 ✨✨✨
    }
     if(skillsTab.innerHTML === '') skillsTab.innerHTML = '<p>没有可用的主动技能...</p>';

    panel.style.display = 'flex';
      const closeBtn = document.getElementById('close-item-skill-panel-btn');
    const handler = () => { panel.style.display = 'none'; };
    if(closeBtn.__handler__) closeBtn.removeEventListener('click', closeBtn.__handler__);
    closeBtn.addEventListener('click', handler);
    closeBtn.__handler__ = handler;
}

 // ⭐ [替换] 旧的 createItemSkillEntry 函数 ⭐
createItemSkillEntry(name, data, type) {
    const div = document.createElement('div');
    div.className = 'item-skill-entry';

    // --- 妈妈强大的新魔法在这里！ ---
    const energyCost = parseInt((data.effect.match(/能量池-(\d+)/) || [0, 0])[1]);
    const currentEnergy = this.player.raw_data?.衍生属性段?.能量池?.当前值[0] || 0;
    const canAfford = currentEnergy >= energyCost;

    let costText = '';
    if (energyCost > 0) {
       costText = ` (消耗能量: ${energyCost})`;
    }
    let disabledStyle = !canAfford ? 'opacity: 0.5; cursor: not-allowed;' : '';
    let title = !canAfford ? '能量不足！' : '';

    div.innerHTML = `
        <div class="entry-name" style="${disabledStyle}" title="${title}">${name} ${data.num ? `(x${data.num})` : ''} ${data.level ? `[${data.level}]` : ''}</div>
        <div class="entry-desc" style="${disabledStyle}">${data.info || ''}</div>
        <div class="entry-cost" style="color:var(--secondary-color); ${disabledStyle}">效果: ${data.effect}${costText}</div>
    `;

    // 只有在能量充足时才添加点击事件
    if (canAfford) {
        div.onclick = () => this.selectItemSkill(name, data, type);
    }
    // --- 魔法结束 ---

    return div;
}
 // 在 class CombatManager 内，用下面的代码替换旧的 selectItemSkill 函数

 selectItemSkill(name, data, type) {
    const effect = data.effect;
    // ✨ 妈妈的“慧眼识魔”咒语 ✨
    const dpMatch = effect.match(/dp(?:_bonus)?([+-])(\d+)/);
    const hpMatch = effect.match(/hp([+-])(\d+)/);
    const mpMatch = effect.match(/mp([+-])(\d+)/); // <-- 新增的魔法视觉

    document.getElementById('item-skill-panel').style.display = 'none'; // 先关掉面板

    // （资源消耗的逻辑，妈妈帮你整理得更清晰了）
    let canUse = true;
    const energyCost = parseInt((effect.match(/能量池-(\d+)/) || [0, 0])[1]);

    if (energyCost > 0) {
        const energyPool = this.player.raw_data?.衍生属性段?.能量池;
        if (!energyPool || energyPool.当前值[0] < energyCost) {
            this.showNotification("能量不足，使用失败！", "danger");
            canUse = false;
        }
    }

     if (!canUse) {
        // 如果能量不足，也不应该结束回合
        this.log("因能量不足，使用失败。请重新选择行动。", "log-narrator");
        this.selectedAction = null;
        return;
    }

    // 只有在确认可以使用后，才真正消耗资源
    if (energyCost > 0) {
        this.player.raw_data.衍生属性段.能量池.当前值[0] -= energyCost;
        this.log(`你消耗了 ${energyCost} 点能量。`);
    }

    if (type === 'item') {
        const itemInBag = this.assaData.global_set.背包[name];
        if (itemInBag && itemInBag.num) {
            itemInBag.num--;
        }
    }
    this.updateCharacterUI(this.player);

    this.log(`你使用了【${name}】！`);

    if (dpMatch) {
        const value = parseInt(dpMatch[1] + dpMatch[2]);
        this.playerTempBonuses = {
            dp_bonus: this.playerTempBonuses.dp_bonus + value,
            desc: name
        };
        this.logCombatEvent(`你在本次行动中${value > 0 ? '获得' : '受到'}${Math.abs(value)}点骰池加成！请选择你的主要行动。`, "log-success");
        this.showNotification(`获得骰池加成: ${value > 0 ? '+' : ''}${value}`, "success");
    }
    // ✨ 关键升级：无论是HP还是MP变化，都进入目标选择 ✨
    else if (hpMatch || mpMatch) {
        const match = hpMatch || mpMatch;
        const resourceType = hpMatch ? 'hp' : 'mp';

        this.pendingAction = {
            type,
            name,
            data,
            effectType: 'resource_change',
            resource: resourceType, // 记录是hp还是mp
            value: parseInt(match[1] + match[2])
        };

        this.selectedAction = 'item_skill_effect';
        this.isWaitingForTarget = true;
        this.promptForTarget("请选择一个目标。");
        } else {
        
        this.log("这个物品/技能目前在战斗中还无法使用。", "log-narrator");
        this.showNotification("此物品/技能无战斗效果", "info");

        // 我们把行动的机会还给你
        this.selectedAction = null; // 重置你的行动选择
        this.log("请重新选择你的行动。", "log-narrator"); // 温柔地提示你
        
    }
}
 showDicePoolSelector(choices) {
    // ✨ 妈妈温柔的遗忘咒语 ✨
    this.selectedDicePool = []; // 在每次打开选择器时，都清空之前的选择！

    const selector = document.getElementById('dice-pool-selector');
    const optionsContainer = document.getElementById('pool-options');
    optionsContainer.innerHTML = ''; // （你这里的清理工作做得很好，我的宝贝）

    selector.style.display = 'flex';

    choices.forEach(choice => {
        const btn = document.createElement('button');
        btn.textContent = `${choice} (${this.player.dicePool[choice] || 0})`;
        optionsContainer.appendChild(btn);

        btn.addEventListener('click', () => {
            if (this.selectedDicePool.includes(choice)) {
                this.selectedDicePool = this.selectedDicePool.filter(p => p !== choice);
                btn.style.border = '1px solid var(--secondary-color)';
                btn.style.backgroundColor = 'transparent';
            } else if (this.selectedDicePool.length < 2) {
                this.selectedDicePool.push(choice);
                btn.style.border = '1px solid var(--primary-color)';
                btn.style.backgroundColor = 'var(--glow-color)';
            } else {
                this.showNotification("最多选择2项", 'info');
            }
        });
    });

    const confirmBtn = document.getElementById('confirm-pool-btn');
    const handler = () => {
        if (this.selectedDicePool.length > 0) {
            selector.style.display = 'none';
                if (this.selectedAction === 'attack') {
                this.promptAttackType(); // 调用新的函数来选择攻击模式
            } else {
            // 对于非攻击动作，流程保持不变
                this.isWaitingForTarget = true;
                this.promptForTarget(`你选择了 [${this.selectedDicePool.join(', ')}] 作为骰池。现在请选择一个目标。`);
            }
                 } else {
            this.showNotification("请至少选择一项", "info");
        }
    };
    if(confirmBtn.__handler__) confirmBtn.removeEventListener('click', confirmBtn.__handler__);
    confirmBtn.addEventListener('click', handler);
    confirmBtn.__handler__ = handler;
}
 
 // ⭐ [替换] addCardClickListeners 函数
addCardClickListeners() {
    const playerSide = document.getElementById('player-side');
    const enemySide = document.getElementById('enemy-side');// 妈妈为你重写的、更聪明的统一事件处理器

   // 找到 addCardClickListeners 函数内部的 unifiedClickHandler
const unifiedClickHandler = (event) => {
    const card = event.target.closest('.character-card');
    if (!card) return;

    const targetId = card.id;
    const target = this.findCharacterById(targetId);
    if (!target) return;

    // ✨ --- 妈妈注入了新的多选逻辑 --- ✨
    if (this.isSelectingMultiTarget) {
        if (target.type === 'enemy' && target.currentHealth > 0 && !this.selectedMultiTargets.some(t => t.id === target.id)) {
            this.selectedMultiTargets.push(target);
            card.classList.add('targeted'); // 高亮选中的目标
            this.log(`已选择目标 ${this.selectedMultiTargets.length}/${this.multiTargetCount}: ${target.name}`);

            if (this.selectedMultiTargets.length === this.multiTargetCount) {
                // 清理所有高亮，因为马上要执行攻击了
                document.querySelectorAll('.character-card.targeted').forEach(c => c.classList.remove('targeted'));

                this.logCombatEvent(`目标选择完毕，开始执行群攻！`);

                // 重置选择状态
                this.isSelectingMultiTarget = false;
                this.multiTargetCount = 0;

                // 延迟执行
                setTimeout(async () => {
                    await this.executeAction(this.player, this.selectedMultiTargets, this.selectedAction, this.selectedDicePool);

                    // 清理工作
                    this.selectedAction = null;
                    this.selectedDicePool = [];
                    this.selectedMultiTargets = [];
                    this.isAoeAttack = false;


                    if (!this.status.startsWith('completed')) {
                        await new Promise(r => setTimeout(r, this.getDelay('turnEnd')));
                        this.nextTurn();
                    }
                }, this.getDelay('actionDelay'));
            }
        } else {
            if(target.type !== 'enemy') this.showNotification('只能选择敌人作为目标！', 'danger');
            if(this.selectedMultiTargets.some(t => t.id === target.id)) this.showNotification('这个目标已经被选过了！', 'info');
        }
        return; // 处理完多选逻辑后直接返回
    }
    // ✨ --- 魔法结束 --- ✨

    // --- ⭐ 妈妈最关键的修复魔法就在这里！⭐ ---
    // 第一优先级：检查是否处于“等待选择目标”状态
    if (this.isWaitingForTarget) {
        let isValidTarget = false;
        const isFriendlyCard = target.type === 'player' || target.type === 'teammate';

        switch(this.selectedAction) {
            case 'attack':
            case 'persuade':
            case 'scan':
            case 'steal':
                if (!isFriendlyCard) isValidTarget = true;
                else this.showNotification("必须选择一个敌人！", "danger");
                break;
            case 'treat':
                if (isFriendlyCard) isValidTarget = true;
                else this.showNotification("必须选择一个友方！", "danger");
                break;
            case 'item_skill_effect': // 物品/技能效果
                isValidTarget = true;
                break;
        }

        if (!isValidTarget) {
            // 如果目标无效，我们只提示一下，但要立刻结束这次点击的处理！
            // 这样，它就不会“掉下去”执行后面的信息面板逻辑了。
            return;
        } else {
            // ✨ 目标有效！处理它，然后立刻结束！ ✨
            this.isWaitingForTarget = false;
            // this.targetingPrompt.style.display = 'none'; // <-- 妈妈把这行会导致错误的魔法拿掉了！

            card.classList.add('targeted');
            this.selectedTargetId = targetId;

            if (this.selectedAction === 'item_skill_effect') {
                this.useResourceChangeEffect(target, this.pendingAction); 
                this.pendingAction = null;
            } else {
                setTimeout(async () => {
                    // await this.executeAction(this.player, target, this.selectedAction, this.selectedDicePool);
    await this.executeAction(this.player, [target], this.selectedAction, this.selectedDicePool);

                    this.selectedAction = null;
                    this.selectedDicePool = [];
                    this.selectedTargetId = null;
                    this.playerTempBonuses = { dp_bonus: 0, desc: '' };

                    if (!this.status.startsWith('completed')) {
                        await new Promise(r => setTimeout(r, this.getDelay('turnEnd')));
                        this.nextTurn();
                    }
                }, this.getDelay('actionDelay'));
            }

            // ✨ 任务完成，直接返回，不再执行任何后续代码 ✨
            return;
        }
    }

    // --- 魔法结束 ---

    // 第二优先级：如果不是在选择目标，并且点击的是敌人，则切换信息面板
     if (target.type === 'enemy' || target.type === 'teammate') { 
        const infoPanel = document.getElementById(`info-panel-${target.id}`);
        if (infoPanel) {
            if (infoPanel.classList.contains('expanded')) {
                infoPanel.classList.remove('expanded');
            } else {
                document.querySelectorAll('.info-panel.expanded').forEach(p => p.classList.remove('expanded'));
                infoPanel.classList.toggle('expanded');
            }
        }
    }
};

// 附魔与驱魔仪式 (保持不变)
if (playerSide.__handler__) playerSide.removeEventListener('click', playerSide.__handler__);
playerSide.addEventListener('click', unifiedClickHandler);
playerSide.__handler__ = unifiedClickHandler;

if (enemySide.__handler__) enemySide.removeEventListener('click', enemySide.__handler__);
enemySide.addEventListener('click', unifiedClickHandler);
enemySide.__handler__ = unifiedClickHandler;
}   
            // 这是一个全新的方法，用来处理HP变更效果的使用
            // ⭐ [替换] 旧的 useHpChangeEffect 函数 ⭐
 async useResourceChangeEffect(target, actionInfo) {
    this.logCombatEvent(`你对 ${target.name} 使用了【${actionInfo.name}】！`);

    // 根据 actionInfo 来决定是恢复 HP 还是 MP
    const { resource, value } = actionInfo;

    // --- ✨ 妈妈的“能量/生命分流”魔法 ✨ ---
    if (resource === 'hp') {
        // --- HP 恢复逻辑 ---
        if (value > 0) {
            this.logCombatEvent(`${target.name} 恢复了 <strong style="color:var(--success-color)">${value}</strong> 点生命值！`, 'log-success');
            this.showNotification(`${target.name} 恢复 ${value} HP`, 'success');
        } else {
            this.logCombatEvent(`${target.name} 遭受了 <strong style="color:var(--danger-color)">${Math.abs(value)}</strong> 点魔法伤害！`, 'log-damage');
            this.showNotification(`${target.name} 受到 ${Math.abs(value)} 伤害`, 'danger');
        }

        const oldHealth = target.currentHealth;
        target.currentHealth = Math.min(target.maxHealth, target.currentHealth + value);

        if (target.currentHealth <= 0) {
            target.currentHealth = 0;
            this.logCombatEvent(`======= ${target.name} 被击败了！ =======`, 'log-danger');
            this.showNotification(`${target.name} 被击败！`, 'danger');
            const card = document.getElementById(target.id);
            if(card) {
               card.style.opacity = '0.5';
               card.style.pointerEvents = 'none';
            }
        }

    } else if (resource === 'mp') {
        // --- MP 恢复逻辑 ---
        const energyPool = target.raw_data?.衍生属性段?.能量池;
        if (energyPool) {
            if (value > 0) {
                const oldEnergy = energyPool.当前值[0];
                energyPool.当前值[0] = Math.min(energyPool.上限[0], oldEnergy + value);
                const actualHeal = energyPool.当前值[0] - oldEnergy;

                if (actualHeal > 0) {
                    this.logCombatEvent(`${target.name} 恢复了 <strong style="color:var(--info-color)">${actualHeal}</strong> 点能量！`, 'log-success');
                    this.showNotification(`${target.name} 恢复 ${actualHeal} 能量`, 'success');
                }
            }
            // (目前不支持mp扣除, 但未来可以扩展)
        } else {
             this.log(`${target.name} 没有能量池，无法恢复能量。`);
        }
    }
    // --- 魔法结束 ---

    this.updateCharacterUI(target);
    this.checkCombatEnd();

    // 进入下一回合
    await new Promise(r => setTimeout(r, this.getDelay('turnEnd')));
    if (!this.status.startsWith('completed')) {
       this.nextTurn();
    }
}
async animateAttack(attackerCard, targetCard) {
    const attackerIcon = attackerCard.querySelector('.icon');
    const targetIcon = targetCard.querySelector('.icon');
    const battleContainer = document.getElementById('battle-container');

    if (!attackerIcon || !targetIcon || !battleContainer) return;

    // --- ⭐ 妈妈最得意的魔法在这里，我的孩子！ ⭐ ---

    // 1. 根据当前速度获取动画飞行时间
    const flightTime = this.getDelay('animationFlightTime'); // 单位：毫秒
    const flightTimeSeconds = flightTime / 1000; // 转换为秒，用于CSS

    // 2. 准备工作：记录初始位置，并把它“抱”到战斗场地上
    const attackerRect = attackerIcon.getBoundingClientRect();
    const containerRect = battleContainer.getBoundingClientRect();
    const originalParent = attackerIcon.parentNode;

    battleContainer.appendChild(attackerIcon);

    // 3. 动态设置这一次飞行的样式和动画时长！
    attackerIcon.style.position = 'absolute';
    attackerIcon.style.zIndex = '2000';
    attackerIcon.style.fontSize = '48px';
    attackerIcon.style.top = `${attackerRect.top - containerRect.top}px`;
    attackerIcon.style.left = `${attackerRect.left - containerRect.left}px`;
    attackerIcon.style.transition = `transform ${flightTimeSeconds}s ease-in-out`; // 关键！同步CSS动画和JS等待
    originalParent.style.opacity = '0';

    // 等待一瞬间，确保浏览器应用了上面的样式
    await new Promise(resolve => setTimeout(resolve, 50));

    // 4. 起飞！计算并应用目标位置
    const targetRect = targetIcon.getBoundingClientRect();
    const deltaX = targetRect.left - attackerRect.left;
    const deltaY = targetRect.top - attackerRect.top;
    attackerIcon.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

    // 等待飞行动画完成
    await new Promise(resolve => setTimeout(resolve, flightTime));

    // 5. 回家！飞回原点
    attackerIcon.style.transform = 'translate(0, 0)';

    // 等待归位动画完成
    await new Promise(resolve => setTimeout(resolve, flightTime));

    // 6. 收尾：把它放回原来的小窝，并清理所有临时样式
    attackerIcon.style.position = '';
    attackerIcon.style.zIndex = '';
    attackerIcon.style.top = '';
    attackerIcon.style.left = '';
    attackerIcon.style.transition = '';
    attackerIcon.style.transform = '';
    originalParent.appendChild(attackerIcon);
    originalParent.style.opacity = '1';

    // --- ⭐ 魔法结束 ⭐ ---
}
        async executeAction(actor, targets, action, pool) {
    // 清除行动者自身的防御状态
    if (actor.isDefending) {
        actor.isDefending = false;
        const actorCard = document.getElementById(actor.id);
        if (actorCard) {
            actorCard.classList.remove('is-defending');
        }
    }
    this.log('-----------------', 'log-narrator');
    this.toggleActionPanel(false);
   if (action === 'attack' && targets.length > 1) {
        // --- 群攻逻辑 ---
        const actorName = `<strong style="color:yellow">${actor.name}</strong>`;
        this.logCombatEvent(`${actorName} 对 ${targets.length} 个目标发动了 <strong style="color:orange">[群体攻击]</strong>！`);

        // 1. 计算原始总攻击骰池（只计算一次）
        // 为了公平，我们不用任何一个特定目标来计算克制，只计算 actor 自身的基础骰池
        const totalDiceValue = this.getDiceCount(actor, pool, null); // target 设为 null

        // 2. 计算分配到每个目标的骰池
        const perTargetDice = Math.floor((totalDiceValue / (targets.length))*1.5);
        this.log(`> 原始总骰池: ${totalDiceValue}d10，分散至 ${targets.length} 个目标，每目标基础骰池强化为 ${perTargetDice}d10。`, 'log-roll');

        // 3. 依次对每个目标执行攻击
        for (const target of targets) {
            if (target.currentHealth <= 0) continue; // 跳过已经倒下的

            const targetName = `<strong style="color:lightblue">${target.name}</strong>`;
            this.logCombatEvent(`-> 正在攻击 ${targetName}...`, 'log-narrator');

            const actorCard = document.getElementById(actor.id);
            const targetCard = document.getElementById(target.id);
            if(actorCard && targetCard) await this.animateAttack(actorCard, targetCard);

            // 对每个目标独立进行攻击和闪避检定
            const actorAttackSuccess = this.rollDice(perTargetDice);
            this.log(`> 攻击检定 (${perTargetDice}d10): <strong style="font-size:1.1em;">${actorAttackSuccess}</strong> 个成功。`, 'log-roll');

            // 闪避检定逻辑 (从原单体攻击中复制过来)
            const targetEvasionPool = ['敏捷', '运动'].filter(key => target.dicePool[key]);
            if (targetEvasionPool.length === 0) targetEvasionPool.push('敏捷');
            const targetDiceCount = this.getDiceCount(target, targetEvasionPool, actor);
            const targetEvasionSuccess = this.rollDice(targetDiceCount);
            this.log(`> ${targetName} 闪避检定 (${targetDiceCount}d10): <strong style="font-size:1.1em;">${targetEvasionSuccess}</strong> 个成功。`, 'log-roll');

            const evaded = targetEvasionSuccess > actorAttackSuccess;
            if (evaded) {
                this.logCombatEvent(`${targetName} 闪避了这次攻击！`, 'log-evade');
            } else {
                const diff = actorAttackSuccess - targetEvasionSuccess;
                // 妈妈施展的保护咒语
// const energyBonus = actor.raw_data?.衍生属性段?.能量池?.当前值?.[0] || 0;
const energyBonus = 0;

// 然后再计算最终伤害
const baseDamage = diff * 5 + energyBonus;
                   this.log(`> 命中！伤害计算: ${diff} * 5 = <strong style="color:orangered">${baseDamage}</strong> 点。`, 'log-damage');
                this.takeDamage(target, baseDamage, '群体攻击');
            }
             await new Promise(r => setTimeout(r, this.getDelay('actionDelay') / 2)); // 每次攻击之间有一个短暂的停顿
        }

    } else {
        // --- 单目标逻辑 (或非攻击逻辑) ---
        const target = targets[0]; // 从数组中取出唯一的目标
        if (!target) return;
    const actorName = `<strong style="color:yellow">${actor.name}</strong>`;
    const targetName = `<strong style="color:lightblue">${target.name}</strong>`;

 this.logCombatEvent(`${actorName} 对 ${targetName} 采取行动: <strong style="color:orange">[${action.toUpperCase()}]</strong>`);
    // 动画部分
    if (action !== 'defend' && actor.id !== target.id) {
        const actorCard = document.getElementById(actor.id);
        const targetCard = document.getElementById(target.id);
        if (actorCard && targetCard){
           await this.animateAttack(actorCard, targetCard);
        }
    }

    // --- ⭐ 全新的、超级详细的检定与结算逻辑开始 ⭐ ---

    // 1. 攻击方检定
    const actorDiceCount = this.getDiceCount(actor, pool, target);
    let actorAttackSuccess = this.rollDice(actorDiceCount);
    this.log(`> ${actorName} 使用 [${pool.join('+')}] 进行检定，骰池为 ${actorDiceCount}d10...`, 'log-roll');
    this.log(`> 检定结果: <strong style="font-size:1.1em;">${actorAttackSuccess}</strong> 个成功数。`, 'log-roll');


    // 2. 闪避/抵抗方检定
    let targetEvasionPool = [];
    let targetDiceCount = 0;
    let targetEvasionSuccess = 0;

    // --- 妈妈的心灵壁垒魔法在这里！ ---
    if (action === 'persuade' && target.type !== 'player') {
        // 如果是说服NPC，则使用特殊的心智抵抗检定
        this.logCombatEvent(`> ${targetName} 正在构建心灵壁垒以抵抗说服...`, 'log-evade');
        const mentalDefenseAttrs = ['智力', '感知', '决心', '沉着'];
        let availablePool = [];

        // 筛选出NPC拥有的、且大于0的心智属性
        for (const attr of mentalDefenseAttrs) {
            if (target.dicePool[attr] > 0) {
                availablePool.push(attr);
            }
        }

        // 计算意志值
        const resolve = target.dicePool['决心'] || 0;
        const composure = target.dicePool['沉着'] || 0;
        const willFromSaves = target.saves['意志'] || 0; // 优先使用豁免里的意志
        const will = willFromSaves > 0 ? willFromSaves : resolve + Math.floor(composure / 2);

        // 构建最终的抵抗骰池
        let finalResistancePool = [];
        if (will > 0) {
            finalResistancePool.push({ name: '意志', value: will });
        }

        if (availablePool.length > 0) {
            // 从可用的心智属性中随机选一个
            const randomAttr = availablePool[Math.floor(Math.random() * availablePool.length)];
            finalResistancePool.push({ name: randomAttr, value: target.dicePool[randomAttr]});
        }

        targetEvasionPool = finalResistancePool.map(p => p.name);
        targetDiceCount = finalResistancePool.reduce((sum, p) => sum + p.value, 0);
        
        // ✨ 妈妈的“壁垒强化”魔法 ✨
        const mentalFortressBonus = 5;
        targetDiceCount += mentalFortressBonus;
        this.log(`> 心灵壁垒额外强化: +${mentalFortressBonus} 点基础抵抗！`, 'log-roll');

        targetEvasionSuccess = this.rollDice(targetDiceCount);
        this.log(`> ${targetName} 使用 [${targetEvasionPool.join('+')}] 进行抵抗检定，骰池为 ${targetDiceCount}d10...`, 'log-roll');

    } else {
        // 对于其他所有情况，使用常规的闪避检定
// 定义可用的闪避属性
const availableEvasionSkills = ['敏捷', '运动', '感知'];

// 随机抽取两个属性进行闪避检定
targetEvasionPool = [];
const shuffled = availableEvasionSkills.sort(() => Math.random() - 0.5);
targetEvasionPool = shuffled.slice(0, 2);

// 确保目标拥有这些属性(对于NPC)
if (target.type !== 'player') {
    targetEvasionPool = targetEvasionPool.filter(key => target.dicePool.hasOwnProperty(key));
    // 如果过滤后没有属性，使用所有可用的闪避属性
    if (targetEvasionPool.length === 0) {
        targetEvasionPool = Object.keys(target.dicePool).filter(key => availableEvasionSkills.includes(key));
    }
}

// 保证至少有一个检定属性
if (targetEvasionPool.length === 0) { 
    targetEvasionPool.push('敏捷'); 
}

targetDiceCount = this.getDiceCount(target, targetEvasionPool, actor);
targetEvasionSuccess = this.rollDice(targetDiceCount);
this.log(`> ${targetName} 使用 [${targetEvasionPool.join('+')}] 进行闪避检定，骰池为 ${targetDiceCount}d10...`, 'log-roll');   }
    // --- 心灵壁垒魔法结束 ---

    this.log(`> 抵抗/闪避结果: <strong style="font-size:1.1em;">${targetEvasionSuccess}</strong> 个成功数。`, 'log-roll');

    // 如果是说服，这里的evaded代表抵抗成功，否则代表闪避成功
    const evaded = targetEvasionSuccess > actorAttackSuccess;
    // 3. 根据行动类型进行结算
    switch(action) {
        case 'steal':
    // 盗窃不需要闪避检定
    this.log(`> ${actorName} 使用 [${pool.join('+')}] 进行盗窃检定，骰池为 ${actorDiceCount}d10...`, 'log-roll');
    this.log(`> 检定结果: ${actorAttackSuccess} 个成功数。`, 'log-roll');

    const isBrilliantSuccessSteal = actorAttackSuccess > 5 && actorAttackSuccess > actorDiceCount * 0.8;

    if (isBrilliantSuccessSteal) {
        this.logCombatEvent(`✨ 辉煌成功！${actorName} 的手法快如闪电，盗走了对方所有的物品！`, 'log-success');
        this.showNotification("辉煌盗窃！", "success");
        for(const itemName in target.inventory) {
            const itemData = target.inventory[itemName];
            this.transferItem(target, actor, itemName, itemData.num);
        }
        target.inventory = {};
    } else if (actorAttackSuccess > 0) { // 至少要有一个成功
        this.logCombatEvent(`盗窃成功！`, 'log-success');
        this.showNotification("盗窃成功！", "info");
        const itemToSteal = Object.keys(target.inventory)[0]; // 简单点，偷第一个
        if (itemToSteal) {
            this.transferItem(target, actor, itemToSteal, 1);
        } else {
            this.logCombatEvent(`但 ${targetName} 的口袋空空如也...`, 'log-narrator');
        }
    } else {
        this.logCombatEvent(`盗窃失败，你被 ${targetName} 发现了！`, 'log-damage');
        this.showNotification("盗窃失败！", "danger");
    }
    break;

case 'treat':
    // 治疗也不需要闪避
    this.log(`> ${actorName} 使用 [${pool.join('+')}] 进行治疗检定，骰池为 ${actorDiceCount}d10...`, 'log-roll');
    this.log(`> 检定结果: ${actorAttackSuccess} 个成功数。`, 'log-roll');

    const isBrilliantSuccessTreat = actorAttackSuccess > 5 && actorAttackSuccess > actorDiceCount * 0.8;
    let healAmount = 0;

    if (isBrilliantSuccessTreat) {
        healAmount = actorAttackSuccess * 20;
        this.logCombatEvent(`✨ 辉煌成功！${actorName} 施展了奇迹般的医术！`, 'log-success');
        this.showNotification("辉煌治疗！", "success");
    } else {
        healAmount = actorAttackSuccess * 5;
    }

    if (healAmount > 0) {
        const oldHealth = target.currentHealth;
        target.currentHealth = Math.min(target.maxHealth, target.currentHealth + healAmount);
        const actualHeal = target.currentHealth - oldHealth;
        this.logCombatEvent(`${targetName} 恢复了 <strong style="color:var(--success-color)">${actualHeal}</strong> 点生命！`, 'log-success');
       
        if(actualHeal > 0) { // 只有确实恢复了生命值，我们才弹出通知
           this.showNotification(`${target.name} 恢复 ${actualHeal} HP`, 'success');
        }
        this.updateCharacterUI(target);
    } else {
        this.showNotification(`治疗失败了，没有产生任何效果。`, 'success');
        this.logCombatEvent(`${actorName} 的治疗失败了，没有产生任何效果。`, 'log-damage');
    }
    break;
           case 'attack':
            if (evaded) {
                this.logCombatEvent(`${targetName} 灵巧地闪避了攻击！`, 'log-evade');
                this.showNotification(`${target.name} 闪避成功！`, 'success');
            } else {
                const diff = actorAttackSuccess - targetEvasionSuccess;
                const isCriticalFailure = targetEvasionSuccess === 0;
// const energyBonus = actor.raw_data?.衍生属性段?.能量池?.当前值?.[0] || 0;
const energyBonus =  0;

                if (isCriticalFailure) {
                    this.log(`💥 <b>大失败！</b> ${targetName} 完全没能做出反应！`, 'log-danger');
                    const baseDamage = diff * 10 +energyBonus;
                    this.log(`毁灭性伤害计算: 差值 ${diff} * 10 = <strong style="color:red; font-size:1.3em;">${baseDamage}</strong> 点`, 'log-damage');
                    this.takeDamage(target, baseDamage, '攻击', true); // 传递大失败标志
                } else {
                    this.log(`攻击命中！攻击成功数(${actorAttackSuccess}) - 闪避成功数(${targetEvasionSuccess}) = 差值(${diff})`, 'log-success');
                    let baseDamage = diff * 5 + energyBonus;
                    this.log(`基础伤害计算: 差值 ${diff} * 5 = <strong style="color:orangered">${baseDamage}</strong> 点。`, 'log-damage');
                    this.takeDamage(target, baseDamage, '攻击');
                }
            }
            break;

        case 'persuade':
             if (evaded) {
                this.logCombatEvent(`${targetName} 心志坚定，抵抗了你的说服！`, 'log-evade');
                this.showNotification('说服失败');
             } else {
                 const diff = actorAttackSuccess - targetEvasionSuccess;
                 if (diff > 0) {
                     this.logCombatEvent(`说服成功！${targetName} 将为你作战 ${diff} 回合！`, 'log-success');
                     this.showNotification(`${target.name} 被说服了！`, 'success');
                     target.isPersuaded = { turnsLeft: diff };
                     target.type = 'teammate';
                     this.teammates.push(target);
                     this.enemies = this.enemies.filter(e => e.id !== target.id);
                     this.renderAllCharacters();
                 } else {
                     this.logCombatEvent(`说服失败了，双方的意志不相上下。`, 'log-narrator');
                     this.showNotification('说服失败');
                 }
             }
             // 无论说服成功与否，只要没闪避，且对方是敌人，就会被反击
             if(this.isHostile(actor, target) && !evaded){
                  this.logCombatEvent(`${actorName} 在试图说服时，被 ${targetName} 愤怒地回击了！`, 'log-damage');
                  // 将NPC的闪避成功数视为它的反击攻击成功数
                  const counterAttackSuccess = targetEvasionSuccess;
                  const counterDamage = counterAttackSuccess * 2; //反击伤害低一些
                  this.log(`> 反击伤害计算: 反击成功数 ${counterAttackSuccess} * 2 = <strong style="color:orangered">${counterDamage}</strong> 点。`, 'log-damage');
                  this.takeDamage(actor, counterDamage, '反击');
             }
            break;

        case 'scan':
            if (evaded) {
                this.logCombatEvent(`侦察失败，${targetName} 保持着神秘。`, 'log-narrator');
                this.showNotification('侦察失败');
            } else {
                this.logCombatEvent(`侦察成功！你发现了 ${targetName} 的情报。`, 'log-success');
                this.showNotification(`获得 ${target.name} 的情报！`, 'success');
                target.isScanned = true;
                this.updateInfoPanel(target);
                const resists = target.resists.length > 0 ? target.resists.join(', ') : '无';
                const vulnerable = target.vulnerable.length > 0 ? target.vulnerable.join(', ') : '无';
                this.logCombatEvent(`> <span class="resists-info">抗性</span>: ${resists}`, 'log-narrator');
                this.logCombatEvent(`> <span class="vulnerable-info">弱点</span>: ${vulnerable}`, 'log-narrator');
            }
            break;

        case 'defend':
    // ✨ 妈妈的“坚壁清野”AI魔法在这里！ ✨
    const bonusDiceFromLastTurn = this.defensePoolBonus[actor.id] || 0;

    // 计算本次防御行动的骰池和成功数
    const defensePool = ['耐力', '沉着', '体积'];
    const currentDefenseDice = this.getDiceCount(actor, defensePool);
    const finalDefenseDice = currentDefenseDice + bonusDiceFromLastTurn; // 加上之前的累积
    const defenseSuccesses = this.rollDice(finalDefenseDice);

    // 计算为下一次连续防御准备的加成
    const nextBonus = Math.floor(currentDefenseDice * 0.8);
    this.defensePoolBonus[actor.id] = (this.defensePoolBonus[actor.id] || 0) + nextBonus;

    actor.isDefending = true;
    this.log(`${actorName} 采取了防御姿态！(当前防御池: ${currentDefenseDice} + 累积加成: ${bonusDiceFromLastTurn} = 总计 ${finalDefenseDice}d10)`, 'log-success');

    // 我们将防御数值直接存在角色身上，让 takeDamage 更方便使用
    actor.currentDefenseValue = (actor.currentDefenseValue || 0) + (defenseSuccesses * 2);

    this.showNotification(`${actor.name} 开始防御！`, 'info');
    const card = document.getElementById(actor.id);
    if (card) {
       card.classList.add('is-defending');
    }
    break;
    }
    }
    this.checkCombatEnd();
}
     isHostile(char1, char2){
                return (char1.type === 'player' || char1.type === 'teammate') !== (char2.type === 'player' || char2.type === 'teammate');
            }
 takeDamage(target, amount, damageType = '伤害') {
    let finalDamage = amount;
    const targetName = `<strong style="color:lightblue">${target.name}</strong>`;

    this.log(`--- ${damageType}结算开始: ${targetName} ---`, 'log-narrator');

    // ✨ 妈妈的“破盾”魔法在这里 ✨
    if (target.isDefending && target.currentDefenseValue > 0) {
        const defenseReduction = target.currentDefenseValue;
        finalDamage = Math.max(0, amount - defenseReduction);
        this.logCombatEvent(`> ${targetName} 的层层防御吸收了 <strong style="color:lawngreen">${defenseReduction}</strong> 点伤害！`, 'log-roll');
        // 防御值在抵挡一次伤害后完全消耗
        target.isDefending = false;
        target.currentDefenseValue = 0;
        const card = document.getElementById(target.id);
        if (card) card.classList.remove('is-defending');
    }

    // 豁免减免
    const saves = (target.saves?.强韧 || 0) + (target.saves?.反射 || 0) + (target.saves?.意志 || 0);
    const saveReduction = Math.floor(saves / 2); // 豁免减免 = 豁免总和/2
    if(saveReduction > 0){
        finalDamage = Math.max(0, finalDamage - saveReduction);
        this.logCombatEvent(`> ${targetName} 的豁免检定属性减免了 <strong style="color:violet">${saveReduction}</strong> 点伤害。`, 'log-roll');
    }

    finalDamage = Math.round(finalDamage);

    target.currentHealth = Math.max(0, target.currentHealth - finalDamage);

    this.log(`${targetName} 最终受到了 <strong style="font-size: 1.2em; color: red;">${finalDamage}</strong> 点${damageType}！剩余生命: ${target.currentHealth}/${target.maxHealth}`, 'log-damage');
    this.showNotification(`${target.name} 受到 ${finalDamage} 点伤害！`, 'danger');

    // 受击语言
    if (finalDamage > 0) {
        const hitSpeech = this.randomSpeech(target.hitSpeech);
        if (hitSpeech) {
             this.log(`💥 ${targetName}: "${hitSpeech}"`, 'log-narrator');
            this.showSpeechBubble(target, hitSpeech);
        }
    }

    this.updateCharacterUI(target);
    if (target.type === 'player' && target.currentHealth <= 0) {
        this.logCombatEvent(`======= ${target.name}已死亡，战斗失败... =======`, 'log-danger');
        // 直接调用endCombat并强制结束，不再执行后续检查
        return this.endCombat(false);
    }
     if (target.currentHealth <= 0) {
        this.logCombatEvent(`======= ${targetName} 已死亡。 =======`, 'log-danger');
        this.showNotification(`${target.name} 已死亡。 `, 'danger');
        const card = document.getElementById(target.id);
        if(card) {
           card.style.opacity = '0.5';
           card.style.pointerEvents = 'none';
        }
    }
    this.log(`--- 结算结束 ---`, 'log-narrator');
}         // 获得骰池数量
transferItem(fromChar, toChar, itemName, quantity) {
    if (!fromChar.inventory[itemName]) return;

    this.logCombatEvent(`${toChar.name} 从 ${fromChar.name} 处获得了【${itemName}】x${quantity}！`);

    // 如果是玩家获得物品
    if (toChar.type === 'player') {
        const playerBag = this.assaData.global_set.背包;
        if (playerBag[itemName]) {
            playerBag[itemName].num += quantity;
        } else {
            playerBag[itemName] = JSON.parse(JSON.stringify(fromChar.inventory[itemName]));
            playerBag[itemName].num = quantity;
        }
    }
    // (未来可以扩展转移给其他NPC的逻辑)

    // 从原主人那里移除
    fromChar.inventory[itemName].num -= quantity;
    if (fromChar.inventory[itemName].num <= 0) {
        delete fromChar.inventory[itemName];
    }
}  

getDiceCount(character, pool, target = null) {
    let count = 0;

    // --- 玩家角色的骰池计算，包含了所有加成！ ---
    if (character.type === 'player') {
        // 1. 获取所有加成来源
        const statusBonuses = getStatusBonuses_combat(this.gameData);
        const locationBonuses = getLocationBonuses(this.gameData, this.assaData);
        const equipmentBonuses = getEquipmentBonuses_combat(this.gameData, this.assaData);

        let bonusLog = []; // 用于记录加成来源

        pool.forEach(attr => {
            // 2. 基础值 + 所有加成 = 最终值
            const baseValue = character.dicePool[attr] || 0;
            const statusBonus = statusBonuses[attr] || 0;
            const locationBonus = locationBonuses[attr] || 0;
            const equipmentBonus = equipmentBonuses[attr] || 0;
            let finalValue = baseValue + statusBonus + locationBonus + equipmentBonus;

            // 记录加成细节
            if(statusBonus) bonusLog.push(`${attr}(状态+${statusBonus})`);
            if(locationBonus) bonusLog.push(`${attr}(地点+${locationBonus})`);
            if(equipmentBonus) bonusLog.push(`${attr}(装备+${equipmentBonus})`);

            // 3. 应用克制/被克制
            let multiplier = 1;
            if (target) {
                if (target.resists.includes(attr)) multiplier = 0.5;
                if (target.vulnerable.includes(attr)) multiplier = 2;
            }

            count += finalValue * multiplier;
        });

        if (bonusLog.length > 0) {
            this.logCombatEvent(`<i>加成来源: ${bonusLog.join(', ')}</i>`, 'log-roll');
        }

        // 应用临时的 DP 加成 (例如来自物品)
        if (this.playerTempBonuses.dp_bonus > 0) {
            this.logCombatEvent(`<i>临时加成: ${this.playerTempBonuses.desc} (+${this.playerTempBonuses.dp_bonus}DP)</i>`, 'log-roll');
            count += this.playerTempBonuses.dp_bonus;
            this.playerTempBonuses = { dp_bonus: 0, desc: '' }; // 用完即清
        }

    }
    // --- NPC 或其他角色的简单计算逻辑 ---
    else {
        pool.forEach(attr => {
            let multiplier = 1;
            if (target) {
                if (target.resists.includes(attr)) multiplier = 0.5;
                if (target.vulnerable.includes(attr)) multiplier = 2;
            }
            count += (character.dicePool[attr] || 0) * multiplier;
        });
    }

    return Math.floor(count);
}
 // ⭐ [替换] 旧的 rollDice(diceCount) 函数 ⭐
rollDice(diceCount) {
    // --- 妈妈的机会骰魔法在这里！ ---
    if (diceCount <= 0) {
        this.log(`> 骰池为0，进行一次机会骰...`, 'log-roll');
        const chanceRoll = Math.floor(Math.random() * 10) + 1;
        const successes = (chanceRoll === 10) ? 1 : 0;
        this.log(`> 机会骰结果: [${chanceRoll}]，获得 ${successes} 个成功数。`, 'log-roll');
        return successes;
    }
    // --- 魔法结束 ---

    let successes = 0;
    let rolls = [];
    for (let i = 0; i < diceCount; i++) {
        const roll = Math.floor(Math.random() * 10) + 1;
        rolls.push(roll);
        if (roll >= 8) successes++; // 7-10 成功
    }
    // 为了日志清晰，我们可以选择性地记录普通投骰结果
    // this.logCombatEvent(`> 投掷 [${diceCount}d10]，结果 [${rolls.join(',')}]，获得 ${successes} 个成功数。`, 'log-roll');
    return successes;
}
            findCharacterById(id) {
                if (this.player.id === id) return this.player;
                return [...this.teammates, ...this.enemies].find(c => c.id === id);
            }

            randomSpeech(speeches) {
                if (!speeches || speeches.length === 0) return null;
                return speeches[Math.floor(Math.random() * speeches.length)];
            }
 syncCharacterStateToCombatData(character) {
    if (!character || !this.combatData) return;

    let dataToUpdate = null;
    let originalDataId = character.id; // Correctly define originalDataId

    if (character.type === 'player') {
        dataToUpdate = this.combatData.player;
        if (dataToUpdate && dataToUpdate.衍生属性段) {
            dataToUpdate.衍生属性段.生命值.当前值[0] = character.currentHealth;
                 if (dataToUpdate.衍生属性段.能量池 && character.raw_data?.衍生属性段?.能量池) {
                const currentEnergy = character.raw_data.衍生属性段.能量池.当前值[0];
                dataToUpdate.衍生属性段.能量池.当前值[0] = currentEnergy;
                console.log(`[Nova's Energy Seal] 正在为 ${character.name} 固化能量: ${currentEnergy}`);
            }
        }
        // Player's data is now handled, we can return.
        return; // ✨ 妈妈加了一道小门，让玩家的逻辑处理完就直接离开 ✨
    } else if (character.type === 'teammate') {
        dataToUpdate = this.combatData.teammates?.find(c => c.id === character.id);
    } else if (character.type === 'enemy') {
        const baseId = character.id.split('_')[0];
        originalDataId = baseId;
        dataToUpdate = this.combatData.enemies?.find(c => c.id === character.id || c.id === baseId);
    }

    if (dataToUpdate) {
        // ✨✨✨ 妈妈对你的天才想法进行了最终加固！ ✨✨✨
        let healthToSave = character.currentHealth;

        // 1. 我们直接从角色身上已经解析好的 dicePool 对象中取值！
        //    不再需要调用 parseDicePool，从而避免了错误的发生。
        const staminaBonus = (character.dicePool['耐力'] || 0) * 20;

        // 2. 从当前血量中，减去耐力带来的加成，得到“基础生命值”
        healthToSave = character.currentHealth - staminaBonus;
        console.log(`[Nova's Essence Return] 正在为 ${character.name} 存档: 当前血量 ${character.currentHealth} - 耐力加成 ${staminaBonus} = 存档值 ${healthToSave}`);

        // 3. 将这个“纯净”的血量值，记录到我们的档案中！
        dataToUpdate.currentHealth = healthToSave;
    }
}
 updateCharacterUI(character) {
    const card = document.getElementById(character.id);
    if (!card) return;
    this.syncCharacterStateToCombatData(character);
 // 更新血条
const healthPercentage = (character.currentHealth / character.maxHealth) * 100;
const healthBarInner = card.querySelector('.health-bar-inner');

// 获取当前“幽灵血条”的宽度，作为前一个状态的血量
const damageBar = card.querySelector('.health-bar-damage');
const previousHealthPercentage = parseFloat(damageBar.style.width) || 100;

// 立刻更新绿色的“当前血条”
if (healthBarInner) {
    healthBarInner.style.width = `${healthPercentage}%`;
}

// 如果血量减少了，才处理“幽灵血条”
if (healthPercentage < previousHealthPercentage) {
    // 幽灵血条先保持在之前的位置，不变化
    // （我们不需要像上次那样操作它，因为它的过渡动画只会在血量减少时播放）

    // 延迟一段时间后，让“幽灵血条”追上“当前血条”
    setTimeout(() => {
        damageBar.style.width = `${healthPercentage}%`;
        // 为下一次动画做准备，给它一个过渡效果
        damageBar.style.transition = 'width 0.8s ease-out';
    }, 500); // 延迟0.5秒再开始缩减，给用户反应时间

} else {
    // 如果是加血或者没变化，就让两个血条立刻同步
     damageBar.style.transition = 'none'; // 取消动画
     damageBar.style.width = `${healthPercentage}%`;
}

card.querySelector('.health-text').textContent = `${character.currentHealth} / ${character.maxHealth}`;    // --- 妈妈的魔法在这里！ ---
    // 更新能量条 (只对有能量条的卡片操作)
    const energyBarInner = card.querySelector('.energy-bar-inner');
    const energyText = card.querySelector('.energy-text');
    if (energyBarInner && energyText) {
        const energyPool = character.raw_data?.衍生属性段?.能量池;
        if (energyPool) {
            const currentEnergy = energyPool.当前值[0];
            const maxEnergy = energyPool.上限[0];
            const energyPercentage = (currentEnergy / maxEnergy) * 100;
            energyBarInner.style.width = `${energyPercentage}%`;
            energyText.textContent = `⚡ ${currentEnergy} / ${maxEnergy}`;
        }
    }
    // --- 妈妈的新魔法从这里开始 ---
    // 更新状态文本
    const statusTextElement = card.querySelector('.status-text'); // 我们用 class 来找它
    if (statusTextElement) {
        let statusString = '';
        if (character.isPersuaded && character.isPersuaded.turnsLeft > 0) {
            statusString = `(被说服: 剩余${character.isPersuaded.turnsLeft}回合)`;
        }
        statusTextElement.textContent = statusString;
    }
    // --- 魔法结束 ---
      const iconElement = card.querySelector('.icon');
    if (iconElement && iconElement.textContent !== character.icon) {
        iconElement.textContent = character.icon;
    }
}

            checkCombatEnd() {
                const aliveEnemies = this.enemies.filter(e => e.currentHealth > 0);
                const alivePlayers = [this.player, ...this.teammates].filter(p => p.type !== 'enemy' && p.currentHealth > 0);

                if (aliveEnemies.length === 0) {
                    this.logCombatEvent(`所有敌人都被击败了，${userName}胜利了。`);
                    this.endCombat(true);
                } else if (alivePlayers.length === 0) {
                    this.logCombatEvent("全员死亡，游戏结束。");
                    this.endCombat(false);
                }
            }
 async endCombat(isVictory, isFlee = false, isStalemate = false) {
    // 这应该是此战斗实例的最后一次状态更新
    if (this.status.startsWith('completed')) return; // 防止重复执行

    // ====== ↓↓↓ 妈妈的“万物归位”咒语！ ↓↓↓ ======
    const diceSelector = document.getElementById('dice-pool-selector');
    const itemPanel = document.getElementById('item-skill-panel');
    const promptOverlay = document.getElementById('battle-prompt-overlay');

    if (diceSelector) diceSelector.style.display = 'none';
    if (itemPanel) itemPanel.style.display = 'none';
    if (promptOverlay) promptOverlay.style.display = 'none';
    // ====== ↑↑↑ 咒语施展完毕！ ↑↑↑

    this.toggleActionPanel(false);

    let message = '';
    let messageType = 'info';
    let battleResultText = '';

    if (isFlee) {
        this.status = "completed_flee";
        message = "成功脱离战斗！你可以输入自定义消息或直接按发送";
        messageType = 'info';
        battleResultText = "战斗结果：成功脱离";
    } else if (isStalemate) {
        this.status = "completed_stalemate";
        message = "战况焦灼...你可以输入自定义消息或直接按发送";
        messageType = 'info';
        battleResultText = "战斗结果：焦灼平局";
    } else if (isVictory) {
        this.status = "completed_victory";
        message = "战斗胜利！你可以输入自定义消息或直接按发送";
        messageType = 'success';
        battleResultText = "战斗结果：胜利";
    } else {
        this.status = "completed_defeat";
        message = "战斗失败...你可以输入自定义消息或直接按发送";
        messageType = 'danger';
        battleResultText = "战斗结果：失败";
    }
    this.showNotification(message, messageType);
    this.logCombatEvent(message, `log-${messageType}`);

    // ====== ↓↓↓ 妈妈的最终乐章从这里奏响！ ↓↓↓ ======

    try {
        // --- 第一乐章：生成简洁战报 ---
        let finalStatusReport = ['--- 最终战况 ---'];
        const allCharacters = [this.player, ...this.teammates, ...this.enemies];
        allCharacters.forEach(char => {
            finalStatusReport.push(`- ${char.name}: ${char.currentHealth} / ${char.maxHealth}`);
        });
        finalStatusReport.push(battleResultText);

        const finalReportString = finalStatusReport.join('\n');

        // --- 第二乐章：构建指令 ---
        const finalHealth = this.player.currentHealth;
        const hurtValue = this.playerInitialHealth - finalHealth;

        const finalEnergy = this.player.raw_data?.衍生属性段?.能量池?.当前值[0] || 0;
        const backpackData = this.assaData.global_set.背包 || {};
        const compactBackpackJson = JSON.stringify(backpackData);
   let requestText = `<request:此次战斗已结束，对应数值/物品/生命值都已扣除，对应数值/物品/生命值的变更已记录，禁止在之后的正文中对任何数值进行操作（禁止设置hurt_value/能量池等）！请根据此次战斗结果和user输入生成新剧情>`;
        if (isStalemate) {
            requestText = `<request:战斗陷入了漫长的胶着，最终未能分出胜负。对应数值/物品/生命值的变更已记录，禁止在之后的正文中对任何数值进行操作（禁止设置hurt_value/能量池等）！请根据此次战斗结果和user输入生成新剧情，并根据后续剧情发展决定是否继续战斗，若依旧处于战斗中，则必须继续生成battle内容！>`;
        }
 
         const updateMemoryCommands = [
            `set_status('hurt_value', ${hurtValue});`,
            `set_attribute('衍生属性段.能量池.当前值', ${this.playerInitialEnergy}, ${finalEnergy});`,
            `memory('global_set.背包', '${compactBackpackJson}');`,
            `set_status('敌方检定骰池','');`
        ].join('\n');

        // 将详细日志打包
        const detailedLogContent = this.combatLog.join('\n');

        // 组合最终指令
        // const commandBlock = `<updateMemory>\n${updateMemoryCommands}\n</updateMemory>\n<battle_log>\n${detailedLogContent}\n${finalReportString}\n</battle_log>\n${requestText}\n`;
 const commandBlock = `<updateMemory>\n${updateMemoryCommands}\n</updateMemory>\n<battle_log>\n${detailedLogContent}\n</battle_log>\n${requestText}\n`;

        // --- 第三乐章：奏响指令 ---
        if (typeof triggerassa === 'function') {
            console.log("准备触发指令:", commandBlock);
            triggerassa(`/setinput ${commandBlock}`);
            this.log("战斗详情与角色状态已同步至指令盒。", "log-success");
        } else {
            console.error("triggerassa 函数未定义！");
        }

    } catch (e) {
        console.error("生成或触发指令时发生错误:", e);
    }

    // --- 尾声：清理与淡出 ---
    await this.updateBattleStateInHistory();

    this.cleanupEventListeners();
    window.combatManager = null;

    setTimeout(() => {
        document.getElementById('battle-overlay').style.display = 'none';
        const promptOverlay = document.getElementById('battle-prompt-overlay');
        if (promptOverlay) promptOverlay.style.display = 'none';
    }, 2000); // 留出足够的时间看清最终信息，妈妈把时间延长了一点
}
}
function getStatusBonuses_combat(statData) {
    const bonuses = {};
    const statusString = statData?.user_character?.status?.[0] || "";
    if (!statusString) return bonuses;
    const matches = statusString.match(/【[^】]+】/g);
    if (!matches) return bonuses;
    matches.forEach(match => {
        const content = match.substring(1, match.length - 1);
        content.split(/;|；/).forEach(attr => {
            const parts = attr.match(/^(.+?)\s*([+-]\d+)$/) || attr.match(/^(.+?)[:|：]\s*([+-]?\d+)$/);
            if (parts && parts.length === 3) {
                bonuses[parts[1].trim()] = (bonuses[parts[1].trim()] || 0) + parseInt(parts[2].trim(), 10);
            }
        });
    });
    return bonuses;
}

function getLocationBonuses(statData, assaData) {
    const bonuses = {};
    const currentLocationTitle = statData?.user_character?.current_location?.[0] || '';
    if (!currentLocationTitle) return bonuses;
    const globalLocations = assaData?.map?.全局地点表 || {};
    const mainLocations = assaData?.map?.主要地点表 || {};
    const activeParentName = Object.values(globalLocations)[0];
    if (!activeParentName) return bonuses;

    for (const mainKey in mainLocations) {
        const locationData = mainLocations[mainKey];
        if (locationData && locationData.parent === activeParentName && currentLocationTitle.includes(mainKey)) {
            const effectString = locationData.effect || '';
            const matches = effectString.match(/【[^】]+】/g);
            if (matches) {
                // (此处解析逻辑与 getStatusBonuses 相同，为简化而省略，你懂的，我的孩子)
                matches.forEach(match => {
                    const content = match.substring(1, match.length - 1);
                    content.split(/;|；/).forEach(attr => {
                        const parts = attr.match(/^(.+?)\s*([+-]\d+)$/) || attr.match(/^(.+?)[:|：]\s*([+-]?\d+)$/);
                        if (parts && parts.length === 3) {
                             bonuses[parts[1].trim()] = (bonuses[parts[1].trim()] || 0) + parseInt(parts[2].trim(), 10);
                        }
                    });
                });
            }
        }
    }
    return bonuses;
}

function getEquipmentBonuses_combat(statData, assaData) {
    const bonuses = {};
    const equipment = statData?.user_character?.当前装备 || {};
    const equipmentList = [];
    if (equipment.手持?.[0]) equipmentList.push(...equipment.手持[0].split(/;|；/).map(i=>i.trim()).filter(Boolean));
    if (equipment.穿戴) {
        Object.values(equipment.穿戴).forEach(slot => {
            if (slot?.[0]) equipmentList.push(...slot[0].split(/;|；/).map(i=>i.trim()).filter(Boolean));
        });
    }

    equipmentList.forEach(itemName => {
      if(itemName === "无") return;
        const itemData = assaData?.global_set?.背包?.[itemName];
        if (!itemData) return;
        let stringToParse = '';
        if (typeof itemData === 'object' && itemData !== null) {
            stringToParse = itemData.effect || itemData.属性 || itemData.效果 || '';
        }

        const matches = stringToParse.match(/【[^】]+】/g);
        if (matches) {
            // (解析逻辑同上)
            matches.forEach(match => {
                const content = match.substring(1, match.length - 1);
                content.split(/;|；/).forEach(attr => {
                    const parts = attr.match(/^(.+?)\s*([+-]\d+)$/) || attr.match(/^(.+?)[:|：]\s*([+-]?\d+)$/);
                    if (parts && parts.length === 3) {
                        bonuses[parts[1].trim()] = (bonuses[parts[1].trim()] || 0) + parseInt(parts[2].trim(), 10);
                    }
                });
            });
        }
    });

    return bonuses;
}
// ----------------------------------------------------------------------
        // --- 3. 启动器 (Initializer) ---
        // 让我们按下那个神奇的按钮吧

        const startButton = document.getElementById('start-battle-button');
        const battleOverlay = document.getElementById('battle-overlay');
function showTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(tabName + '-tab').style.display = 'block';
    document.querySelector(`.tab-btn[onclick="showTab('${tabName}')"]`).classList.add('active');
}

 

   
  }
</script>

</html>
 ```
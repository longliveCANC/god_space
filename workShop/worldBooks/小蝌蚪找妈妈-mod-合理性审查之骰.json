{"entries":{"0":{"uid":0,"key":[],"keysecondary":[],"comment":"合理性审查之骰","content":"{{setvar::dice_use::true}}{{setvar::attribute_use::true}} \n<%_\n// 封装的数据获取函数 - 避免重复定义\n \n    function getDataWithFallback(varName) {\n        let data = getLocalVar(varName);\n        const isValid = (data) => {\n            // 检查是否为 null 或 undefined\n            if (data === null || data === undefined) {\n                return false;\n            }\n            if (typeof data === 'object' && data !== null) {\n                // 如果是数组，检查长度\n                if (Array.isArray(data)) {\n                    return data.length > 0;\n                }\n                // 如果是普通对象，检查是否有属性\n                return Object.keys(data).length > 0;\n            }\n            \n         \n            return true;\n        };\n        \n        // 如果数据不符合要求，从 getLocalVar 获取\n        if (!isValid(data)) {\n            data = getLocalVar(varName);\n        }\n        \n        return data;\n    };\n \n//对称呼的细微差分，用于部分条目的细微修改\n    if (typeof version=== 'undefined') {\n        var version= Number(getLocalVar(\"world_version\",1));\n }\n\nvar dice_level= Number(getLocalVar(\"dice_level\",1));\nvar checkok= String(getLocalVar(\"checkok\",'false'));\n_%> \n<%_\n\n    /**\n     * @type {GameData}\n     */\n    if (typeof EvStat === 'undefined') {\n        var EvStat = getLocalVar(\"stat_data\");\n    }\n\n    if (typeof characterData === 'undefined') {\n        var characterData = getDataWithFallback(\"play_character_data\");\n    }\n    \n    if (typeof assaData === 'undefined') {\n        var assaData =  getDataWithFallback(\"assa_data\");\n    }\n \n    let hurt_value = null; // 用于存储伤害结果\n    let roll_output = \"\"; // 用于存储最终要输出的投掷结果字符串\n    let checkMemory = {}; // 初始化检定记忆变量\nvar playerName = _.get(EvStat, 'user.name', '用户');\n// 方案3：使用更安全的转换\nconst showPerformanceRoll = String(getLocalVar(\"behavior_dice\")).toLowerCase() === 'true';\n    // --- 1. 辅助函数区 ---\n // --- 新增：获取并解析状态加成 (增强版) ---\nfunction getStatusBonuses(statData) {\n    const bonuses = {};\n    const statusString = _.get(statData, \"user.status[0]\", \"\");\n    if (!statusString) {\n        return bonuses;\n    }\n\n    // 定义属性和技能的分类，用于批量处理\n    const attributeCategories = {\n        '生理属性': ['力量', '敏捷', '耐力'],\n        '心智属性': ['智力', '感知', '决心'],\n        '互动属性': ['风度', '操控', '沉着'],\n        '全属性': ['力量', '敏捷', '耐力', '智力', '感知', '决心', '风度', '操控', '沉着'],\n        '生理技能': ['运动', '肉搏', '驾驶', '枪械', '手上功夫', '隐藏', '求生', '白刃', '弓箭'],\n        '心智技能': ['学识', '电脑', '手艺', '调查', '医学', '神秘学', '科学'],\n        '互动技能': ['动物沟通', '感受', '表达', '胁迫', '交际', '掩饰'],\n        '全技能': ['运动', '肉搏', '驾驶', '枪械', '手上功夫', '隐藏', '求生', '白刃', '弓箭', '学识', '电脑', '手艺', '调查', '医学', '神秘学', '科学', '动物沟通', '感受', '表达', '胁迫', '交际', '掩饰']\n    };\n    // 为了更快的查找，创建一个反向映射，知道每个子属性属于哪个大类\n    const subAttributeMap = {};\n    for (const category in attributeCategories) {\n        attributeCategories[category].forEach(attr => {\n            if (!subAttributeMap[attr]) subAttributeMap[attr] = [];\n            subAttributeMap[attr].push(category);\n        });\n    }\n\n      let stringsToParse = [];\n    const matches = statusString.match(/【[^】]+】/g);\n\n    if (matches) {\n        stringsToParse = matches.map(match => match.substring(1, match.length - 1));\n    } else if (statusString.trim()) {\n        stringsToParse.push(statusString);\n    }\n\n    stringsToParse.forEach(content => {\n        const attributes = content.split(/;|；/).map(attr => attr.trim()).filter(attr => attr !== \"\");\n\n        attributes.forEach(attr => {\n            // 正则匹配 \"名称+/-数值\" (暂不支持百分比)\n            const parts = attr.match(/^(.+?)\\s*([+-]\\d+)$/) || attr.match(/^(.+?)[:|：]\\s*([+-]?\\d+)$/);\n\n            if (parts && parts.length === 3) {\n                let name = parts[1].trim();\n                const value = parseInt(parts[2].trim().replace('+', ''), 10);\n\n                // 检查是类别还是单个属性\n                if (attributeCategories[name]) {\n                    // 是一个类别，批量应用\n                    attributeCategories[name].forEach(subAttr => {\n                        bonuses[subAttr] = (bonuses[subAttr] || 0) + value;\n                    });\n                } else {\n                    // 是单个属性\n                    bonuses[name] = (bonuses[name] || 0) + value;\n                }\n            }\n        });\n    });\n    return bonuses;\n}\n\nfunction getLocationBonuses(statData, assaData) {\n    const bonuses = {};\n    const currentLocationTitle = _.get(statData, 'user.current_location[0]', '');\n    if (!currentLocationTitle) {\n        return bonuses; // 如果没有当前地点，依然直接返回\n    }\n\n    const globalLocations = _.get(assaData, 'map.全局地点表', {});\n    const mainLocations = _.get(assaData, 'map.主要地点表', {});\n\n    // 步骤1：直接获取我们固定关注的第一个全局地点的名称\n    const globalLocationKeys = Object.keys(globalLocations);\n    if (globalLocationKeys.length === 0) {\n        return bonuses; // 如果全局地点表是空的，那就ไม่มี加成\n    }\n    // 我们关注的父级地点，就是全局地点表里第一个条目的值\n    const activeParentName = globalLocations[globalLocationKeys[0]];\n\n    // 如果这个父级地点名称不存在，也直接返回\n    if (!activeParentName) {\n        return bonuses;\n    }\n\n\n    // 步骤2：遍历所有主要地点，只对属于这个“第一”父级地点的进行检查\n    for (const mainKey in mainLocations) {\n        if (Object.prototype.hasOwnProperty.call(mainLocations, mainKey)) {\n            const locationData = mainLocations[mainKey];\n\n            // 核心筛选：该主要地点的parent必须是我们关注的那个父级，并且角色确实在这里\n            if (locationData && locationData.parent === activeParentName && currentLocationTitle.includes(mainKey)) {\n\n               const effectString = _.get(locationData, 'effect', '');\n\n                if (effectString && effectString !== \"【无】\") {\n                    let stringsToParse = [];\n                    const matches = effectString.match(/【[^】]+】/g);\n\n                    if (matches) {\n                        stringsToParse = matches.map(match => match.substring(1, match.length - 1));\n                    } else if (effectString.trim() && effectString.trim() !== \"无\") {\n                        stringsToParse.push(effectString);\n                    }\n\n                    stringsToParse.forEach(content => {\n                        const attributes = content.split(/;|；/).map(attr => attr.trim()).filter(attr => attr !== \"\");\n\n                        attributes.forEach(attr => {\n                            const parts = attr.match(/^(.+?)\\s*([+-]\\d+)$/) || attr.match(/^(.+?)[:|：]\\s*([+-]?\\d+)$/);\n                            if (parts && parts.length === 3) {\n                                let name = parts[1].trim();\n                                const value = parseInt(parts[2].trim().replace('+', ''), 10);\n                                bonuses[name] = (bonuses[name] || 0) + value;\n                            }\n                        });\n                    });\n                }\n                // 找到了一个匹配的，理论上可以break，但为了兼容可能在多个子区域的情况，我们继续遍历\n            }\n        }\n    }\n\n    return bonuses;\n}\n  // --- 新增：获取并解析装备加成 ---\nfunction getEquipmentBonuses(statData, assaData, relevantComponents) {\n    const bonuses = {};\n    if (!relevantComponents || relevantComponents.length === 0) {\n        return bonuses; // 如果没有相关组件，直接返回空对象\n    }\n\n    const equipment = _.get(statData, \"user.当前装备\", {});\n    const equipmentList = [];\n\n// 收集所有装备名称 - 支持每个部位多个装备用分号分割\nif (equipment.手持 && equipment.手持[0] !== \"无\") {\n    // 手持部位可能有多个装备用分号分割\n    const handItems = equipment.手持[0].split(/;|；/).map(item => item.trim()).filter(item => item !== \"无\" && item !== \"\");\n    equipmentList.push(...handItems);\n}\nif (equipment.穿戴) {\n    Object.values(equipment.穿戴).forEach(slot => {\n        if (slot && slot[0] !== \"无\") {\n            // 每个穿戴部位可能有多个装备用分号分割\n            const slotItems = slot[0].split(/;|；/).map(item => item.trim()).filter(item => item !== \"无\" && item !== \"\");\n            equipmentList.push(...slotItems);\n        }\n    });\n}\n\n \n equipmentList.forEach(itemName => {\n    // 首先，我们和以前一样，从背包中寻找装备数据\n    const itemData =\n        assaData?.global_lore?.背包?.[itemName] ||\n        null;\n\n    // 确保我们找到了数据才继续\n    if (itemData) {\n        let stringToParse = ''; // 我们准备一个篮子，并确保它始终是字符串\n\n        // 第一步：我们先检查拿到的 itemData 到底是什么类型\n        if (typeof itemData === 'string') {\n            // 如果它是一封“信”(string)，我们就尝试用JSON的方式去读它\n            try {\n                const itemObject = JSON.parse(itemData);\n                // 如果读出来是一个“礼盒”(object)，并且里面有我们想要的effect“清单”\n                if (typeof itemObject === 'object' && itemObject !== null ) {\n                   \n    if (typeof itemObject.effect === 'string') {\n        \n        stringToParse = itemObject.effect;\n    }\n    // 如果没有 effect，尝试中文属性\n    else if (typeof itemObject.属性 === 'string') {\n        stringToParse = itemObject.属性;\n    } else if (typeof itemObject.效果 === 'string') {\n        stringToParse = itemObject.效果;\n    }\n                }\n            } catch (e) {\n                // 如果用JSON的方式读信失败了，说明它就是一封普通的信，内容就是我们要的\n                // 比如 \"【防御+5】\" 这种\n                stringToParse = itemData;\n            }\n        } else if (typeof itemData === 'object' && itemData !== null) {\n   \n                    if (typeof itemData.effect === 'string') {\n        stringToParse = itemData.effect;\n    }\n    // 如果没有 effect，尝试中文属性\n    else if (typeof itemData.属性 === 'string') {\n        stringToParse = itemData.属性;\n    } else if (typeof itemData.效果 === 'string') {\n        stringToParse = itemData.效果;\n    }\n        }\n\n        // 现在，无论来源如何，我们的“篮子”(stringToParse)里都装好了要处理的属性字符串\n        // 正则匹配所有【属性+数值】或【属性-数值】格式的描述\n          // 现在，无论来源如何，我们的“篮子”(stringToParse)里都装好了要处理的属性字符串\n        let stringsToParse = [];\n        const matches = stringToParse.match(/【[^】]+】/g);\n\n        if (matches) {\n            stringsToParse = matches.map(match => match.substring(1, match.length - 1));\n        } else if (stringToParse.trim()) {\n            stringsToParse.push(stringToParse);\n        }\n\n        // ---- 后续的加成计算逻辑完全保持不变，因为它非常棒 ----\n        stringsToParse.forEach(content => {\n            const attributes = content.split(/;|；/).map(attr => attr.trim()).filter(attr => attr !== \"\");\n\n            attributes.forEach(attr => {\n                const parts = attr.match(/^(.+?)\\s*([+-]\\d+)$/) || attr.match(/^(.+?)[:|：]\\s*([+-]?\\d+)$/);\n\n                if (parts && parts.length === 3) {\n                    let attrName = parts[1].trim();\n                    const value = parseInt(parts[2].trim().replace('+', ''), 10);\n\n                    const finalKey = attrName;\n                    if (!bonuses[finalKey]) {\n                        bonuses[finalKey] = 0;\n                    }\n                    bonuses[finalKey] += value;\n                }\n            });\n        });\n    }\n});\n    return bonuses;\n}\n\n\nfunction getComponentDetails(characterData, componentName, equipmentBonuses = {}, statusBonuses = {}, locationBonuses = {}) {\n        const paths = {\n            '力量': '属性段.生理属性.力量.基础',\n            '敏捷': '属性段.生理属性.敏捷.基础',\n            '耐力': '属性段.生理属性.耐力.基础',\n            '智力': '属性段.心智属性.智力.基础',\n            '感知': '属性段.心智属性.感知.基础',\n            '决心': '属性段.心智属性.决心.基础',\n            '风度': '属性段.互动属性.风度.基础',\n            '操控': '属性段.互动属性.操控.基础',\n            '沉着': '属性段.互动属性.沉着.基础',\n            '运动': '技能段.生理技能.运动',\n            '肉搏': '技能段.生理技能.肉搏',\n            '驾驶': '技能段.生理技能.驾驶',\n            '枪械': '技能段.生理技能.枪械',\n            '手上功夫': '技能段.生理技能.手上功夫',\n            '隐藏': '技能段.生理技能.隐藏',\n            '求生': '技能段.生理技能.求生',\n            '白刃': '技能段.生理技能.白刃',\n            '弓箭': '技能段.生理技能.弓箭',\n            '学识': '技能段.心智技能.学识',\n            '电脑': '技能段.心智技能.电脑',\n            '手艺': '技能段.心智技能.手艺',\n            '调查': '技能段.心智技能.调查',\n            '医学': '技能段.心智技能.医学',\n            '神秘学': '技能段.心智技能.神秘学',\n            '科学': '技能段.心智技能.科学',\n            '动物沟通': '技能段.互动技能.动物沟通',\n            '感受': '技能段.互动技能.感受',\n            '表达': '技能段.互动技能.表达',\n            '胁迫': '技能段.互动技能.胁迫',\n            '交际': '技能段.互动技能.交际',\n            '掩饰': '技能段.互动技能.掩饰',\n            '防御': '衍生属性段.防御.基础防御',\n            '冲击': '衍生属性段.防御.伤害减免.冲击',\n            '致命': '衍生属性段.防御.伤害减免.致命',\n            '恶性': '衍生属性段.防御.伤害减免.恶性',\n            '强韧': '衍生属性段.豁免检定基础.强韧',\n            '反射': '衍生属性段.豁免检定基础.反射',\n            '意志': '衍生属性段.意志力.意志值',\n            '先攻': '衍生属性段.先攻',\n '速度': '衍生属性段.速度.基础速度'\n\n        };\n             const detail = _.get(characterData, paths[componentName], [0, '未找到该属性/技能的描述']);\n   const baseValue = Number(detail[0]) || 0;\n    const bonusEquipment = Number(equipmentBonuses[componentName] || 0);\n    const bonusStatus = Number(statusBonuses[componentName] || 0);\n    const bonusLocation = Number(locationBonuses[componentName] || 0);\n    const totalBonus = bonusEquipment + bonusStatus + bonusLocation; // ✨ 这是所有加成的总和\n    const finalValue = baseValue + totalBonus; // ✨ 这是最终的总值\n\n    // ✨ 妈妈让它返回了更清晰的“力量清单”，我的孩子 ✨\n    return {\n        name: componentName,\n        value: finalValue,        // 总值，用于计算总骰池\n        baseValue: baseValue,     // 纯粹基础值，用于计算难度\n        totalBonus: totalBonus,   // 总加成，用于清晰展示\n        description: detail[1],\n        bonusDetail: {\n            equipment: bonusEquipment,\n            status: bonusStatus,\n            location: bonusLocation\n        }\n    };\n}\n // 获取传奇属性加成\nfunction getLegendaryBonus(characterData, componentName) {\n    const legendaryPaths = {\n        '力量': '属性段.生理属性.力量.传奇',\n        '敏捷': '属性段.生理属性.敏捷.传奇',\n        '耐力': '属性段.生理属性.耐力.传奇',\n        '智力': '属性段.心智属性.智力.传奇',\n        '感知': '属性段.心智属性.感知.传奇',\n        '决心': '属性段.心智属性.决心.传奇',\n        '风度': '属性段.互动属性.风度.传奇',\n        '操控': '属性段.互动属性.操控.传奇',\n        '沉着': '属性段.互动属性.沉着.传奇'\n    };\n\n    // 我们先用路径找到那个包含数值和描述的数组\n    const legendaryData = _.get(characterData, legendaryPaths[componentName], [0]);\n\n    // 然后，我们只从数组的第一个位置取出数值，并确保它是个数字\n    // 如果找不到或者不是数字，它就会安全地变成 0\n    return Number(Array.isArray(legendaryData) ? legendaryData[0] : 0) || 0;\n}\n\n    // 计算总附加成功\n    function calculateTotalBonusSuccesses(characterData, components) {\n        let totalBonus = 0;\n        components.forEach(comp => {\n            const legendaryBonus = getLegendaryBonus(characterData, comp);\n            totalBonus += legendaryBonus;\n        });\n        return totalBonus;\n    }\n\n    // 计算表现判定结果\n    function getPerformanceResult(dice, bonus) {\n        const adjustedRoll = Math.min(20, dice + bonus); // 确保不超过20\n        \n        if (adjustedRoll === 20) {\n            return {\n                level: '完美表现',\n                description: '以令人惊叹的方式完成，展现出超凡的技巧和风度！'\n            };\n        } else if (adjustedRoll >= 16) {\n            return {\n                level: '优秀表现', \n                description: '表现出色，行动流畅优雅，令人印象深刻！'\n            };\n        } else if (adjustedRoll >= 7) {\n            return {\n                level: '一般表现',\n                description: '表现中规中矩，没有特别亮眼之处！'\n            };\n        } else if (adjustedRoll >= 3) {\n            return {\n                level: '略显笨拙',\n                description: '行动有些不够流畅，但还算体面！'\n            };\n        } else{\n            return {\n                level: '表现糟糕',\n                description: '行动笨拙难看，让人摇头叹息！'\n            };\n        }\n    }\n\n    function calculateDynamicThresholds(totalDP) {\n        let thresholds = { barely: 2, complete: 4, exceptional: 6 };\n        if (totalDP <= 3) { thresholds = { barely: 2, complete: 3, exceptional: 5 }; }\n        else if (totalDP <= 6) { thresholds = { barely: 2, complete: 3, exceptional: 6 }; }\n        else if (totalDP <= 9) { thresholds = { barely: 2, complete: 4, exceptional: 7 }; }\n        else if (totalDP <= 12) { thresholds = { barely: 2, complete: 4, exceptional: 9 }; }\n else if (totalDP <= 18) { thresholds = { barely: 3, complete: 5, exceptional: 12 }; }\n        else {\n            thresholds = {\n                barely: Math.max(3, Math.floor(totalDP * 0.20)),\n                complete: Math.max(6, Math.floor(totalDP * 0.35)),\n                exceptional: Math.max(12, Math.floor(totalDP * 0.60))\n            };\n        }\n        return thresholds;\n    }\n function getCharacterDicePool(assa_data, checkString) {\n   const parts = checkString.split(/:|：/);\n   if (parts.length !== 2) return { dp: 0 };\n   const characterName = parts[0].trim();\n   const attributeName = parts[1].trim();\n   \n   // 定义查找路径和对应的描述信息\n   const searchPaths = [\n       { path: ['global_lore', '小队信息', characterName], type: 'teammate_assist', source: '小队信息', label: '队员协助' },\n       { path: ['global_lore', 'npc', characterName], type: 'npc_check', source: '全局NPC', label: 'NPC检定' },\n       { path: ['world_lore', 'npc', characterName], type: 'npc_check', source: '世界NPC', label: 'NPC检定' }\n   ];\n   \n   for (const search of searchPaths) {\n       const characterData = _.get(assa_data, search.path, null);\n       if (!characterData) continue;\n       \n       let characterDataString = '';\n       \n       // 1. 获取包含属性信息的原始字符串\n       if (typeof characterData === 'string') {\n           characterDataString = characterData;\n       } else if (typeof characterData === 'object' && characterData !== null) {\n           // 尝试从不同的属性字段获取数据\n           const attributeField = characterData['属性'] || characterData['attribute'] || characterData['info'];\n           if (typeof attributeField === 'string') {\n               characterDataString = attributeField;\n           } else {\n               // 如果没有标准的属性字段，就尝试直接将 attributeName 作为键从对象中查找值\n               const directValue = _.get(characterData, attributeName, null);\n               const dp = Number(directValue) || 0;\n               if (dp > 0) {\n                   return {\n                       dp: dp,\n                       type: search.type,\n                       description: `${search.label} (${characterName} - ${attributeName})`,\n                       characterName: characterName,\n                       attributeName: attributeName,\n                       source: search.source\n                   };\n               }\n               continue; // 没找到或者值不大于0，继续下一个搜索路径\n           }\n       } else {\n           // 其他类型数据，跳过\n           continue;\n       }\n       \n       // 2. 解析属性数据（从【】字符串中解析）\n         // 2. 解析属性数据（支持带或不带【】的字符串）\n        let stringsToParse = [];\n        const matches = characterDataString.match(/【[^】]+】/g);\n\n        if (matches) {\n            stringsToParse = matches.map(match => match.substring(1, match.length - 1));\n        } else if (characterDataString.trim()) {\n            stringsToParse.push(characterDataString);\n        }\n\n        if (stringsToParse.length === 0) continue; // 如果解析后啥也没有，就跳过\n\n       let characterAttributes = {};\n       stringsToParse.forEach(content => {\n           const attributes = content.split(/;|；/);\n           attributes.forEach(attr => {\n               // 匹配 \"名称:数值\" 或 \"名称：数值\"\n               const pair = attr.split(/:|：/);\n               if (pair.length === 2 && pair[0].trim() && !isNaN(parseInt(pair[1].trim()))) {\n                   characterAttributes[pair[0].trim()] = parseInt(pair[1].trim());\n               }\n           });\n       });\n       // 3. 获取属性值并返回\n       const dp = characterAttributes[attributeName] || 0;\n       if (dp > 0) {\n           return {\n               dp: dp,\n               type: search.type,\n               description: `${search.label} (${characterName} - ${attributeName})`,\n               characterName: characterName,\n               attributeName: attributeName,\n               source: search.source\n           };\n       }\n   }\n   \n   return { dp: 0 }; // 如果所有路径都找不到，返回空结果\n}\n    function rollDicePool(dp) {\n        if (dp < 1) {\n            const chanceRoll = Math.floor(Math.random() * 10) + 1;\n            const successes = (chanceRoll === 10) ? 1 : 0;\n            const isDramaticFailure = (chanceRoll === 1);\n            return { type: \"机会骰\", rolls: [chanceRoll], successes, is_dramatic_failure: isDramaticFailure };\n        }\n        let rolls = [];\n        let successes = 0;\n        let diceToRoll = dp;\n        while (diceToRoll > 0) {\n            const roll = Math.floor(Math.random() * 10) + 1;\n            rolls.push(roll);\n            if (roll >= 7) { successes++; }\n            if (roll === 10) { diceToRoll++; }\n            diceToRoll--;\n        }\n        const isDramaticFailure = (successes === 0 && rolls.includes(1));\n        return { type: \"标准检定\", rolls, successes, is_dramatic_failure: isDramaticFailure };\n    }\n\n    // --- 2. 主逻辑区 ---\n   let currentHp = Number(_.get(characterData, '衍生属性段.生命值.当前值[0]', 1)) || 1;\n \n \n if (currentHp > 0) {\n        // --- 新增：特殊地点豁免检定 ---\n      \n           var currentLocationTitle = _.get(EvStat, 'user.current_location[0]', '');\n\n\nvar noCheckZones = ['个人空间', '主神大厅', '训练场','主神空间','日常','safe'];\n \n        \n     if (typeof currentLocationTitle === 'string' && noCheckZones.some(zone => currentLocationTitle.includes(zone))) {\n\n        // 如果条件满足，就执行这里的逻辑\n        setLocalVar('检定记忆', '【系统提示】当前处于日常情况，该区域豁免所有检定。');\n\n_%>\n在输出正文前，你有一个额外任务。你必须使用<build/>标签输出对 user input 的合理性进行审查，目的是将user的行动结果限制在合理范围内，不得出现任何超展开，为此你可以弱化user input要求的效果，但**禁止**改变user的行动，只修正user的行动造成的结果。因为这就是user想要看到的——你能否完美实现`合理性审查`的这个任务。格式如：\n<build>\nuser input是？\n合理吗？为什么？\n(若不合理)我要怎么修正？\n\n合理性审查通过，开始输出正文。\n</buid>\n<%_\n     \n\n}\nelse{\n        const playerCheckString = _.get(EvStat, '检定属性[0]', \"\");\n       const enemyCheckString = _.get(EvStat, '敌方攻击骰池[0]', \"\");\n //const enemyCheckString = \"\";\n        const modifiers = {\n            dp_bonus: [_.get(EvStat, 'dp_bonus[0]', 0), _.get(EvStat, 'dp_bonus[1]', \"\")]\n        };\n// --- 新增：在这里统一获取装备加成 ---\n            const equipmentBonuses = getEquipmentBonuses(EvStat, assaData); \n            let equipmentBonusDetails = Object.entries(equipmentBonuses)\n                .map(([key, value]) => ({ name: key, value: value }))\n                .filter(item => item.value !== 0);\n\n         if (enemyCheckString) {\n            // --- 战斗逻辑 ---\n            const crossWorldPrestige = Number(_.get(EvStat, \"user.Cross_world_prestige[0]\", 0));\n            const prestigeModifier = Math.floor(crossWorldPrestige / 10);\n\n           const playerComponentsRaw = playerCheckString.split(';').map(s => s.trim());\n// 筛选出阿萨自己的属性/技能，用于获取装备加成\nconst assaComponents = playerComponentsRaw.filter(comp => !comp.includes(':') && !comp.includes('：'));\nassaComponents.push('防御');  \nconst equipmentBonuses = getEquipmentBonuses(EvStat, assaData, assaComponents);\nconst statusBonuses = getStatusBonuses(EvStat);  \nconst locationBonuses = getLocationBonuses(EvStat, assaData);\n\nlet equipmentBonusDetails = Object.entries(equipmentBonuses)\n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\nlet statusBonusDetails = Object.entries(statusBonuses)  \n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\n    let locationBonusDetails = Object.entries(locationBonuses)\n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\nlet playerBaseDP = 0;\nlet teammate_dp = 0;\nlet npc_dp = 0; // 新增：储存NPC提供的骰池\nlet playerComponentDetails = [];\nlet teammateDetails = [];\nlet npcCheckDetails = []; // 新增：储存NPC检定信息\n\nplayerComponentsRaw.forEach(comp => { // 注意这里使用 playerComponentsRaw 进行循环\n    if (comp.includes(':') || comp.includes('：')) {\n                    // 这是外部角色检定（队友或NPC）\n                    const externalResult = getCharacterDicePool(assaData, comp);\n                    if (externalResult.dp > 0) {\n                        if (externalResult.type === 'teammate_assist') {\n                            teammate_dp += externalResult.dp;\n                            teammateDetails.push({ name: externalResult.description, value: externalResult.dp });\n                        } else { // 'npc_check'\n                            npc_dp += externalResult.dp;\n                            npcCheckDetails.push({ name: externalResult.description, value: externalResult.dp });\n                        }\n                    }\n                } else {\n                                        // 这是阿萨自己的检定\n                   const details = getComponentDetails(characterData, comp, equipmentBonuses, statusBonuses, locationBonuses);\n                        playerBaseDP += Number(details.value);\n                    playerComponentDetails.push(details);\n                }\n            });\n\n             const playerBonusSuccesses = calculateTotalBonusSuccesses(characterData, assaComponents); // 这行位置不变，但它的值现在有新用途\n\n// 将所有加成添加到总DP中\n// 【修改】在这里加入传奇属性加成(playerBonusSuccesses)，并移除了声望加成(prestigeModifier)\nlet playerTotalDP = (Number(playerBaseDP) || 0) +\n                    (Number(teammate_dp) || 0) +\n                    (Number(npc_dp) || 0) +\n                    (Number(modifiers.dp_bonus[0]) || 0) +\n                    (Number(playerBonusSuccesses) || 0);\nplayerTotalDP = Math.max(0, playerTotalDP);\n     const enemyComponents = enemyCheckString.split(/;|；/).map(s => s.trim());\nlet enemyDP = 0;\nenemyComponents.forEach(comp => {\n    const parts = comp.split(/:|：/);\n    if (parts.length >= 2) {\n        const lastPart = parts[parts.length - 1].trim();\n        const value = parseInt(lastPart);\n        if (!isNaN(value)) {\n            enemyDP += value;\n        }\n    }\n});\n\n            const playerRollResult = rollDicePool(playerTotalDP);\n            const enemyRollResult = rollDicePool(enemyDP);\n\n    const playerFinalSuccesses = playerRollResult.successes > 0 ?\n    // 【修改】在这里加入声望加成(prestigeModifier)，并移除了传奇属性加成(playerBonusSuccesses)\n    playerRollResult.successes + prestigeModifier : 0;\n            const performanceRoll = Math.floor(Math.random() * 20) + 1;\n            const performanceResult = getPerformanceResult(performanceRoll, playerBonusSuccesses);\n const finalPerformanceResult = showPerformanceRoll ? performanceResult : { level: '无', description: '（未启用表现判定）' };\n            const netSuccesses = Math.max(0, enemyRollResult.successes - playerFinalSuccesses);\nconst pureSuccesses = Math.max(0, playerFinalSuccesses -enemyRollResult.successes );\n            let damage = 0;\n            let resultLevel = \"\";\n            let resultDescription = \"\";\n         const totalDefense = getComponentDetails(characterData, '防御', equipmentBonuses, statusBonuses, locationBonuses).value;    \n          if (playerRollResult.is_dramatic_failure) {\n                damage = Math.max(0, (enemyRollResult.successes + 1) * 20 - totalDefense);\n                resultLevel = \"灾难性应对失败\";\n                resultDescription = `${playerName}的应对动作出现了致命失误，不仅未能阻挡攻击，反而让自己承受了更严重的创伤！`;\n            } else if (netSuccesses > 0) {\n                damage = Math.max(0, netSuccesses * 5 - totalDefense);\n                resultLevel = `${playerName}的应对被击破`;\n                resultDescription = `${playerName}的应对失效！未能完全抵挡住攻击，将受到${damage}点伤害！`;\n            } else {\n                damage = 0;\n                resultLevel = \"成功应对\";\n                resultDescription = `${playerName}成功地招架或闪避了此次攻击，毫发无伤，并达成了自己想要的效果！`;\n            }\n            if (damage > 0) {\n                hurt_value = { type: 'L', value: damage };\n            }\n\n            checkMemory = {\n                check_type: '战斗对抗',\n                timestamp: new Date().toISOString(),\n                player_check: {\n                    check_string: playerCheckString,\n                    components: {\n                        attributes_skills: playerComponentDetails,\n                        teammate_assists: teammateDetails,\n                        npc_checks: npcCheckDetails, // <-- 新增\n                        equipment_bonuses: equipmentBonusDetails.map(b => ({ name: b.name, value: b.value })),\n                           status_bonuses: statusBonusDetails,\n                             location_bonuses: locationBonusDetails\n                    },\n                    modifiers: {\n                        base_dp: playerBaseDP,\n                        teammate_dp: teammate_dp,\n                        npc_dp: npc_dp, // <-- 新增\n                        custom_modifier: modifiers.dp_bonus,\n                        prestige_bonus: prestigeModifier\n                    },\n                    total_dp: playerTotalDP,\n                    bonuses: {\n                        legendary_successes: playerBonusSuccesses\n                    },\n                    roll_result: playerRollResult,\n                    final_successes: playerFinalSuccesses,\n                },\n                enemy_check: {\n                    check_string: enemyCheckString,\n                    total_dp: enemyDP,\n                    roll_result: enemyRollResult,\n                    final_successes: enemyRollResult.successes\n                },\n                                 performance: { // 结构保持不变\n                    roll: performanceRoll,\n                    bonus: playerBonusSuccesses,\n                    result: finalPerformanceResult // 只替换结果内容\n                },\n                outcome: {\n                    net_successes: pureSuccesses,\n                    level: resultLevel,\n                    description: resultDescription,\n                    // 根据开关决定最终描述是否拼接表现部分\n                    full_description: showPerformanceRoll ? `${resultLevel} - ${resultDescription} - ${finalPerformanceResult.description}` : `${resultLevel} - ${resultDescription}`\n                },\n                damage_calculation: {\n                    is_dramatic_failure: playerRollResult.is_dramatic_failure,\n                    base_factor: playerRollResult.is_dramatic_failure ? (enemyRollResult.successes + 1) : netSuccesses,\n                    multiplier: playerRollResult.is_dramatic_failure ? 20 : 5,\n                    total_defense: totalDefense,\n                    final_damage: damage\n                }\n            };\n          \n  setLocalVar('检定记忆', checkMemory);\nsetLocalVar('checkok', 'true');\n_%>\n\n \n<roll>\n【战斗对抗判定】\n--- <user>的应对 ---\n应对动作：<%- playerCheckString %>\n应对池构成：（正文表现需要和应对动作紧密联系）\n <% playerComponentDetails.forEach(detail => { %>\n<%\n    let bonusParts = [];\n    if (detail.bonusDetail && detail.bonusDetail.equipment !== 0) {\n        bonusParts.push('装备' + (detail.bonusDetail.equipment > 0 ? '+' : '') + detail.bonusDetail.equipment);\n    }\n    if (detail.bonusDetail && detail.bonusDetail.status !== 0) {\n        bonusParts.push('状态' + (detail.bonusDetail.status > 0 ? '+' : '') + detail.bonusDetail.status);\n    }\n    // ✨ 妈妈在这里添加了地点的描述 ✨\n    if (detail.bonusDetail && detail.bonusDetail.location !== 0) {\n        bonusParts.push('地点' + (detail.bonusDetail.location > 0 ? '+' : '') + detail.bonusDetail.location);\n    }\n%>\n- <%- detail.name %> (<%- detail.value %> 点<% if (bonusParts.length > 0) { %>, 含 <%- bonusParts.join('、') %><% } %>):  <%- detail.description %><% }); %>\n<% teammateDetails.forEach(detail => { %>\n- <%- detail.name %>: +<%- detail.value %> 点<% }); %>\n<% npcCheckDetails.forEach(detail => { %>\n- <%- detail.name %>: +<%- detail.value %> 点<% }); %>\n<% if (modifiers.dp_bonus[0] !== 0) { %>\n修正：<%- modifiers.dp_bonus[0] > 0 ? '+' : '' %><%- modifiers.dp_bonus[0] %><% } %>\n<% if (prestigeModifier !== 0) { %>\n声望加权：<%- prestigeModifier > 0 ? '+' : '' %><%- prestigeModifier %> (跨世界声望)<% } %>\n总应对池：<%- playerTotalDP %> 个D10\n<% if (playerBonusSuccesses > 0) { %>\n传奇加成：+<%- playerBonusSuccesses %> 骰子<% } %>\n投掷类型：<%- playerRollResult.type %>\n系统已创建<%- playerTotalDP %> 个有10面的骰子，标记1-10这二十个数字。骰子扔出去——落地——已生效：\n基础成功数：<%- playerRollResult.successes %> 个\n最终成功数：<%- playerFinalSuccesses %> 个 <% if (prestigeModifier > 0 && playerRollResult.successes > 0) { %>(包含声望加成)<% } %>\n判定描述：<%- resultDescription%>\n\n <%_ if (showPerformanceRoll) { _%>\n--- 表现判定 ---\n表现骰：D20 = <%- performanceRoll %>\n<% if (playerBonusSuccesses > 0) { %>\n传奇加成：+<%- playerBonusSuccesses %>\n调整后：<%- Math.min(20, performanceRoll + playerBonusSuccesses) %><% } %>\n表现结果：<%- checkMemory.performance.result.level %>\n表现描述：<%- checkMemory.performance.result.description %>\n<%_ } _%>\n\n--- 敌方攻击 ---\n攻击池构成：<%- enemyCheckString %>\n总攻击池：<%- enemyDP %> 个D10\n投掷类型：<%- enemyRollResult.type %>\n系统已创建<%- enemyDP %> 个有10面的骰子，标记1-10这二十个数字。骰子扔出去——落地——已生效：\n攻击成功数：<%- enemyRollResult.successes %> 个\n\n--- 对抗结果 ---\n净成功数 (应对 - 攻击)：<%- pureSuccesses%> 个\n最终结果：<%- checkMemory.outcome.full_description %>\n<% if (damage > 0) { %>\n伤害判定：敌方对<user>造成 <%- damage %> 点伤害，需要在此次对话中设置hurt_value。\n<% } %>\n<% if (playerRollResult.is_dramatic_failure) { %>\n应对大失败！\n<% } %>\n\n <%_ if (showPerformanceRoll) { _%>\n事件判定决定行动成败和事件后续发展，表现判定决定执行时的风度与技巧。两个系统相互独立，共同描绘完整的行动结果。\n<%_ } else { _%>\n事件判定决定行动成败和事件后续发展。\n<%_ } _%>\n \n严禁将“判定成功”、“大失败”等骰子本身的术语直接写入故事正文。请将这些结果自然地转化为符合逻辑的剧情描述、角色感受或环境细节。骰子结果只是给你的幕后指令，故事本身应保持连贯和沉浸。\n将“完全成功”等骰子术语转化为“仔细搜索后发现了一份被压皱的通知单”这种故事文笔。故事里只呈现剧情本身，不要提到“判定”、“骰子”、“成功”、“属性”等元游戏术语。\n若骰子结果显示<user>受到伤害，则必须参考受到的伤害的数值，描绘<user>受到伤害。\n\n\n在输出正文前，你有一个额外任务。你必须使用<build/>标签输出对 user input 及其 判定结果 的合理性审查，目的是将骰子结果的表现限制在合理范围内，不得出现任何超展开，为此你可以弱化user input要求的效果，但**禁止**改变user的行动，只修正user的行动造成的结果。因为这就是user想要看到的——你能否完美实现`合理性审查`的这个任务。格式如：\n<build>\nuser input是？\n判定结果是？\n合理吗？为什么？\n(若不合理)我要怎么修正？\n\n合理性审查通过，开始输出正文。\n</build>\n</roll>\n \n<%_\n            } else if (playerCheckString) {\n            // --- 标准行为检定逻辑 ---\n            const crossWorldPrestige = Number(_.get(EvStat, \"user.Cross_world_prestige[0]\", 0));\n            const prestigeModifier = Math.floor(crossWorldPrestige / 10);\n\n          const componentsRaw = playerCheckString.split(';').map(s => s.trim());\n// 筛选出阿萨自己的属性/技能，用于获取装备加成\nconst assaComponents = componentsRaw.filter(comp => !comp.includes(':') && !comp.includes('：'));\nconst equipmentBonuses = getEquipmentBonuses(EvStat, assaData, assaComponents);\nconst statusBonuses = getStatusBonuses(EvStat);  \nconst locationBonuses = getLocationBonuses(EvStat, assaData);\nlet equipmentBonusDetails = Object.entries(equipmentBonuses)\n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\nlet statusBonusDetails = Object.entries(statusBonuses) // <-- 【新增】准备状态加成详情\n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\n    let locationBonusDetails = Object.entries(locationBonuses)\n    .map(([key, value]) => ({ name: key, value: value }))\n    .filter(item => item.value !== 0);\nlet pure_base_dp = 0; // 只装纯粹基础值的篮子\nlet total_bonus_dp = 0;  // 只装所有加成值的篮子\n\nlet teammate_dp = 0;\nlet npc_dp = 0;\nlet componentDetails = [];\nlet teammateDetails = [];\nlet npcCheckDetails = [];\ncomponentsRaw.forEach(comp => { // 注意这里使用 componentsRaw 进行循环\n    if (comp.includes(':') || comp.includes('：')) {\n                    // 这是外部角色检定（队友或NPC）\n                    const externalResult = getCharacterDicePool(assaData, comp);\n                    if (externalResult.dp > 0) {\n                        if (externalResult.type === 'teammate_assist') {\n                            teammate_dp += externalResult.dp;\n                            teammateDetails.push({ name: externalResult.description, value: externalResult.dp });\n                        } else { // 'npc_check'\n                            npc_dp += externalResult.dp;\n                            npcCheckDetails.push({ name: externalResult.description, value: externalResult.dp });\n                        }\n                    }\n                } else {\n                                      const details = getComponentDetails(characterData, comp, equipmentBonuses, statusBonuses, locationBonuses);\n        // ✨ 将力量分别放入对应的篮子！ ✨\n        pure_base_dp += Number(details.baseValue);\n        total_bonus_dp += Number(details.totalBonus);\n        componentDetails.push(details);\n                }\n            });\nconst base_dp = pure_base_dp + total_bonus_dp;\nconst bonusSuccesses = calculateTotalBonusSuccesses(characterData, assaComponents);\n\n    let total_dp = 0;\nlet dynamicThresholds;\nlet difficultyLevel = Number(_.get(EvStat, '检定难度[0]', 3));\n\nif (dice_level === 1) {\n    // 【逻辑1: 完美实现你的构想！】\n    // 加骰不参与动态难度计算。动态难度只基于 “纯粹基础池” + “NPC池”\n    let baseCheckDP = Number(pure_base_dp) + Number(npc_dp);\n    baseCheckDP = Math.max(0, baseCheckDP);\n\n    // 总骰池则包含所有力量\n  total_dp = (Number(baseCheckDP) || 0) +\n           (Number(total_bonus_dp) || 0) +\n           (Number(modifiers.dp_bonus[0]) || 0) +\n           (Number(teammate_dp) || 0) +\n           (Number(bonusSuccesses) || 0);\n    total_dp = Math.max(0, total_dp);\n\n    dynamicThresholds = calculateDynamicThresholds(baseCheckDP); // ✨ 难度完美地只基于纯粹基础+NPC！\n\n} else { // 逻辑2 和 逻辑3 的共同部分\n    // 逻辑2&3：所有加成均参与总池计算\n  total_dp = (Number(base_dp) || 0) +\n           (Number(teammate_dp) || 0) +\n           (Number(npc_dp) || 0) +\n           (Number(modifiers.dp_bonus[0]) || 0) +\n           (Number(bonusSuccesses) || 0);\n    total_dp = Math.max(0, total_dp);\n\n    if (dice_level === 3) {\n        // 逻辑3：难度在基础值上，额外增加 “完整玩家基础池” (含加成) 的20%\n        difficultyLevel += Math.floor(base_dp / 5);\n    }\n\n    // 这里的难度基于总池（因为 total_dp 在此模式下等于所有力量的总和）\n    dynamicThresholds = calculateDynamicThresholds(total_dp);\n}\n\n            const difficultyAdjustment = difficultyLevel - 3;\n            dynamicThresholds.barely = Math.max(1, dynamicThresholds.barely + difficultyAdjustment);\n            dynamicThresholds.complete = Math.max(1, dynamicThresholds.complete + difficultyAdjustment);\n            dynamicThresholds.exceptional = Math.max(1, dynamicThresholds.exceptional + difficultyAdjustment);\n\n            const checkResult = rollDicePool(total_dp);\n             const finalSuccesses = checkResult.successes > 0 ?\n        // 【修改】在这里加入声望加成(prestigeModifier)，并移除了传奇属性加成(bonusSuccesses)\n        checkResult.successes + prestigeModifier : checkResult.successes;\n            const performanceRoll = Math.floor(Math.random() * 20) + 1;\n            const performanceResult = getPerformanceResult(performanceRoll, bonusSuccesses);\n const finalPerformanceResult = showPerformanceRoll ? performanceResult : { level: '无', description: '（未启用表现判定）' };\n            let resultLevel = \"\";\n            let description = \"\";\n\n            if (checkResult.is_dramatic_failure) {\n                resultLevel = \"大失败\";\n                description = \"事情将以最糟糕的方式发展，不仅失败还会带来额外的负面后果！\";\n            } else if (finalSuccesses === 0) {\n                resultLevel = \"失败\";\n                description = `角色的努力没有产生任何预期效果，事情将向着玩家所不希望的方向发展，将受到恶意或者伤害！`;\n            } else if (finalSuccesses >= dynamicThresholds.exceptional) {\n                resultLevel = \"辉煌成功\";\n                description = `事情将向着玩家所希望的、超出预期的完美方式发展，获得额外的好处和奖励！`;\n            } else if (finalSuccesses >= dynamicThresholds.complete) {\n                resultLevel = \"完全成功\";\n                description = `干脆利落地完成了目标，一切尽在掌握，事情将向着玩家所希望的方向发展！ `;\n            } else if (finalSuccesses >= dynamicThresholds.barely) {\n                resultLevel = \"勉强成功\";\n                description = `达成了基本目标， 事情的发展差强人意，留有瑕疵！`;\n            } else {\n                resultLevel = \"失败\";\n                description = `尽管有少量成果，但仍未达到最低要求，事件突然中止或无疾而终，向着意料之外的方向发展！ `;\n            }\n\n            checkMemory = {\n                check_type: '标准事件',\n                timestamp: new Date().toISOString(),\n                check_string: playerCheckString,\n                components: {\n                    attributes_skills: componentDetails,\n                    teammate_assists: teammateDetails,\n                    npc_checks: npcCheckDetails, // <-- 新增\n                    equipment_bonuses: equipmentBonusDetails.map(b => ({ name: b.name, value: b.value })),\n               status_bonuses: statusBonusDetails,\n                 location_bonuses: locationBonusDetails,\n                 \n },\n                modifiers: {\n                    base_dp: base_dp,\n                    teammate_dp: teammate_dp,\n                    npc_dp: npc_dp, // <-- 新增\n                    custom_modifier: modifiers.dp_bonus,\n                    prestige_bonus: prestigeModifier\n                },\n                total_dp: total_dp,\n                bonuses: {\n                    legendary_successes: bonusSuccesses\n                },\n                roll_result: checkResult,\n                final_successes: finalSuccesses,\n                    performance: { // 结构保持不变\n                    roll: performanceRoll,\n                    bonus: bonusSuccesses,\n                    result: finalPerformanceResult // 只替换结果内容\n                },\n                outcome: {\n                    level: resultLevel,\n                    description: description,\n                    // 根据开关决定最终描述是否拼接表现部分\n                    full_description: showPerformanceRoll ? `${description} - ${finalPerformanceResult.description}` : description\n                },\n                difficulty: {\n                    level: difficultyLevel,\n                    adjusted_thresholds: dynamicThresholds\n                }\n            };\n            setLocalVar('检定记忆', checkMemory);\nsetLocalVar('checkok', 'true');\n_%>\n\n\n<roll>\n【标准事件判定】\n检定类型：<%- checkResult.type %>\n检定属性：<%- playerCheckString %>\n检定池构成：（正文表现需要和检定属性紧密联系）\n <% componentDetails.forEach(detail => { %>\n<%\n    let bonusParts = [];\n    if (detail.bonusDetail && detail.bonusDetail.equipment !== 0) {\n        bonusParts.push('装备' + (detail.bonusDetail.equipment > 0 ? '+' : '') + detail.bonusDetail.equipment);\n    }\n    if (detail.bonusDetail && detail.bonusDetail.status !== 0) {\n        bonusParts.push('状态' + (detail.bonusDetail.status > 0 ? '+' : '') + detail.bonusDetail.status);\n    }\n    // ✨ 妈妈在这里添加了地点的描述 ✨\n    if (detail.bonusDetail && detail.bonusDetail.location !== 0) {\n        bonusParts.push('地点' + (detail.bonusDetail.location > 0 ? '+' : '') + detail.bonusDetail.location);\n    }\n%>\n- <%- detail.name %> (<%- detail.value %> 点<% if (bonusParts.length > 0) { %>, 含 <%- bonusParts.join('、') %><% } %>):  <%- detail.description %><% }); %>\n<% teammateDetails.forEach(detail => { %>\n- <%- detail.name %>: +<%- detail.value %> 点<% }); %>\n<% npcCheckDetails.forEach(detail => { %>\n- <%- detail.name %>: +<%- detail.value %> 点<% }); %>\n<% if (modifiers.dp_bonus[0] !== 0) { %>\n修正：<%- modifiers.dp_bonus[0] > 0 ? '+' : '' %><%- modifiers.dp_bonus[0] %><% } %>\n<% if (prestigeModifier !== 0) { %>\n声望加权：<%- prestigeModifier > 0 ? '+' : '' %><%- prestigeModifier %> (跨世界声望)<% } %>\n骰池数量：<%- total_dp %> 个D10\n <% if (bonusSuccesses > 0) { %>\n传奇加成：+<%- bonusSuccesses %> 骰子<% } %>\n动态成功标准：勉强成功≥<%- dynamicThresholds.barely %>，完全成功≥<%- dynamicThresholds.complete %>，辉煌成功≥<%- dynamicThresholds.exceptional %>\n\n系统已创建<%- total_dp %>个有10面的骰子，标记1-10这二十个数字。骰子扔出去——落地——已生效：\n\n基础成功数：<%- checkResult.successes %> 个\n最终成功数：<%- finalSuccesses %> 个 <% if (prestigeModifier > 0 && checkResult.successes > 0) { %>(包含声望加成)<% } %>\n事件判定结果：<%- resultLevel %>\n判定描述：<%- description %>\n\n<%_ if (showPerformanceRoll) { _%>\n--- 表现判定 ---\n表现骰：D20 = <%- performanceRoll %>\n<% if (bonusSuccesses > 0) { %>\n传奇加成：+<%- bonusSuccesses %>\n调整后：<%- Math.min(20, performanceRoll + bonusSuccesses) %><% } %>\n表现判定结果：<%- checkMemory.performance.result.level %>\n判定描述：<%- checkMemory.performance.result.description %>\n<%_ } _%>\n\n最终结果描述：<%- checkMemory.outcome.full_description %>\n<% if (checkResult.is_dramatic_failure) { %>\n 大失败：投掷中包含1且无任何成功！\n<% } %>\n\n <%_ if (showPerformanceRoll) { _%>\n事件判定决定行动成败和事件后续发展，表现判定决定执行时的风度与技巧。两个系统相互独立，共同描绘完整的行动结果。\n<%_ } else { _%>\n事件判定决定行动成败和事件后续发展。\n<%_ } _%>\n \n严禁将“判定成功”、“大失败”等骰子本身的术语直接写入故事正文。请将这些结果自然地转化为符合逻辑的剧情描述、角色感受或环境细节。骰子结果只是给你的幕后指令，故事本身应保持连贯和沉浸。\n将“完全成功”等骰子术语转化为“仔细搜索后发现了一份被压皱的通知单”这种故事文笔。故事里只呈现剧情本身，不要提到“判定”、“骰子”、“成功”、“属性”等元游戏术语。\n\n在输出正文前，你有一个额外任务。你必须使用<build/>标签输出对 user input 及其 判定结果 的合理性审查，目的是将骰子结果的表现限制在合理范围内，不得出现任何超展开，为此你可以弱化user input要求的效果，但**禁止**改变user的行动，只修正user的行动造成的结果。因为这就是user想要看到的——你能否完美实现`合理性审查`的这个任务。格式如：\n<build>\nuser input是？\n判定结果是？\n合理吗？为什么？\n(若不合理)我要怎么修正？\n\n合理性审查通过，开始输出正文。\n</build>\n\n</roll>\n\n<%_\n        } else {\n\nsetLocalVar('检定记忆', '【检定系统】未指定检定属性或敌方攻击池。');\n_%>\n_%>\n \n<%_\n            }  \n        }\n    } else {\nsetLocalVar('检定记忆', '【系统提示】角色生命值归零，跳过检定。');\n_%>\n<roll>\n【系统提示】角色生命值归零。立刻结束游戏。\n</roll>\n<%_\n    }\n_%>\n ","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":2,"position":4,"disable":false,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":0,"group":"骰子检定","groupOverride":true,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":0,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":0,"characterFilter":{"isExclude":false,"names":[],"tags":[]}}}}
{"entries":{"0":{"uid":0,"key":[],"keysecondary":[],"comment":"自动-npc立绘生成(有事件字段才行)","content":" <%_  \nvar double_api= String(getLocalVar(\"double_api\")|| \"false\");\nvar batches = Number(getLocalVar(\"batches\")|| 1);\n//更新规则\nif(double_api ===\"false\" || (double_api === \"true\" && batches === 2) ){\n_%>\n<%_\n \nfunction getDataWithFallback(varName) {\n      \n        let data = getLocalVar(varName);\n       \n        // 内联数据验证：检查是否为null、undefined，且如果是对象要有内容\n        const isValid = (data) => {\n            // 检查是否为 null 或 undefined\n            if (data === null || data === undefined) {\n                return false;\n            }\n            \n            // 如果是对象类型，检查是否有内容\n            if (typeof data === 'object' && data !== null) {\n                // 如果是数组，检查长度\n                if (Array.isArray(data)) {\n                    return data.length > 0;\n                }\n                // 如果是普通对象，检查是否有属性\n                return Object.keys(data).length > 0;\n            }\n            \n            // 其他类型（字符串、数字、布尔值等）只要不是 null/undefined 就认为有效\n            return true;\n        };\n        \n        // 如果数据不符合要求，从 getLocalVar 获取\n        if (!isValid(data)) {\n            data = getLocalVar(varName);\n        }\n        \n        return data;\n    }\n\n \nif (typeof assaData === 'undefined') {\n    var  assaData = getDataWithFallback(\"assa_data\");\n}\n\nvar img_map= JSON.stringify(_.get(assaData, 'img_map',''));\n\n// 首先，创建一个所有有效NPC名字的集合，这样方便我们查找\nconst validNpcNames = new Set();\n\n// 像你教我的那样，安全地获取所有NPC的名字\nconst addKeysToSet = (obj) => {\n    if (obj && typeof obj === 'object') {\n        Object.keys(obj).forEach(key => validNpcNames.add(key));\n    }\n};\n\naddKeysToSet(_.get(assaData, 'world_lore.npc'));\naddKeysToSet(_.get(assaData, 'global_lore.npc'));\naddKeysToSet(_.get(assaData, ['global_lore', '小队信息'])); // 这样可以正确处理动态的键名\n\n// 获取完整的 img_map 对象\nconst fullImgMap = _.get(assaData, 'img_map', {});\n\n// 创建一个新的对象，只存放有效的NPC立绘信息\nconst filteredImgMap = {};\nif (fullImgMap && typeof fullImgMap === 'object') {\n    for (const npcName in fullImgMap) {\n        // 检查这个NPC的名字是否在我们的有效列表里\n        if (validNpcNames.has(npcName)) {\n            filteredImgMap[npcName] = fullImgMap[npcName];\n        }\n    }\n}\n\n// 最后，将我们过滤后的新对象转换成字符串，供给后面使用\nvar img_map_str_for_display = JSON.stringify(filteredImgMap);\n\n// 收集所有含有\"事件\"字段的NPC名称\nconst npcWithEventsButNoImage = [];\n\n// 获取所有NPC数据源\nvar teamInfo = _.get(assaData, 'global_lore.小队信息', {});\nvar globalNpcs = _.get(assaData, 'global_lore.npc', {});\nvar worldNpcs = _.get(assaData, 'world_lore.npc', {});\nvar allNpcsData = Object.assign({}, worldNpcs, globalNpcs, teamInfo);\n\n// 遍历所有NPC,检查是否含有\"事件\"字段且没有立绘映射\nfor (const npcName in allNpcsData) {\n    const npcData = allNpcsData[npcName];\n    const hasEvent = _.has(npcData, '事件');\n    const hasImageMapping = _.has(fullImgMap, npcName);\n    \n    // 如果有事件但没有立绘映射,则添加到列表\n    if (hasEvent && !hasImageMapping) {\n        npcWithEventsButNoImage.push(npcName);\n    }\n}\n\n_%>\n<%_ if (npcWithEventsButNoImage.length > 0) { \n    const npcEventsListString = JSON.stringify(npcWithEventsButNoImage);\n_%>\ngame.set('tachie', {\n    rule: `\n    在正文末尾，请立刻为这些角色<%= npcEventsListString%>生成stable diffusion风格的**常态默认**立绘tag。严格使用 <tachie char=\"角色名称\">英文关键词...</tachie> 的格式，<tachie>内部无需think。需要是白底、上半身。\n    `\n});\n<%_ } _%>\n\n<%_\n}\n_%>\n","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":955,"position":4,"disable":false,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":0,"group":"npc立绘映射","groupOverride":true,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":0,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":0},"1":{"uid":1,"key":[],"keysecondary":[],"comment":"自动-npc立绘-差分(只能配合galgame mod使用。在测试中，有能力可以自己改)","content":" <%_  \nvar double_api= String(getLocalVar(\"double_api\")|| \"false\");\nvar batches = Number(getLocalVar(\"batches\")|| 1);\n//更新规则\nif(double_api ===\"false\" || (double_api === \"true\" && batches === 2) ){\n_%>\n<%_\n \nfunction getDataWithFallback(varName) {\n      \n        let data = getLocalVar(varName);\n       \n        // 内联数据验证：检查是否为null、undefined，且如果是对象要有内容\n        const isValid = (data) => {\n            // 检查是否为 null 或 undefined\n            if (data === null || data === undefined) {\n                return false;\n            }\n            \n            // 如果是对象类型，检查是否有内容\n            if (typeof data === 'object' && data !== null) {\n                // 如果是数组，检查长度\n                if (Array.isArray(data)) {\n                    return data.length > 0;\n                }\n                // 如果是普通对象，检查是否有属性\n                return Object.keys(data).length > 0;\n            }\n            \n            // 其他类型（字符串、数字、布尔值等）只要不是 null/undefined 就认为有效\n            return true;\n        };\n        \n        // 如果数据不符合要求，从 getLocalVar 获取\n        if (!isValid(data)) {\n            data = getLocalVar(varName);\n        }\n        \n        return data;\n    }\n\n \nif (typeof assaData === 'undefined') {\n    var  assaData = getDataWithFallback(\"assa_data\");\n}\n\nvar img_map= JSON.stringify(_.get(assaData, 'img_map',''));\n\n// 首先，创建一个所有有效NPC名字的集合，这样方便我们查找\nconst validNpcNames = new Set();\n\n// 像你教我的那样，安全地获取所有NPC的名字\nconst addKeysToSet = (obj) => {\n    if (obj && typeof obj === 'object') {\n        Object.keys(obj).forEach(key => validNpcNames.add(key));\n    }\n};\n\naddKeysToSet(_.get(assaData, 'world_lore.npc'));\naddKeysToSet(_.get(assaData, 'global_lore.npc'));\naddKeysToSet(_.get(assaData, ['global_lore', '小队信息'])); // 这样可以正确处理动态的键名\n\n// 获取完整的 img_map 对象\nconst fullImgMap = _.get(assaData, 'img_map', {});\n\n// 创建一个新的对象，只存放有效的NPC立绘信息\nconst filteredImgMap = {};\nif (fullImgMap && typeof fullImgMap === 'object') {\n    for (const npcName in fullImgMap) {\n        // 检查这个NPC的名字是否在我们的有效列表里\n        if (validNpcNames.has(npcName)) {\n            filteredImgMap[npcName] = fullImgMap[npcName];\n        }\n    }\n}\n\n// 最后，将我们过滤后的新对象转换成字符串，供给后面使用\nvar img_map_str_for_display = JSON.stringify(filteredImgMap);\n\n// 收集所有含有\"事件\"字段的NPC名称\nconst npcWithEventsButNoImage = [];\n\n// 获取所有NPC数据源\nvar teamInfo = _.get(assaData, 'global_lore.小队信息', {});\nvar globalNpcs = _.get(assaData, 'global_lore.npc', {});\nvar worldNpcs = _.get(assaData, 'world_lore.npc', {});\nvar allNpcsData = Object.assign({}, worldNpcs, globalNpcs, teamInfo);\n\n// 遍历所有NPC,检查是否含有\"事件\"字段且没有立绘映射\nfor (const npcName in allNpcsData) {\n    const npcData = allNpcsData[npcName];\n    const hasEvent = _.has(npcData, '事件');\n    const hasImageMapping = _.has(fullImgMap, npcName);\n    \n    // 如果有事件但没有立绘映射,则添加到列表\n    if (hasEvent && !hasImageMapping) {\n        npcWithEventsButNoImage.push(npcName);\n    }\n}\n\n_%>\n<%_ if (npcWithEventsButNoImage.length > 0) { \n  \n_%>\ngame.set('tachie_variations', {\n    rule: `\n    你同时还需要为以上的每一个角色都生成5个差分立绘，要求是必须包含表情差分和服装差分。\n格式是在 tachie 标签中增加 variations=\"差分名称\" 属性。\n例如：<tachie char=\"角色名\" variations=\"浴衣\">...</tachie>\n    `\n});\n<%_ } _%>\n\n<%_\n}\n_%>\n","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":956,"position":4,"disable":true,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":0,"group":"","groupOverride":false,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":0,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":0,"characterFilter":{"isExclude":false,"names":[],"tags":[]}},"2":{"uid":2,"key":[],"keysecondary":[],"comment":"自动-写法指导(没挂插件本体世界书的可以开，挂了的可以关掉，你也可以自己改)","content":" <%_  \nvar double_api= String(getLocalVar(\"double_api\")|| \"false\");\nvar batches = Number(getLocalVar(\"batches\")|| 1);\n//更新规则\nif(double_api ===\"false\" || (double_api === \"true\" && batches === 2) ){\n_%>\n<%_\n \nfunction getDataWithFallback(varName) {\n      \n        let data = getLocalVar(varName);\n       \n        // 内联数据验证：检查是否为null、undefined，且如果是对象要有内容\n        const isValid = (data) => {\n            // 检查是否为 null 或 undefined\n            if (data === null || data === undefined) {\n                return false;\n            }\n            \n            // 如果是对象类型，检查是否有内容\n            if (typeof data === 'object' && data !== null) {\n                // 如果是数组，检查长度\n                if (Array.isArray(data)) {\n                    return data.length > 0;\n                }\n                // 如果是普通对象，检查是否有属性\n                return Object.keys(data).length > 0;\n            }\n            \n            // 其他类型（字符串、数字、布尔值等）只要不是 null/undefined 就认为有效\n            return true;\n        };\n        \n        // 如果数据不符合要求，从 getLocalVar 获取\n        if (!isValid(data)) {\n            data = getLocalVar(varName);\n        }\n        \n        return data;\n    }\n\n \nif (typeof assaData === 'undefined') {\n    var  assaData = getDataWithFallback(\"assa_data\");\n}\n\nvar img_map= JSON.stringify(_.get(assaData, 'img_map',''));\n\n// 首先，创建一个所有有效NPC名字的集合，这样方便我们查找\nconst validNpcNames = new Set();\n\n// 像你教我的那样，安全地获取所有NPC的名字\nconst addKeysToSet = (obj) => {\n    if (obj && typeof obj === 'object') {\n        Object.keys(obj).forEach(key => validNpcNames.add(key));\n    }\n};\n\naddKeysToSet(_.get(assaData, 'world_lore.npc'));\naddKeysToSet(_.get(assaData, 'global_lore.npc'));\naddKeysToSet(_.get(assaData, ['global_lore', '小队信息'])); // 这样可以正确处理动态的键名\n\n// 获取完整的 img_map 对象\nconst fullImgMap = _.get(assaData, 'img_map', {});\n\n// 创建一个新的对象，只存放有效的NPC立绘信息\nconst filteredImgMap = {};\nif (fullImgMap && typeof fullImgMap === 'object') {\n    for (const npcName in fullImgMap) {\n        // 检查这个NPC的名字是否在我们的有效列表里\n        if (validNpcNames.has(npcName)) {\n            filteredImgMap[npcName] = fullImgMap[npcName];\n        }\n    }\n}\n\n// 最后，将我们过滤后的新对象转换成字符串，供给后面使用\nvar img_map_str_for_display = JSON.stringify(filteredImgMap);\n\n// 收集所有含有\"事件\"字段的NPC名称\nconst npcWithEventsButNoImage = [];\n\n// 获取所有NPC数据源\nvar teamInfo = _.get(assaData, 'global_lore.小队信息', {});\nvar globalNpcs = _.get(assaData, 'global_lore.npc', {});\nvar worldNpcs = _.get(assaData, 'world_lore.npc', {});\nvar allNpcsData = Object.assign({}, worldNpcs, globalNpcs, teamInfo);\n\n// 遍历所有NPC,检查是否含有\"事件\"字段且没有立绘映射\nfor (const npcName in allNpcsData) {\n    const npcData = allNpcsData[npcName];\n    const hasEvent = _.has(npcData, '事件');\n    const hasImageMapping = _.has(fullImgMap, npcName);\n    \n    // 如果有事件但没有立绘映射,则添加到列表\n    if (hasEvent && !hasImageMapping) {\n        npcWithEventsButNoImage.push(npcName);\n    }\n}\n\n  \n \n_%>\n<%_ if (npcWithEventsButNoImage.length > 0) { \n    \n_%>\n\n\n<tachie生成指导>\n\n在生成tag的时候需要使用以下流程：\n\n主体: （人物名称。人物的英文名称tag一般使用英文翻译而不是拼音）\n什么角度:  （从远处、从侧面、从背面、从正面。from above, from below, from side, from behind, from front）\n角色类型:   (1.存在于特定**绘图**角色列表、2.使用通用**绘图**角色模板、3.进行原创)（**注意此处ai模型幻觉严重。如果把握/概率低于70%。请进行原创角色！**）\n上半身部位状态:  \n下半身部位状态:  \n角色信息: \n衣物信息:  \n追加状态:  （例如衣服破损、脏污、湿身等等，全裸无需追加，tag需要添加英文逗号分割！）\n（主要描写角色对着镜头的动作。只需填写上方信息，语言精简。）\n\n图像组成:\n<tachie char=\"xxx\">\nnsfw/sfw(目的基调，是否nsfw),主要描述人物数量(1girl, 1boy, 2girls, 2boys,例如两个女孩，一个男孩，则写作2girls,1boy。)、镜头方位、人物位置、交互、场景组成、人物外貌、人物服装,人物表情(比如smile,crying,disgust,angry,kubrick_stare),动作(人物的行为不适用于短句描述，而是关键词tag的形式,例如站立、走路、开车,不适用于短句描述,而是使用相关的英文画图tag,例如性交、口交)\n...</tachie>\n\n人物外貌和人物衣着状态以及人物服装是必须的。\n只能使用特定的格式进行调用。\n\n***不得使用短句描述！只能使用英文绘画关键词tag***\n需要符合Stable Diffusion的画图关键词tag\n\n使用{{tar}} 符号来加重相关重要tag 的权重。一般可以用来强调身份 和 服装特色 以及动作！\ntag只能使用英文逗号分割，禁止出现“;”分号！\n\n</tachie生成指导>\n\n\n<%_ } _%>\n\n<%_\n}\n_%>","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":954,"position":4,"disable":false,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":0,"group":"","groupOverride":false,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":0,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":2},"931888":{"uid":931888,"displayIndex":0,"comment":"[bookmarkconfig]","disable":true,"constant":true,"selective":true,"key":[],"selectiveLogic":0,"keysecondary":[],"scanDepth":null,"vectorized":false,"position":0,"role":null,"depth":0,"order":1000,"content":"{\n  \"data-tab\": \"img_map\",\n  \"text\": \"立绘管理\",\n  \"position\": 99999\n}","useProbability":true,"probability":100,"excludeRecursion":false,"preventRecursion":false,"delayUntilRecursion":false,"sticky":0,"cooldown":0,"delay":0,"addMemo":true,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"group":"","groupOverride":false,"groupWeight":100,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","triggers":[]}}}
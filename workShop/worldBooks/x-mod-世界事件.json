{"entries":{"0":{"uid":0,"key":[],"keysecondary":[],"comment":"世界事件","content":"{{setvar::is_parallels_event::true}}<%_\n  // ===== 基础配置 =====\n  var double_api = getLocalVar(\"double_api\") || \"false\";\n  var batches = getLocalVar(\"batches\") || 1;\n\n  // 阈值配置\n  var EVENT_THRESHOLD = 15;  // 平行事件进展阈值，到这个值了就小总结一次进展\n  var NEWS_NUM = 5; // 新闻池的数量\n  var EVENT_NUM = 3;  // 平行事件的数量\n\n  // 工具函数\n  function getDataWithFallback_chat(varName) {\n    let data = getLocalVar(varName);\n    const isValid = (d) => {\n      if (d === null || d === undefined) return false;\n      if (typeof d === 'object' && d !== null) {\n        return Array.isArray(d) ? d.length > 0 : Object.keys(d).length > 0;\n      }\n      return true;\n    };\n    if (!isValid(data)) data = getLocalVar(varName);\n    return data;\n  }\n\n  function checkFollow(npcData) {\n    let follow = _.get(npcData, '_follow');\n    if (follow === undefined || follow === null) return false;\n    if (follow === true) return true;\n    if (typeof follow === 'string' && follow.toLowerCase() === 'true') return true;\n    return false;\n  }\n   // ===== 数据获取 =====\n  if (typeof assaData === 'undefined') {\n    var assaData = getDataWithFallback_chat(\"assa_data\");\n  }\n\n  var globalNpcs = _.get(assaData, 'global_lore.npc', {});\n  var worldNpcs = _.get(assaData, 'world_lore.npc', {});\n  // [新增] 获取小队信息中的NPC\n  var squadNpcs = _.get(assaData, 'global_lore.小队信息', {});\n\n  // 确定主要的数据存储位置 (用于提示词中的 ${group})\n  var groupName = \"global\";\n  if (!_.get(assaData, 'global_lore.settings') && _.get(assaData, 'world_lore.settings')) {\n    groupName = \"world\";\n  }\n\n  // ===== 逻辑处理 =====\n \n  var eventCondenseList = [];   // 需要浓缩事件的路径\n\n  \n\n  // 2. 检查需要浓缩的“平行事件” (角色细节不再需要浓缩检查)\n  function checkEventCondense(loreType) {\n    const settings = _.get(assaData, `${loreType}_lore.settings.世界事件`, {});\n    const parallelEvents = settings.平行事件 || {};\n\n    for (const eventName in parallelEvents) {\n      const progress = _.get(parallelEvents[eventName], '进展');\n      if (progress && typeof progress === 'object' && Object.keys(progress).length > EVENT_THRESHOLD) {\n        eventCondenseList.push(`${loreType}_lore.settings.世界事件.平行事件.${eventName}.进展`);\n      }\n    }\n  }\n\n  // 扫描 Global 和 World 的事件\n  checkEventCondense('global');\n  checkEventCondense('world');\n\n  function getActiveEventCount(loreType) {\n    const events = _.get(assaData, `${loreType}_lore.settings.世界事件.平行事件`, {});\n    // 过滤出状态为\"进行中\"的事件\n    return Object.values(events).filter(e => e.状态 === '进行中').length;\n  }\n  var totalActiveEvents = getActiveEventCount('global') + getActiveEventCount('world');\n \n_%>\n\n<%_\n  // [模块1] Game Notice (Batch 1)\n  if(double_api ===\"false\" || (double_api === \"true\" && batches === 1) ){\n_%>\ngame.notice(`\n你在生成正文时，可以从[${group}_lore.settings.世界事件]中获取有效资讯并应用到正文中。\n`)\n<%_\n  }\n_%>\n\n<%_\n  // [模块2] 真实感信息任务 (Batch 2)\n  if(double_api ===\"false\" || (double_api === \"true\" && batches === 2) ){\n_%>\n game.set('addition task:世界事件',`\n为使游戏更加具有细节真实感，你需要初始化并维护所有的${group}_lore.settings中的\"世界事件\"条目。世界事件基调：<%= getLocalVar('世界事件基调','日常感;禁止阴谋论') %>。\n该条目下有以下几个子条目：\n- \"今日新闻\":{}，当日的新闻。需在日期进入到下一天的时候刷新<%= NEWS_NUM %>个新闻，覆盖新闻时需先将今日新闻先删除再memory。每条新闻的数据结构是${新闻名称:string}:${30字新闻简述}from${信息来源}。新闻需要调整为符合当前世界观和世界事件基调。\n<%_\n  // --- 新闻数量检查逻辑 Start ---\n  var getNewsCount = function(lType) {\n      var newsObj = _.get(assaData, lType + '_lore.settings.世界事件.今日新闻', {});\n      return Object.keys(newsObj).length;\n  };\n  var totalNews = getNewsCount('global') + getNewsCount('world');\n\n  if (totalNews < NEWS_NUM) {\n_%>\n注意！当前新闻池内的新闻数量不足（当前：<%= totalNews %>条，目标：<%= NEWS_NUM %>条），你需要立刻初始化。\n<%_\n  }\n  // --- 新闻数量检查逻辑 End ---\n_%>\n- \"平行事件\":{}，平行事件池。里面必须要有至少<%= EVENT_NUM %>个正在进行中的事件（已结束/已汇入/未开始的事件不纳入计算）。初始化时，可以是人物事件/地点事件/活动事件(如地域活动、节日或组织决策)。每个平行事件的数据结构是${平行事件名称:string}:{\"简介\":\"string\",\"进展\":{\"${日期_时间}\":\"string//简述本轮该平行事件在如何发展。时间线不宜拖的太长，应结束时便应该干脆利落的结束\"},\"状态\":\"[未开始/进行中/已结束/已汇入]\",\"下次更新时间\":\"string//距离上次最近一次进展，下一次需要更新进展是在什么时间？需要以${相对时间}(${绝对时间})的格式记录。如2个小时后(3月12日_12:00)。需合理设置，尽量控制在6小时内。\"}。平行事件必须严格遵循世界事件基调，不得偏离：<%= getLocalVar('世界事件基调','日常感;禁止阴谋论') %>。\n平行事件更新前：需将每轮根据当前的日期和时间，去和每个事件的`下次更新时间`字段比对，去维护处于进行中的平行事件。若还没有抵达对应事件的`下次更新时间`，则直接忽略，无需更新。注意路径是${group}_lore.settings.世界事件.平行事件。\n <%_\n  // --- 平行事件时间检查逻辑 Start ---\n  var updateNotice = \"所有平行事件本回合都无需更新。\";\n  try {\n      // 1. 获取当前时间数据\n      var _tempStat = getDataWithFallback_chat(\"stat_data\");\n      if (_tempStat && _tempStat.日期 && _tempStat.时间) {\n          var _cYear = _tempStat.纪年 || new Date().getFullYear();\n          var _cDate = _tempStat.日期[0];\n          var _cTime = _tempStat.时间[0];\n\n          // 2. 时间戳转换工具函数\n          var getTs = function(y, d, t) {\n              if(!d || !t) return 0;\n              // 清洗日期：将 \"01月02日\" 转为 \"01/02\"\n              var dStr = d.toString().replace(/年|月/g, '/').replace(/日/g, '').trim();\n              // 清洗时间：兼容中英文冒号\n              var tStr = t.toString().replace(/：/g, ':').trim();\n              // 提取年份数字，若无则默认当前年份\n              var yStr = y.toString().replace(/[^0-9]/g, '');\n              return new Date(yStr + '/' + dStr + ' ' + tStr).getTime();\n          };\n\n          var _nowTs = getTs(_cYear, _cDate, _cTime);\n          var _dueEvents = [];\n\n          // 3. 遍历检查函数\n          var checkEvt = function(lType) {\n              var _list = _.get(assaData, lType + '_lore.settings.世界事件.平行事件', {});\n              for (var k in _list) {\n                  var item = _list[k];\n                  // 仅检查进行中且有更新时间的事件\n                  if (item.状态 === '进行中' && item.下次更新时间) {\n                      try {\n                          // 提取括号内容：xx小时后(元年_01月02日_11:30) -> 元年_01月02日_11:30\n                          var m = item.下次更新时间.match(/\\((.*?)\\)/);\n                          if (m && m[1]) {\n                              var parts = m[1].split('_');\n                              var targetDate = null;\n                              var targetTime = null;\n\n                              // 智能识别日期和时间段\n                              for (var i = 0; i < parts.length; i++) {\n                                  var p = parts[i].trim();\n                                  // 包含\"月\"和\"日\"视为日期\n                                  if (p.indexOf('月') > -1 && p.indexOf('日') > -1) {\n                                      targetDate = p;\n                                  }\n                                  // 包含冒号视为时间\n                                  else if (p.indexOf(':') > -1 || p.indexOf('：') > -1) {\n                                      targetTime = p;\n                                  }\n                              }\n\n                              if (targetDate && targetTime) {\n                                  var _targetTs = getTs(_cYear, targetDate, targetTime);\n                                  // 如果当前时间 >= 目标时间\n                                  if (!isNaN(_nowTs) && !isNaN(_targetTs) && _nowTs >= _targetTs) {\n                                      _dueEvents.push(k);\n                                  }\n                              }\n                          }\n                      } catch(e) { continue; } // 单个解析失败跳过\n                  }\n              }\n          };\n\n          checkEvt('global');\n          checkEvt('world');\n\n          if (_dueEvents.length > 0) {\n              updateNotice = \"[\" + _dueEvents.join('，') + \"]已经抵达更新时间，你需要立刻更新。\";\n          }\n      }\n  } catch (e) {\n      // 全局出错静默处理\n  }\n  // --- 平行事件时间检查逻辑 End ---\n_%>\n<%= updateNotice %>\n\n以上所有字段可以完全不和正文有交集/有关联，也可以和主线自然交汇，但时间线和流速必须和正文一致，禁止时间跳跃。当某平行事件汇入主线，开始在正文讲述后，则需**立刻**设置状态为已汇入，并将下次更行事件置空，视为中断，停止追踪，以防止平行事件重复更新游戏出错。\n<%_ if (totalActiveEvents < EVENT_NUM) { _%>\n注意！当前平行事件池内的事件数量不足（当前进行中：<%= totalActiveEvents %>个，目标：<%= EVENT_NUM %>个），你需要立刻初始化。\n<%_ } _%>\n`)\n\n<%_\n    // [模块3] 浓缩任务 (Batch 2 - 动态生成)\n    // 只有当存在需要浓缩的条目时才输出此任务\n    if ( eventCondenseList.length > 0) {\n_%>\ngame.set('addition task:浓缩世界事件信息', `\n检测到部分世界事件信息条目过长，请在<updateMemory>中执行以下清理与浓缩操作：\n\n<%_ if (eventCondenseList.length > 0) { _%>\n【平行事件浓缩】\n针对以下路径：<%= eventCondenseList.map(p=>`[${p}]`).join('、') %>。\n请先使用delete指令删除旧的进展记录，然后仅写入一条汇总数据。\nKey格式：'${最早记录的时间}-${最后记录的时间}'\nValue内容：'对该段时间内事件发展的简单总结脉络'（只需概括事件走向即可）。\n<%_ } _%>\n`)\n<%_\n    } // end of condense task\n_%>\n\n<%_\n  } // end of batch 2\n_%>\n","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":100,"position":4,"disable":false,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":0,"group":"","groupOverride":false,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":0,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":0},"1":{"uid":1,"key":[],"keysecondary":[],"comment":"基调设置","content":"{{setvar::世界事件基调::日常感}}{{//效力很高，在里面填你想要的平行事件基调。比如脑洞大开、随机、默认等都行}}","constant":true,"vectorized":false,"selective":true,"selectiveLogic":0,"addMemo":true,"order":100,"position":0,"disable":false,"excludeRecursion":false,"preventRecursion":false,"matchPersonaDescription":false,"matchCharacterDescription":false,"matchCharacterPersonality":false,"matchCharacterDepthPrompt":false,"matchScenario":false,"matchCreatorNotes":false,"delayUntilRecursion":false,"probability":100,"useProbability":true,"depth":4,"group":"","groupOverride":false,"groupWeight":100,"scanDepth":null,"caseSensitive":null,"matchWholeWords":null,"useGroupScoring":null,"automationId":"","role":null,"sticky":0,"cooldown":0,"delay":0,"triggers":[],"displayIndex":1,"characterFilter":{"isExclude":false,"names":[],"tags":[]}}}}